var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __knownSymbol = (name, symbol) => (symbol = Symbol[name]) ? symbol : Symbol.for("Symbol." + name);
var __typeError = (msg) => {
  throw TypeError(msg);
};
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __decoratorStart = (base) => [, , , __create(base?.[__knownSymbol("metadata")] ?? null)];
var __decoratorStrings = ["class", "method", "getter", "setter", "accessor", "field", "value", "get", "set"];
var __expectFn = (fn) => fn !== void 0 && typeof fn !== "function" ? __typeError("Function expected") : fn;
var __decoratorContext = (kind, name, done, metadata, fns) => ({ kind: __decoratorStrings[kind], name, metadata, addInitializer: (fn) => done._ ? __typeError("Already initialized") : fns.push(__expectFn(fn || null)) });
var __decoratorMetadata = (array, target) => __defNormalProp(target, __knownSymbol("metadata"), array[3]);
var __runInitializers = (array, flags, self2, value) => {
  for (var i5 = 0, fns = array[flags >> 1], n5 = fns && fns.length; i5 < n5; i5++) flags & 1 ? fns[i5].call(self2) : value = fns[i5].call(self2, value);
  return value;
};
var __decorateElement = (array, flags, name, decorators, target, extra) => {
  var fn, it, done, ctx, access, k3 = flags & 7, s3 = !!(flags & 8), p3 = !!(flags & 16);
  var j3 = k3 > 3 ? array.length + 1 : k3 ? s3 ? 1 : 2 : 0, key = __decoratorStrings[k3 + 5];
  var initializers = k3 > 3 && (array[j3 - 1] = []), extraInitializers = array[j3] || (array[j3] = []);
  var desc = k3 && (!p3 && !s3 && (target = target.prototype), k3 < 5 && (k3 > 3 || !p3) && __getOwnPropDesc(k3 < 4 ? target : { get [name]() {
    return __privateGet(this, extra);
  }, set [name](x3) {
    return __privateSet(this, extra, x3);
  } }, name));
  k3 ? p3 && k3 < 4 && __name(extra, (k3 > 2 ? "set " : k3 > 1 ? "get " : "") + name) : __name(target, name);
  for (var i5 = decorators.length - 1; i5 >= 0; i5--) {
    ctx = __decoratorContext(k3, name, done = {}, array[3], extraInitializers);
    if (k3) {
      ctx.static = s3, ctx.private = p3, access = ctx.access = { has: p3 ? (x3) => __privateIn(target, x3) : (x3) => name in x3 };
      if (k3 ^ 3) access.get = p3 ? (x3) => (k3 ^ 1 ? __privateGet : __privateMethod)(x3, target, k3 ^ 4 ? extra : desc.get) : (x3) => x3[name];
      if (k3 > 2) access.set = p3 ? (x3, y3) => __privateSet(x3, target, y3, k3 ^ 4 ? extra : desc.set) : (x3, y3) => x3[name] = y3;
    }
    it = (0, decorators[i5])(k3 ? k3 < 4 ? p3 ? extra : desc[key] : k3 > 4 ? void 0 : { get: desc.get, set: desc.set } : target, ctx), done._ = 1;
    if (k3 ^ 4 || it === void 0) __expectFn(it) && (k3 > 4 ? initializers.unshift(it) : k3 ? p3 ? extra = it : desc[key] = it : target = it);
    else if (typeof it !== "object" || it === null) __typeError("Object expected");
    else __expectFn(fn = it.get) && (desc.get = fn), __expectFn(fn = it.set) && (desc.set = fn), __expectFn(fn = it.init) && initializers.unshift(fn);
  }
  return k3 || __decoratorMetadata(array, target), desc && __defProp(target, name, desc), p3 ? k3 ^ 4 ? extra : desc : target;
};
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
var __accessCheck = (obj, member, msg) => member.has(obj) || __typeError("Cannot " + msg);
var __privateIn = (member, obj) => Object(obj) !== obj ? __typeError('Cannot use the "in" operator on this value') : member.has(obj);
var __privateGet = (obj, member, getter) => (__accessCheck(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);
var __privateMethod = (obj, member, method) => (__accessCheck(obj, member, "access private method"), method);

// node_modules/maplibre-gl/dist/maplibre-gl.js
var require_maplibre_gl = __commonJS({
  "node_modules/maplibre-gl/dist/maplibre-gl.js"(exports, module) {
    (function(global, factory) {
      typeof exports === "object" && typeof module !== "undefined" ? module.exports = factory() : typeof define === "function" && define.amd ? define(factory) : (global = typeof globalThis !== "undefined" ? globalThis : global || self, global.maplibregl = factory());
    })(exports, function() {
      "use strict";
      var maplibregl2 = {};
      var modules = {};
      function define2(moduleName, _dependencies, moduleFactory) {
        modules[moduleName] = moduleFactory;
        if (moduleName !== "index") {
          return;
        }
        var workerBundleString = "var sharedModule = {}; (" + modules.shared + ")(sharedModule); (" + modules.worker + ")(sharedModule);";
        var sharedModule = {};
        modules.shared(sharedModule);
        modules.index(maplibregl2, sharedModule);
        if (typeof window !== "undefined") {
          maplibregl2.setWorkerUrl(window.URL.createObjectURL(new Blob([workerBundleString], { type: "text/javascript" })));
        }
        return maplibregl2;
      }
      ;
      define2("shared", ["exports"], function(t4) {
        "use strict";
        function e5(t5, e6, r8, n6) {
          return new (r8 || (r8 = Promise))(function(i6, s4) {
            function a4(t6) {
              try {
                l5(n6.next(t6));
              } catch (t7) {
                s4(t7);
              }
            }
            function o6(t6) {
              try {
                l5(n6.throw(t6));
              } catch (t7) {
                s4(t7);
              }
            }
            function l5(t6) {
              var e7;
              t6.done ? i6(t6.value) : (e7 = t6.value, e7 instanceof r8 ? e7 : new r8(function(t7) {
                t7(e7);
              })).then(a4, o6);
            }
            l5((n6 = n6.apply(t5, e6 || [])).next());
          });
        }
        function r7(t5) {
          return t5 && t5.__esModule && Object.prototype.hasOwnProperty.call(t5, "default") ? t5.default : t5;
        }
        var n5, i5;
        function s3() {
          if (i5) return n5;
          function t5(t6, e6) {
            this.x = t6, this.y = e6;
          }
          return i5 = 1, n5 = t5, t5.prototype = { clone: function() {
            return new t5(this.x, this.y);
          }, add: function(t6) {
            return this.clone()._add(t6);
          }, sub: function(t6) {
            return this.clone()._sub(t6);
          }, multByPoint: function(t6) {
            return this.clone()._multByPoint(t6);
          }, divByPoint: function(t6) {
            return this.clone()._divByPoint(t6);
          }, mult: function(t6) {
            return this.clone()._mult(t6);
          }, div: function(t6) {
            return this.clone()._div(t6);
          }, rotate: function(t6) {
            return this.clone()._rotate(t6);
          }, rotateAround: function(t6, e6) {
            return this.clone()._rotateAround(t6, e6);
          }, matMult: function(t6) {
            return this.clone()._matMult(t6);
          }, unit: function() {
            return this.clone()._unit();
          }, perp: function() {
            return this.clone()._perp();
          }, round: function() {
            return this.clone()._round();
          }, mag: function() {
            return Math.sqrt(this.x * this.x + this.y * this.y);
          }, equals: function(t6) {
            return this.x === t6.x && this.y === t6.y;
          }, dist: function(t6) {
            return Math.sqrt(this.distSqr(t6));
          }, distSqr: function(t6) {
            var e6 = t6.x - this.x, r8 = t6.y - this.y;
            return e6 * e6 + r8 * r8;
          }, angle: function() {
            return Math.atan2(this.y, this.x);
          }, angleTo: function(t6) {
            return Math.atan2(this.y - t6.y, this.x - t6.x);
          }, angleWith: function(t6) {
            return this.angleWithSep(t6.x, t6.y);
          }, angleWithSep: function(t6, e6) {
            return Math.atan2(this.x * e6 - this.y * t6, this.x * t6 + this.y * e6);
          }, _matMult: function(t6) {
            var e6 = t6[2] * this.x + t6[3] * this.y;
            return this.x = t6[0] * this.x + t6[1] * this.y, this.y = e6, this;
          }, _add: function(t6) {
            return this.x += t6.x, this.y += t6.y, this;
          }, _sub: function(t6) {
            return this.x -= t6.x, this.y -= t6.y, this;
          }, _mult: function(t6) {
            return this.x *= t6, this.y *= t6, this;
          }, _div: function(t6) {
            return this.x /= t6, this.y /= t6, this;
          }, _multByPoint: function(t6) {
            return this.x *= t6.x, this.y *= t6.y, this;
          }, _divByPoint: function(t6) {
            return this.x /= t6.x, this.y /= t6.y, this;
          }, _unit: function() {
            return this._div(this.mag()), this;
          }, _perp: function() {
            var t6 = this.y;
            return this.y = this.x, this.x = -t6, this;
          }, _rotate: function(t6) {
            var e6 = Math.cos(t6), r8 = Math.sin(t6), n6 = r8 * this.x + e6 * this.y;
            return this.x = e6 * this.x - r8 * this.y, this.y = n6, this;
          }, _rotateAround: function(t6, e6) {
            var r8 = Math.cos(t6), n6 = Math.sin(t6), i6 = e6.y + n6 * (this.x - e6.x) + r8 * (this.y - e6.y);
            return this.x = e6.x + r8 * (this.x - e6.x) - n6 * (this.y - e6.y), this.y = i6, this;
          }, _round: function() {
            return this.x = Math.round(this.x), this.y = Math.round(this.y), this;
          } }, t5.convert = function(e6) {
            return e6 instanceof t5 ? e6 : Array.isArray(e6) ? new t5(e6[0], e6[1]) : e6;
          }, n5;
        }
        "function" == typeof SuppressedError && SuppressedError;
        var a3, o5, l4 = r7(s3()), u3 = function() {
          if (o5) return a3;
          function t5(t6, e6, r8, n6) {
            this.cx = 3 * t6, this.bx = 3 * (r8 - t6) - this.cx, this.ax = 1 - this.cx - this.bx, this.cy = 3 * e6, this.by = 3 * (n6 - e6) - this.cy, this.ay = 1 - this.cy - this.by, this.p1x = t6, this.p1y = e6, this.p2x = r8, this.p2y = n6;
          }
          return o5 = 1, a3 = t5, t5.prototype = { sampleCurveX: function(t6) {
            return ((this.ax * t6 + this.bx) * t6 + this.cx) * t6;
          }, sampleCurveY: function(t6) {
            return ((this.ay * t6 + this.by) * t6 + this.cy) * t6;
          }, sampleCurveDerivativeX: function(t6) {
            return (3 * this.ax * t6 + 2 * this.bx) * t6 + this.cx;
          }, solveCurveX: function(t6, e6) {
            if (void 0 === e6 && (e6 = 1e-6), t6 < 0) return 0;
            if (t6 > 1) return 1;
            for (var r8 = t6, n6 = 0; n6 < 8; n6++) {
              var i6 = this.sampleCurveX(r8) - t6;
              if (Math.abs(i6) < e6) return r8;
              var s4 = this.sampleCurveDerivativeX(r8);
              if (Math.abs(s4) < 1e-6) break;
              r8 -= i6 / s4;
            }
            var a4 = 0, o6 = 1;
            for (r8 = t6, n6 = 0; n6 < 20 && (i6 = this.sampleCurveX(r8), !(Math.abs(i6 - t6) < e6)); n6++) t6 > i6 ? a4 = r8 : o6 = r8, r8 = 0.5 * (o6 - a4) + a4;
            return r8;
          }, solve: function(t6, e6) {
            return this.sampleCurveY(this.solveCurveX(t6, e6));
          } }, a3;
        }(), c4 = r7(u3);
        let h3, p3;
        function f3() {
          return null == h3 && (h3 = "undefined" != typeof OffscreenCanvas && new OffscreenCanvas(1, 1).getContext("2d") && "function" == typeof createImageBitmap), h3;
        }
        function d3() {
          if (null == p3 && (p3 = false, f3())) {
            const t5 = 5, e6 = new OffscreenCanvas(t5, t5).getContext("2d", { willReadFrequently: true });
            if (e6) {
              for (let r9 = 0; r9 < t5 * t5; r9++) {
                const n6 = 4 * r9;
                e6.fillStyle = `rgb(${n6},${n6 + 1},${n6 + 2})`, e6.fillRect(r9 % t5, Math.floor(r9 / t5), 1, 1);
              }
              const r8 = e6.getImageData(0, 0, t5, t5).data;
              for (let e7 = 0; e7 < t5 * t5 * 4; e7++) if (e7 % 4 != 3 && r8[e7] !== e7) {
                p3 = true;
                break;
              }
            }
          }
          return p3 || false;
        }
        var y3, m3 = 1e-6, g3 = "undefined" != typeof Float32Array ? Float32Array : Array;
        function x3() {
          var t5 = new g3(9);
          return g3 != Float32Array && (t5[1] = 0, t5[2] = 0, t5[3] = 0, t5[5] = 0, t5[6] = 0, t5[7] = 0), t5[0] = 1, t5[4] = 1, t5[8] = 1, t5;
        }
        function v3(t5) {
          return t5[0] = 1, t5[1] = 0, t5[2] = 0, t5[3] = 0, t5[4] = 0, t5[5] = 1, t5[6] = 0, t5[7] = 0, t5[8] = 0, t5[9] = 0, t5[10] = 1, t5[11] = 0, t5[12] = 0, t5[13] = 0, t5[14] = 0, t5[15] = 1, t5;
        }
        function b4() {
          var t5 = new g3(3);
          return g3 != Float32Array && (t5[0] = 0, t5[1] = 0, t5[2] = 0), t5;
        }
        function w3(t5, e6, r8) {
          var n6 = new g3(3);
          return n6[0] = t5, n6[1] = e6, n6[2] = r8, n6;
        }
        function _3(t5, e6, r8) {
          var n6 = e6[0], i6 = e6[1], s4 = e6[2], a4 = e6[3];
          return t5[0] = r8[0] * n6 + r8[4] * i6 + r8[8] * s4 + r8[12] * a4, t5[1] = r8[1] * n6 + r8[5] * i6 + r8[9] * s4 + r8[13] * a4, t5[2] = r8[2] * n6 + r8[6] * i6 + r8[10] * s4 + r8[14] * a4, t5[3] = r8[3] * n6 + r8[7] * i6 + r8[11] * s4 + r8[15] * a4, t5;
        }
        function S4() {
          var t5 = new g3(4);
          return g3 != Float32Array && (t5[0] = 0, t5[1] = 0, t5[2] = 0), t5[3] = 1, t5;
        }
        function A4() {
          var t5 = new g3(2);
          return g3 != Float32Array && (t5[0] = 0, t5[1] = 0), t5;
        }
        function k3(t5, e6) {
          var r8 = new g3(2);
          return r8[0] = t5, r8[1] = e6, r8;
        }
        Math.hypot || (Math.hypot = function() {
          for (var t5 = 0, e6 = arguments.length; e6--; ) t5 += arguments[e6] * arguments[e6];
          return Math.sqrt(t5);
        }), b4(), y3 = new g3(4), g3 != Float32Array && (y3[0] = 0, y3[1] = 0, y3[2] = 0, y3[3] = 0), b4(), w3(1, 0, 0), w3(0, 1, 0), S4(), S4(), x3(), A4();
        const M4 = 8192;
        function I3(t5, e6, r8) {
          return e6 * (M4 / (t5.tileSize * Math.pow(2, r8 - t5.tileID.overscaledZ)));
        }
        function z3(t5, e6) {
          return (t5 % e6 + e6) % e6;
        }
        function P3(t5, e6, r8) {
          return t5 * (1 - r8) + e6 * r8;
        }
        function C3(t5) {
          if (t5 <= 0) return 0;
          if (t5 >= 1) return 1;
          const e6 = t5 * t5, r8 = e6 * t5;
          return 4 * (t5 < 0.5 ? r8 : 3 * (t5 - e6) + r8 - 0.75);
        }
        function B4(t5, e6, r8, n6) {
          const i6 = new c4(t5, e6, r8, n6);
          return (t6) => i6.solve(t6);
        }
        const V2 = B4(0.25, 0.1, 0.25, 1);
        function E3(t5, e6, r8) {
          return Math.min(r8, Math.max(e6, t5));
        }
        function T4(t5, e6, r8) {
          const n6 = r8 - e6, i6 = ((t5 - e6) % n6 + n6) % n6 + e6;
          return i6 === e6 ? r8 : i6;
        }
        function F2(t5, ...e6) {
          for (const r8 of e6) for (const e7 in r8) t5[e7] = r8[e7];
          return t5;
        }
        let $2 = 1;
        function L3(t5, e6, r8) {
          const n6 = {};
          for (const r9 in t5) n6[r9] = e6.call(this, t5[r9], r9, t5);
          return n6;
        }
        function O2(t5, e6, r8) {
          const n6 = {};
          for (const r9 in t5) e6.call(this, t5[r9], r9, t5) && (n6[r9] = t5[r9]);
          return n6;
        }
        function D2(t5) {
          return Array.isArray(t5) ? t5.map(D2) : "object" == typeof t5 && t5 ? L3(t5, D2) : t5;
        }
        const R4 = {};
        function j3(t5) {
          R4[t5] || ("undefined" != typeof console && console.warn(t5), R4[t5] = true);
        }
        function N3(t5, e6, r8) {
          return (r8.y - t5.y) * (e6.x - t5.x) > (e6.y - t5.y) * (r8.x - t5.x);
        }
        function U3(t5) {
          return "undefined" != typeof WorkerGlobalScope && void 0 !== t5 && t5 instanceof WorkerGlobalScope;
        }
        let q2 = null;
        function G2(t5) {
          return "undefined" != typeof ImageBitmap && t5 instanceof ImageBitmap;
        }
        const Z2 = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAC0lEQVQYV2NgAAIAAAUAAarVyFEAAAAASUVORK5CYII=";
        function K2(t5, r8, n6, i6, s4) {
          return e5(this, void 0, void 0, function* () {
            if ("undefined" == typeof VideoFrame) throw new Error("VideoFrame not supported");
            const e6 = new VideoFrame(t5, { timestamp: 0 });
            try {
              const a4 = null == e6 ? void 0 : e6.format;
              if (!a4 || !a4.startsWith("BGR") && !a4.startsWith("RGB")) throw new Error(`Unrecognized format ${a4}`);
              const o6 = a4.startsWith("BGR"), l5 = new Uint8ClampedArray(i6 * s4 * 4);
              if (yield e6.copyTo(l5, function(t6, e7, r9, n7, i7) {
                const s5 = 4 * Math.max(1, 0), a5 = (Math.max(0, r9) - r9) * n7 * 4 + s5, o7 = 4 * n7, l6 = Math.max(0, e7), u4 = Math.max(0, r9);
                return { rect: { x: l6, y: u4, width: Math.min(t6.width, e7 + n7) - l6, height: Math.min(t6.height, r9 + i7) - u4 }, layout: [{ offset: a5, stride: o7 }] };
              }(t5, r8, n6, i6, s4)), o6) for (let t6 = 0; t6 < l5.length; t6 += 4) {
                const e7 = l5[t6];
                l5[t6] = l5[t6 + 2], l5[t6 + 2] = e7;
              }
              return l5;
            } finally {
              e6.close();
            }
          });
        }
        let X2, H4;
        function Y2(t5, e6, r8, n6) {
          return t5.addEventListener(e6, r8, n6), { unsubscribe: () => {
            t5.removeEventListener(e6, r8, n6);
          } };
        }
        function J2(t5) {
          return t5 / Math.PI * 180;
        }
        const W = { touchstart: true, touchmove: true, touchmoveWindow: true, touchend: true, touchcancel: true }, Q2 = { dblclick: true, click: true, mouseover: true, mouseout: true, mousedown: true, mousemove: true, mousemoveWindow: true, mouseup: true, mouseupWindow: true, contextmenu: true, wheel: true }, tt = "AbortError";
        function et2() {
          return new Error(tt);
        }
        const rt = { MAX_PARALLEL_IMAGE_REQUESTS: 16, MAX_PARALLEL_IMAGE_REQUESTS_PER_FRAME: 8, MAX_TILE_CACHE_ZOOM_LEVELS: 5, REGISTERED_PROTOCOLS: {}, WORKER_URL: "" };
        function nt(t5) {
          return rt.REGISTERED_PROTOCOLS[t5.substring(0, t5.indexOf("://"))];
        }
        const it = "global-dispatcher";
        class st extends Error {
          constructor(t5, e6, r8, n6) {
            super(`AJAXError: ${e6} (${t5}): ${r8}`), this.status = t5, this.statusText = e6, this.url = r8, this.body = n6;
          }
        }
        const at = () => U3(self) ? self.worker && self.worker.referrer : ("blob:" === window.location.protocol ? window.parent : window).location.href, ot = function(t5, r8) {
          if (/:\/\//.test(t5.url) && !/^https?:|^file:/.test(t5.url)) {
            const e6 = nt(t5.url);
            if (e6) return e6(t5, r8);
            if (U3(self) && self.worker && self.worker.actor) return self.worker.actor.sendAsync({ type: "GR", data: t5, targetMapId: it }, r8);
          }
          if (!(/^file:/.test(n6 = t5.url) || /^file:/.test(at()) && !/^\w+:/.test(n6))) {
            if (fetch && Request && AbortController && Object.prototype.hasOwnProperty.call(Request.prototype, "signal")) return function(t6, r9) {
              return e5(this, void 0, void 0, function* () {
                const e6 = new Request(t6.url, { method: t6.method || "GET", body: t6.body, credentials: t6.credentials, headers: t6.headers, cache: t6.cache, referrer: at(), signal: r9.signal });
                let n7, i6;
                "json" !== t6.type || e6.headers.has("Accept") || e6.headers.set("Accept", "application/json");
                try {
                  n7 = yield fetch(e6);
                } catch (e7) {
                  throw new st(0, e7.message, t6.url, new Blob());
                }
                if (!n7.ok) {
                  const e7 = yield n7.blob();
                  throw new st(n7.status, n7.statusText, t6.url, e7);
                }
                i6 = "arrayBuffer" === t6.type || "image" === t6.type ? n7.arrayBuffer() : "json" === t6.type ? n7.json() : n7.text();
                const s4 = yield i6;
                if (r9.signal.aborted) throw et2();
                return { data: s4, cacheControl: n7.headers.get("Cache-Control"), expires: n7.headers.get("Expires") };
              });
            }(t5, r8);
            if (U3(self) && self.worker && self.worker.actor) return self.worker.actor.sendAsync({ type: "GR", data: t5, mustQueue: true, targetMapId: it }, r8);
          }
          var n6;
          return function(t6, e6) {
            return new Promise((r9, n7) => {
              var i6;
              const s4 = new XMLHttpRequest();
              s4.open(t6.method || "GET", t6.url, true), "arrayBuffer" !== t6.type && "image" !== t6.type || (s4.responseType = "arraybuffer");
              for (const e7 in t6.headers) s4.setRequestHeader(e7, t6.headers[e7]);
              "json" === t6.type && (s4.responseType = "text", (null === (i6 = t6.headers) || void 0 === i6 ? void 0 : i6.Accept) || s4.setRequestHeader("Accept", "application/json")), s4.withCredentials = "include" === t6.credentials, s4.onerror = () => {
                n7(new Error(s4.statusText));
              }, s4.onload = () => {
                if (!e6.signal.aborted) if ((s4.status >= 200 && s4.status < 300 || 0 === s4.status) && null !== s4.response) {
                  let e7 = s4.response;
                  if ("json" === t6.type) try {
                    e7 = JSON.parse(s4.response);
                  } catch (t7) {
                    return void n7(t7);
                  }
                  r9({ data: e7, cacheControl: s4.getResponseHeader("Cache-Control"), expires: s4.getResponseHeader("Expires") });
                } else {
                  const e7 = new Blob([s4.response], { type: s4.getResponseHeader("Content-Type") });
                  n7(new st(s4.status, s4.statusText, t6.url, e7));
                }
              }, e6.signal.addEventListener("abort", () => {
                s4.abort(), n7(et2());
              }), s4.send(t6.body);
            });
          }(t5, r8);
        };
        function lt(t5) {
          if (!t5 || t5.indexOf("://") <= 0 || 0 === t5.indexOf("data:image/") || 0 === t5.indexOf("blob:")) return true;
          const e6 = new URL(t5), r8 = window.location;
          return e6.protocol === r8.protocol && e6.host === r8.host;
        }
        function ut(t5, e6, r8) {
          r8[t5] && -1 !== r8[t5].indexOf(e6) || (r8[t5] = r8[t5] || [], r8[t5].push(e6));
        }
        function ct(t5, e6, r8) {
          if (r8 && r8[t5]) {
            const n6 = r8[t5].indexOf(e6);
            -1 !== n6 && r8[t5].splice(n6, 1);
          }
        }
        class ht {
          constructor(t5, e6 = {}) {
            F2(this, e6), this.type = t5;
          }
        }
        class pt extends ht {
          constructor(t5, e6 = {}) {
            super("error", F2({ error: t5 }, e6));
          }
        }
        class ft {
          on(t5, e6) {
            return this._listeners = this._listeners || {}, ut(t5, e6, this._listeners), { unsubscribe: () => {
              this.off(t5, e6);
            } };
          }
          off(t5, e6) {
            return ct(t5, e6, this._listeners), ct(t5, e6, this._oneTimeListeners), this;
          }
          once(t5, e6) {
            return e6 ? (this._oneTimeListeners = this._oneTimeListeners || {}, ut(t5, e6, this._oneTimeListeners), this) : new Promise((e7) => this.once(t5, e7));
          }
          fire(t5, e6) {
            "string" == typeof t5 && (t5 = new ht(t5, e6 || {}));
            const r8 = t5.type;
            if (this.listens(r8)) {
              t5.target = this;
              const e7 = this._listeners && this._listeners[r8] ? this._listeners[r8].slice() : [];
              for (const r9 of e7) r9.call(this, t5);
              const n6 = this._oneTimeListeners && this._oneTimeListeners[r8] ? this._oneTimeListeners[r8].slice() : [];
              for (const e8 of n6) ct(r8, e8, this._oneTimeListeners), e8.call(this, t5);
              const i6 = this._eventedParent;
              i6 && (F2(t5, "function" == typeof this._eventedParentData ? this._eventedParentData() : this._eventedParentData), i6.fire(t5));
            } else t5 instanceof pt && console.error(t5.error);
            return this;
          }
          listens(t5) {
            return this._listeners && this._listeners[t5] && this._listeners[t5].length > 0 || this._oneTimeListeners && this._oneTimeListeners[t5] && this._oneTimeListeners[t5].length > 0 || this._eventedParent && this._eventedParent.listens(t5);
          }
          setEventedParent(t5, e6) {
            return this._eventedParent = t5, this._eventedParentData = e6, this;
          }
        }
        var dt = { $version: 8, $root: { version: { required: true, type: "enum", values: [8] }, name: { type: "string" }, metadata: { type: "*" }, center: { type: "array", value: "number" }, centerAltitude: { type: "number" }, zoom: { type: "number" }, bearing: { type: "number", default: 0, period: 360, units: "degrees" }, pitch: { type: "number", default: 0, units: "degrees" }, roll: { type: "number", default: 0, units: "degrees" }, light: { type: "light" }, sky: { type: "sky" }, projection: { type: "projection" }, terrain: { type: "terrain" }, sources: { required: true, type: "sources" }, sprite: { type: "sprite" }, glyphs: { type: "string" }, transition: { type: "transition" }, layers: { required: true, type: "array", value: "layer" } }, sources: { "*": { type: "source" } }, source: ["source_vector", "source_raster", "source_raster_dem", "source_geojson", "source_video", "source_image"], source_vector: { type: { required: true, type: "enum", values: { vector: {} } }, url: { type: "string" }, tiles: { type: "array", value: "string" }, bounds: { type: "array", value: "number", length: 4, default: [-180, -85.051129, 180, 85.051129] }, scheme: { type: "enum", values: { xyz: {}, tms: {} }, default: "xyz" }, minzoom: { type: "number", default: 0 }, maxzoom: { type: "number", default: 22 }, attribution: { type: "string" }, promoteId: { type: "promoteId" }, volatile: { type: "boolean", default: false }, "*": { type: "*" } }, source_raster: { type: { required: true, type: "enum", values: { raster: {} } }, url: { type: "string" }, tiles: { type: "array", value: "string" }, bounds: { type: "array", value: "number", length: 4, default: [-180, -85.051129, 180, 85.051129] }, minzoom: { type: "number", default: 0 }, maxzoom: { type: "number", default: 22 }, tileSize: { type: "number", default: 512, units: "pixels" }, scheme: { type: "enum", values: { xyz: {}, tms: {} }, default: "xyz" }, attribution: { type: "string" }, volatile: { type: "boolean", default: false }, "*": { type: "*" } }, source_raster_dem: { type: { required: true, type: "enum", values: { "raster-dem": {} } }, url: { type: "string" }, tiles: { type: "array", value: "string" }, bounds: { type: "array", value: "number", length: 4, default: [-180, -85.051129, 180, 85.051129] }, minzoom: { type: "number", default: 0 }, maxzoom: { type: "number", default: 22 }, tileSize: { type: "number", default: 512, units: "pixels" }, attribution: { type: "string" }, encoding: { type: "enum", values: { terrarium: {}, mapbox: {}, custom: {} }, default: "mapbox" }, redFactor: { type: "number", default: 1 }, blueFactor: { type: "number", default: 1 }, greenFactor: { type: "number", default: 1 }, baseShift: { type: "number", default: 0 }, volatile: { type: "boolean", default: false }, "*": { type: "*" } }, source_geojson: { type: { required: true, type: "enum", values: { geojson: {} } }, data: { required: true, type: "*" }, maxzoom: { type: "number", default: 18 }, attribution: { type: "string" }, buffer: { type: "number", default: 128, maximum: 512, minimum: 0 }, filter: { type: "*" }, tolerance: { type: "number", default: 0.375 }, cluster: { type: "boolean", default: false }, clusterRadius: { type: "number", default: 50, minimum: 0 }, clusterMaxZoom: { type: "number" }, clusterMinPoints: { type: "number" }, clusterProperties: { type: "*" }, lineMetrics: { type: "boolean", default: false }, generateId: { type: "boolean", default: false }, promoteId: { type: "promoteId" } }, source_video: { type: { required: true, type: "enum", values: { video: {} } }, urls: { required: true, type: "array", value: "string" }, coordinates: { required: true, type: "array", length: 4, value: { type: "array", length: 2, value: "number" } } }, source_image: { type: { required: true, type: "enum", values: { image: {} } }, url: { required: true, type: "string" }, coordinates: { required: true, type: "array", length: 4, value: { type: "array", length: 2, value: "number" } } }, layer: { id: { type: "string", required: true }, type: { type: "enum", values: { fill: {}, line: {}, symbol: {}, circle: {}, heatmap: {}, "fill-extrusion": {}, raster: {}, hillshade: {}, background: {} }, required: true }, metadata: { type: "*" }, source: { type: "string" }, "source-layer": { type: "string" }, minzoom: { type: "number", minimum: 0, maximum: 24 }, maxzoom: { type: "number", minimum: 0, maximum: 24 }, filter: { type: "filter" }, layout: { type: "layout" }, paint: { type: "paint" } }, layout: ["layout_fill", "layout_line", "layout_circle", "layout_heatmap", "layout_fill-extrusion", "layout_symbol", "layout_raster", "layout_hillshade", "layout_background"], layout_background: { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_fill: { "fill-sort-key": { type: "number", expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_circle: { "circle-sort-key": { type: "number", expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_heatmap: { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, "layout_fill-extrusion": { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_line: { "line-cap": { type: "enum", values: { butt: {}, round: {}, square: {} }, default: "butt", expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-join": { type: "enum", values: { bevel: {}, round: {}, miter: {} }, default: "miter", expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "line-miter-limit": { type: "number", default: 2, requires: [{ "line-join": "miter" }], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-round-limit": { type: "number", default: 1.05, requires: [{ "line-join": "round" }], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-sort-key": { type: "number", expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_symbol: { "symbol-placement": { type: "enum", values: { point: {}, line: {}, "line-center": {} }, default: "point", expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "symbol-spacing": { type: "number", default: 250, minimum: 1, units: "pixels", requires: [{ "symbol-placement": "line" }], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "symbol-avoid-edges": { type: "boolean", default: false, expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "symbol-sort-key": { type: "number", expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "symbol-z-order": { type: "enum", values: { auto: {}, "viewport-y": {}, source: {} }, default: "auto", expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-allow-overlap": { type: "boolean", default: false, requires: ["icon-image", { "!": "icon-overlap" }], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-overlap": { type: "enum", values: { never: {}, always: {}, cooperative: {} }, requires: ["icon-image"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-ignore-placement": { type: "boolean", default: false, requires: ["icon-image"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-optional": { type: "boolean", default: false, requires: ["icon-image", "text-field"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-rotation-alignment": { type: "enum", values: { map: {}, viewport: {}, auto: {} }, default: "auto", requires: ["icon-image"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-size": { type: "number", default: 1, minimum: 0, units: "factor of the original icon size", requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-text-fit": { type: "enum", values: { none: {}, width: {}, height: {}, both: {} }, default: "none", requires: ["icon-image", "text-field"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-text-fit-padding": { type: "array", value: "number", length: 4, default: [0, 0, 0, 0], units: "pixels", requires: ["icon-image", "text-field", { "icon-text-fit": ["both", "width", "height"] }], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-image": { type: "resolvedImage", tokens: true, expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-rotate": { type: "number", default: 0, period: 360, units: "degrees", requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-padding": { type: "padding", default: [2], units: "pixels", requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-keep-upright": { type: "boolean", default: false, requires: ["icon-image", { "icon-rotation-alignment": "map" }, { "symbol-placement": ["line", "line-center"] }], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-offset": { type: "array", value: "number", length: 2, default: [0, 0], requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-anchor": { type: "enum", values: { center: {}, left: {}, right: {}, top: {}, bottom: {}, "top-left": {}, "top-right": {}, "bottom-left": {}, "bottom-right": {} }, default: "center", requires: ["icon-image"], expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-pitch-alignment": { type: "enum", values: { map: {}, viewport: {}, auto: {} }, default: "auto", requires: ["icon-image"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-pitch-alignment": { type: "enum", values: { map: {}, viewport: {}, auto: {} }, default: "auto", requires: ["text-field"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-rotation-alignment": { type: "enum", values: { map: {}, viewport: {}, "viewport-glyph": {}, auto: {} }, default: "auto", requires: ["text-field"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-field": { type: "formatted", default: "", tokens: true, expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-font": { type: "array", value: "string", default: ["Open Sans Regular", "Arial Unicode MS Regular"], requires: ["text-field"], expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-size": { type: "number", default: 16, minimum: 0, units: "pixels", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-max-width": { type: "number", default: 10, minimum: 0, units: "ems", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-line-height": { type: "number", default: 1.2, units: "ems", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-letter-spacing": { type: "number", default: 0, units: "ems", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-justify": { type: "enum", values: { auto: {}, left: {}, center: {}, right: {} }, default: "center", requires: ["text-field"], expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-radial-offset": { type: "number", units: "ems", default: 0, requires: ["text-field"], "property-type": "data-driven", expression: { interpolated: true, parameters: ["zoom", "feature"] } }, "text-variable-anchor": { type: "array", value: "enum", values: { center: {}, left: {}, right: {}, top: {}, bottom: {}, "top-left": {}, "top-right": {}, "bottom-left": {}, "bottom-right": {} }, requires: ["text-field", { "symbol-placement": ["point"] }], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-variable-anchor-offset": { type: "variableAnchorOffsetCollection", requires: ["text-field", { "symbol-placement": ["point"] }], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-anchor": { type: "enum", values: { center: {}, left: {}, right: {}, top: {}, bottom: {}, "top-left": {}, "top-right": {}, "bottom-left": {}, "bottom-right": {} }, default: "center", requires: ["text-field", { "!": "text-variable-anchor" }], expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-max-angle": { type: "number", default: 45, units: "degrees", requires: ["text-field", { "symbol-placement": ["line", "line-center"] }], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-writing-mode": { type: "array", value: "enum", values: { horizontal: {}, vertical: {} }, requires: ["text-field", { "symbol-placement": ["point"] }], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-rotate": { type: "number", default: 0, period: 360, units: "degrees", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-padding": { type: "number", default: 2, minimum: 0, units: "pixels", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-keep-upright": { type: "boolean", default: true, requires: ["text-field", { "text-rotation-alignment": "map" }, { "symbol-placement": ["line", "line-center"] }], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-transform": { type: "enum", values: { none: {}, uppercase: {}, lowercase: {} }, default: "none", requires: ["text-field"], expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-offset": { type: "array", value: "number", units: "ems", length: 2, default: [0, 0], requires: ["text-field", { "!": "text-radial-offset" }], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-allow-overlap": { type: "boolean", default: false, requires: ["text-field", { "!": "text-overlap" }], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-overlap": { type: "enum", values: { never: {}, always: {}, cooperative: {} }, requires: ["text-field"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-ignore-placement": { type: "boolean", default: false, requires: ["text-field"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-optional": { type: "boolean", default: false, requires: ["text-field", "icon-image"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_raster: { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_hillshade: { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, filter: { type: "array", value: "*" }, filter_operator: { type: "enum", values: { "==": {}, "!=": {}, ">": {}, ">=": {}, "<": {}, "<=": {}, in: {}, "!in": {}, all: {}, any: {}, none: {}, has: {}, "!has": {} } }, geometry_type: { type: "enum", values: { Point: {}, LineString: {}, Polygon: {} } }, function: { expression: { type: "expression" }, stops: { type: "array", value: "function_stop" }, base: { type: "number", default: 1, minimum: 0 }, property: { type: "string", default: "$zoom" }, type: { type: "enum", values: { identity: {}, exponential: {}, interval: {}, categorical: {} }, default: "exponential" }, colorSpace: { type: "enum", values: { rgb: {}, lab: {}, hcl: {} }, default: "rgb" }, default: { type: "*", required: false } }, function_stop: { type: "array", minimum: 0, maximum: 24, value: ["number", "color"], length: 2 }, expression: { type: "array", value: "*", minimum: 1 }, light: { anchor: { type: "enum", default: "viewport", values: { map: {}, viewport: {} }, "property-type": "data-constant", transition: false, expression: { interpolated: false, parameters: ["zoom"] } }, position: { type: "array", default: [1.15, 210, 30], length: 3, value: "number", "property-type": "data-constant", transition: true, expression: { interpolated: true, parameters: ["zoom"] } }, color: { type: "color", "property-type": "data-constant", default: "#ffffff", expression: { interpolated: true, parameters: ["zoom"] }, transition: true }, intensity: { type: "number", "property-type": "data-constant", default: 0.5, minimum: 0, maximum: 1, expression: { interpolated: true, parameters: ["zoom"] }, transition: true } }, sky: { "sky-color": { type: "color", "property-type": "data-constant", default: "#88C6FC", expression: { interpolated: true, parameters: ["zoom"] }, transition: true }, "horizon-color": { type: "color", "property-type": "data-constant", default: "#ffffff", expression: { interpolated: true, parameters: ["zoom"] }, transition: true }, "fog-color": { type: "color", "property-type": "data-constant", default: "#ffffff", expression: { interpolated: true, parameters: ["zoom"] }, transition: true }, "fog-ground-blend": { type: "number", "property-type": "data-constant", default: 0.5, minimum: 0, maximum: 1, expression: { interpolated: true, parameters: ["zoom"] }, transition: true }, "horizon-fog-blend": { type: "number", "property-type": "data-constant", default: 0.8, minimum: 0, maximum: 1, expression: { interpolated: true, parameters: ["zoom"] }, transition: true }, "sky-horizon-blend": { type: "number", "property-type": "data-constant", default: 0.8, minimum: 0, maximum: 1, expression: { interpolated: true, parameters: ["zoom"] }, transition: true }, "atmosphere-blend": { type: "number", "property-type": "data-constant", default: 0.8, minimum: 0, maximum: 1, expression: { interpolated: true, parameters: ["zoom"] }, transition: true } }, terrain: { source: { type: "string", required: true }, exaggeration: { type: "number", minimum: 0, default: 1 } }, projection: { type: { type: "projectionDefinition", default: "mercator", "property-type": "data-constant", transition: false, expression: { interpolated: true, parameters: ["zoom"] } } }, paint: ["paint_fill", "paint_line", "paint_circle", "paint_heatmap", "paint_fill-extrusion", "paint_symbol", "paint_raster", "paint_hillshade", "paint_background"], paint_fill: { "fill-antialias": { type: "boolean", default: true, expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-color": { type: "color", default: "#000000", transition: true, requires: [{ "!": "fill-pattern" }], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-outline-color": { type: "color", transition: true, requires: [{ "!": "fill-pattern" }, { "fill-antialias": true }], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["fill-translate"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-pattern": { type: "resolvedImage", transition: true, expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "cross-faded-data-driven" } }, "paint_fill-extrusion": { "fill-extrusion-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-extrusion-color": { type: "color", default: "#000000", transition: true, requires: [{ "!": "fill-extrusion-pattern" }], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-extrusion-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-extrusion-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["fill-extrusion-translate"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-extrusion-pattern": { type: "resolvedImage", transition: true, expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "cross-faded-data-driven" }, "fill-extrusion-height": { type: "number", default: 0, minimum: 0, units: "meters", transition: true, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-extrusion-base": { type: "number", default: 0, minimum: 0, units: "meters", transition: true, requires: ["fill-extrusion-height"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-extrusion-vertical-gradient": { type: "boolean", default: true, transition: false, expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_line: { "line-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-color": { type: "color", default: "#000000", transition: true, requires: [{ "!": "line-pattern" }], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["line-translate"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-width": { type: "number", default: 1, minimum: 0, transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-gap-width": { type: "number", default: 0, minimum: 0, transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-offset": { type: "number", default: 0, transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-blur": { type: "number", default: 0, minimum: 0, transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-dasharray": { type: "array", value: "number", minimum: 0, transition: true, units: "line widths", requires: [{ "!": "line-pattern" }], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "cross-faded" }, "line-pattern": { type: "resolvedImage", transition: true, expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "cross-faded-data-driven" }, "line-gradient": { type: "color", transition: false, requires: [{ "!": "line-dasharray" }, { "!": "line-pattern" }, { source: "geojson", has: { lineMetrics: true } }], expression: { interpolated: true, parameters: ["line-progress"] }, "property-type": "color-ramp" } }, paint_circle: { "circle-radius": { type: "number", default: 5, minimum: 0, transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-color": { type: "color", default: "#000000", transition: true, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-blur": { type: "number", default: 0, transition: true, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "circle-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["circle-translate"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "circle-pitch-scale": { type: "enum", values: { map: {}, viewport: {} }, default: "map", expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "circle-pitch-alignment": { type: "enum", values: { map: {}, viewport: {} }, default: "viewport", expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "circle-stroke-width": { type: "number", default: 0, minimum: 0, transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-stroke-color": { type: "color", default: "#000000", transition: true, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-stroke-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" } }, paint_heatmap: { "heatmap-radius": { type: "number", default: 30, minimum: 1, transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "heatmap-weight": { type: "number", default: 1, minimum: 0, transition: false, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "heatmap-intensity": { type: "number", default: 1, minimum: 0, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "heatmap-color": { type: "color", default: ["interpolate", ["linear"], ["heatmap-density"], 0, "rgba(0, 0, 255, 0)", 0.1, "royalblue", 0.3, "cyan", 0.5, "lime", 0.7, "yellow", 1, "red"], transition: false, expression: { interpolated: true, parameters: ["heatmap-density"] }, "property-type": "color-ramp" }, "heatmap-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_symbol: { "icon-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-color": { type: "color", default: "#000000", transition: true, requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-halo-color": { type: "color", default: "rgba(0, 0, 0, 0)", transition: true, requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-halo-width": { type: "number", default: 0, minimum: 0, transition: true, units: "pixels", requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-halo-blur": { type: "number", default: 0, minimum: 0, transition: true, units: "pixels", requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: true, units: "pixels", requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["icon-image", "icon-translate"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-color": { type: "color", default: "#000000", transition: true, overridable: true, requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-halo-color": { type: "color", default: "rgba(0, 0, 0, 0)", transition: true, requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-halo-width": { type: "number", default: 0, minimum: 0, transition: true, units: "pixels", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-halo-blur": { type: "number", default: 0, minimum: 0, transition: true, units: "pixels", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: true, units: "pixels", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["text-field", "text-translate"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_raster: { "raster-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-hue-rotate": { type: "number", default: 0, period: 360, transition: true, units: "degrees", expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-brightness-min": { type: "number", default: 0, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-brightness-max": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-saturation": { type: "number", default: 0, minimum: -1, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-contrast": { type: "number", default: 0, minimum: -1, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-resampling": { type: "enum", values: { linear: {}, nearest: {} }, default: "linear", expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-fade-duration": { type: "number", default: 300, minimum: 0, transition: false, units: "milliseconds", expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_hillshade: { "hillshade-illumination-direction": { type: "number", default: 335, minimum: 0, maximum: 359, transition: false, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-illumination-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "viewport", expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-exaggeration": { type: "number", default: 0.5, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-shadow-color": { type: "color", default: "#000000", transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-highlight-color": { type: "color", default: "#FFFFFF", transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-accent-color": { type: "color", default: "#000000", transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_background: { "background-color": { type: "color", default: "#000000", transition: true, requires: [{ "!": "background-pattern" }], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "background-pattern": { type: "resolvedImage", transition: true, expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "cross-faded" }, "background-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" } }, transition: { duration: { type: "number", default: 300, minimum: 0, units: "milliseconds" }, delay: { type: "number", default: 0, minimum: 0, units: "milliseconds" } }, "property-type": { "data-driven": { type: "property-type" }, "cross-faded": { type: "property-type" }, "cross-faded-data-driven": { type: "property-type" }, "color-ramp": { type: "property-type" }, "data-constant": { type: "property-type" }, constant: { type: "property-type" } }, promoteId: { "*": { type: "string" } } };
        const yt = ["type", "source", "source-layer", "minzoom", "maxzoom", "filter", "layout"];
        function mt(t5, e6) {
          const r8 = {};
          for (const e7 in t5) "ref" !== e7 && (r8[e7] = t5[e7]);
          return yt.forEach((t6) => {
            t6 in e6 && (r8[t6] = e6[t6]);
          }), r8;
        }
        function gt(t5, e6) {
          if (Array.isArray(t5)) {
            if (!Array.isArray(e6) || t5.length !== e6.length) return false;
            for (let r8 = 0; r8 < t5.length; r8++) if (!gt(t5[r8], e6[r8])) return false;
            return true;
          }
          if ("object" == typeof t5 && null !== t5 && null !== e6) {
            if ("object" != typeof e6) return false;
            if (Object.keys(t5).length !== Object.keys(e6).length) return false;
            for (const r8 in t5) if (!gt(t5[r8], e6[r8])) return false;
            return true;
          }
          return t5 === e6;
        }
        function xt(t5, e6) {
          t5.push(e6);
        }
        function vt(t5, e6, r8) {
          xt(r8, { command: "addSource", args: [t5, e6[t5]] });
        }
        function bt(t5, e6, r8) {
          xt(e6, { command: "removeSource", args: [t5] }), r8[t5] = true;
        }
        function wt(t5, e6, r8, n6) {
          bt(t5, r8, n6), vt(t5, e6, r8);
        }
        function _t(t5, e6, r8) {
          let n6;
          for (n6 in t5[r8]) if (Object.prototype.hasOwnProperty.call(t5[r8], n6) && "data" !== n6 && !gt(t5[r8][n6], e6[r8][n6])) return false;
          for (n6 in e6[r8]) if (Object.prototype.hasOwnProperty.call(e6[r8], n6) && "data" !== n6 && !gt(t5[r8][n6], e6[r8][n6])) return false;
          return true;
        }
        function St(t5, e6, r8, n6, i6, s4) {
          t5 = t5 || {}, e6 = e6 || {};
          for (const a4 in t5) Object.prototype.hasOwnProperty.call(t5, a4) && (gt(t5[a4], e6[a4]) || r8.push({ command: s4, args: [n6, a4, e6[a4], i6] }));
          for (const a4 in e6) Object.prototype.hasOwnProperty.call(e6, a4) && !Object.prototype.hasOwnProperty.call(t5, a4) && (gt(t5[a4], e6[a4]) || r8.push({ command: s4, args: [n6, a4, e6[a4], i6] }));
        }
        function At(t5) {
          return t5.id;
        }
        function kt(t5, e6) {
          return t5[e6.id] = e6, t5;
        }
        class Mt {
          constructor(t5, e6, r8, n6) {
            this.message = (t5 ? `${t5}: ` : "") + r8, n6 && (this.identifier = n6), null != e6 && e6.__line__ && (this.line = e6.__line__);
          }
        }
        function It(t5, ...e6) {
          for (const r8 of e6) for (const e7 in r8) t5[e7] = r8[e7];
          return t5;
        }
        class zt extends Error {
          constructor(t5, e6) {
            super(e6), this.message = e6, this.key = t5;
          }
        }
        class Pt {
          constructor(t5, e6 = []) {
            this.parent = t5, this.bindings = {};
            for (const [t6, r8] of e6) this.bindings[t6] = r8;
          }
          concat(t5) {
            return new Pt(this, t5);
          }
          get(t5) {
            if (this.bindings[t5]) return this.bindings[t5];
            if (this.parent) return this.parent.get(t5);
            throw new Error(`${t5} not found in scope.`);
          }
          has(t5) {
            return !!this.bindings[t5] || !!this.parent && this.parent.has(t5);
          }
        }
        const Ct = { kind: "null" }, Bt = { kind: "number" }, Vt = { kind: "string" }, Et = { kind: "boolean" }, Tt = { kind: "color" }, Ft = { kind: "projectionDefinition" }, $t = { kind: "object" }, Lt = { kind: "value" }, Ot = { kind: "collator" }, Dt = { kind: "formatted" }, Rt = { kind: "padding" }, jt = { kind: "resolvedImage" }, Nt = { kind: "variableAnchorOffsetCollection" };
        function Ut(t5, e6) {
          return { kind: "array", itemType: t5, N: e6 };
        }
        function qt(t5) {
          if ("array" === t5.kind) {
            const e6 = qt(t5.itemType);
            return "number" == typeof t5.N ? `array<${e6}, ${t5.N}>` : "value" === t5.itemType.kind ? "array" : `array<${e6}>`;
          }
          return t5.kind;
        }
        const Gt = [Ct, Bt, Vt, Et, Tt, Ft, Dt, $t, Ut(Lt), Rt, jt, Nt];
        function Zt(t5, e6) {
          if ("error" === e6.kind) return null;
          if ("array" === t5.kind) {
            if ("array" === e6.kind && (0 === e6.N && "value" === e6.itemType.kind || !Zt(t5.itemType, e6.itemType)) && ("number" != typeof t5.N || t5.N === e6.N)) return null;
          } else {
            if (t5.kind === e6.kind) return null;
            if ("value" === t5.kind) {
              for (const t6 of Gt) if (!Zt(t6, e6)) return null;
            }
          }
          return `Expected ${qt(t5)} but found ${qt(e6)} instead.`;
        }
        function Kt(t5, e6) {
          return e6.some((e7) => e7.kind === t5.kind);
        }
        function Xt(t5, e6) {
          return e6.some((e7) => "null" === e7 ? null === t5 : "array" === e7 ? Array.isArray(t5) : "object" === e7 ? t5 && !Array.isArray(t5) && "object" == typeof t5 : e7 === typeof t5);
        }
        function Ht(t5, e6) {
          return "array" === t5.kind && "array" === e6.kind ? t5.itemType.kind === e6.itemType.kind && "number" == typeof t5.N : t5.kind === e6.kind;
        }
        const Yt = 0.96422, Jt = 0.82521, Wt = 4 / 29, Qt = 6 / 29, te = 3 * Qt * Qt, ee = Qt * Qt * Qt, re2 = Math.PI / 180, ne = 180 / Math.PI;
        function ie2(t5) {
          return (t5 %= 360) < 0 && (t5 += 360), t5;
        }
        function se([t5, e6, r8, n6]) {
          let i6, s4;
          const a4 = oe((0.2225045 * (t5 = ae(t5)) + 0.7168786 * (e6 = ae(e6)) + 0.0606169 * (r8 = ae(r8))) / 1);
          t5 === e6 && e6 === r8 ? i6 = s4 = a4 : (i6 = oe((0.4360747 * t5 + 0.3850649 * e6 + 0.1430804 * r8) / Yt), s4 = oe((0.0139322 * t5 + 0.0971045 * e6 + 0.7141733 * r8) / Jt));
          const o6 = 116 * a4 - 16;
          return [o6 < 0 ? 0 : o6, 500 * (i6 - a4), 200 * (a4 - s4), n6];
        }
        function ae(t5) {
          return t5 <= 0.04045 ? t5 / 12.92 : Math.pow((t5 + 0.055) / 1.055, 2.4);
        }
        function oe(t5) {
          return t5 > ee ? Math.pow(t5, 1 / 3) : t5 / te + Wt;
        }
        function le([t5, e6, r8, n6]) {
          let i6 = (t5 + 16) / 116, s4 = isNaN(e6) ? i6 : i6 + e6 / 500, a4 = isNaN(r8) ? i6 : i6 - r8 / 200;
          return i6 = 1 * ce(i6), s4 = Yt * ce(s4), a4 = Jt * ce(a4), [ue(3.1338561 * s4 - 1.6168667 * i6 - 0.4906146 * a4), ue(-0.9787684 * s4 + 1.9161415 * i6 + 0.033454 * a4), ue(0.0719453 * s4 - 0.2289914 * i6 + 1.4052427 * a4), n6];
        }
        function ue(t5) {
          return (t5 = t5 <= 304e-5 ? 12.92 * t5 : 1.055 * Math.pow(t5, 1 / 2.4) - 0.055) < 0 ? 0 : t5 > 1 ? 1 : t5;
        }
        function ce(t5) {
          return t5 > Qt ? t5 * t5 * t5 : te * (t5 - Wt);
        }
        function he(t5) {
          return parseInt(t5.padEnd(2, t5), 16) / 255;
        }
        function pe(t5, e6) {
          return fe(e6 ? t5 / 100 : t5, 0, 1);
        }
        function fe(t5, e6, r8) {
          return Math.min(Math.max(e6, t5), r8);
        }
        function de(t5) {
          return !t5.some(Number.isNaN);
        }
        const ye = { aliceblue: [240, 248, 255], antiquewhite: [250, 235, 215], aqua: [0, 255, 255], aquamarine: [127, 255, 212], azure: [240, 255, 255], beige: [245, 245, 220], bisque: [255, 228, 196], black: [0, 0, 0], blanchedalmond: [255, 235, 205], blue: [0, 0, 255], blueviolet: [138, 43, 226], brown: [165, 42, 42], burlywood: [222, 184, 135], cadetblue: [95, 158, 160], chartreuse: [127, 255, 0], chocolate: [210, 105, 30], coral: [255, 127, 80], cornflowerblue: [100, 149, 237], cornsilk: [255, 248, 220], crimson: [220, 20, 60], cyan: [0, 255, 255], darkblue: [0, 0, 139], darkcyan: [0, 139, 139], darkgoldenrod: [184, 134, 11], darkgray: [169, 169, 169], darkgreen: [0, 100, 0], darkgrey: [169, 169, 169], darkkhaki: [189, 183, 107], darkmagenta: [139, 0, 139], darkolivegreen: [85, 107, 47], darkorange: [255, 140, 0], darkorchid: [153, 50, 204], darkred: [139, 0, 0], darksalmon: [233, 150, 122], darkseagreen: [143, 188, 143], darkslateblue: [72, 61, 139], darkslategray: [47, 79, 79], darkslategrey: [47, 79, 79], darkturquoise: [0, 206, 209], darkviolet: [148, 0, 211], deeppink: [255, 20, 147], deepskyblue: [0, 191, 255], dimgray: [105, 105, 105], dimgrey: [105, 105, 105], dodgerblue: [30, 144, 255], firebrick: [178, 34, 34], floralwhite: [255, 250, 240], forestgreen: [34, 139, 34], fuchsia: [255, 0, 255], gainsboro: [220, 220, 220], ghostwhite: [248, 248, 255], gold: [255, 215, 0], goldenrod: [218, 165, 32], gray: [128, 128, 128], green: [0, 128, 0], greenyellow: [173, 255, 47], grey: [128, 128, 128], honeydew: [240, 255, 240], hotpink: [255, 105, 180], indianred: [205, 92, 92], indigo: [75, 0, 130], ivory: [255, 255, 240], khaki: [240, 230, 140], lavender: [230, 230, 250], lavenderblush: [255, 240, 245], lawngreen: [124, 252, 0], lemonchiffon: [255, 250, 205], lightblue: [173, 216, 230], lightcoral: [240, 128, 128], lightcyan: [224, 255, 255], lightgoldenrodyellow: [250, 250, 210], lightgray: [211, 211, 211], lightgreen: [144, 238, 144], lightgrey: [211, 211, 211], lightpink: [255, 182, 193], lightsalmon: [255, 160, 122], lightseagreen: [32, 178, 170], lightskyblue: [135, 206, 250], lightslategray: [119, 136, 153], lightslategrey: [119, 136, 153], lightsteelblue: [176, 196, 222], lightyellow: [255, 255, 224], lime: [0, 255, 0], limegreen: [50, 205, 50], linen: [250, 240, 230], magenta: [255, 0, 255], maroon: [128, 0, 0], mediumaquamarine: [102, 205, 170], mediumblue: [0, 0, 205], mediumorchid: [186, 85, 211], mediumpurple: [147, 112, 219], mediumseagreen: [60, 179, 113], mediumslateblue: [123, 104, 238], mediumspringgreen: [0, 250, 154], mediumturquoise: [72, 209, 204], mediumvioletred: [199, 21, 133], midnightblue: [25, 25, 112], mintcream: [245, 255, 250], mistyrose: [255, 228, 225], moccasin: [255, 228, 181], navajowhite: [255, 222, 173], navy: [0, 0, 128], oldlace: [253, 245, 230], olive: [128, 128, 0], olivedrab: [107, 142, 35], orange: [255, 165, 0], orangered: [255, 69, 0], orchid: [218, 112, 214], palegoldenrod: [238, 232, 170], palegreen: [152, 251, 152], paleturquoise: [175, 238, 238], palevioletred: [219, 112, 147], papayawhip: [255, 239, 213], peachpuff: [255, 218, 185], peru: [205, 133, 63], pink: [255, 192, 203], plum: [221, 160, 221], powderblue: [176, 224, 230], purple: [128, 0, 128], rebeccapurple: [102, 51, 153], red: [255, 0, 0], rosybrown: [188, 143, 143], royalblue: [65, 105, 225], saddlebrown: [139, 69, 19], salmon: [250, 128, 114], sandybrown: [244, 164, 96], seagreen: [46, 139, 87], seashell: [255, 245, 238], sienna: [160, 82, 45], silver: [192, 192, 192], skyblue: [135, 206, 235], slateblue: [106, 90, 205], slategray: [112, 128, 144], slategrey: [112, 128, 144], snow: [255, 250, 250], springgreen: [0, 255, 127], steelblue: [70, 130, 180], tan: [210, 180, 140], teal: [0, 128, 128], thistle: [216, 191, 216], tomato: [255, 99, 71], turquoise: [64, 224, 208], violet: [238, 130, 238], wheat: [245, 222, 179], white: [255, 255, 255], whitesmoke: [245, 245, 245], yellow: [255, 255, 0], yellowgreen: [154, 205, 50] };
        function me(t5, e6, r8) {
          return t5 + r8 * (e6 - t5);
        }
        function ge(t5, e6, r8) {
          return t5.map((t6, n6) => me(t6, e6[n6], r8));
        }
        class xe {
          constructor(t5, e6, r8, n6 = 1, i6 = true) {
            this.r = t5, this.g = e6, this.b = r8, this.a = n6, i6 || (this.r *= n6, this.g *= n6, this.b *= n6, n6 || this.overwriteGetter("rgb", [t5, e6, r8, n6]));
          }
          static parse(t5) {
            if (t5 instanceof xe) return t5;
            if ("string" != typeof t5) return;
            const e6 = function(t6) {
              if ("transparent" === (t6 = t6.toLowerCase().trim())) return [0, 0, 0, 0];
              const e7 = ye[t6];
              if (e7) {
                const [t7, r9, n6] = e7;
                return [t7 / 255, r9 / 255, n6 / 255, 1];
              }
              if (t6.startsWith("#") && /^#(?:[0-9a-f]{3,4}|[0-9a-f]{6}|[0-9a-f]{8})$/.test(t6)) {
                const e8 = t6.length < 6 ? 1 : 2;
                let r9 = 1;
                return [he(t6.slice(r9, r9 += e8)), he(t6.slice(r9, r9 += e8)), he(t6.slice(r9, r9 += e8)), he(t6.slice(r9, r9 + e8) || "ff")];
              }
              if (t6.startsWith("rgb")) {
                const e8 = t6.match(/^rgba?\(\s*([\de.+-]+)(%)?(?:\s+|\s*(,)\s*)([\de.+-]+)(%)?(?:\s+|\s*(,)\s*)([\de.+-]+)(%)?(?:\s*([,\/])\s*([\de.+-]+)(%)?)?\s*\)$/);
                if (e8) {
                  const [t7, r9, n6, i6, s4, a4, o6, l5, u4, c5, h4, p4] = e8, f4 = [i6 || " ", o6 || " ", c5].join("");
                  if ("  " === f4 || "  /" === f4 || ",," === f4 || ",,," === f4) {
                    const t8 = [n6, a4, u4].join(""), e9 = "%%%" === t8 ? 100 : "" === t8 ? 255 : 0;
                    if (e9) {
                      const t9 = [fe(+r9 / e9, 0, 1), fe(+s4 / e9, 0, 1), fe(+l5 / e9, 0, 1), h4 ? pe(+h4, p4) : 1];
                      if (de(t9)) return t9;
                    }
                  }
                  return;
                }
              }
              const r8 = t6.match(/^hsla?\(\s*([\de.+-]+)(?:deg)?(?:\s+|\s*(,)\s*)([\de.+-]+)%(?:\s+|\s*(,)\s*)([\de.+-]+)%(?:\s*([,\/])\s*([\de.+-]+)(%)?)?\s*\)$/);
              if (r8) {
                const [t7, e8, n6, i6, s4, a4, o6, l5, u4] = r8, c5 = [n6 || " ", s4 || " ", o6].join("");
                if ("  " === c5 || "  /" === c5 || ",," === c5 || ",,," === c5) {
                  const t8 = [+e8, fe(+i6, 0, 100), fe(+a4, 0, 100), l5 ? pe(+l5, u4) : 1];
                  if (de(t8)) return function([t9, e9, r9, n7]) {
                    function i7(n8) {
                      const i8 = (n8 + t9 / 30) % 12, s5 = e9 * Math.min(r9, 1 - r9);
                      return r9 - s5 * Math.max(-1, Math.min(i8 - 3, 9 - i8, 1));
                    }
                    return t9 = ie2(t9), e9 /= 100, r9 /= 100, [i7(0), i7(8), i7(4), n7];
                  }(t8);
                }
              }
            }(t5);
            return e6 ? new xe(...e6, false) : void 0;
          }
          get rgb() {
            const { r: t5, g: e6, b: r8, a: n6 } = this, i6 = n6 || 1 / 0;
            return this.overwriteGetter("rgb", [t5 / i6, e6 / i6, r8 / i6, n6]);
          }
          get hcl() {
            return this.overwriteGetter("hcl", function(t5) {
              const [e6, r8, n6, i6] = se(t5), s4 = Math.sqrt(r8 * r8 + n6 * n6);
              return [Math.round(1e4 * s4) ? ie2(Math.atan2(n6, r8) * ne) : NaN, s4, e6, i6];
            }(this.rgb));
          }
          get lab() {
            return this.overwriteGetter("lab", se(this.rgb));
          }
          overwriteGetter(t5, e6) {
            return Object.defineProperty(this, t5, { value: e6 }), e6;
          }
          toString() {
            const [t5, e6, r8, n6] = this.rgb;
            return `rgba(${[t5, e6, r8].map((t6) => Math.round(255 * t6)).join(",")},${n6})`;
          }
          static interpolate(t5, e6, r8, n6 = "rgb") {
            switch (n6) {
              case "rgb": {
                const [n7, i6, s4, a4] = ge(t5.rgb, e6.rgb, r8);
                return new xe(n7, i6, s4, a4, false);
              }
              case "hcl": {
                const [n7, i6, s4, a4] = t5.hcl, [o6, l5, u4, c5] = e6.hcl;
                let h4, p4;
                if (isNaN(n7) || isNaN(o6)) isNaN(n7) ? isNaN(o6) ? h4 = NaN : (h4 = o6, 1 !== s4 && 0 !== s4 || (p4 = l5)) : (h4 = n7, 1 !== u4 && 0 !== u4 || (p4 = i6));
                else {
                  let t6 = o6 - n7;
                  o6 > n7 && t6 > 180 ? t6 -= 360 : o6 < n7 && n7 - o6 > 180 && (t6 += 360), h4 = n7 + r8 * t6;
                }
                const [f4, d4, y4, m4] = function([t6, e7, r9, n8]) {
                  return t6 = isNaN(t6) ? 0 : t6 * re2, le([r9, Math.cos(t6) * e7, Math.sin(t6) * e7, n8]);
                }([h4, null != p4 ? p4 : me(i6, l5, r8), me(s4, u4, r8), me(a4, c5, r8)]);
                return new xe(f4, d4, y4, m4, false);
              }
              case "lab": {
                const [n7, i6, s4, a4] = le(ge(t5.lab, e6.lab, r8));
                return new xe(n7, i6, s4, a4, false);
              }
            }
          }
        }
        xe.black = new xe(0, 0, 0, 1), xe.white = new xe(1, 1, 1, 1), xe.transparent = new xe(0, 0, 0, 0), xe.red = new xe(1, 0, 0, 1);
        class ve {
          constructor(t5, e6, r8) {
            this.sensitivity = t5 ? e6 ? "variant" : "case" : e6 ? "accent" : "base", this.locale = r8, this.collator = new Intl.Collator(this.locale ? this.locale : [], { sensitivity: this.sensitivity, usage: "search" });
          }
          compare(t5, e6) {
            return this.collator.compare(t5, e6);
          }
          resolvedLocale() {
            return new Intl.Collator(this.locale ? this.locale : []).resolvedOptions().locale;
          }
        }
        const be = ["bottom", "center", "top"];
        class we {
          constructor(t5, e6, r8, n6, i6, s4) {
            this.text = t5, this.image = e6, this.scale = r8, this.fontStack = n6, this.textColor = i6, this.verticalAlign = s4;
          }
        }
        class _e {
          constructor(t5) {
            this.sections = t5;
          }
          static fromString(t5) {
            return new _e([new we(t5, null, null, null, null, null)]);
          }
          isEmpty() {
            return 0 === this.sections.length || !this.sections.some((t5) => 0 !== t5.text.length || t5.image && 0 !== t5.image.name.length);
          }
          static factory(t5) {
            return t5 instanceof _e ? t5 : _e.fromString(t5);
          }
          toString() {
            return 0 === this.sections.length ? "" : this.sections.map((t5) => t5.text).join("");
          }
        }
        class Se {
          constructor(t5) {
            this.values = t5.slice();
          }
          static parse(t5) {
            if (t5 instanceof Se) return t5;
            if ("number" == typeof t5) return new Se([t5, t5, t5, t5]);
            if (Array.isArray(t5) && !(t5.length < 1 || t5.length > 4)) {
              for (const e6 of t5) if ("number" != typeof e6) return;
              switch (t5.length) {
                case 1:
                  t5 = [t5[0], t5[0], t5[0], t5[0]];
                  break;
                case 2:
                  t5 = [t5[0], t5[1], t5[0], t5[1]];
                  break;
                case 3:
                  t5 = [t5[0], t5[1], t5[2], t5[1]];
              }
              return new Se(t5);
            }
          }
          toString() {
            return JSON.stringify(this.values);
          }
          static interpolate(t5, e6, r8) {
            return new Se(ge(t5.values, e6.values, r8));
          }
        }
        class Ae {
          constructor(t5) {
            this.name = "ExpressionEvaluationError", this.message = t5;
          }
          toJSON() {
            return this.message;
          }
        }
        const ke = /* @__PURE__ */ new Set(["center", "left", "right", "top", "bottom", "top-left", "top-right", "bottom-left", "bottom-right"]);
        class Me {
          constructor(t5) {
            this.values = t5.slice();
          }
          static parse(t5) {
            if (t5 instanceof Me) return t5;
            if (Array.isArray(t5) && !(t5.length < 1) && t5.length % 2 == 0) {
              for (let e6 = 0; e6 < t5.length; e6 += 2) {
                const r8 = t5[e6], n6 = t5[e6 + 1];
                if ("string" != typeof r8 || !ke.has(r8)) return;
                if (!Array.isArray(n6) || 2 !== n6.length || "number" != typeof n6[0] || "number" != typeof n6[1]) return;
              }
              return new Me(t5);
            }
          }
          toString() {
            return JSON.stringify(this.values);
          }
          static interpolate(t5, e6, r8) {
            const n6 = t5.values, i6 = e6.values;
            if (n6.length !== i6.length) throw new Ae(`Cannot interpolate values of different length. from: ${t5.toString()}, to: ${e6.toString()}`);
            const s4 = [];
            for (let t6 = 0; t6 < n6.length; t6 += 2) {
              if (n6[t6] !== i6[t6]) throw new Ae(`Cannot interpolate values containing mismatched anchors. from[${t6}]: ${n6[t6]}, to[${t6}]: ${i6[t6]}`);
              s4.push(n6[t6]);
              const [e7, a4] = n6[t6 + 1], [o6, l5] = i6[t6 + 1];
              s4.push([me(e7, o6, r8), me(a4, l5, r8)]);
            }
            return new Me(s4);
          }
        }
        class Ie {
          constructor(t5) {
            this.name = t5.name, this.available = t5.available;
          }
          toString() {
            return this.name;
          }
          static fromString(t5) {
            return t5 ? new Ie({ name: t5, available: false }) : null;
          }
        }
        class ze {
          constructor(t5, e6, r8) {
            this.from = t5, this.to = e6, this.transition = r8;
          }
          static interpolate(t5, e6, r8) {
            return new ze(t5, e6, r8);
          }
          static parse(t5) {
            return t5 instanceof ze ? t5 : Array.isArray(t5) && 3 === t5.length && "string" == typeof t5[0] && "string" == typeof t5[1] && "number" == typeof t5[2] ? new ze(t5[0], t5[1], t5[2]) : "object" == typeof t5 && "string" == typeof t5.from && "string" == typeof t5.to && "number" == typeof t5.transition ? new ze(t5.from, t5.to, t5.transition) : "string" == typeof t5 ? new ze(t5, t5, 1) : void 0;
          }
        }
        function Pe(t5, e6, r8, n6) {
          return "number" == typeof t5 && t5 >= 0 && t5 <= 255 && "number" == typeof e6 && e6 >= 0 && e6 <= 255 && "number" == typeof r8 && r8 >= 0 && r8 <= 255 ? void 0 === n6 || "number" == typeof n6 && n6 >= 0 && n6 <= 1 ? null : `Invalid rgba value [${[t5, e6, r8, n6].join(", ")}]: 'a' must be between 0 and 1.` : `Invalid rgba value [${("number" == typeof n6 ? [t5, e6, r8, n6] : [t5, e6, r8]).join(", ")}]: 'r', 'g', and 'b' must be between 0 and 255.`;
        }
        function Ce(t5) {
          if (null === t5 || "string" == typeof t5 || "boolean" == typeof t5 || "number" == typeof t5 || t5 instanceof ze || t5 instanceof xe || t5 instanceof ve || t5 instanceof _e || t5 instanceof Se || t5 instanceof Me || t5 instanceof Ie) return true;
          if (Array.isArray(t5)) {
            for (const e6 of t5) if (!Ce(e6)) return false;
            return true;
          }
          if ("object" == typeof t5) {
            for (const e6 in t5) if (!Ce(t5[e6])) return false;
            return true;
          }
          return false;
        }
        function Be(t5) {
          if (null === t5) return Ct;
          if ("string" == typeof t5) return Vt;
          if ("boolean" == typeof t5) return Et;
          if ("number" == typeof t5) return Bt;
          if (t5 instanceof xe) return Tt;
          if (t5 instanceof ze) return Ft;
          if (t5 instanceof ve) return Ot;
          if (t5 instanceof _e) return Dt;
          if (t5 instanceof Se) return Rt;
          if (t5 instanceof Me) return Nt;
          if (t5 instanceof Ie) return jt;
          if (Array.isArray(t5)) {
            const e6 = t5.length;
            let r8;
            for (const e7 of t5) {
              const t6 = Be(e7);
              if (r8) {
                if (r8 === t6) continue;
                r8 = Lt;
                break;
              }
              r8 = t6;
            }
            return Ut(r8 || Lt, e6);
          }
          return $t;
        }
        function Ve(t5) {
          const e6 = typeof t5;
          return null === t5 ? "" : "string" === e6 || "number" === e6 || "boolean" === e6 ? String(t5) : t5 instanceof xe || t5 instanceof ze || t5 instanceof _e || t5 instanceof Se || t5 instanceof Me || t5 instanceof Ie ? t5.toString() : JSON.stringify(t5);
        }
        class Ee {
          constructor(t5, e6) {
            this.type = t5, this.value = e6;
          }
          static parse(t5, e6) {
            if (2 !== t5.length) return e6.error(`'literal' expression requires exactly one argument, but found ${t5.length - 1} instead.`);
            if (!Ce(t5[1])) return e6.error("invalid value");
            const r8 = t5[1];
            let n6 = Be(r8);
            const i6 = e6.expectedType;
            return "array" !== n6.kind || 0 !== n6.N || !i6 || "array" !== i6.kind || "number" == typeof i6.N && 0 !== i6.N || (n6 = i6), new Ee(n6, r8);
          }
          evaluate() {
            return this.value;
          }
          eachChild() {
          }
          outputDefined() {
            return true;
          }
        }
        const Te = { string: Vt, number: Bt, boolean: Et, object: $t };
        class Fe {
          constructor(t5, e6) {
            this.type = t5, this.args = e6;
          }
          static parse(t5, e6) {
            if (t5.length < 2) return e6.error("Expected at least one argument.");
            let r8, n6 = 1;
            const i6 = t5[0];
            if ("array" === i6) {
              let i7, s5;
              if (t5.length > 2) {
                const r9 = t5[1];
                if ("string" != typeof r9 || !(r9 in Te) || "object" === r9) return e6.error('The item type argument of "array" must be one of string, number, boolean', 1);
                i7 = Te[r9], n6++;
              } else i7 = Lt;
              if (t5.length > 3) {
                if (null !== t5[2] && ("number" != typeof t5[2] || t5[2] < 0 || t5[2] !== Math.floor(t5[2]))) return e6.error('The length argument to "array" must be a positive integer literal', 2);
                s5 = t5[2], n6++;
              }
              r8 = Ut(i7, s5);
            } else {
              if (!Te[i6]) throw new Error(`Types doesn't contain name = ${i6}`);
              r8 = Te[i6];
            }
            const s4 = [];
            for (; n6 < t5.length; n6++) {
              const r9 = e6.parse(t5[n6], n6, Lt);
              if (!r9) return null;
              s4.push(r9);
            }
            return new Fe(r8, s4);
          }
          evaluate(t5) {
            for (let e6 = 0; e6 < this.args.length; e6++) {
              const r8 = this.args[e6].evaluate(t5);
              if (!Zt(this.type, Be(r8))) return r8;
              if (e6 === this.args.length - 1) throw new Ae(`Expected value to be of type ${qt(this.type)}, but found ${qt(Be(r8))} instead.`);
            }
            throw new Error();
          }
          eachChild(t5) {
            this.args.forEach(t5);
          }
          outputDefined() {
            return this.args.every((t5) => t5.outputDefined());
          }
        }
        const $e = { "to-boolean": Et, "to-color": Tt, "to-number": Bt, "to-string": Vt };
        class Le {
          constructor(t5, e6) {
            this.type = t5, this.args = e6;
          }
          static parse(t5, e6) {
            if (t5.length < 2) return e6.error("Expected at least one argument.");
            const r8 = t5[0];
            if (!$e[r8]) throw new Error(`Can't parse ${r8} as it is not part of the known types`);
            if (("to-boolean" === r8 || "to-string" === r8) && 2 !== t5.length) return e6.error("Expected one argument.");
            const n6 = $e[r8], i6 = [];
            for (let r9 = 1; r9 < t5.length; r9++) {
              const n7 = e6.parse(t5[r9], r9, Lt);
              if (!n7) return null;
              i6.push(n7);
            }
            return new Le(n6, i6);
          }
          evaluate(t5) {
            switch (this.type.kind) {
              case "boolean":
                return Boolean(this.args[0].evaluate(t5));
              case "color": {
                let e6, r8;
                for (const n6 of this.args) {
                  if (e6 = n6.evaluate(t5), r8 = null, e6 instanceof xe) return e6;
                  if ("string" == typeof e6) {
                    const r9 = t5.parseColor(e6);
                    if (r9) return r9;
                  } else if (Array.isArray(e6) && (r8 = e6.length < 3 || e6.length > 4 ? `Invalid rgba value ${JSON.stringify(e6)}: expected an array containing either three or four numeric values.` : Pe(e6[0], e6[1], e6[2], e6[3]), !r8)) return new xe(e6[0] / 255, e6[1] / 255, e6[2] / 255, e6[3]);
                }
                throw new Ae(r8 || `Could not parse color from value '${"string" == typeof e6 ? e6 : JSON.stringify(e6)}'`);
              }
              case "padding": {
                let e6;
                for (const r8 of this.args) {
                  e6 = r8.evaluate(t5);
                  const n6 = Se.parse(e6);
                  if (n6) return n6;
                }
                throw new Ae(`Could not parse padding from value '${"string" == typeof e6 ? e6 : JSON.stringify(e6)}'`);
              }
              case "variableAnchorOffsetCollection": {
                let e6;
                for (const r8 of this.args) {
                  e6 = r8.evaluate(t5);
                  const n6 = Me.parse(e6);
                  if (n6) return n6;
                }
                throw new Ae(`Could not parse variableAnchorOffsetCollection from value '${"string" == typeof e6 ? e6 : JSON.stringify(e6)}'`);
              }
              case "number": {
                let e6 = null;
                for (const r8 of this.args) {
                  if (e6 = r8.evaluate(t5), null === e6) return 0;
                  const n6 = Number(e6);
                  if (!isNaN(n6)) return n6;
                }
                throw new Ae(`Could not convert ${JSON.stringify(e6)} to number.`);
              }
              case "formatted":
                return _e.fromString(Ve(this.args[0].evaluate(t5)));
              case "resolvedImage":
                return Ie.fromString(Ve(this.args[0].evaluate(t5)));
              case "projectionDefinition":
                return this.args[0].evaluate(t5);
              default:
                return Ve(this.args[0].evaluate(t5));
            }
          }
          eachChild(t5) {
            this.args.forEach(t5);
          }
          outputDefined() {
            return this.args.every((t5) => t5.outputDefined());
          }
        }
        const Oe = ["Unknown", "Point", "LineString", "Polygon"];
        class De {
          constructor() {
            this.globals = null, this.feature = null, this.featureState = null, this.formattedSection = null, this._parseColorCache = {}, this.availableImages = null, this.canonical = null;
          }
          id() {
            return this.feature && "id" in this.feature ? this.feature.id : null;
          }
          geometryType() {
            return this.feature ? "number" == typeof this.feature.type ? Oe[this.feature.type] : this.feature.type : null;
          }
          geometry() {
            return this.feature && "geometry" in this.feature ? this.feature.geometry : null;
          }
          canonicalID() {
            return this.canonical;
          }
          properties() {
            return this.feature && this.feature.properties || {};
          }
          parseColor(t5) {
            let e6 = this._parseColorCache[t5];
            return e6 || (e6 = this._parseColorCache[t5] = xe.parse(t5)), e6;
          }
        }
        class Re {
          constructor(t5, e6, r8 = [], n6, i6 = new Pt(), s4 = []) {
            this.registry = t5, this.path = r8, this.key = r8.map((t6) => `[${t6}]`).join(""), this.scope = i6, this.errors = s4, this.expectedType = n6, this._isConstant = e6;
          }
          parse(t5, e6, r8, n6, i6 = {}) {
            return e6 ? this.concat(e6, r8, n6)._parse(t5, i6) : this._parse(t5, i6);
          }
          _parse(t5, e6) {
            function r8(t6, e7, r9) {
              return "assert" === r9 ? new Fe(e7, [t6]) : "coerce" === r9 ? new Le(e7, [t6]) : t6;
            }
            if (null !== t5 && "string" != typeof t5 && "boolean" != typeof t5 && "number" != typeof t5 || (t5 = ["literal", t5]), Array.isArray(t5)) {
              if (0 === t5.length) return this.error('Expected an array with at least one element. If you wanted a literal array, use ["literal", []].');
              const n6 = t5[0];
              if ("string" != typeof n6) return this.error(`Expression name must be a string, but found ${typeof n6} instead. If you wanted a literal array, use ["literal", [...]].`, 0), null;
              const i6 = this.registry[n6];
              if (i6) {
                let n7 = i6.parse(t5, this);
                if (!n7) return null;
                if (this.expectedType) {
                  const t6 = this.expectedType, i7 = n7.type;
                  if ("string" !== t6.kind && "number" !== t6.kind && "boolean" !== t6.kind && "object" !== t6.kind && "array" !== t6.kind || "value" !== i7.kind) if ("projectionDefinition" !== t6.kind || "string" !== i7.kind && "array" !== i7.kind) if ("color" !== t6.kind && "formatted" !== t6.kind && "resolvedImage" !== t6.kind || "value" !== i7.kind && "string" !== i7.kind) if ("padding" !== t6.kind || "value" !== i7.kind && "number" !== i7.kind && "array" !== i7.kind) if ("variableAnchorOffsetCollection" !== t6.kind || "value" !== i7.kind && "array" !== i7.kind) {
                    if (this.checkSubtype(t6, i7)) return null;
                  } else n7 = r8(n7, t6, e6.typeAnnotation || "coerce");
                  else n7 = r8(n7, t6, e6.typeAnnotation || "coerce");
                  else n7 = r8(n7, t6, e6.typeAnnotation || "coerce");
                  else n7 = r8(n7, t6, e6.typeAnnotation || "coerce");
                  else n7 = r8(n7, t6, e6.typeAnnotation || "assert");
                }
                if (!(n7 instanceof Ee) && "resolvedImage" !== n7.type.kind && this._isConstant(n7)) {
                  const t6 = new De();
                  try {
                    n7 = new Ee(n7.type, n7.evaluate(t6));
                  } catch (t7) {
                    return this.error(t7.message), null;
                  }
                }
                return n7;
              }
              return this.error(`Unknown expression "${n6}". If you wanted a literal array, use ["literal", [...]].`, 0);
            }
            return this.error(void 0 === t5 ? "'undefined' value invalid. Use null instead." : "object" == typeof t5 ? 'Bare objects invalid. Use ["literal", {...}] instead.' : `Expected an array, but found ${typeof t5} instead.`);
          }
          concat(t5, e6, r8) {
            const n6 = "number" == typeof t5 ? this.path.concat(t5) : this.path, i6 = r8 ? this.scope.concat(r8) : this.scope;
            return new Re(this.registry, this._isConstant, n6, e6 || null, i6, this.errors);
          }
          error(t5, ...e6) {
            const r8 = `${this.key}${e6.map((t6) => `[${t6}]`).join("")}`;
            this.errors.push(new zt(r8, t5));
          }
          checkSubtype(t5, e6) {
            const r8 = Zt(t5, e6);
            return r8 && this.error(r8), r8;
          }
        }
        class je {
          constructor(t5, e6) {
            this.type = e6.type, this.bindings = [].concat(t5), this.result = e6;
          }
          evaluate(t5) {
            return this.result.evaluate(t5);
          }
          eachChild(t5) {
            for (const e6 of this.bindings) t5(e6[1]);
            t5(this.result);
          }
          static parse(t5, e6) {
            if (t5.length < 4) return e6.error(`Expected at least 3 arguments, but found ${t5.length - 1} instead.`);
            const r8 = [];
            for (let n7 = 1; n7 < t5.length - 1; n7 += 2) {
              const i6 = t5[n7];
              if ("string" != typeof i6) return e6.error(`Expected string, but found ${typeof i6} instead.`, n7);
              if (/[^a-zA-Z0-9_]/.test(i6)) return e6.error("Variable names must contain only alphanumeric characters or '_'.", n7);
              const s4 = e6.parse(t5[n7 + 1], n7 + 1);
              if (!s4) return null;
              r8.push([i6, s4]);
            }
            const n6 = e6.parse(t5[t5.length - 1], t5.length - 1, e6.expectedType, r8);
            return n6 ? new je(r8, n6) : null;
          }
          outputDefined() {
            return this.result.outputDefined();
          }
        }
        class Ne {
          constructor(t5, e6) {
            this.type = e6.type, this.name = t5, this.boundExpression = e6;
          }
          static parse(t5, e6) {
            if (2 !== t5.length || "string" != typeof t5[1]) return e6.error("'var' expression requires exactly one string literal argument.");
            const r8 = t5[1];
            return e6.scope.has(r8) ? new Ne(r8, e6.scope.get(r8)) : e6.error(`Unknown variable "${r8}". Make sure "${r8}" has been bound in an enclosing "let" expression before using it.`, 1);
          }
          evaluate(t5) {
            return this.boundExpression.evaluate(t5);
          }
          eachChild() {
          }
          outputDefined() {
            return false;
          }
        }
        class Ue {
          constructor(t5, e6, r8) {
            this.type = t5, this.index = e6, this.input = r8;
          }
          static parse(t5, e6) {
            if (3 !== t5.length) return e6.error(`Expected 2 arguments, but found ${t5.length - 1} instead.`);
            const r8 = e6.parse(t5[1], 1, Bt), n6 = e6.parse(t5[2], 2, Ut(e6.expectedType || Lt));
            return r8 && n6 ? new Ue(n6.type.itemType, r8, n6) : null;
          }
          evaluate(t5) {
            const e6 = this.index.evaluate(t5), r8 = this.input.evaluate(t5);
            if (e6 < 0) throw new Ae(`Array index out of bounds: ${e6} < 0.`);
            if (e6 >= r8.length) throw new Ae(`Array index out of bounds: ${e6} > ${r8.length - 1}.`);
            if (e6 !== Math.floor(e6)) throw new Ae(`Array index must be an integer, but found ${e6} instead.`);
            return r8[e6];
          }
          eachChild(t5) {
            t5(this.index), t5(this.input);
          }
          outputDefined() {
            return false;
          }
        }
        class qe {
          constructor(t5, e6) {
            this.type = Et, this.needle = t5, this.haystack = e6;
          }
          static parse(t5, e6) {
            if (3 !== t5.length) return e6.error(`Expected 2 arguments, but found ${t5.length - 1} instead.`);
            const r8 = e6.parse(t5[1], 1, Lt), n6 = e6.parse(t5[2], 2, Lt);
            return r8 && n6 ? Kt(r8.type, [Et, Vt, Bt, Ct, Lt]) ? new qe(r8, n6) : e6.error(`Expected first argument to be of type boolean, string, number or null, but found ${qt(r8.type)} instead`) : null;
          }
          evaluate(t5) {
            const e6 = this.needle.evaluate(t5), r8 = this.haystack.evaluate(t5);
            if (!r8) return false;
            if (!Xt(e6, ["boolean", "string", "number", "null"])) throw new Ae(`Expected first argument to be of type boolean, string, number or null, but found ${qt(Be(e6))} instead.`);
            if (!Xt(r8, ["string", "array"])) throw new Ae(`Expected second argument to be of type array or string, but found ${qt(Be(r8))} instead.`);
            return r8.indexOf(e6) >= 0;
          }
          eachChild(t5) {
            t5(this.needle), t5(this.haystack);
          }
          outputDefined() {
            return true;
          }
        }
        class Ge {
          constructor(t5, e6, r8) {
            this.type = Bt, this.needle = t5, this.haystack = e6, this.fromIndex = r8;
          }
          static parse(t5, e6) {
            if (t5.length <= 2 || t5.length >= 5) return e6.error(`Expected 3 or 4 arguments, but found ${t5.length - 1} instead.`);
            const r8 = e6.parse(t5[1], 1, Lt), n6 = e6.parse(t5[2], 2, Lt);
            if (!r8 || !n6) return null;
            if (!Kt(r8.type, [Et, Vt, Bt, Ct, Lt])) return e6.error(`Expected first argument to be of type boolean, string, number or null, but found ${qt(r8.type)} instead`);
            if (4 === t5.length) {
              const i6 = e6.parse(t5[3], 3, Bt);
              return i6 ? new Ge(r8, n6, i6) : null;
            }
            return new Ge(r8, n6);
          }
          evaluate(t5) {
            const e6 = this.needle.evaluate(t5), r8 = this.haystack.evaluate(t5);
            if (!Xt(e6, ["boolean", "string", "number", "null"])) throw new Ae(`Expected first argument to be of type boolean, string, number or null, but found ${qt(Be(e6))} instead.`);
            let n6;
            if (this.fromIndex && (n6 = this.fromIndex.evaluate(t5)), Xt(r8, ["string"])) {
              const t6 = r8.indexOf(e6, n6);
              return -1 === t6 ? -1 : [...r8.slice(0, t6)].length;
            }
            if (Xt(r8, ["array"])) return r8.indexOf(e6, n6);
            throw new Ae(`Expected second argument to be of type array or string, but found ${qt(Be(r8))} instead.`);
          }
          eachChild(t5) {
            t5(this.needle), t5(this.haystack), this.fromIndex && t5(this.fromIndex);
          }
          outputDefined() {
            return false;
          }
        }
        class Ze {
          constructor(t5, e6, r8, n6, i6, s4) {
            this.inputType = t5, this.type = e6, this.input = r8, this.cases = n6, this.outputs = i6, this.otherwise = s4;
          }
          static parse(t5, e6) {
            if (t5.length < 5) return e6.error(`Expected at least 4 arguments, but found only ${t5.length - 1}.`);
            if (t5.length % 2 != 1) return e6.error("Expected an even number of arguments.");
            let r8, n6;
            e6.expectedType && "value" !== e6.expectedType.kind && (n6 = e6.expectedType);
            const i6 = {}, s4 = [];
            for (let a5 = 2; a5 < t5.length - 1; a5 += 2) {
              let o7 = t5[a5];
              const l5 = t5[a5 + 1];
              Array.isArray(o7) || (o7 = [o7]);
              const u4 = e6.concat(a5);
              if (0 === o7.length) return u4.error("Expected at least one branch label.");
              for (const t6 of o7) {
                if ("number" != typeof t6 && "string" != typeof t6) return u4.error("Branch labels must be numbers or strings.");
                if ("number" == typeof t6 && Math.abs(t6) > Number.MAX_SAFE_INTEGER) return u4.error(`Branch labels must be integers no larger than ${Number.MAX_SAFE_INTEGER}.`);
                if ("number" == typeof t6 && Math.floor(t6) !== t6) return u4.error("Numeric branch labels must be integer values.");
                if (r8) {
                  if (u4.checkSubtype(r8, Be(t6))) return null;
                } else r8 = Be(t6);
                if (void 0 !== i6[String(t6)]) return u4.error("Branch labels must be unique.");
                i6[String(t6)] = s4.length;
              }
              const c5 = e6.parse(l5, a5, n6);
              if (!c5) return null;
              n6 = n6 || c5.type, s4.push(c5);
            }
            const a4 = e6.parse(t5[1], 1, Lt);
            if (!a4) return null;
            const o6 = e6.parse(t5[t5.length - 1], t5.length - 1, n6);
            return o6 ? "value" !== a4.type.kind && e6.concat(1).checkSubtype(r8, a4.type) ? null : new Ze(r8, n6, a4, i6, s4, o6) : null;
          }
          evaluate(t5) {
            const e6 = this.input.evaluate(t5);
            return (Be(e6) === this.inputType && this.outputs[this.cases[e6]] || this.otherwise).evaluate(t5);
          }
          eachChild(t5) {
            t5(this.input), this.outputs.forEach(t5), t5(this.otherwise);
          }
          outputDefined() {
            return this.outputs.every((t5) => t5.outputDefined()) && this.otherwise.outputDefined();
          }
        }
        class Ke {
          constructor(t5, e6, r8) {
            this.type = t5, this.branches = e6, this.otherwise = r8;
          }
          static parse(t5, e6) {
            if (t5.length < 4) return e6.error(`Expected at least 3 arguments, but found only ${t5.length - 1}.`);
            if (t5.length % 2 != 0) return e6.error("Expected an odd number of arguments.");
            let r8;
            e6.expectedType && "value" !== e6.expectedType.kind && (r8 = e6.expectedType);
            const n6 = [];
            for (let i7 = 1; i7 < t5.length - 1; i7 += 2) {
              const s4 = e6.parse(t5[i7], i7, Et);
              if (!s4) return null;
              const a4 = e6.parse(t5[i7 + 1], i7 + 1, r8);
              if (!a4) return null;
              n6.push([s4, a4]), r8 = r8 || a4.type;
            }
            const i6 = e6.parse(t5[t5.length - 1], t5.length - 1, r8);
            if (!i6) return null;
            if (!r8) throw new Error("Can't infer output type");
            return new Ke(r8, n6, i6);
          }
          evaluate(t5) {
            for (const [e6, r8] of this.branches) if (e6.evaluate(t5)) return r8.evaluate(t5);
            return this.otherwise.evaluate(t5);
          }
          eachChild(t5) {
            for (const [e6, r8] of this.branches) t5(e6), t5(r8);
            t5(this.otherwise);
          }
          outputDefined() {
            return this.branches.every(([t5, e6]) => e6.outputDefined()) && this.otherwise.outputDefined();
          }
        }
        class Xe {
          constructor(t5, e6, r8, n6) {
            this.type = t5, this.input = e6, this.beginIndex = r8, this.endIndex = n6;
          }
          static parse(t5, e6) {
            if (t5.length <= 2 || t5.length >= 5) return e6.error(`Expected 3 or 4 arguments, but found ${t5.length - 1} instead.`);
            const r8 = e6.parse(t5[1], 1, Lt), n6 = e6.parse(t5[2], 2, Bt);
            if (!r8 || !n6) return null;
            if (!Kt(r8.type, [Ut(Lt), Vt, Lt])) return e6.error(`Expected first argument to be of type array or string, but found ${qt(r8.type)} instead`);
            if (4 === t5.length) {
              const i6 = e6.parse(t5[3], 3, Bt);
              return i6 ? new Xe(r8.type, r8, n6, i6) : null;
            }
            return new Xe(r8.type, r8, n6);
          }
          evaluate(t5) {
            const e6 = this.input.evaluate(t5), r8 = this.beginIndex.evaluate(t5);
            let n6;
            if (this.endIndex && (n6 = this.endIndex.evaluate(t5)), Xt(e6, ["string"])) return [...e6].slice(r8, n6).join("");
            if (Xt(e6, ["array"])) return e6.slice(r8, n6);
            throw new Ae(`Expected first argument to be of type array or string, but found ${qt(Be(e6))} instead.`);
          }
          eachChild(t5) {
            t5(this.input), t5(this.beginIndex), this.endIndex && t5(this.endIndex);
          }
          outputDefined() {
            return false;
          }
        }
        function He(t5, e6) {
          const r8 = t5.length - 1;
          let n6, i6, s4 = 0, a4 = r8, o6 = 0;
          for (; s4 <= a4; ) if (o6 = Math.floor((s4 + a4) / 2), n6 = t5[o6], i6 = t5[o6 + 1], n6 <= e6) {
            if (o6 === r8 || e6 < i6) return o6;
            s4 = o6 + 1;
          } else {
            if (!(n6 > e6)) throw new Ae("Input is not a number.");
            a4 = o6 - 1;
          }
          return 0;
        }
        class Ye {
          constructor(t5, e6, r8) {
            this.type = t5, this.input = e6, this.labels = [], this.outputs = [];
            for (const [t6, e7] of r8) this.labels.push(t6), this.outputs.push(e7);
          }
          static parse(t5, e6) {
            if (t5.length - 1 < 4) return e6.error(`Expected at least 4 arguments, but found only ${t5.length - 1}.`);
            if ((t5.length - 1) % 2 != 0) return e6.error("Expected an even number of arguments.");
            const r8 = e6.parse(t5[1], 1, Bt);
            if (!r8) return null;
            const n6 = [];
            let i6 = null;
            e6.expectedType && "value" !== e6.expectedType.kind && (i6 = e6.expectedType);
            for (let r9 = 1; r9 < t5.length; r9 += 2) {
              const s4 = 1 === r9 ? -1 / 0 : t5[r9], a4 = t5[r9 + 1], o6 = r9, l5 = r9 + 1;
              if ("number" != typeof s4) return e6.error('Input/output pairs for "step" expressions must be defined using literal numeric values (not computed expressions) for the input values.', o6);
              if (n6.length && n6[n6.length - 1][0] >= s4) return e6.error('Input/output pairs for "step" expressions must be arranged with input values in strictly ascending order.', o6);
              const u4 = e6.parse(a4, l5, i6);
              if (!u4) return null;
              i6 = i6 || u4.type, n6.push([s4, u4]);
            }
            return new Ye(i6, r8, n6);
          }
          evaluate(t5) {
            const e6 = this.labels, r8 = this.outputs;
            if (1 === e6.length) return r8[0].evaluate(t5);
            const n6 = this.input.evaluate(t5);
            if (n6 <= e6[0]) return r8[0].evaluate(t5);
            const i6 = e6.length;
            return n6 >= e6[i6 - 1] ? r8[i6 - 1].evaluate(t5) : r8[He(e6, n6)].evaluate(t5);
          }
          eachChild(t5) {
            t5(this.input);
            for (const e6 of this.outputs) t5(e6);
          }
          outputDefined() {
            return this.outputs.every((t5) => t5.outputDefined());
          }
        }
        function Je(t5) {
          return t5 && t5.__esModule && Object.prototype.hasOwnProperty.call(t5, "default") ? t5.default : t5;
        }
        var We, Qe, tr = function() {
          if (Qe) return We;
          function t5(t6, e6, r8, n6) {
            this.cx = 3 * t6, this.bx = 3 * (r8 - t6) - this.cx, this.ax = 1 - this.cx - this.bx, this.cy = 3 * e6, this.by = 3 * (n6 - e6) - this.cy, this.ay = 1 - this.cy - this.by, this.p1x = t6, this.p1y = e6, this.p2x = r8, this.p2y = n6;
          }
          return Qe = 1, We = t5, t5.prototype = { sampleCurveX: function(t6) {
            return ((this.ax * t6 + this.bx) * t6 + this.cx) * t6;
          }, sampleCurveY: function(t6) {
            return ((this.ay * t6 + this.by) * t6 + this.cy) * t6;
          }, sampleCurveDerivativeX: function(t6) {
            return (3 * this.ax * t6 + 2 * this.bx) * t6 + this.cx;
          }, solveCurveX: function(t6, e6) {
            if (void 0 === e6 && (e6 = 1e-6), t6 < 0) return 0;
            if (t6 > 1) return 1;
            for (var r8 = t6, n6 = 0; n6 < 8; n6++) {
              var i6 = this.sampleCurveX(r8) - t6;
              if (Math.abs(i6) < e6) return r8;
              var s4 = this.sampleCurveDerivativeX(r8);
              if (Math.abs(s4) < 1e-6) break;
              r8 -= i6 / s4;
            }
            var a4 = 0, o6 = 1;
            for (r8 = t6, n6 = 0; n6 < 20 && (i6 = this.sampleCurveX(r8), !(Math.abs(i6 - t6) < e6)); n6++) t6 > i6 ? a4 = r8 : o6 = r8, r8 = 0.5 * (o6 - a4) + a4;
            return r8;
          }, solve: function(t6, e6) {
            return this.sampleCurveY(this.solveCurveX(t6, e6));
          } }, We;
        }(), er = Je(tr);
        class rr {
          constructor(t5, e6, r8, n6, i6) {
            this.type = t5, this.operator = e6, this.interpolation = r8, this.input = n6, this.labels = [], this.outputs = [];
            for (const [t6, e7] of i6) this.labels.push(t6), this.outputs.push(e7);
          }
          static interpolationFactor(t5, e6, r8, n6) {
            let i6 = 0;
            if ("exponential" === t5.name) i6 = nr(e6, t5.base, r8, n6);
            else if ("linear" === t5.name) i6 = nr(e6, 1, r8, n6);
            else if ("cubic-bezier" === t5.name) {
              const s4 = t5.controlPoints;
              i6 = new er(s4[0], s4[1], s4[2], s4[3]).solve(nr(e6, 1, r8, n6));
            }
            return i6;
          }
          static parse(t5, e6) {
            let [r8, n6, i6, ...s4] = t5;
            if (!Array.isArray(n6) || 0 === n6.length) return e6.error("Expected an interpolation type expression.", 1);
            if ("linear" === n6[0]) n6 = { name: "linear" };
            else if ("exponential" === n6[0]) {
              const t6 = n6[1];
              if ("number" != typeof t6) return e6.error("Exponential interpolation requires a numeric base.", 1, 1);
              n6 = { name: "exponential", base: t6 };
            } else {
              if ("cubic-bezier" !== n6[0]) return e6.error(`Unknown interpolation type ${String(n6[0])}`, 1, 0);
              {
                const t6 = n6.slice(1);
                if (4 !== t6.length || t6.some((t7) => "number" != typeof t7 || t7 < 0 || t7 > 1)) return e6.error("Cubic bezier interpolation requires four numeric arguments with values between 0 and 1.", 1);
                n6 = { name: "cubic-bezier", controlPoints: t6 };
              }
            }
            if (t5.length - 1 < 4) return e6.error(`Expected at least 4 arguments, but found only ${t5.length - 1}.`);
            if ((t5.length - 1) % 2 != 0) return e6.error("Expected an even number of arguments.");
            if (i6 = e6.parse(i6, 2, Bt), !i6) return null;
            const a4 = [];
            let o6 = null;
            "interpolate-hcl" === r8 || "interpolate-lab" === r8 ? o6 = Tt : e6.expectedType && "value" !== e6.expectedType.kind && (o6 = e6.expectedType);
            for (let t6 = 0; t6 < s4.length; t6 += 2) {
              const r9 = s4[t6], n7 = s4[t6 + 1], i7 = t6 + 3, l5 = t6 + 4;
              if ("number" != typeof r9) return e6.error('Input/output pairs for "interpolate" expressions must be defined using literal numeric values (not computed expressions) for the input values.', i7);
              if (a4.length && a4[a4.length - 1][0] >= r9) return e6.error('Input/output pairs for "interpolate" expressions must be arranged with input values in strictly ascending order.', i7);
              const u4 = e6.parse(n7, l5, o6);
              if (!u4) return null;
              o6 = o6 || u4.type, a4.push([r9, u4]);
            }
            return Ht(o6, Bt) || Ht(o6, Ft) || Ht(o6, Tt) || Ht(o6, Rt) || Ht(o6, Nt) || Ht(o6, Ut(Bt)) ? new rr(o6, r8, n6, i6, a4) : e6.error(`Type ${qt(o6)} is not interpolatable.`);
          }
          evaluate(t5) {
            const e6 = this.labels, r8 = this.outputs;
            if (1 === e6.length) return r8[0].evaluate(t5);
            const n6 = this.input.evaluate(t5);
            if (n6 <= e6[0]) return r8[0].evaluate(t5);
            const i6 = e6.length;
            if (n6 >= e6[i6 - 1]) return r8[i6 - 1].evaluate(t5);
            const s4 = He(e6, n6), a4 = rr.interpolationFactor(this.interpolation, n6, e6[s4], e6[s4 + 1]), o6 = r8[s4].evaluate(t5), l5 = r8[s4 + 1].evaluate(t5);
            switch (this.operator) {
              case "interpolate":
                switch (this.type.kind) {
                  case "number":
                    return me(o6, l5, a4);
                  case "color":
                    return xe.interpolate(o6, l5, a4);
                  case "padding":
                    return Se.interpolate(o6, l5, a4);
                  case "variableAnchorOffsetCollection":
                    return Me.interpolate(o6, l5, a4);
                  case "array":
                    return ge(o6, l5, a4);
                  case "projectionDefinition":
                    return ze.interpolate(o6, l5, a4);
                }
              case "interpolate-hcl":
                return xe.interpolate(o6, l5, a4, "hcl");
              case "interpolate-lab":
                return xe.interpolate(o6, l5, a4, "lab");
            }
          }
          eachChild(t5) {
            t5(this.input);
            for (const e6 of this.outputs) t5(e6);
          }
          outputDefined() {
            return this.outputs.every((t5) => t5.outputDefined());
          }
        }
        function nr(t5, e6, r8, n6) {
          const i6 = n6 - r8, s4 = t5 - r8;
          return 0 === i6 ? 0 : 1 === e6 ? s4 / i6 : (Math.pow(e6, s4) - 1) / (Math.pow(e6, i6) - 1);
        }
        const ir = { color: xe.interpolate, number: me, padding: Se.interpolate, variableAnchorOffsetCollection: Me.interpolate, array: ge };
        class sr {
          constructor(t5, e6) {
            this.type = t5, this.args = e6;
          }
          static parse(t5, e6) {
            if (t5.length < 2) return e6.error("Expected at least one argument.");
            let r8 = null;
            const n6 = e6.expectedType;
            n6 && "value" !== n6.kind && (r8 = n6);
            const i6 = [];
            for (const n7 of t5.slice(1)) {
              const t6 = e6.parse(n7, 1 + i6.length, r8, void 0, { typeAnnotation: "omit" });
              if (!t6) return null;
              r8 = r8 || t6.type, i6.push(t6);
            }
            if (!r8) throw new Error("No output type");
            const s4 = n6 && i6.some((t6) => Zt(n6, t6.type));
            return new sr(s4 ? Lt : r8, i6);
          }
          evaluate(t5) {
            let e6, r8 = null, n6 = 0;
            for (const i6 of this.args) if (n6++, r8 = i6.evaluate(t5), r8 && r8 instanceof Ie && !r8.available && (e6 || (e6 = r8.name), r8 = null, n6 === this.args.length && (r8 = e6)), null !== r8) break;
            return r8;
          }
          eachChild(t5) {
            this.args.forEach(t5);
          }
          outputDefined() {
            return this.args.every((t5) => t5.outputDefined());
          }
        }
        function ar(t5, e6) {
          return "==" === t5 || "!=" === t5 ? "boolean" === e6.kind || "string" === e6.kind || "number" === e6.kind || "null" === e6.kind || "value" === e6.kind : "string" === e6.kind || "number" === e6.kind || "value" === e6.kind;
        }
        function or(t5, e6, r8, n6) {
          return 0 === n6.compare(e6, r8);
        }
        function lr(t5, e6, r8) {
          const n6 = "==" !== t5 && "!=" !== t5;
          return class i6 {
            constructor(t6, e7, r9) {
              this.type = Et, this.lhs = t6, this.rhs = e7, this.collator = r9, this.hasUntypedArgument = "value" === t6.type.kind || "value" === e7.type.kind;
            }
            static parse(t6, e7) {
              if (3 !== t6.length && 4 !== t6.length) return e7.error("Expected two or three arguments.");
              const r9 = t6[0];
              let s4 = e7.parse(t6[1], 1, Lt);
              if (!s4) return null;
              if (!ar(r9, s4.type)) return e7.concat(1).error(`"${r9}" comparisons are not supported for type '${qt(s4.type)}'.`);
              let a4 = e7.parse(t6[2], 2, Lt);
              if (!a4) return null;
              if (!ar(r9, a4.type)) return e7.concat(2).error(`"${r9}" comparisons are not supported for type '${qt(a4.type)}'.`);
              if (s4.type.kind !== a4.type.kind && "value" !== s4.type.kind && "value" !== a4.type.kind) return e7.error(`Cannot compare types '${qt(s4.type)}' and '${qt(a4.type)}'.`);
              n6 && ("value" === s4.type.kind && "value" !== a4.type.kind ? s4 = new Fe(a4.type, [s4]) : "value" !== s4.type.kind && "value" === a4.type.kind && (a4 = new Fe(s4.type, [a4])));
              let o6 = null;
              if (4 === t6.length) {
                if ("string" !== s4.type.kind && "string" !== a4.type.kind && "value" !== s4.type.kind && "value" !== a4.type.kind) return e7.error("Cannot use collator to compare non-string types.");
                if (o6 = e7.parse(t6[3], 3, Ot), !o6) return null;
              }
              return new i6(s4, a4, o6);
            }
            evaluate(i7) {
              const s4 = this.lhs.evaluate(i7), a4 = this.rhs.evaluate(i7);
              if (n6 && this.hasUntypedArgument) {
                const e7 = Be(s4), r9 = Be(a4);
                if (e7.kind !== r9.kind || "string" !== e7.kind && "number" !== e7.kind) throw new Ae(`Expected arguments for "${t5}" to be (string, string) or (number, number), but found (${e7.kind}, ${r9.kind}) instead.`);
              }
              if (this.collator && !n6 && this.hasUntypedArgument) {
                const t6 = Be(s4), r9 = Be(a4);
                if ("string" !== t6.kind || "string" !== r9.kind) return e6(i7, s4, a4);
              }
              return this.collator ? r8(i7, s4, a4, this.collator.evaluate(i7)) : e6(i7, s4, a4);
            }
            eachChild(t6) {
              t6(this.lhs), t6(this.rhs), this.collator && t6(this.collator);
            }
            outputDefined() {
              return true;
            }
          };
        }
        const ur = lr("==", function(t5, e6, r8) {
          return e6 === r8;
        }, or), cr = lr("!=", function(t5, e6, r8) {
          return e6 !== r8;
        }, function(t5, e6, r8, n6) {
          return !or(0, e6, r8, n6);
        }), hr = lr("<", function(t5, e6, r8) {
          return e6 < r8;
        }, function(t5, e6, r8, n6) {
          return n6.compare(e6, r8) < 0;
        }), pr = lr(">", function(t5, e6, r8) {
          return e6 > r8;
        }, function(t5, e6, r8, n6) {
          return n6.compare(e6, r8) > 0;
        }), fr = lr("<=", function(t5, e6, r8) {
          return e6 <= r8;
        }, function(t5, e6, r8, n6) {
          return n6.compare(e6, r8) <= 0;
        }), dr = lr(">=", function(t5, e6, r8) {
          return e6 >= r8;
        }, function(t5, e6, r8, n6) {
          return n6.compare(e6, r8) >= 0;
        });
        class yr {
          constructor(t5, e6, r8) {
            this.type = Ot, this.locale = r8, this.caseSensitive = t5, this.diacriticSensitive = e6;
          }
          static parse(t5, e6) {
            if (2 !== t5.length) return e6.error("Expected one argument.");
            const r8 = t5[1];
            if ("object" != typeof r8 || Array.isArray(r8)) return e6.error("Collator options argument must be an object.");
            const n6 = e6.parse(void 0 !== r8["case-sensitive"] && r8["case-sensitive"], 1, Et);
            if (!n6) return null;
            const i6 = e6.parse(void 0 !== r8["diacritic-sensitive"] && r8["diacritic-sensitive"], 1, Et);
            if (!i6) return null;
            let s4 = null;
            return r8.locale && (s4 = e6.parse(r8.locale, 1, Vt), !s4) ? null : new yr(n6, i6, s4);
          }
          evaluate(t5) {
            return new ve(this.caseSensitive.evaluate(t5), this.diacriticSensitive.evaluate(t5), this.locale ? this.locale.evaluate(t5) : null);
          }
          eachChild(t5) {
            t5(this.caseSensitive), t5(this.diacriticSensitive), this.locale && t5(this.locale);
          }
          outputDefined() {
            return false;
          }
        }
        class mr {
          constructor(t5, e6, r8, n6, i6) {
            this.type = Vt, this.number = t5, this.locale = e6, this.currency = r8, this.minFractionDigits = n6, this.maxFractionDigits = i6;
          }
          static parse(t5, e6) {
            if (3 !== t5.length) return e6.error("Expected two arguments.");
            const r8 = e6.parse(t5[1], 1, Bt);
            if (!r8) return null;
            const n6 = t5[2];
            if ("object" != typeof n6 || Array.isArray(n6)) return e6.error("NumberFormat options argument must be an object.");
            let i6 = null;
            if (n6.locale && (i6 = e6.parse(n6.locale, 1, Vt), !i6)) return null;
            let s4 = null;
            if (n6.currency && (s4 = e6.parse(n6.currency, 1, Vt), !s4)) return null;
            let a4 = null;
            if (n6["min-fraction-digits"] && (a4 = e6.parse(n6["min-fraction-digits"], 1, Bt), !a4)) return null;
            let o6 = null;
            return n6["max-fraction-digits"] && (o6 = e6.parse(n6["max-fraction-digits"], 1, Bt), !o6) ? null : new mr(r8, i6, s4, a4, o6);
          }
          evaluate(t5) {
            return new Intl.NumberFormat(this.locale ? this.locale.evaluate(t5) : [], { style: this.currency ? "currency" : "decimal", currency: this.currency ? this.currency.evaluate(t5) : void 0, minimumFractionDigits: this.minFractionDigits ? this.minFractionDigits.evaluate(t5) : void 0, maximumFractionDigits: this.maxFractionDigits ? this.maxFractionDigits.evaluate(t5) : void 0 }).format(this.number.evaluate(t5));
          }
          eachChild(t5) {
            t5(this.number), this.locale && t5(this.locale), this.currency && t5(this.currency), this.minFractionDigits && t5(this.minFractionDigits), this.maxFractionDigits && t5(this.maxFractionDigits);
          }
          outputDefined() {
            return false;
          }
        }
        class gr {
          constructor(t5) {
            this.type = Dt, this.sections = t5;
          }
          static parse(t5, e6) {
            if (t5.length < 2) return e6.error("Expected at least one argument.");
            const r8 = t5[1];
            if (!Array.isArray(r8) && "object" == typeof r8) return e6.error("First argument must be an image or text section.");
            const n6 = [];
            let i6 = false;
            for (let r9 = 1; r9 <= t5.length - 1; ++r9) {
              const s4 = t5[r9];
              if (i6 && "object" == typeof s4 && !Array.isArray(s4)) {
                i6 = false;
                let t6 = null;
                if (s4["font-scale"] && (t6 = e6.parse(s4["font-scale"], 1, Bt), !t6)) return null;
                let r10 = null;
                if (s4["text-font"] && (r10 = e6.parse(s4["text-font"], 1, Ut(Vt)), !r10)) return null;
                let a4 = null;
                if (s4["text-color"] && (a4 = e6.parse(s4["text-color"], 1, Tt), !a4)) return null;
                let o6 = null;
                if (s4["vertical-align"]) {
                  if ("string" == typeof s4["vertical-align"] && !be.includes(s4["vertical-align"])) return e6.error(`'vertical-align' must be one of: 'bottom', 'center', 'top' but found '${s4["vertical-align"]}' instead.`);
                  if (o6 = e6.parse(s4["vertical-align"], 1, Vt), !o6) return null;
                }
                const l5 = n6[n6.length - 1];
                l5.scale = t6, l5.font = r10, l5.textColor = a4, l5.verticalAlign = o6;
              } else {
                const s5 = e6.parse(t5[r9], 1, Lt);
                if (!s5) return null;
                const a4 = s5.type.kind;
                if ("string" !== a4 && "value" !== a4 && "null" !== a4 && "resolvedImage" !== a4) return e6.error("Formatted text type must be 'string', 'value', 'image' or 'null'.");
                i6 = true, n6.push({ content: s5, scale: null, font: null, textColor: null, verticalAlign: null });
              }
            }
            return new gr(n6);
          }
          evaluate(t5) {
            return new _e(this.sections.map((e6) => {
              const r8 = e6.content.evaluate(t5);
              return Be(r8) === jt ? new we("", r8, null, null, null, e6.verticalAlign ? e6.verticalAlign.evaluate(t5) : null) : new we(Ve(r8), null, e6.scale ? e6.scale.evaluate(t5) : null, e6.font ? e6.font.evaluate(t5).join(",") : null, e6.textColor ? e6.textColor.evaluate(t5) : null, e6.verticalAlign ? e6.verticalAlign.evaluate(t5) : null);
            }));
          }
          eachChild(t5) {
            for (const e6 of this.sections) t5(e6.content), e6.scale && t5(e6.scale), e6.font && t5(e6.font), e6.textColor && t5(e6.textColor), e6.verticalAlign && t5(e6.verticalAlign);
          }
          outputDefined() {
            return false;
          }
        }
        class xr {
          constructor(t5) {
            this.type = jt, this.input = t5;
          }
          static parse(t5, e6) {
            if (2 !== t5.length) return e6.error("Expected two arguments.");
            const r8 = e6.parse(t5[1], 1, Vt);
            return r8 ? new xr(r8) : e6.error("No image name provided.");
          }
          evaluate(t5) {
            const e6 = this.input.evaluate(t5), r8 = Ie.fromString(e6);
            return r8 && t5.availableImages && (r8.available = t5.availableImages.indexOf(e6) > -1), r8;
          }
          eachChild(t5) {
            t5(this.input);
          }
          outputDefined() {
            return false;
          }
        }
        class vr {
          constructor(t5) {
            this.type = Bt, this.input = t5;
          }
          static parse(t5, e6) {
            if (2 !== t5.length) return e6.error(`Expected 1 argument, but found ${t5.length - 1} instead.`);
            const r8 = e6.parse(t5[1], 1);
            return r8 ? "array" !== r8.type.kind && "string" !== r8.type.kind && "value" !== r8.type.kind ? e6.error(`Expected argument of type string or array, but found ${qt(r8.type)} instead.`) : new vr(r8) : null;
          }
          evaluate(t5) {
            const e6 = this.input.evaluate(t5);
            if ("string" == typeof e6) return [...e6].length;
            if (Array.isArray(e6)) return e6.length;
            throw new Ae(`Expected value to be of type string or array, but found ${qt(Be(e6))} instead.`);
          }
          eachChild(t5) {
            t5(this.input);
          }
          outputDefined() {
            return false;
          }
        }
        const br = 8192;
        function wr(t5, e6) {
          const r8 = (180 + t5[0]) / 360, n6 = (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + t5[1] * Math.PI / 360))) / 360, i6 = Math.pow(2, e6.z);
          return [Math.round(r8 * i6 * br), Math.round(n6 * i6 * br)];
        }
        function _r(t5, e6) {
          const r8 = Math.pow(2, e6.z);
          return [(i6 = (t5[0] / br + e6.x) / r8, 360 * i6 - 180), (n6 = (t5[1] / br + e6.y) / r8, 360 / Math.PI * Math.atan(Math.exp((180 - 360 * n6) * Math.PI / 180)) - 90)];
          var n6, i6;
        }
        function Sr(t5, e6) {
          t5[0] = Math.min(t5[0], e6[0]), t5[1] = Math.min(t5[1], e6[1]), t5[2] = Math.max(t5[2], e6[0]), t5[3] = Math.max(t5[3], e6[1]);
        }
        function Ar(t5, e6) {
          return !(t5[0] <= e6[0] || t5[2] >= e6[2] || t5[1] <= e6[1] || t5[3] >= e6[3]);
        }
        function kr(t5, e6, r8) {
          const n6 = t5[0] - e6[0], i6 = t5[1] - e6[1], s4 = t5[0] - r8[0], a4 = t5[1] - r8[1];
          return n6 * a4 - s4 * i6 == 0 && n6 * s4 <= 0 && i6 * a4 <= 0;
        }
        function Mr(t5, e6, r8, n6) {
          return 0 != (i6 = [n6[0] - r8[0], n6[1] - r8[1]])[0] * (s4 = [e6[0] - t5[0], e6[1] - t5[1]])[1] - i6[1] * s4[0] && !(!Vr(t5, e6, r8, n6) || !Vr(r8, n6, t5, e6));
          var i6, s4;
        }
        function Ir(t5, e6, r8) {
          for (const n6 of r8) for (let r9 = 0; r9 < n6.length - 1; ++r9) if (Mr(t5, e6, n6[r9], n6[r9 + 1])) return true;
          return false;
        }
        function zr(t5, e6, r8 = false) {
          let n6 = false;
          for (const o6 of e6) for (let e7 = 0; e7 < o6.length - 1; e7++) {
            if (kr(t5, o6[e7], o6[e7 + 1])) return r8;
            (s4 = o6[e7])[1] > (i6 = t5)[1] != (a4 = o6[e7 + 1])[1] > i6[1] && i6[0] < (a4[0] - s4[0]) * (i6[1] - s4[1]) / (a4[1] - s4[1]) + s4[0] && (n6 = !n6);
          }
          var i6, s4, a4;
          return n6;
        }
        function Pr(t5, e6) {
          for (const r8 of e6) if (zr(t5, r8)) return true;
          return false;
        }
        function Cr(t5, e6) {
          for (const r8 of t5) if (!zr(r8, e6)) return false;
          for (let r8 = 0; r8 < t5.length - 1; ++r8) if (Ir(t5[r8], t5[r8 + 1], e6)) return false;
          return true;
        }
        function Br(t5, e6) {
          for (const r8 of e6) if (Cr(t5, r8)) return true;
          return false;
        }
        function Vr(t5, e6, r8, n6) {
          const i6 = n6[0] - r8[0], s4 = n6[1] - r8[1], a4 = (t5[0] - r8[0]) * s4 - i6 * (t5[1] - r8[1]), o6 = (e6[0] - r8[0]) * s4 - i6 * (e6[1] - r8[1]);
          return a4 > 0 && o6 < 0 || a4 < 0 && o6 > 0;
        }
        function Er(t5, e6, r8) {
          const n6 = [];
          for (let i6 = 0; i6 < t5.length; i6++) {
            const s4 = [];
            for (let n7 = 0; n7 < t5[i6].length; n7++) {
              const a4 = wr(t5[i6][n7], r8);
              Sr(e6, a4), s4.push(a4);
            }
            n6.push(s4);
          }
          return n6;
        }
        function Tr(t5, e6, r8) {
          const n6 = [];
          for (let i6 = 0; i6 < t5.length; i6++) {
            const s4 = Er(t5[i6], e6, r8);
            n6.push(s4);
          }
          return n6;
        }
        function Fr(t5, e6, r8, n6) {
          if (t5[0] < r8[0] || t5[0] > r8[2]) {
            const e7 = 0.5 * n6;
            let i6 = t5[0] - r8[0] > e7 ? -n6 : r8[0] - t5[0] > e7 ? n6 : 0;
            0 === i6 && (i6 = t5[0] - r8[2] > e7 ? -n6 : r8[2] - t5[0] > e7 ? n6 : 0), t5[0] += i6;
          }
          Sr(e6, t5);
        }
        function $r(t5, e6, r8, n6) {
          const i6 = Math.pow(2, n6.z) * br, s4 = [n6.x * br, n6.y * br], a4 = [];
          for (const n7 of t5) for (const t6 of n7) {
            const n8 = [t6.x + s4[0], t6.y + s4[1]];
            Fr(n8, e6, r8, i6), a4.push(n8);
          }
          return a4;
        }
        function Lr(t5, e6, r8, n6) {
          const i6 = Math.pow(2, n6.z) * br, s4 = [n6.x * br, n6.y * br], a4 = [];
          for (const r9 of t5) {
            const t6 = [];
            for (const n7 of r9) {
              const r10 = [n7.x + s4[0], n7.y + s4[1]];
              Sr(e6, r10), t6.push(r10);
            }
            a4.push(t6);
          }
          if (e6[2] - e6[0] <= i6 / 2) {
            (o6 = e6)[0] = o6[1] = 1 / 0, o6[2] = o6[3] = -1 / 0;
            for (const t6 of a4) for (const n7 of t6) Fr(n7, e6, r8, i6);
          }
          var o6;
          return a4;
        }
        class Or {
          constructor(t5, e6) {
            this.type = Et, this.geojson = t5, this.geometries = e6;
          }
          static parse(t5, e6) {
            if (2 !== t5.length) return e6.error(`'within' expression requires exactly one argument, but found ${t5.length - 1} instead.`);
            if (Ce(t5[1])) {
              const e7 = t5[1];
              if ("FeatureCollection" === e7.type) {
                const t6 = [];
                for (const r8 of e7.features) {
                  const { type: e8, coordinates: n6 } = r8.geometry;
                  "Polygon" === e8 && t6.push(n6), "MultiPolygon" === e8 && t6.push(...n6);
                }
                if (t6.length) return new Or(e7, { type: "MultiPolygon", coordinates: t6 });
              } else if ("Feature" === e7.type) {
                const t6 = e7.geometry.type;
                if ("Polygon" === t6 || "MultiPolygon" === t6) return new Or(e7, e7.geometry);
              } else if ("Polygon" === e7.type || "MultiPolygon" === e7.type) return new Or(e7, e7);
            }
            return e6.error("'within' expression requires valid geojson object that contains polygon geometry type.");
          }
          evaluate(t5) {
            if (null != t5.geometry() && null != t5.canonicalID()) {
              if ("Point" === t5.geometryType()) return function(t6, e6) {
                const r8 = [1 / 0, 1 / 0, -1 / 0, -1 / 0], n6 = [1 / 0, 1 / 0, -1 / 0, -1 / 0], i6 = t6.canonicalID();
                if ("Polygon" === e6.type) {
                  const s4 = Er(e6.coordinates, n6, i6), a4 = $r(t6.geometry(), r8, n6, i6);
                  if (!Ar(r8, n6)) return false;
                  for (const t7 of a4) if (!zr(t7, s4)) return false;
                }
                if ("MultiPolygon" === e6.type) {
                  const s4 = Tr(e6.coordinates, n6, i6), a4 = $r(t6.geometry(), r8, n6, i6);
                  if (!Ar(r8, n6)) return false;
                  for (const t7 of a4) if (!Pr(t7, s4)) return false;
                }
                return true;
              }(t5, this.geometries);
              if ("LineString" === t5.geometryType()) return function(t6, e6) {
                const r8 = [1 / 0, 1 / 0, -1 / 0, -1 / 0], n6 = [1 / 0, 1 / 0, -1 / 0, -1 / 0], i6 = t6.canonicalID();
                if ("Polygon" === e6.type) {
                  const s4 = Er(e6.coordinates, n6, i6), a4 = Lr(t6.geometry(), r8, n6, i6);
                  if (!Ar(r8, n6)) return false;
                  for (const t7 of a4) if (!Cr(t7, s4)) return false;
                }
                if ("MultiPolygon" === e6.type) {
                  const s4 = Tr(e6.coordinates, n6, i6), a4 = Lr(t6.geometry(), r8, n6, i6);
                  if (!Ar(r8, n6)) return false;
                  for (const t7 of a4) if (!Br(t7, s4)) return false;
                }
                return true;
              }(t5, this.geometries);
            }
            return false;
          }
          eachChild() {
          }
          outputDefined() {
            return true;
          }
        }
        let Dr = class {
          constructor(t5 = [], e6 = (t6, e7) => t6 < e7 ? -1 : t6 > e7 ? 1 : 0) {
            if (this.data = t5, this.length = this.data.length, this.compare = e6, this.length > 0) for (let t6 = (this.length >> 1) - 1; t6 >= 0; t6--) this._down(t6);
          }
          push(t5) {
            this.data.push(t5), this._up(this.length++);
          }
          pop() {
            if (0 === this.length) return;
            const t5 = this.data[0], e6 = this.data.pop();
            return --this.length > 0 && (this.data[0] = e6, this._down(0)), t5;
          }
          peek() {
            return this.data[0];
          }
          _up(t5) {
            const { data: e6, compare: r8 } = this, n6 = e6[t5];
            for (; t5 > 0; ) {
              const i6 = t5 - 1 >> 1, s4 = e6[i6];
              if (r8(n6, s4) >= 0) break;
              e6[t5] = s4, t5 = i6;
            }
            e6[t5] = n6;
          }
          _down(t5) {
            const { data: e6, compare: r8 } = this, n6 = this.length >> 1, i6 = e6[t5];
            for (; t5 < n6; ) {
              let n7 = 1 + (t5 << 1);
              const s4 = n7 + 1;
              if (s4 < this.length && r8(e6[s4], e6[n7]) < 0 && (n7 = s4), r8(e6[n7], i6) >= 0) break;
              e6[t5] = e6[n7], t5 = n7;
            }
            e6[t5] = i6;
          }
        };
        function Rr(t5, e6, r8 = 0, n6 = t5.length - 1, i6 = Nr) {
          for (; n6 > r8; ) {
            if (n6 - r8 > 600) {
              const s5 = n6 - r8 + 1, a5 = e6 - r8 + 1, o7 = Math.log(s5), l5 = 0.5 * Math.exp(2 * o7 / 3), u4 = 0.5 * Math.sqrt(o7 * l5 * (s5 - l5) / s5) * (a5 - s5 / 2 < 0 ? -1 : 1);
              Rr(t5, e6, Math.max(r8, Math.floor(e6 - a5 * l5 / s5 + u4)), Math.min(n6, Math.floor(e6 + (s5 - a5) * l5 / s5 + u4)), i6);
            }
            const s4 = t5[e6];
            let a4 = r8, o6 = n6;
            for (jr(t5, r8, e6), i6(t5[n6], s4) > 0 && jr(t5, r8, n6); a4 < o6; ) {
              for (jr(t5, a4, o6), a4++, o6--; i6(t5[a4], s4) < 0; ) a4++;
              for (; i6(t5[o6], s4) > 0; ) o6--;
            }
            0 === i6(t5[r8], s4) ? jr(t5, r8, o6) : (o6++, jr(t5, o6, n6)), o6 <= e6 && (r8 = o6 + 1), e6 <= o6 && (n6 = o6 - 1);
          }
        }
        function jr(t5, e6, r8) {
          const n6 = t5[e6];
          t5[e6] = t5[r8], t5[r8] = n6;
        }
        function Nr(t5, e6) {
          return t5 < e6 ? -1 : t5 > e6 ? 1 : 0;
        }
        function Ur(t5, e6) {
          if (t5.length <= 1) return [t5];
          const r8 = [];
          let n6, i6;
          for (const e7 of t5) {
            const t6 = Gr(e7);
            0 !== t6 && (e7.area = Math.abs(t6), void 0 === i6 && (i6 = t6 < 0), i6 === t6 < 0 ? (n6 && r8.push(n6), n6 = [e7]) : n6.push(e7));
          }
          if (n6 && r8.push(n6), e6 > 1) for (let t6 = 0; t6 < r8.length; t6++) r8[t6].length <= e6 || (Rr(r8[t6], e6, 1, r8[t6].length - 1, qr), r8[t6] = r8[t6].slice(0, e6));
          return r8;
        }
        function qr(t5, e6) {
          return e6.area - t5.area;
        }
        function Gr(t5) {
          let e6 = 0;
          for (let r8, n6, i6 = 0, s4 = t5.length, a4 = s4 - 1; i6 < s4; a4 = i6++) r8 = t5[i6], n6 = t5[a4], e6 += (n6.x - r8.x) * (r8.y + n6.y);
          return e6;
        }
        const Zr = 1 / 298.257223563, Kr = Zr * (2 - Zr), Xr = Math.PI / 180;
        class Hr {
          constructor(t5) {
            const e6 = 6378.137 * Xr * 1e3, r8 = Math.cos(t5 * Xr), n6 = 1 / (1 - Kr * (1 - r8 * r8)), i6 = Math.sqrt(n6);
            this.kx = e6 * i6 * r8, this.ky = e6 * i6 * n6 * (1 - Kr);
          }
          distance(t5, e6) {
            const r8 = this.wrap(t5[0] - e6[0]) * this.kx, n6 = (t5[1] - e6[1]) * this.ky;
            return Math.sqrt(r8 * r8 + n6 * n6);
          }
          pointOnLine(t5, e6) {
            let r8, n6, i6, s4, a4 = 1 / 0;
            for (let o6 = 0; o6 < t5.length - 1; o6++) {
              let l5 = t5[o6][0], u4 = t5[o6][1], c5 = this.wrap(t5[o6 + 1][0] - l5) * this.kx, h4 = (t5[o6 + 1][1] - u4) * this.ky, p4 = 0;
              0 === c5 && 0 === h4 || (p4 = (this.wrap(e6[0] - l5) * this.kx * c5 + (e6[1] - u4) * this.ky * h4) / (c5 * c5 + h4 * h4), p4 > 1 ? (l5 = t5[o6 + 1][0], u4 = t5[o6 + 1][1]) : p4 > 0 && (l5 += c5 / this.kx * p4, u4 += h4 / this.ky * p4)), c5 = this.wrap(e6[0] - l5) * this.kx, h4 = (e6[1] - u4) * this.ky;
              const f4 = c5 * c5 + h4 * h4;
              f4 < a4 && (a4 = f4, r8 = l5, n6 = u4, i6 = o6, s4 = p4);
            }
            return { point: [r8, n6], index: i6, t: Math.max(0, Math.min(1, s4)) };
          }
          wrap(t5) {
            for (; t5 < -180; ) t5 += 360;
            for (; t5 > 180; ) t5 -= 360;
            return t5;
          }
        }
        function Yr(t5, e6) {
          return e6[0] - t5[0];
        }
        function Jr(t5) {
          return t5[1] - t5[0] + 1;
        }
        function Wr(t5, e6) {
          return t5[1] >= t5[0] && t5[1] < e6;
        }
        function Qr(t5, e6) {
          if (t5[0] > t5[1]) return [null, null];
          const r8 = Jr(t5);
          if (e6) {
            if (2 === r8) return [t5, null];
            const e7 = Math.floor(r8 / 2);
            return [[t5[0], t5[0] + e7], [t5[0] + e7, t5[1]]];
          }
          if (1 === r8) return [t5, null];
          const n6 = Math.floor(r8 / 2) - 1;
          return [[t5[0], t5[0] + n6], [t5[0] + n6 + 1, t5[1]]];
        }
        function tn(t5, e6) {
          if (!Wr(e6, t5.length)) return [1 / 0, 1 / 0, -1 / 0, -1 / 0];
          const r8 = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
          for (let n6 = e6[0]; n6 <= e6[1]; ++n6) Sr(r8, t5[n6]);
          return r8;
        }
        function en(t5) {
          const e6 = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
          for (const r8 of t5) for (const t6 of r8) Sr(e6, t6);
          return e6;
        }
        function rn(t5) {
          return t5[0] !== -1 / 0 && t5[1] !== -1 / 0 && t5[2] !== 1 / 0 && t5[3] !== 1 / 0;
        }
        function nn(t5, e6, r8) {
          if (!rn(t5) || !rn(e6)) return NaN;
          let n6 = 0, i6 = 0;
          return t5[2] < e6[0] && (n6 = e6[0] - t5[2]), t5[0] > e6[2] && (n6 = t5[0] - e6[2]), t5[1] > e6[3] && (i6 = t5[1] - e6[3]), t5[3] < e6[1] && (i6 = e6[1] - t5[3]), r8.distance([0, 0], [n6, i6]);
        }
        function sn(t5, e6, r8) {
          const n6 = r8.pointOnLine(e6, t5);
          return r8.distance(t5, n6.point);
        }
        function an(t5, e6, r8, n6, i6) {
          const s4 = Math.min(sn(t5, [r8, n6], i6), sn(e6, [r8, n6], i6)), a4 = Math.min(sn(r8, [t5, e6], i6), sn(n6, [t5, e6], i6));
          return Math.min(s4, a4);
        }
        function on(t5, e6, r8, n6, i6) {
          if (!Wr(e6, t5.length) || !Wr(n6, r8.length)) return 1 / 0;
          let s4 = 1 / 0;
          for (let a4 = e6[0]; a4 < e6[1]; ++a4) {
            const e7 = t5[a4], o6 = t5[a4 + 1];
            for (let t6 = n6[0]; t6 < n6[1]; ++t6) {
              const n7 = r8[t6], a5 = r8[t6 + 1];
              if (Mr(e7, o6, n7, a5)) return 0;
              s4 = Math.min(s4, an(e7, o6, n7, a5, i6));
            }
          }
          return s4;
        }
        function ln(t5, e6, r8, n6, i6) {
          if (!Wr(e6, t5.length) || !Wr(n6, r8.length)) return NaN;
          let s4 = 1 / 0;
          for (let a4 = e6[0]; a4 <= e6[1]; ++a4) for (let e7 = n6[0]; e7 <= n6[1]; ++e7) if (s4 = Math.min(s4, i6.distance(t5[a4], r8[e7])), 0 === s4) return s4;
          return s4;
        }
        function un(t5, e6, r8) {
          if (zr(t5, e6, true)) return 0;
          let n6 = 1 / 0;
          for (const i6 of e6) {
            const e7 = i6[0], s4 = i6[i6.length - 1];
            if (e7 !== s4 && (n6 = Math.min(n6, sn(t5, [s4, e7], r8)), 0 === n6)) return n6;
            const a4 = r8.pointOnLine(i6, t5);
            if (n6 = Math.min(n6, r8.distance(t5, a4.point)), 0 === n6) return n6;
          }
          return n6;
        }
        function cn(t5, e6, r8, n6) {
          if (!Wr(e6, t5.length)) return NaN;
          for (let n7 = e6[0]; n7 <= e6[1]; ++n7) if (zr(t5[n7], r8, true)) return 0;
          let i6 = 1 / 0;
          for (let s4 = e6[0]; s4 < e6[1]; ++s4) {
            const e7 = t5[s4], a4 = t5[s4 + 1];
            for (const t6 of r8) for (let r9 = 0, s5 = t6.length, o6 = s5 - 1; r9 < s5; o6 = r9++) {
              const s6 = t6[o6], l5 = t6[r9];
              if (Mr(e7, a4, s6, l5)) return 0;
              i6 = Math.min(i6, an(e7, a4, s6, l5, n6));
            }
          }
          return i6;
        }
        function hn(t5, e6) {
          for (const r8 of t5) for (const t6 of r8) if (zr(t6, e6, true)) return true;
          return false;
        }
        function pn(t5, e6, r8, n6 = 1 / 0) {
          const i6 = en(t5), s4 = en(e6);
          if (n6 !== 1 / 0 && nn(i6, s4, r8) >= n6) return n6;
          if (Ar(i6, s4)) {
            if (hn(t5, e6)) return 0;
          } else if (hn(e6, t5)) return 0;
          let a4 = 1 / 0;
          for (const n7 of t5) for (let t6 = 0, i7 = n7.length, s5 = i7 - 1; t6 < i7; s5 = t6++) {
            const i8 = n7[s5], o6 = n7[t6];
            for (const t7 of e6) for (let e7 = 0, n8 = t7.length, s6 = n8 - 1; e7 < n8; s6 = e7++) {
              const n9 = t7[s6], l5 = t7[e7];
              if (Mr(i8, o6, n9, l5)) return 0;
              a4 = Math.min(a4, an(i8, o6, n9, l5, r8));
            }
          }
          return a4;
        }
        function fn(t5, e6, r8, n6, i6, s4) {
          if (!s4) return;
          const a4 = nn(tn(n6, s4), i6, r8);
          a4 < e6 && t5.push([a4, s4, [0, 0]]);
        }
        function dn(t5, e6, r8, n6, i6, s4, a4) {
          if (!s4 || !a4) return;
          const o6 = nn(tn(n6, s4), tn(i6, a4), r8);
          o6 < e6 && t5.push([o6, s4, a4]);
        }
        function yn(t5, e6, r8, n6, i6 = 1 / 0) {
          let s4 = Math.min(n6.distance(t5[0], r8[0][0]), i6);
          if (0 === s4) return s4;
          const a4 = new Dr([[0, [0, t5.length - 1], [0, 0]]], Yr), o6 = en(r8);
          for (; a4.length > 0; ) {
            const i7 = a4.pop();
            if (i7[0] >= s4) continue;
            const l5 = i7[1], u4 = e6 ? 50 : 100;
            if (Jr(l5) <= u4) {
              if (!Wr(l5, t5.length)) return NaN;
              if (e6) {
                const e7 = cn(t5, l5, r8, n6);
                if (isNaN(e7) || 0 === e7) return e7;
                s4 = Math.min(s4, e7);
              } else for (let e7 = l5[0]; e7 <= l5[1]; ++e7) {
                const i8 = un(t5[e7], r8, n6);
                if (s4 = Math.min(s4, i8), 0 === s4) return 0;
              }
            } else {
              const r9 = Qr(l5, e6);
              fn(a4, s4, n6, t5, o6, r9[0]), fn(a4, s4, n6, t5, o6, r9[1]);
            }
          }
          return s4;
        }
        function mn(t5, e6, r8, n6, i6, s4 = 1 / 0) {
          let a4 = Math.min(s4, i6.distance(t5[0], r8[0]));
          if (0 === a4) return a4;
          const o6 = new Dr([[0, [0, t5.length - 1], [0, r8.length - 1]]], Yr);
          for (; o6.length > 0; ) {
            const s5 = o6.pop();
            if (s5[0] >= a4) continue;
            const l5 = s5[1], u4 = s5[2], c5 = e6 ? 50 : 100, h4 = n6 ? 50 : 100;
            if (Jr(l5) <= c5 && Jr(u4) <= h4) {
              if (!Wr(l5, t5.length) && Wr(u4, r8.length)) return NaN;
              let s6;
              if (e6 && n6) s6 = on(t5, l5, r8, u4, i6), a4 = Math.min(a4, s6);
              else if (e6 && !n6) {
                const e7 = t5.slice(l5[0], l5[1] + 1);
                for (let t6 = u4[0]; t6 <= u4[1]; ++t6) if (s6 = sn(r8[t6], e7, i6), a4 = Math.min(a4, s6), 0 === a4) return a4;
              } else if (!e6 && n6) {
                const e7 = r8.slice(u4[0], u4[1] + 1);
                for (let r9 = l5[0]; r9 <= l5[1]; ++r9) if (s6 = sn(t5[r9], e7, i6), a4 = Math.min(a4, s6), 0 === a4) return a4;
              } else s6 = ln(t5, l5, r8, u4, i6), a4 = Math.min(a4, s6);
            } else {
              const s6 = Qr(l5, e6), c6 = Qr(u4, n6);
              dn(o6, a4, i6, t5, r8, s6[0], c6[0]), dn(o6, a4, i6, t5, r8, s6[0], c6[1]), dn(o6, a4, i6, t5, r8, s6[1], c6[0]), dn(o6, a4, i6, t5, r8, s6[1], c6[1]);
            }
          }
          return a4;
        }
        function gn(t5) {
          return "MultiPolygon" === t5.type ? t5.coordinates.map((t6) => ({ type: "Polygon", coordinates: t6 })) : "MultiLineString" === t5.type ? t5.coordinates.map((t6) => ({ type: "LineString", coordinates: t6 })) : "MultiPoint" === t5.type ? t5.coordinates.map((t6) => ({ type: "Point", coordinates: t6 })) : [t5];
        }
        class xn {
          constructor(t5, e6) {
            this.type = Bt, this.geojson = t5, this.geometries = e6;
          }
          static parse(t5, e6) {
            if (2 !== t5.length) return e6.error(`'distance' expression requires exactly one argument, but found ${t5.length - 1} instead.`);
            if (Ce(t5[1])) {
              const e7 = t5[1];
              if ("FeatureCollection" === e7.type) return new xn(e7, e7.features.map((t6) => gn(t6.geometry)).flat());
              if ("Feature" === e7.type) return new xn(e7, gn(e7.geometry));
              if ("type" in e7 && "coordinates" in e7) return new xn(e7, gn(e7));
            }
            return e6.error("'distance' expression requires valid geojson object that contains polygon geometry type.");
          }
          evaluate(t5) {
            if (null != t5.geometry() && null != t5.canonicalID()) {
              if ("Point" === t5.geometryType()) return function(t6, e6) {
                const r8 = t6.geometry(), n6 = r8.flat().map((e7) => _r([e7.x, e7.y], t6.canonical));
                if (0 === r8.length) return NaN;
                const i6 = new Hr(n6[0][1]);
                let s4 = 1 / 0;
                for (const t7 of e6) {
                  switch (t7.type) {
                    case "Point":
                      s4 = Math.min(s4, mn(n6, false, [t7.coordinates], false, i6, s4));
                      break;
                    case "LineString":
                      s4 = Math.min(s4, mn(n6, false, t7.coordinates, true, i6, s4));
                      break;
                    case "Polygon":
                      s4 = Math.min(s4, yn(n6, false, t7.coordinates, i6, s4));
                  }
                  if (0 === s4) return s4;
                }
                return s4;
              }(t5, this.geometries);
              if ("LineString" === t5.geometryType()) return function(t6, e6) {
                const r8 = t6.geometry(), n6 = r8.flat().map((e7) => _r([e7.x, e7.y], t6.canonical));
                if (0 === r8.length) return NaN;
                const i6 = new Hr(n6[0][1]);
                let s4 = 1 / 0;
                for (const t7 of e6) {
                  switch (t7.type) {
                    case "Point":
                      s4 = Math.min(s4, mn(n6, true, [t7.coordinates], false, i6, s4));
                      break;
                    case "LineString":
                      s4 = Math.min(s4, mn(n6, true, t7.coordinates, true, i6, s4));
                      break;
                    case "Polygon":
                      s4 = Math.min(s4, yn(n6, true, t7.coordinates, i6, s4));
                  }
                  if (0 === s4) return s4;
                }
                return s4;
              }(t5, this.geometries);
              if ("Polygon" === t5.geometryType()) return function(t6, e6) {
                const r8 = t6.geometry();
                if (0 === r8.length || 0 === r8[0].length) return NaN;
                const n6 = Ur(r8, 0).map((e7) => e7.map((e8) => e8.map((e9) => _r([e9.x, e9.y], t6.canonical)))), i6 = new Hr(n6[0][0][0][1]);
                let s4 = 1 / 0;
                for (const t7 of e6) for (const e7 of n6) {
                  switch (t7.type) {
                    case "Point":
                      s4 = Math.min(s4, yn([t7.coordinates], false, e7, i6, s4));
                      break;
                    case "LineString":
                      s4 = Math.min(s4, yn(t7.coordinates, true, e7, i6, s4));
                      break;
                    case "Polygon":
                      s4 = Math.min(s4, pn(e7, t7.coordinates, i6, s4));
                  }
                  if (0 === s4) return s4;
                }
                return s4;
              }(t5, this.geometries);
            }
            return NaN;
          }
          eachChild() {
          }
          outputDefined() {
            return true;
          }
        }
        const vn = { "==": ur, "!=": cr, ">": pr, "<": hr, ">=": dr, "<=": fr, array: Fe, at: Ue, boolean: Fe, case: Ke, coalesce: sr, collator: yr, format: gr, image: xr, in: qe, "index-of": Ge, interpolate: rr, "interpolate-hcl": rr, "interpolate-lab": rr, length: vr, let: je, literal: Ee, match: Ze, number: Fe, "number-format": mr, object: Fe, slice: Xe, step: Ye, string: Fe, "to-boolean": Le, "to-color": Le, "to-number": Le, "to-string": Le, var: Ne, within: Or, distance: xn };
        class bn {
          constructor(t5, e6, r8, n6) {
            this.name = t5, this.type = e6, this._evaluate = r8, this.args = n6;
          }
          evaluate(t5) {
            return this._evaluate(t5, this.args);
          }
          eachChild(t5) {
            this.args.forEach(t5);
          }
          outputDefined() {
            return false;
          }
          static parse(t5, e6) {
            const r8 = t5[0], n6 = bn.definitions[r8];
            if (!n6) return e6.error(`Unknown expression "${r8}". If you wanted a literal array, use ["literal", [...]].`, 0);
            const i6 = Array.isArray(n6) ? n6[0] : n6.type, s4 = Array.isArray(n6) ? [[n6[1], n6[2]]] : n6.overloads, a4 = s4.filter(([e7]) => !Array.isArray(e7) || e7.length === t5.length - 1);
            let o6 = null;
            for (const [n7, s5] of a4) {
              o6 = new Re(e6.registry, kn, e6.path, null, e6.scope);
              const a5 = [];
              let l5 = false;
              for (let e7 = 1; e7 < t5.length; e7++) {
                const r9 = t5[e7], i7 = Array.isArray(n7) ? n7[e7 - 1] : n7.type, s6 = o6.parse(r9, 1 + a5.length, i7);
                if (!s6) {
                  l5 = true;
                  break;
                }
                a5.push(s6);
              }
              if (!l5) if (Array.isArray(n7) && n7.length !== a5.length) o6.error(`Expected ${n7.length} arguments, but found ${a5.length} instead.`);
              else {
                for (let t6 = 0; t6 < a5.length; t6++) {
                  const e7 = Array.isArray(n7) ? n7[t6] : n7.type, r9 = a5[t6];
                  o6.concat(t6 + 1).checkSubtype(e7, r9.type);
                }
                if (0 === o6.errors.length) return new bn(r8, i6, s5, a5);
              }
            }
            if (1 === a4.length) e6.errors.push(...o6.errors);
            else {
              const r9 = (a4.length ? a4 : s4).map(([t6]) => {
                return e7 = t6, Array.isArray(e7) ? `(${e7.map(qt).join(", ")})` : `(${qt(e7.type)}...)`;
                var e7;
              }).join(" | "), n7 = [];
              for (let r10 = 1; r10 < t5.length; r10++) {
                const i7 = e6.parse(t5[r10], 1 + n7.length);
                if (!i7) return null;
                n7.push(qt(i7.type));
              }
              e6.error(`Expected arguments of type ${r9}, but found (${n7.join(", ")}) instead.`);
            }
            return null;
          }
          static register(t5, e6) {
            bn.definitions = e6;
            for (const r8 in e6) t5[r8] = bn;
          }
        }
        function wn(t5, [e6, r8, n6, i6]) {
          e6 = e6.evaluate(t5), r8 = r8.evaluate(t5), n6 = n6.evaluate(t5);
          const s4 = i6 ? i6.evaluate(t5) : 1, a4 = Pe(e6, r8, n6, s4);
          if (a4) throw new Ae(a4);
          return new xe(e6 / 255, r8 / 255, n6 / 255, s4, false);
        }
        function _n(t5, e6) {
          return t5 in e6;
        }
        function Sn(t5, e6) {
          const r8 = e6[t5];
          return void 0 === r8 ? null : r8;
        }
        function An(t5) {
          return { type: t5 };
        }
        function kn(t5) {
          if (t5 instanceof Ne) return kn(t5.boundExpression);
          if (t5 instanceof bn && "error" === t5.name) return false;
          if (t5 instanceof yr) return false;
          if (t5 instanceof Or) return false;
          if (t5 instanceof xn) return false;
          const e6 = t5 instanceof Le || t5 instanceof Fe;
          let r8 = true;
          return t5.eachChild((t6) => {
            r8 = e6 ? r8 && kn(t6) : r8 && t6 instanceof Ee;
          }), !!r8 && Mn(t5) && zn(t5, ["zoom", "heatmap-density", "line-progress", "accumulated", "is-supported-script"]);
        }
        function Mn(t5) {
          if (t5 instanceof bn) {
            if ("get" === t5.name && 1 === t5.args.length) return false;
            if ("feature-state" === t5.name) return false;
            if ("has" === t5.name && 1 === t5.args.length) return false;
            if ("properties" === t5.name || "geometry-type" === t5.name || "id" === t5.name) return false;
            if (/^filter-/.test(t5.name)) return false;
          }
          if (t5 instanceof Or) return false;
          if (t5 instanceof xn) return false;
          let e6 = true;
          return t5.eachChild((t6) => {
            e6 && !Mn(t6) && (e6 = false);
          }), e6;
        }
        function In(t5) {
          if (t5 instanceof bn && "feature-state" === t5.name) return false;
          let e6 = true;
          return t5.eachChild((t6) => {
            e6 && !In(t6) && (e6 = false);
          }), e6;
        }
        function zn(t5, e6) {
          if (t5 instanceof bn && e6.indexOf(t5.name) >= 0) return false;
          let r8 = true;
          return t5.eachChild((t6) => {
            r8 && !zn(t6, e6) && (r8 = false);
          }), r8;
        }
        function Pn(t5) {
          return { result: "success", value: t5 };
        }
        function Cn(t5) {
          return { result: "error", value: t5 };
        }
        function Bn(t5) {
          return "data-driven" === t5["property-type"] || "cross-faded-data-driven" === t5["property-type"];
        }
        function Vn(t5) {
          return !!t5.expression && t5.expression.parameters.indexOf("zoom") > -1;
        }
        function En(t5) {
          return !!t5.expression && t5.expression.interpolated;
        }
        function Tn(t5) {
          return t5 instanceof Number ? "number" : t5 instanceof String ? "string" : t5 instanceof Boolean ? "boolean" : Array.isArray(t5) ? "array" : null === t5 ? "null" : typeof t5;
        }
        function Fn(t5) {
          return "object" == typeof t5 && null !== t5 && !Array.isArray(t5);
        }
        function $n(t5) {
          return t5;
        }
        function Ln(t5, e6) {
          const r8 = "color" === e6.type, n6 = t5.stops && "object" == typeof t5.stops[0][0], i6 = n6 || !(n6 || void 0 !== t5.property), s4 = t5.type || (En(e6) ? "exponential" : "interval");
          if (r8 || "padding" === e6.type) {
            const n7 = r8 ? xe.parse : Se.parse;
            (t5 = It({}, t5)).stops && (t5.stops = t5.stops.map((t6) => [t6[0], n7(t6[1])])), t5.default = n7(t5.default ? t5.default : e6.default);
          }
          if (t5.colorSpace && "rgb" !== (a4 = t5.colorSpace) && "hcl" !== a4 && "lab" !== a4) throw new Error(`Unknown color space: "${t5.colorSpace}"`);
          var a4;
          let o6, l5, u4;
          if ("exponential" === s4) o6 = jn;
          else if ("interval" === s4) o6 = Rn;
          else if ("categorical" === s4) {
            o6 = Dn, l5 = /* @__PURE__ */ Object.create(null);
            for (const e7 of t5.stops) l5[e7[0]] = e7[1];
            u4 = typeof t5.stops[0][0];
          } else {
            if ("identity" !== s4) throw new Error(`Unknown function type "${s4}"`);
            o6 = Nn;
          }
          if (n6) {
            const r9 = {}, n7 = [];
            for (let e7 = 0; e7 < t5.stops.length; e7++) {
              const i8 = t5.stops[e7], s6 = i8[0].zoom;
              void 0 === r9[s6] && (r9[s6] = { zoom: s6, type: t5.type, property: t5.property, default: t5.default, stops: [] }, n7.push(s6)), r9[s6].stops.push([i8[0].value, i8[1]]);
            }
            const i7 = [];
            for (const t6 of n7) i7.push([r9[t6].zoom, Ln(r9[t6], e6)]);
            const s5 = { name: "linear" };
            return { kind: "composite", interpolationType: s5, interpolationFactor: rr.interpolationFactor.bind(void 0, s5), zoomStops: i7.map((t6) => t6[0]), evaluate: ({ zoom: r10 }, n8) => jn({ stops: i7, base: t5.base }, e6, r10).evaluate(r10, n8) };
          }
          if (i6) {
            const r9 = "exponential" === s4 ? { name: "exponential", base: void 0 !== t5.base ? t5.base : 1 } : null;
            return { kind: "camera", interpolationType: r9, interpolationFactor: rr.interpolationFactor.bind(void 0, r9), zoomStops: t5.stops.map((t6) => t6[0]), evaluate: ({ zoom: r10 }) => o6(t5, e6, r10, l5, u4) };
          }
          return { kind: "source", evaluate(r9, n7) {
            const i7 = n7 && n7.properties ? n7.properties[t5.property] : void 0;
            return void 0 === i7 ? On(t5.default, e6.default) : o6(t5, e6, i7, l5, u4);
          } };
        }
        function On(t5, e6, r8) {
          return void 0 !== t5 ? t5 : void 0 !== e6 ? e6 : void 0 !== r8 ? r8 : void 0;
        }
        function Dn(t5, e6, r8, n6, i6) {
          return On(typeof r8 === i6 ? n6[r8] : void 0, t5.default, e6.default);
        }
        function Rn(t5, e6, r8) {
          if ("number" !== Tn(r8)) return On(t5.default, e6.default);
          const n6 = t5.stops.length;
          if (1 === n6) return t5.stops[0][1];
          if (r8 <= t5.stops[0][0]) return t5.stops[0][1];
          if (r8 >= t5.stops[n6 - 1][0]) return t5.stops[n6 - 1][1];
          const i6 = He(t5.stops.map((t6) => t6[0]), r8);
          return t5.stops[i6][1];
        }
        function jn(t5, e6, r8) {
          const n6 = void 0 !== t5.base ? t5.base : 1;
          if ("number" !== Tn(r8)) return On(t5.default, e6.default);
          const i6 = t5.stops.length;
          if (1 === i6) return t5.stops[0][1];
          if (r8 <= t5.stops[0][0]) return t5.stops[0][1];
          if (r8 >= t5.stops[i6 - 1][0]) return t5.stops[i6 - 1][1];
          const s4 = He(t5.stops.map((t6) => t6[0]), r8), a4 = function(t6, e7, r9, n7) {
            const i7 = n7 - r9, s5 = t6 - r9;
            return 0 === i7 ? 0 : 1 === e7 ? s5 / i7 : (Math.pow(e7, s5) - 1) / (Math.pow(e7, i7) - 1);
          }(r8, n6, t5.stops[s4][0], t5.stops[s4 + 1][0]), o6 = t5.stops[s4][1], l5 = t5.stops[s4 + 1][1], u4 = ir[e6.type] || $n;
          return "function" == typeof o6.evaluate ? { evaluate(...e7) {
            const r9 = o6.evaluate.apply(void 0, e7), n7 = l5.evaluate.apply(void 0, e7);
            if (void 0 !== r9 && void 0 !== n7) return u4(r9, n7, a4, t5.colorSpace);
          } } : u4(o6, l5, a4, t5.colorSpace);
        }
        function Nn(t5, e6, r8) {
          switch (e6.type) {
            case "color":
              r8 = xe.parse(r8);
              break;
            case "formatted":
              r8 = _e.fromString(r8.toString());
              break;
            case "resolvedImage":
              r8 = Ie.fromString(r8.toString());
              break;
            case "padding":
              r8 = Se.parse(r8);
              break;
            default:
              Tn(r8) === e6.type || "enum" === e6.type && e6.values[r8] || (r8 = void 0);
          }
          return On(r8, t5.default, e6.default);
        }
        bn.register(vn, { error: [{ kind: "error" }, [Vt], (t5, [e6]) => {
          throw new Ae(e6.evaluate(t5));
        }], typeof: [Vt, [Lt], (t5, [e6]) => qt(Be(e6.evaluate(t5)))], "to-rgba": [Ut(Bt, 4), [Tt], (t5, [e6]) => {
          const [r8, n6, i6, s4] = e6.evaluate(t5).rgb;
          return [255 * r8, 255 * n6, 255 * i6, s4];
        }], rgb: [Tt, [Bt, Bt, Bt], wn], rgba: [Tt, [Bt, Bt, Bt, Bt], wn], has: { type: Et, overloads: [[[Vt], (t5, [e6]) => _n(e6.evaluate(t5), t5.properties())], [[Vt, $t], (t5, [e6, r8]) => _n(e6.evaluate(t5), r8.evaluate(t5))]] }, get: { type: Lt, overloads: [[[Vt], (t5, [e6]) => Sn(e6.evaluate(t5), t5.properties())], [[Vt, $t], (t5, [e6, r8]) => Sn(e6.evaluate(t5), r8.evaluate(t5))]] }, "feature-state": [Lt, [Vt], (t5, [e6]) => Sn(e6.evaluate(t5), t5.featureState || {})], properties: [$t, [], (t5) => t5.properties()], "geometry-type": [Vt, [], (t5) => t5.geometryType()], id: [Lt, [], (t5) => t5.id()], zoom: [Bt, [], (t5) => t5.globals.zoom], "heatmap-density": [Bt, [], (t5) => t5.globals.heatmapDensity || 0], "line-progress": [Bt, [], (t5) => t5.globals.lineProgress || 0], accumulated: [Lt, [], (t5) => void 0 === t5.globals.accumulated ? null : t5.globals.accumulated], "+": [Bt, An(Bt), (t5, e6) => {
          let r8 = 0;
          for (const n6 of e6) r8 += n6.evaluate(t5);
          return r8;
        }], "*": [Bt, An(Bt), (t5, e6) => {
          let r8 = 1;
          for (const n6 of e6) r8 *= n6.evaluate(t5);
          return r8;
        }], "-": { type: Bt, overloads: [[[Bt, Bt], (t5, [e6, r8]) => e6.evaluate(t5) - r8.evaluate(t5)], [[Bt], (t5, [e6]) => -e6.evaluate(t5)]] }, "/": [Bt, [Bt, Bt], (t5, [e6, r8]) => e6.evaluate(t5) / r8.evaluate(t5)], "%": [Bt, [Bt, Bt], (t5, [e6, r8]) => e6.evaluate(t5) % r8.evaluate(t5)], ln2: [Bt, [], () => Math.LN2], pi: [Bt, [], () => Math.PI], e: [Bt, [], () => Math.E], "^": [Bt, [Bt, Bt], (t5, [e6, r8]) => Math.pow(e6.evaluate(t5), r8.evaluate(t5))], sqrt: [Bt, [Bt], (t5, [e6]) => Math.sqrt(e6.evaluate(t5))], log10: [Bt, [Bt], (t5, [e6]) => Math.log(e6.evaluate(t5)) / Math.LN10], ln: [Bt, [Bt], (t5, [e6]) => Math.log(e6.evaluate(t5))], log2: [Bt, [Bt], (t5, [e6]) => Math.log(e6.evaluate(t5)) / Math.LN2], sin: [Bt, [Bt], (t5, [e6]) => Math.sin(e6.evaluate(t5))], cos: [Bt, [Bt], (t5, [e6]) => Math.cos(e6.evaluate(t5))], tan: [Bt, [Bt], (t5, [e6]) => Math.tan(e6.evaluate(t5))], asin: [Bt, [Bt], (t5, [e6]) => Math.asin(e6.evaluate(t5))], acos: [Bt, [Bt], (t5, [e6]) => Math.acos(e6.evaluate(t5))], atan: [Bt, [Bt], (t5, [e6]) => Math.atan(e6.evaluate(t5))], min: [Bt, An(Bt), (t5, e6) => Math.min(...e6.map((e7) => e7.evaluate(t5)))], max: [Bt, An(Bt), (t5, e6) => Math.max(...e6.map((e7) => e7.evaluate(t5)))], abs: [Bt, [Bt], (t5, [e6]) => Math.abs(e6.evaluate(t5))], round: [Bt, [Bt], (t5, [e6]) => {
          const r8 = e6.evaluate(t5);
          return r8 < 0 ? -Math.round(-r8) : Math.round(r8);
        }], floor: [Bt, [Bt], (t5, [e6]) => Math.floor(e6.evaluate(t5))], ceil: [Bt, [Bt], (t5, [e6]) => Math.ceil(e6.evaluate(t5))], "filter-==": [Et, [Vt, Lt], (t5, [e6, r8]) => t5.properties()[e6.value] === r8.value], "filter-id-==": [Et, [Lt], (t5, [e6]) => t5.id() === e6.value], "filter-type-==": [Et, [Vt], (t5, [e6]) => t5.geometryType() === e6.value], "filter-<": [Et, [Vt, Lt], (t5, [e6, r8]) => {
          const n6 = t5.properties()[e6.value], i6 = r8.value;
          return typeof n6 == typeof i6 && n6 < i6;
        }], "filter-id-<": [Et, [Lt], (t5, [e6]) => {
          const r8 = t5.id(), n6 = e6.value;
          return typeof r8 == typeof n6 && r8 < n6;
        }], "filter->": [Et, [Vt, Lt], (t5, [e6, r8]) => {
          const n6 = t5.properties()[e6.value], i6 = r8.value;
          return typeof n6 == typeof i6 && n6 > i6;
        }], "filter-id->": [Et, [Lt], (t5, [e6]) => {
          const r8 = t5.id(), n6 = e6.value;
          return typeof r8 == typeof n6 && r8 > n6;
        }], "filter-<=": [Et, [Vt, Lt], (t5, [e6, r8]) => {
          const n6 = t5.properties()[e6.value], i6 = r8.value;
          return typeof n6 == typeof i6 && n6 <= i6;
        }], "filter-id-<=": [Et, [Lt], (t5, [e6]) => {
          const r8 = t5.id(), n6 = e6.value;
          return typeof r8 == typeof n6 && r8 <= n6;
        }], "filter->=": [Et, [Vt, Lt], (t5, [e6, r8]) => {
          const n6 = t5.properties()[e6.value], i6 = r8.value;
          return typeof n6 == typeof i6 && n6 >= i6;
        }], "filter-id->=": [Et, [Lt], (t5, [e6]) => {
          const r8 = t5.id(), n6 = e6.value;
          return typeof r8 == typeof n6 && r8 >= n6;
        }], "filter-has": [Et, [Lt], (t5, [e6]) => e6.value in t5.properties()], "filter-has-id": [Et, [], (t5) => null !== t5.id() && void 0 !== t5.id()], "filter-type-in": [Et, [Ut(Vt)], (t5, [e6]) => e6.value.indexOf(t5.geometryType()) >= 0], "filter-id-in": [Et, [Ut(Lt)], (t5, [e6]) => e6.value.indexOf(t5.id()) >= 0], "filter-in-small": [Et, [Vt, Ut(Lt)], (t5, [e6, r8]) => r8.value.indexOf(t5.properties()[e6.value]) >= 0], "filter-in-large": [Et, [Vt, Ut(Lt)], (t5, [e6, r8]) => function(t6, e7, r9, n6) {
          for (; r9 <= n6; ) {
            const i6 = r9 + n6 >> 1;
            if (e7[i6] === t6) return true;
            e7[i6] > t6 ? n6 = i6 - 1 : r9 = i6 + 1;
          }
          return false;
        }(t5.properties()[e6.value], r8.value, 0, r8.value.length - 1)], all: { type: Et, overloads: [[[Et, Et], (t5, [e6, r8]) => e6.evaluate(t5) && r8.evaluate(t5)], [An(Et), (t5, e6) => {
          for (const r8 of e6) if (!r8.evaluate(t5)) return false;
          return true;
        }]] }, any: { type: Et, overloads: [[[Et, Et], (t5, [e6, r8]) => e6.evaluate(t5) || r8.evaluate(t5)], [An(Et), (t5, e6) => {
          for (const r8 of e6) if (r8.evaluate(t5)) return true;
          return false;
        }]] }, "!": [Et, [Et], (t5, [e6]) => !e6.evaluate(t5)], "is-supported-script": [Et, [Vt], (t5, [e6]) => {
          const r8 = t5.globals && t5.globals.isSupportedScript;
          return !r8 || r8(e6.evaluate(t5));
        }], upcase: [Vt, [Vt], (t5, [e6]) => e6.evaluate(t5).toUpperCase()], downcase: [Vt, [Vt], (t5, [e6]) => e6.evaluate(t5).toLowerCase()], concat: [Vt, An(Lt), (t5, e6) => e6.map((e7) => Ve(e7.evaluate(t5))).join("")], "resolved-locale": [Vt, [Ot], (t5, [e6]) => e6.evaluate(t5).resolvedLocale()] });
        class Un {
          constructor(t5, e6) {
            var r8;
            this.expression = t5, this._warningHistory = {}, this._evaluator = new De(), this._defaultValue = e6 ? "color" === (r8 = e6).type && Fn(r8.default) ? new xe(0, 0, 0, 0) : "color" === r8.type ? xe.parse(r8.default) || null : "padding" === r8.type ? Se.parse(r8.default) || null : "variableAnchorOffsetCollection" === r8.type ? Me.parse(r8.default) || null : "projectionDefinition" === r8.type ? ze.parse(r8.default) || null : void 0 === r8.default ? null : r8.default : null, this._enumValues = e6 && "enum" === e6.type ? e6.values : null;
          }
          evaluateWithoutErrorHandling(t5, e6, r8, n6, i6, s4) {
            return this._evaluator.globals = t5, this._evaluator.feature = e6, this._evaluator.featureState = r8, this._evaluator.canonical = n6, this._evaluator.availableImages = i6 || null, this._evaluator.formattedSection = s4, this.expression.evaluate(this._evaluator);
          }
          evaluate(t5, e6, r8, n6, i6, s4) {
            this._evaluator.globals = t5, this._evaluator.feature = e6 || null, this._evaluator.featureState = r8 || null, this._evaluator.canonical = n6, this._evaluator.availableImages = i6 || null, this._evaluator.formattedSection = s4 || null;
            try {
              const t6 = this.expression.evaluate(this._evaluator);
              if (null == t6 || "number" == typeof t6 && t6 != t6) return this._defaultValue;
              if (this._enumValues && !(t6 in this._enumValues)) throw new Ae(`Expected value to be one of ${Object.keys(this._enumValues).map((t7) => JSON.stringify(t7)).join(", ")}, but found ${JSON.stringify(t6)} instead.`);
              return t6;
            } catch (t6) {
              return this._warningHistory[t6.message] || (this._warningHistory[t6.message] = true, "undefined" != typeof console && console.warn(t6.message)), this._defaultValue;
            }
          }
        }
        function qn(t5) {
          return Array.isArray(t5) && t5.length > 0 && "string" == typeof t5[0] && t5[0] in vn;
        }
        function Gn(t5, e6) {
          const r8 = new Re(vn, kn, [], e6 ? function(t6) {
            const e7 = { color: Tt, string: Vt, number: Bt, enum: Vt, boolean: Et, formatted: Dt, padding: Rt, projectionDefinition: Ft, resolvedImage: jt, variableAnchorOffsetCollection: Nt };
            return "array" === t6.type ? Ut(e7[t6.value] || Lt, t6.length) : e7[t6.type];
          }(e6) : void 0), n6 = r8.parse(t5, void 0, void 0, void 0, e6 && "string" === e6.type ? { typeAnnotation: "coerce" } : void 0);
          return n6 ? Pn(new Un(n6, e6)) : Cn(r8.errors);
        }
        class Zn {
          constructor(t5, e6) {
            this.kind = t5, this._styleExpression = e6, this.isStateDependent = "constant" !== t5 && !In(e6.expression);
          }
          evaluateWithoutErrorHandling(t5, e6, r8, n6, i6, s4) {
            return this._styleExpression.evaluateWithoutErrorHandling(t5, e6, r8, n6, i6, s4);
          }
          evaluate(t5, e6, r8, n6, i6, s4) {
            return this._styleExpression.evaluate(t5, e6, r8, n6, i6, s4);
          }
        }
        class Kn {
          constructor(t5, e6, r8, n6) {
            this.kind = t5, this.zoomStops = r8, this._styleExpression = e6, this.isStateDependent = "camera" !== t5 && !In(e6.expression), this.interpolationType = n6;
          }
          evaluateWithoutErrorHandling(t5, e6, r8, n6, i6, s4) {
            return this._styleExpression.evaluateWithoutErrorHandling(t5, e6, r8, n6, i6, s4);
          }
          evaluate(t5, e6, r8, n6, i6, s4) {
            return this._styleExpression.evaluate(t5, e6, r8, n6, i6, s4);
          }
          interpolationFactor(t5, e6, r8) {
            return this.interpolationType ? rr.interpolationFactor(this.interpolationType, t5, e6, r8) : 0;
          }
        }
        function Xn(t5, e6) {
          const r8 = Gn(t5, e6);
          if ("error" === r8.result) return r8;
          const n6 = r8.value.expression, i6 = Mn(n6);
          if (!i6 && !Bn(e6)) return Cn([new zt("", "data expressions not supported")]);
          const s4 = zn(n6, ["zoom"]);
          if (!s4 && !Vn(e6)) return Cn([new zt("", "zoom expressions not supported")]);
          const a4 = Yn(n6);
          return a4 || s4 ? a4 instanceof zt ? Cn([a4]) : a4 instanceof rr && !En(e6) ? Cn([new zt("", '"interpolate" expressions cannot be used with this property')]) : Pn(a4 ? new Kn(i6 ? "camera" : "composite", r8.value, a4.labels, a4 instanceof rr ? a4.interpolation : void 0) : new Zn(i6 ? "constant" : "source", r8.value)) : Cn([new zt("", '"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.')]);
        }
        class Hn {
          constructor(t5, e6) {
            this._parameters = t5, this._specification = e6, It(this, Ln(this._parameters, this._specification));
          }
          static deserialize(t5) {
            return new Hn(t5._parameters, t5._specification);
          }
          static serialize(t5) {
            return { _parameters: t5._parameters, _specification: t5._specification };
          }
        }
        function Yn(t5) {
          let e6 = null;
          if (t5 instanceof je) e6 = Yn(t5.result);
          else if (t5 instanceof sr) {
            for (const r8 of t5.args) if (e6 = Yn(r8), e6) break;
          } else (t5 instanceof Ye || t5 instanceof rr) && t5.input instanceof bn && "zoom" === t5.input.name && (e6 = t5);
          return e6 instanceof zt || t5.eachChild((t6) => {
            const r8 = Yn(t6);
            r8 instanceof zt ? e6 = r8 : !e6 && r8 ? e6 = new zt("", '"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.') : e6 && r8 && e6 !== r8 && (e6 = new zt("", 'Only one zoom-based "step" or "interpolate" subexpression may be used in an expression.'));
          }), e6;
        }
        function Jn(t5) {
          if (true === t5 || false === t5) return true;
          if (!Array.isArray(t5) || 0 === t5.length) return false;
          switch (t5[0]) {
            case "has":
              return t5.length >= 2 && "$id" !== t5[1] && "$type" !== t5[1];
            case "in":
              return t5.length >= 3 && ("string" != typeof t5[1] || Array.isArray(t5[2]));
            case "!in":
            case "!has":
            case "none":
              return false;
            case "==":
            case "!=":
            case ">":
            case ">=":
            case "<":
            case "<=":
              return 3 !== t5.length || Array.isArray(t5[1]) || Array.isArray(t5[2]);
            case "any":
            case "all":
              for (const e6 of t5.slice(1)) if (!Jn(e6) && "boolean" != typeof e6) return false;
              return true;
            default:
              return true;
          }
        }
        const Wn = { type: "boolean", default: false, transition: false, "property-type": "data-driven", expression: { interpolated: false, parameters: ["zoom", "feature"] } };
        function Qn(t5) {
          if (null == t5) return { filter: () => true, needGeometry: false };
          Jn(t5) || (t5 = ri(t5));
          const e6 = Gn(t5, Wn);
          if ("error" === e6.result) throw new Error(e6.value.map((t6) => `${t6.key}: ${t6.message}`).join(", "));
          return { filter: (t6, r8, n6) => e6.value.evaluate(t6, r8, {}, n6), needGeometry: ei(t5) };
        }
        function ti(t5, e6) {
          return t5 < e6 ? -1 : t5 > e6 ? 1 : 0;
        }
        function ei(t5) {
          if (!Array.isArray(t5)) return false;
          if ("within" === t5[0] || "distance" === t5[0]) return true;
          for (let e6 = 1; e6 < t5.length; e6++) if (ei(t5[e6])) return true;
          return false;
        }
        function ri(t5) {
          if (!t5) return true;
          const e6 = t5[0];
          return t5.length <= 1 ? "any" !== e6 : "==" === e6 ? ni(t5[1], t5[2], "==") : "!=" === e6 ? ai(ni(t5[1], t5[2], "==")) : "<" === e6 || ">" === e6 || "<=" === e6 || ">=" === e6 ? ni(t5[1], t5[2], e6) : "any" === e6 ? (r8 = t5.slice(1), ["any"].concat(r8.map(ri))) : "all" === e6 ? ["all"].concat(t5.slice(1).map(ri)) : "none" === e6 ? ["all"].concat(t5.slice(1).map(ri).map(ai)) : "in" === e6 ? ii(t5[1], t5.slice(2)) : "!in" === e6 ? ai(ii(t5[1], t5.slice(2))) : "has" === e6 ? si(t5[1]) : "!has" !== e6 || ai(si(t5[1]));
          var r8;
        }
        function ni(t5, e6, r8) {
          switch (t5) {
            case "$type":
              return [`filter-type-${r8}`, e6];
            case "$id":
              return [`filter-id-${r8}`, e6];
            default:
              return [`filter-${r8}`, t5, e6];
          }
        }
        function ii(t5, e6) {
          if (0 === e6.length) return false;
          switch (t5) {
            case "$type":
              return ["filter-type-in", ["literal", e6]];
            case "$id":
              return ["filter-id-in", ["literal", e6]];
            default:
              return e6.length > 200 && !e6.some((t6) => typeof t6 != typeof e6[0]) ? ["filter-in-large", t5, ["literal", e6.sort(ti)]] : ["filter-in-small", t5, ["literal", e6]];
          }
        }
        function si(t5) {
          switch (t5) {
            case "$type":
              return true;
            case "$id":
              return ["filter-has-id"];
            default:
              return ["filter-has", t5];
          }
        }
        function ai(t5) {
          return ["!", t5];
        }
        function oi(t5) {
          const e6 = typeof t5;
          if ("number" === e6 || "boolean" === e6 || "string" === e6 || null == t5) return JSON.stringify(t5);
          if (Array.isArray(t5)) {
            let e7 = "[";
            for (const r9 of t5) e7 += `${oi(r9)},`;
            return `${e7}]`;
          }
          const r8 = Object.keys(t5).sort();
          let n6 = "{";
          for (let e7 = 0; e7 < r8.length; e7++) n6 += `${JSON.stringify(r8[e7])}:${oi(t5[r8[e7]])},`;
          return `${n6}}`;
        }
        function li(t5) {
          let e6 = "";
          for (const r8 of yt) e6 += `/${oi(t5[r8])}`;
          return e6;
        }
        function ui(t5) {
          const e6 = t5.value;
          return e6 ? [new Mt(t5.key, e6, "constants have been deprecated as of v8")] : [];
        }
        function ci(t5) {
          return t5 instanceof Number || t5 instanceof String || t5 instanceof Boolean ? t5.valueOf() : t5;
        }
        function hi(t5) {
          if (Array.isArray(t5)) return t5.map(hi);
          if (t5 instanceof Object && !(t5 instanceof Number || t5 instanceof String || t5 instanceof Boolean)) {
            const e6 = {};
            for (const r8 in t5) e6[r8] = hi(t5[r8]);
            return e6;
          }
          return ci(t5);
        }
        function pi(t5) {
          const e6 = t5.key, r8 = t5.value, n6 = t5.valueSpec || {}, i6 = t5.objectElementValidators || {}, s4 = t5.style, a4 = t5.styleSpec, o6 = t5.validateSpec;
          let l5 = [];
          const u4 = Tn(r8);
          if ("object" !== u4) return [new Mt(e6, r8, `object expected, ${u4} found`)];
          for (const t6 in r8) {
            const u5 = t6.split(".")[0], c5 = n6[u5] || n6["*"];
            let h4;
            if (i6[u5]) h4 = i6[u5];
            else if (n6[u5]) h4 = o6;
            else if (i6["*"]) h4 = i6["*"];
            else {
              if (!n6["*"]) {
                l5.push(new Mt(e6, r8[t6], `unknown property "${t6}"`));
                continue;
              }
              h4 = o6;
            }
            l5 = l5.concat(h4({ key: (e6 ? `${e6}.` : e6) + t6, value: r8[t6], valueSpec: c5, style: s4, styleSpec: a4, object: r8, objectKey: t6, validateSpec: o6 }, r8));
          }
          for (const t6 in n6) i6[t6] || n6[t6].required && void 0 === n6[t6].default && void 0 === r8[t6] && l5.push(new Mt(e6, r8, `missing required property "${t6}"`));
          return l5;
        }
        function fi(t5) {
          const e6 = t5.value, r8 = t5.valueSpec, n6 = t5.style, i6 = t5.styleSpec, s4 = t5.key, a4 = t5.arrayElementValidator || t5.validateSpec;
          if ("array" !== Tn(e6)) return [new Mt(s4, e6, `array expected, ${Tn(e6)} found`)];
          if (r8.length && e6.length !== r8.length) return [new Mt(s4, e6, `array length ${r8.length} expected, length ${e6.length} found`)];
          if (r8["min-length"] && e6.length < r8["min-length"]) return [new Mt(s4, e6, `array length at least ${r8["min-length"]} expected, length ${e6.length} found`)];
          let o6 = { type: r8.value, values: r8.values };
          i6.$version < 7 && (o6.function = r8.function), "object" === Tn(r8.value) && (o6 = r8.value);
          let l5 = [];
          for (let r9 = 0; r9 < e6.length; r9++) l5 = l5.concat(a4({ array: e6, arrayIndex: r9, value: e6[r9], valueSpec: o6, validateSpec: t5.validateSpec, style: n6, styleSpec: i6, key: `${s4}[${r9}]` }));
          return l5;
        }
        function di(t5) {
          const e6 = t5.key, r8 = t5.value, n6 = t5.valueSpec;
          let i6 = Tn(r8);
          return "number" === i6 && r8 != r8 && (i6 = "NaN"), "number" !== i6 ? [new Mt(e6, r8, `number expected, ${i6} found`)] : "minimum" in n6 && r8 < n6.minimum ? [new Mt(e6, r8, `${r8} is less than the minimum value ${n6.minimum}`)] : "maximum" in n6 && r8 > n6.maximum ? [new Mt(e6, r8, `${r8} is greater than the maximum value ${n6.maximum}`)] : [];
        }
        function yi(t5) {
          const e6 = t5.valueSpec, r8 = ci(t5.value.type);
          let n6, i6, s4, a4 = {};
          const o6 = "categorical" !== r8 && void 0 === t5.value.property, l5 = !o6, u4 = "array" === Tn(t5.value.stops) && "array" === Tn(t5.value.stops[0]) && "object" === Tn(t5.value.stops[0][0]), c5 = pi({ key: t5.key, value: t5.value, valueSpec: t5.styleSpec.function, validateSpec: t5.validateSpec, style: t5.style, styleSpec: t5.styleSpec, objectElementValidators: { stops: function(t6) {
            if ("identity" === r8) return [new Mt(t6.key, t6.value, 'identity function may not have a "stops" property')];
            let e7 = [];
            const n7 = t6.value;
            return e7 = e7.concat(fi({ key: t6.key, value: n7, valueSpec: t6.valueSpec, validateSpec: t6.validateSpec, style: t6.style, styleSpec: t6.styleSpec, arrayElementValidator: h4 })), "array" === Tn(n7) && 0 === n7.length && e7.push(new Mt(t6.key, n7, "array must have at least one stop")), e7;
          }, default: function(t6) {
            return t6.validateSpec({ key: t6.key, value: t6.value, valueSpec: e6, validateSpec: t6.validateSpec, style: t6.style, styleSpec: t6.styleSpec });
          } } });
          return "identity" === r8 && o6 && c5.push(new Mt(t5.key, t5.value, 'missing required property "property"')), "identity" === r8 || t5.value.stops || c5.push(new Mt(t5.key, t5.value, 'missing required property "stops"')), "exponential" === r8 && t5.valueSpec.expression && !En(t5.valueSpec) && c5.push(new Mt(t5.key, t5.value, "exponential functions not supported")), t5.styleSpec.$version >= 8 && (l5 && !Bn(t5.valueSpec) ? c5.push(new Mt(t5.key, t5.value, "property functions not supported")) : o6 && !Vn(t5.valueSpec) && c5.push(new Mt(t5.key, t5.value, "zoom functions not supported"))), "categorical" !== r8 && !u4 || void 0 !== t5.value.property || c5.push(new Mt(t5.key, t5.value, '"property" property is required')), c5;
          function h4(t6) {
            let r9 = [];
            const n7 = t6.value, o7 = t6.key;
            if ("array" !== Tn(n7)) return [new Mt(o7, n7, `array expected, ${Tn(n7)} found`)];
            if (2 !== n7.length) return [new Mt(o7, n7, `array length 2 expected, length ${n7.length} found`)];
            if (u4) {
              if ("object" !== Tn(n7[0])) return [new Mt(o7, n7, `object expected, ${Tn(n7[0])} found`)];
              if (void 0 === n7[0].zoom) return [new Mt(o7, n7, "object stop key must have zoom")];
              if (void 0 === n7[0].value) return [new Mt(o7, n7, "object stop key must have value")];
              if (s4 && s4 > ci(n7[0].zoom)) return [new Mt(o7, n7[0].zoom, "stop zoom values must appear in ascending order")];
              ci(n7[0].zoom) !== s4 && (s4 = ci(n7[0].zoom), i6 = void 0, a4 = {}), r9 = r9.concat(pi({ key: `${o7}[0]`, value: n7[0], valueSpec: { zoom: {} }, validateSpec: t6.validateSpec, style: t6.style, styleSpec: t6.styleSpec, objectElementValidators: { zoom: di, value: p4 } }));
            } else r9 = r9.concat(p4({ key: `${o7}[0]`, value: n7[0], validateSpec: t6.validateSpec, style: t6.style, styleSpec: t6.styleSpec }, n7));
            return qn(hi(n7[1])) ? r9.concat([new Mt(`${o7}[1]`, n7[1], "expressions are not allowed in function stops.")]) : r9.concat(t6.validateSpec({ key: `${o7}[1]`, value: n7[1], valueSpec: e6, validateSpec: t6.validateSpec, style: t6.style, styleSpec: t6.styleSpec }));
          }
          function p4(t6, s5) {
            const o7 = Tn(t6.value), l6 = ci(t6.value), u5 = null !== t6.value ? t6.value : s5;
            if (n6) {
              if (o7 !== n6) return [new Mt(t6.key, u5, `${o7} stop domain type must match previous stop domain type ${n6}`)];
            } else n6 = o7;
            if ("number" !== o7 && "string" !== o7 && "boolean" !== o7) return [new Mt(t6.key, u5, "stop domain value must be a number, string, or boolean")];
            if ("number" !== o7 && "categorical" !== r8) {
              let n7 = `number expected, ${o7} found`;
              return Bn(e6) && void 0 === r8 && (n7 += '\nIf you intended to use a categorical function, specify `"type": "categorical"`.'), [new Mt(t6.key, u5, n7)];
            }
            return "categorical" !== r8 || "number" !== o7 || isFinite(l6) && Math.floor(l6) === l6 ? "categorical" !== r8 && "number" === o7 && void 0 !== i6 && l6 < i6 ? [new Mt(t6.key, u5, "stop domain values must appear in ascending order")] : (i6 = l6, "categorical" === r8 && l6 in a4 ? [new Mt(t6.key, u5, "stop domain values must be unique")] : (a4[l6] = true, [])) : [new Mt(t6.key, u5, `integer expected, found ${l6}`)];
          }
        }
        function mi(t5) {
          const e6 = ("property" === t5.expressionContext ? Xn : Gn)(hi(t5.value), t5.valueSpec);
          if ("error" === e6.result) return e6.value.map((e7) => new Mt(`${t5.key}${e7.key}`, t5.value, e7.message));
          const r8 = e6.value.expression || e6.value._styleExpression.expression;
          if ("property" === t5.expressionContext && "text-font" === t5.propertyKey && !r8.outputDefined()) return [new Mt(t5.key, t5.value, `Invalid data expression for "${t5.propertyKey}". Output values must be contained as literals within the expression.`)];
          if ("property" === t5.expressionContext && "layout" === t5.propertyType && !In(r8)) return [new Mt(t5.key, t5.value, '"feature-state" data expressions are not supported with layout properties.')];
          if ("filter" === t5.expressionContext && !In(r8)) return [new Mt(t5.key, t5.value, '"feature-state" data expressions are not supported with filters.')];
          if (t5.expressionContext && 0 === t5.expressionContext.indexOf("cluster")) {
            if (!zn(r8, ["zoom", "feature-state"])) return [new Mt(t5.key, t5.value, '"zoom" and "feature-state" expressions are not supported with cluster properties.')];
            if ("cluster-initial" === t5.expressionContext && !Mn(r8)) return [new Mt(t5.key, t5.value, "Feature data expressions are not supported with initial expression part of cluster properties.")];
          }
          return [];
        }
        function gi(t5) {
          const e6 = t5.key, r8 = t5.value, n6 = t5.valueSpec, i6 = [];
          return Array.isArray(n6.values) ? -1 === n6.values.indexOf(ci(r8)) && i6.push(new Mt(e6, r8, `expected one of [${n6.values.join(", ")}], ${JSON.stringify(r8)} found`)) : -1 === Object.keys(n6.values).indexOf(ci(r8)) && i6.push(new Mt(e6, r8, `expected one of [${Object.keys(n6.values).join(", ")}], ${JSON.stringify(r8)} found`)), i6;
        }
        function xi(t5) {
          return Jn(hi(t5.value)) ? mi(It({}, t5, { expressionContext: "filter", valueSpec: { value: "boolean" } })) : vi(t5);
        }
        function vi(t5) {
          const e6 = t5.value, r8 = t5.key;
          if ("array" !== Tn(e6)) return [new Mt(r8, e6, `array expected, ${Tn(e6)} found`)];
          const n6 = t5.styleSpec;
          let i6, s4 = [];
          if (e6.length < 1) return [new Mt(r8, e6, "filter array must have at least 1 element")];
          switch (s4 = s4.concat(gi({ key: `${r8}[0]`, value: e6[0], valueSpec: n6.filter_operator, style: t5.style, styleSpec: t5.styleSpec })), ci(e6[0])) {
            case "<":
            case "<=":
            case ">":
            case ">=":
              e6.length >= 2 && "$type" === ci(e6[1]) && s4.push(new Mt(r8, e6, `"$type" cannot be use with operator "${e6[0]}"`));
            case "==":
            case "!=":
              3 !== e6.length && s4.push(new Mt(r8, e6, `filter array for operator "${e6[0]}" must have 3 elements`));
            case "in":
            case "!in":
              e6.length >= 2 && (i6 = Tn(e6[1]), "string" !== i6 && s4.push(new Mt(`${r8}[1]`, e6[1], `string expected, ${i6} found`)));
              for (let a4 = 2; a4 < e6.length; a4++) i6 = Tn(e6[a4]), "$type" === ci(e6[1]) ? s4 = s4.concat(gi({ key: `${r8}[${a4}]`, value: e6[a4], valueSpec: n6.geometry_type, style: t5.style, styleSpec: t5.styleSpec })) : "string" !== i6 && "number" !== i6 && "boolean" !== i6 && s4.push(new Mt(`${r8}[${a4}]`, e6[a4], `string, number, or boolean expected, ${i6} found`));
              break;
            case "any":
            case "all":
            case "none":
              for (let n7 = 1; n7 < e6.length; n7++) s4 = s4.concat(vi({ key: `${r8}[${n7}]`, value: e6[n7], style: t5.style, styleSpec: t5.styleSpec }));
              break;
            case "has":
            case "!has":
              i6 = Tn(e6[1]), 2 !== e6.length ? s4.push(new Mt(r8, e6, `filter array for "${e6[0]}" operator must have 2 elements`)) : "string" !== i6 && s4.push(new Mt(`${r8}[1]`, e6[1], `string expected, ${i6} found`));
          }
          return s4;
        }
        function bi(t5, e6) {
          const r8 = t5.key, n6 = t5.validateSpec, i6 = t5.style, s4 = t5.styleSpec, a4 = t5.value, o6 = t5.objectKey, l5 = s4[`${e6}_${t5.layerType}`];
          if (!l5) return [];
          const u4 = o6.match(/^(.*)-transition$/);
          if ("paint" === e6 && u4 && l5[u4[1]] && l5[u4[1]].transition) return n6({ key: r8, value: a4, valueSpec: s4.transition, style: i6, styleSpec: s4 });
          const c5 = t5.valueSpec || l5[o6];
          if (!c5) return [new Mt(r8, a4, `unknown property "${o6}"`)];
          let h4;
          if ("string" === Tn(a4) && Bn(c5) && !c5.tokens && (h4 = /^{([^}]+)}$/.exec(a4))) return [new Mt(r8, a4, `"${o6}" does not support interpolation syntax
Use an identity property function instead: \`{ "type": "identity", "property": ${JSON.stringify(h4[1])} }\`.`)];
          const p4 = [];
          return "symbol" === t5.layerType && ("text-field" === o6 && i6 && !i6.glyphs && p4.push(new Mt(r8, a4, 'use of "text-field" requires a style "glyphs" property')), "text-font" === o6 && Fn(hi(a4)) && "identity" === ci(a4.type) && p4.push(new Mt(r8, a4, '"text-font" does not support identity functions'))), p4.concat(n6({ key: t5.key, value: a4, valueSpec: c5, style: i6, styleSpec: s4, expressionContext: "property", propertyType: e6, propertyKey: o6 }));
        }
        function wi(t5) {
          return bi(t5, "paint");
        }
        function _i(t5) {
          return bi(t5, "layout");
        }
        function Si(t5) {
          let e6 = [];
          const r8 = t5.value, n6 = t5.key, i6 = t5.style, s4 = t5.styleSpec;
          r8.type || r8.ref || e6.push(new Mt(n6, r8, 'either "type" or "ref" is required'));
          let a4 = ci(r8.type);
          const o6 = ci(r8.ref);
          if (r8.id) {
            const s5 = ci(r8.id);
            for (let a5 = 0; a5 < t5.arrayIndex; a5++) {
              const t6 = i6.layers[a5];
              ci(t6.id) === s5 && e6.push(new Mt(n6, r8.id, `duplicate layer id "${r8.id}", previously used at line ${t6.id.__line__}`));
            }
          }
          if ("ref" in r8) {
            let t6;
            ["type", "source", "source-layer", "filter", "layout"].forEach((t7) => {
              t7 in r8 && e6.push(new Mt(n6, r8[t7], `"${t7}" is prohibited for ref layers`));
            }), i6.layers.forEach((e7) => {
              ci(e7.id) === o6 && (t6 = e7);
            }), t6 ? t6.ref ? e6.push(new Mt(n6, r8.ref, "ref cannot reference another ref layer")) : a4 = ci(t6.type) : e6.push(new Mt(n6, r8.ref, `ref layer "${o6}" not found`));
          } else if ("background" !== a4) if (r8.source) {
            const t6 = i6.sources && i6.sources[r8.source], s5 = t6 && ci(t6.type);
            t6 ? "vector" === s5 && "raster" === a4 ? e6.push(new Mt(n6, r8.source, `layer "${r8.id}" requires a raster source`)) : "raster-dem" !== s5 && "hillshade" === a4 ? e6.push(new Mt(n6, r8.source, `layer "${r8.id}" requires a raster-dem source`)) : "raster" === s5 && "raster" !== a4 ? e6.push(new Mt(n6, r8.source, `layer "${r8.id}" requires a vector source`)) : "vector" !== s5 || r8["source-layer"] ? "raster-dem" === s5 && "hillshade" !== a4 ? e6.push(new Mt(n6, r8.source, "raster-dem source can only be used with layer type 'hillshade'.")) : "line" !== a4 || !r8.paint || !r8.paint["line-gradient"] || "geojson" === s5 && t6.lineMetrics || e6.push(new Mt(n6, r8, `layer "${r8.id}" specifies a line-gradient, which requires a GeoJSON source with \`lineMetrics\` enabled.`)) : e6.push(new Mt(n6, r8, `layer "${r8.id}" must specify a "source-layer"`)) : e6.push(new Mt(n6, r8.source, `source "${r8.source}" not found`));
          } else e6.push(new Mt(n6, r8, 'missing required property "source"'));
          return e6 = e6.concat(pi({ key: n6, value: r8, valueSpec: s4.layer, style: t5.style, styleSpec: t5.styleSpec, validateSpec: t5.validateSpec, objectElementValidators: { "*": () => [], type: () => t5.validateSpec({ key: `${n6}.type`, value: r8.type, valueSpec: s4.layer.type, style: t5.style, styleSpec: t5.styleSpec, validateSpec: t5.validateSpec, object: r8, objectKey: "type" }), filter: xi, layout: (t6) => pi({ layer: r8, key: t6.key, value: t6.value, style: t6.style, styleSpec: t6.styleSpec, validateSpec: t6.validateSpec, objectElementValidators: { "*": (t7) => _i(It({ layerType: a4 }, t7)) } }), paint: (t6) => pi({ layer: r8, key: t6.key, value: t6.value, style: t6.style, styleSpec: t6.styleSpec, validateSpec: t6.validateSpec, objectElementValidators: { "*": (t7) => wi(It({ layerType: a4 }, t7)) } }) } })), e6;
        }
        function Ai(t5) {
          const e6 = t5.value, r8 = t5.key, n6 = Tn(e6);
          return "string" !== n6 ? [new Mt(r8, e6, `string expected, ${n6} found`)] : [];
        }
        const ki = { promoteId: function({ key: t5, value: e6 }) {
          if ("string" === Tn(e6)) return Ai({ key: t5, value: e6 });
          {
            const r8 = [];
            for (const n6 in e6) r8.push(...Ai({ key: `${t5}.${n6}`, value: e6[n6] }));
            return r8;
          }
        } };
        function Mi(t5) {
          const e6 = t5.value, r8 = t5.key, n6 = t5.styleSpec, i6 = t5.style, s4 = t5.validateSpec;
          if (!e6.type) return [new Mt(r8, e6, '"type" is required')];
          const a4 = ci(e6.type);
          let o6;
          switch (a4) {
            case "vector":
            case "raster":
              return o6 = pi({ key: r8, value: e6, valueSpec: n6[`source_${a4.replace("-", "_")}`], style: t5.style, styleSpec: n6, objectElementValidators: ki, validateSpec: s4 }), o6;
            case "raster-dem":
              return o6 = function(t6) {
                var e7;
                const r9 = null !== (e7 = t6.sourceName) && void 0 !== e7 ? e7 : "", n7 = t6.value, i7 = t6.styleSpec, s5 = i7.source_raster_dem, a5 = t6.style;
                let o7 = [];
                const l5 = Tn(n7);
                if (void 0 === n7) return o7;
                if ("object" !== l5) return o7.push(new Mt("source_raster_dem", n7, `object expected, ${l5} found`)), o7;
                const u4 = "custom" === ci(n7.encoding), c5 = ["redFactor", "greenFactor", "blueFactor", "baseShift"], h4 = t6.value.encoding ? `"${t6.value.encoding}"` : "Default";
                for (const e8 in n7) !u4 && c5.includes(e8) ? o7.push(new Mt(e8, n7[e8], `In "${r9}": "${e8}" is only valid when "encoding" is set to "custom". ${h4} encoding found`)) : s5[e8] ? o7 = o7.concat(t6.validateSpec({ key: e8, value: n7[e8], valueSpec: s5[e8], validateSpec: t6.validateSpec, style: a5, styleSpec: i7 })) : o7.push(new Mt(e8, n7[e8], `unknown property "${e8}"`));
                return o7;
              }({ sourceName: r8, value: e6, style: t5.style, styleSpec: n6, validateSpec: s4 }), o6;
            case "geojson":
              if (o6 = pi({ key: r8, value: e6, valueSpec: n6.source_geojson, style: i6, styleSpec: n6, validateSpec: s4, objectElementValidators: ki }), e6.cluster) for (const t6 in e6.clusterProperties) {
                const [n7, i7] = e6.clusterProperties[t6], s5 = "string" == typeof n7 ? [n7, ["accumulated"], ["get", t6]] : n7;
                o6.push(...mi({ key: `${r8}.${t6}.map`, value: i7, expressionContext: "cluster-map" })), o6.push(...mi({ key: `${r8}.${t6}.reduce`, value: s5, expressionContext: "cluster-reduce" }));
              }
              return o6;
            case "video":
              return pi({ key: r8, value: e6, valueSpec: n6.source_video, style: i6, validateSpec: s4, styleSpec: n6 });
            case "image":
              return pi({ key: r8, value: e6, valueSpec: n6.source_image, style: i6, validateSpec: s4, styleSpec: n6 });
            case "canvas":
              return [new Mt(r8, null, "Please use runtime APIs to add canvas sources, rather than including them in stylesheets.", "source.canvas")];
            default:
              return gi({ key: `${r8}.type`, value: e6.type, valueSpec: { values: ["vector", "raster", "raster-dem", "geojson", "video", "image"] } });
          }
        }
        function Ii(t5) {
          const e6 = t5.value, r8 = t5.styleSpec, n6 = r8.light, i6 = t5.style;
          let s4 = [];
          const a4 = Tn(e6);
          if (void 0 === e6) return s4;
          if ("object" !== a4) return s4 = s4.concat([new Mt("light", e6, `object expected, ${a4} found`)]), s4;
          for (const a5 in e6) {
            const o6 = a5.match(/^(.*)-transition$/);
            s4 = s4.concat(o6 && n6[o6[1]] && n6[o6[1]].transition ? t5.validateSpec({ key: a5, value: e6[a5], valueSpec: r8.transition, validateSpec: t5.validateSpec, style: i6, styleSpec: r8 }) : n6[a5] ? t5.validateSpec({ key: a5, value: e6[a5], valueSpec: n6[a5], validateSpec: t5.validateSpec, style: i6, styleSpec: r8 }) : [new Mt(a5, e6[a5], `unknown property "${a5}"`)]);
          }
          return s4;
        }
        function zi(t5) {
          const e6 = t5.value, r8 = t5.styleSpec, n6 = r8.sky, i6 = t5.style, s4 = Tn(e6);
          if (void 0 === e6) return [];
          if ("object" !== s4) return [new Mt("sky", e6, `object expected, ${s4} found`)];
          let a4 = [];
          for (const s5 in e6) a4 = a4.concat(n6[s5] ? t5.validateSpec({ key: s5, value: e6[s5], valueSpec: n6[s5], style: i6, styleSpec: r8 }) : [new Mt(s5, e6[s5], `unknown property "${s5}"`)]);
          return a4;
        }
        function Pi(t5) {
          const e6 = t5.value, r8 = t5.styleSpec, n6 = r8.terrain, i6 = t5.style;
          let s4 = [];
          const a4 = Tn(e6);
          if (void 0 === e6) return s4;
          if ("object" !== a4) return s4 = s4.concat([new Mt("terrain", e6, `object expected, ${a4} found`)]), s4;
          for (const a5 in e6) s4 = s4.concat(n6[a5] ? t5.validateSpec({ key: a5, value: e6[a5], valueSpec: n6[a5], validateSpec: t5.validateSpec, style: i6, styleSpec: r8 }) : [new Mt(a5, e6[a5], `unknown property "${a5}"`)]);
          return s4;
        }
        function Ci(t5) {
          let e6 = [];
          const r8 = t5.value, n6 = t5.key;
          if (Array.isArray(r8)) {
            const i6 = [], s4 = [];
            for (const a4 in r8) r8[a4].id && i6.includes(r8[a4].id) && e6.push(new Mt(n6, r8, `all the sprites' ids must be unique, but ${r8[a4].id} is duplicated`)), i6.push(r8[a4].id), r8[a4].url && s4.includes(r8[a4].url) && e6.push(new Mt(n6, r8, `all the sprites' URLs must be unique, but ${r8[a4].url} is duplicated`)), s4.push(r8[a4].url), e6 = e6.concat(pi({ key: `${n6}[${a4}]`, value: r8[a4], valueSpec: { id: { type: "string", required: true }, url: { type: "string", required: true } }, validateSpec: t5.validateSpec }));
            return e6;
          }
          return Ai({ key: n6, value: r8 });
        }
        const Bi = { "*": () => [], array: fi, boolean: function(t5) {
          const e6 = t5.value, r8 = t5.key, n6 = Tn(e6);
          return "boolean" !== n6 ? [new Mt(r8, e6, `boolean expected, ${n6} found`)] : [];
        }, number: di, color: function(t5) {
          const e6 = t5.key, r8 = t5.value, n6 = Tn(r8);
          return "string" !== n6 ? [new Mt(e6, r8, `color expected, ${n6} found`)] : xe.parse(String(r8)) ? [] : [new Mt(e6, r8, `color expected, "${r8}" found`)];
        }, constants: ui, enum: gi, filter: xi, function: yi, layer: Si, object: pi, source: Mi, light: Ii, sky: zi, terrain: Pi, projection: function(t5) {
          const e6 = t5.value, r8 = t5.styleSpec, n6 = r8.projection, i6 = t5.style, s4 = Tn(e6);
          if (void 0 === e6) return [];
          if ("object" !== s4) return [new Mt("projection", e6, `object expected, ${s4} found`)];
          let a4 = [];
          for (const s5 in e6) a4 = a4.concat(n6[s5] ? t5.validateSpec({ key: s5, value: e6[s5], valueSpec: n6[s5], style: i6, styleSpec: r8 }) : [new Mt(s5, e6[s5], `unknown property "${s5}"`)]);
          return a4;
        }, projectionDefinition: function(t5) {
          const e6 = t5.key;
          let r8 = t5.value;
          r8 = r8 instanceof String ? r8.valueOf() : r8;
          const n6 = Tn(r8);
          return "array" !== n6 || function(t6) {
            return Array.isArray(t6) && 3 === t6.length && "string" == typeof t6[0] && "string" == typeof t6[1] && "number" == typeof t6[2];
          }(r8) || function(t6) {
            return !!["interpolate", "step", "literal"].includes(t6[0]);
          }(r8) ? ["array", "string"].includes(n6) ? [] : [new Mt(e6, r8, `projection expected, invalid type "${n6}" found`)] : [new Mt(e6, r8, `projection expected, invalid array ${JSON.stringify(r8)} found`)];
        }, string: Ai, formatted: function(t5) {
          return 0 === Ai(t5).length ? [] : mi(t5);
        }, resolvedImage: function(t5) {
          return 0 === Ai(t5).length ? [] : mi(t5);
        }, padding: function(t5) {
          const e6 = t5.key, r8 = t5.value;
          if ("array" === Tn(r8)) {
            if (r8.length < 1 || r8.length > 4) return [new Mt(e6, r8, `padding requires 1 to 4 values; ${r8.length} values found`)];
            const n6 = { type: "number" };
            let i6 = [];
            for (let s4 = 0; s4 < r8.length; s4++) i6 = i6.concat(t5.validateSpec({ key: `${e6}[${s4}]`, value: r8[s4], validateSpec: t5.validateSpec, valueSpec: n6 }));
            return i6;
          }
          return di({ key: e6, value: r8, valueSpec: {} });
        }, variableAnchorOffsetCollection: function(t5) {
          const e6 = t5.key, r8 = t5.value, n6 = Tn(r8), i6 = t5.styleSpec;
          if ("array" !== n6 || r8.length < 1 || r8.length % 2 != 0) return [new Mt(e6, r8, "variableAnchorOffsetCollection requires a non-empty array of even length")];
          let s4 = [];
          for (let n7 = 0; n7 < r8.length; n7 += 2) s4 = s4.concat(gi({ key: `${e6}[${n7}]`, value: r8[n7], valueSpec: i6.layout_symbol["text-anchor"] })), s4 = s4.concat(fi({ key: `${e6}[${n7 + 1}]`, value: r8[n7 + 1], valueSpec: { length: 2, value: "number" }, validateSpec: t5.validateSpec, style: t5.style, styleSpec: i6 }));
          return s4;
        }, sprite: Ci };
        function Vi(t5) {
          const e6 = t5.value, r8 = t5.valueSpec, n6 = t5.styleSpec;
          return t5.validateSpec = Vi, r8.expression && Fn(ci(e6)) ? yi(t5) : r8.expression && qn(hi(e6)) ? mi(t5) : r8.type && Bi[r8.type] ? Bi[r8.type](t5) : pi(It({}, t5, { valueSpec: r8.type ? n6[r8.type] : r8 }));
        }
        function Ei(t5) {
          const e6 = t5.value, r8 = t5.key, n6 = Ai(t5);
          return n6.length || (-1 === e6.indexOf("{fontstack}") && n6.push(new Mt(r8, e6, '"glyphs" url must include a "{fontstack}" token')), -1 === e6.indexOf("{range}") && n6.push(new Mt(r8, e6, '"glyphs" url must include a "{range}" token'))), n6;
        }
        function Ti(t5, e6 = dt) {
          let r8 = [];
          return r8 = r8.concat(Vi({ key: "", value: t5, valueSpec: e6.$root, styleSpec: e6, style: t5, validateSpec: Vi, objectElementValidators: { glyphs: Ei, "*": () => [] } })), t5.constants && (r8 = r8.concat(ui({ key: "constants", value: t5.constants }))), $i(r8);
        }
        function Fi(t5) {
          return function(e6) {
            return t5({ ...e6, validateSpec: Vi });
          };
        }
        function $i(t5) {
          return [].concat(t5).sort((t6, e6) => t6.line - e6.line);
        }
        function Li(t5) {
          return function(...e6) {
            return $i(t5.apply(this, e6));
          };
        }
        Ti.source = Li(Fi(Mi)), Ti.sprite = Li(Fi(Ci)), Ti.glyphs = Li(Fi(Ei)), Ti.light = Li(Fi(Ii)), Ti.sky = Li(Fi(zi)), Ti.terrain = Li(Fi(Pi)), Ti.layer = Li(Fi(Si)), Ti.filter = Li(Fi(xi)), Ti.paintProperty = Li(Fi(wi)), Ti.layoutProperty = Li(Fi(_i));
        const Oi = Ti, Di = Oi.light, Ri = Oi.sky, ji = Oi.paintProperty, Ni = Oi.layoutProperty;
        function Ui(t5, e6) {
          let r8 = false;
          if (e6 && e6.length) for (const n6 of e6) t5.fire(new pt(new Error(n6.message))), r8 = true;
          return r8;
        }
        class qi {
          constructor(t5, e6, r8) {
            const n6 = this.cells = [];
            if (t5 instanceof ArrayBuffer) {
              this.arrayBuffer = t5;
              const i7 = new Int32Array(this.arrayBuffer);
              t5 = i7[0], this.d = (e6 = i7[1]) + 2 * (r8 = i7[2]);
              for (let t6 = 0; t6 < this.d * this.d; t6++) {
                const e7 = i7[3 + t6], r9 = i7[3 + t6 + 1];
                n6.push(e7 === r9 ? null : i7.subarray(e7, r9));
              }
              const s4 = i7[3 + n6.length + 1];
              this.keys = i7.subarray(i7[3 + n6.length], s4), this.bboxes = i7.subarray(s4), this.insert = this._insertReadonly;
            } else {
              this.d = e6 + 2 * r8;
              for (let t6 = 0; t6 < this.d * this.d; t6++) n6.push([]);
              this.keys = [], this.bboxes = [];
            }
            this.n = e6, this.extent = t5, this.padding = r8, this.scale = e6 / t5, this.uid = 0;
            const i6 = r8 / e6 * t5;
            this.min = -i6, this.max = t5 + i6;
          }
          insert(t5, e6, r8, n6, i6) {
            this._forEachCell(e6, r8, n6, i6, this._insertCell, this.uid++, void 0, void 0), this.keys.push(t5), this.bboxes.push(e6), this.bboxes.push(r8), this.bboxes.push(n6), this.bboxes.push(i6);
          }
          _insertReadonly() {
            throw new Error("Cannot insert into a GridIndex created from an ArrayBuffer.");
          }
          _insertCell(t5, e6, r8, n6, i6, s4) {
            this.cells[i6].push(s4);
          }
          query(t5, e6, r8, n6, i6) {
            const s4 = this.min, a4 = this.max;
            if (t5 <= s4 && e6 <= s4 && a4 <= r8 && a4 <= n6 && !i6) return Array.prototype.slice.call(this.keys);
            {
              const s5 = [];
              return this._forEachCell(t5, e6, r8, n6, this._queryCell, s5, {}, i6), s5;
            }
          }
          _queryCell(t5, e6, r8, n6, i6, s4, a4, o6) {
            const l5 = this.cells[i6];
            if (null !== l5) {
              const i7 = this.keys, u4 = this.bboxes;
              for (let c5 = 0; c5 < l5.length; c5++) {
                const h4 = l5[c5];
                if (void 0 === a4[h4]) {
                  const l6 = 4 * h4;
                  (o6 ? o6(u4[l6 + 0], u4[l6 + 1], u4[l6 + 2], u4[l6 + 3]) : t5 <= u4[l6 + 2] && e6 <= u4[l6 + 3] && r8 >= u4[l6 + 0] && n6 >= u4[l6 + 1]) ? (a4[h4] = true, s4.push(i7[h4])) : a4[h4] = false;
                }
              }
            }
          }
          _forEachCell(t5, e6, r8, n6, i6, s4, a4, o6) {
            const l5 = this._convertToCellCoord(t5), u4 = this._convertToCellCoord(e6), c5 = this._convertToCellCoord(r8), h4 = this._convertToCellCoord(n6);
            for (let p4 = l5; p4 <= c5; p4++) for (let l6 = u4; l6 <= h4; l6++) {
              const u5 = this.d * l6 + p4;
              if ((!o6 || o6(this._convertFromCellCoord(p4), this._convertFromCellCoord(l6), this._convertFromCellCoord(p4 + 1), this._convertFromCellCoord(l6 + 1))) && i6.call(this, t5, e6, r8, n6, u5, s4, a4, o6)) return;
            }
          }
          _convertFromCellCoord(t5) {
            return (t5 - this.padding) / this.scale;
          }
          _convertToCellCoord(t5) {
            return Math.max(0, Math.min(this.d - 1, Math.floor(t5 * this.scale) + this.padding));
          }
          toArrayBuffer() {
            if (this.arrayBuffer) return this.arrayBuffer;
            const t5 = this.cells, e6 = 3 + this.cells.length + 1 + 1;
            let r8 = 0;
            for (let t6 = 0; t6 < this.cells.length; t6++) r8 += this.cells[t6].length;
            const n6 = new Int32Array(e6 + r8 + this.keys.length + this.bboxes.length);
            n6[0] = this.extent, n6[1] = this.n, n6[2] = this.padding;
            let i6 = e6;
            for (let e7 = 0; e7 < t5.length; e7++) {
              const r9 = t5[e7];
              n6[3 + e7] = i6, n6.set(r9, i6), i6 += r9.length;
            }
            return n6[3 + t5.length] = i6, n6.set(this.keys, i6), i6 += this.keys.length, n6[3 + t5.length + 1] = i6, n6.set(this.bboxes, i6), i6 += this.bboxes.length, n6.buffer;
          }
          static serialize(t5, e6) {
            const r8 = t5.toArrayBuffer();
            return e6 && e6.push(r8), { buffer: r8 };
          }
          static deserialize(t5) {
            return new qi(t5.buffer);
          }
        }
        const Gi = {};
        function Zi(t5, e6, r8 = {}) {
          if (Gi[t5]) throw new Error(`${t5} is already registered.`);
          Object.defineProperty(e6, "_classRegistryKey", { value: t5, writeable: false }), Gi[t5] = { klass: e6, omit: r8.omit || [], shallow: r8.shallow || [] };
        }
        Zi("Object", Object), Zi("TransferableGridIndex", qi), Zi("Color", xe), Zi("Error", Error), Zi("AJAXError", st), Zi("ResolvedImage", Ie), Zi("StylePropertyFunction", Hn), Zi("StyleExpression", Un, { omit: ["_evaluator"] }), Zi("ZoomDependentExpression", Kn), Zi("ZoomConstantExpression", Zn), Zi("CompoundExpression", bn, { omit: ["_evaluate"] });
        for (const t5 in vn) vn[t5]._classRegistryKey || Zi(`Expression_${t5}`, vn[t5]);
        function Ki(t5) {
          return t5 && "undefined" != typeof ArrayBuffer && (t5 instanceof ArrayBuffer || t5.constructor && "ArrayBuffer" === t5.constructor.name);
        }
        function Xi(t5) {
          return t5.$name || t5.constructor._classRegistryKey;
        }
        function Hi(t5) {
          return !function(t6) {
            if (null === t6 || "object" != typeof t6) return false;
            const e6 = Xi(t6);
            return !(!e6 || "Object" === e6);
          }(t5) && (null == t5 || "boolean" == typeof t5 || "number" == typeof t5 || "string" == typeof t5 || t5 instanceof Boolean || t5 instanceof Number || t5 instanceof String || t5 instanceof Date || t5 instanceof RegExp || t5 instanceof Blob || t5 instanceof Error || Ki(t5) || G2(t5) || ArrayBuffer.isView(t5) || t5 instanceof ImageData);
        }
        function Yi(t5, e6) {
          if (Hi(t5)) return (Ki(t5) || G2(t5)) && e6 && e6.push(t5), ArrayBuffer.isView(t5) && e6 && e6.push(t5.buffer), t5 instanceof ImageData && e6 && e6.push(t5.data.buffer), t5;
          if (Array.isArray(t5)) {
            const r9 = [];
            for (const n7 of t5) r9.push(Yi(n7, e6));
            return r9;
          }
          if ("object" != typeof t5) throw new Error("can't serialize object of type " + typeof t5);
          const r8 = Xi(t5);
          if (!r8) throw new Error(`can't serialize object of unregistered class ${t5.constructor.name}`);
          if (!Gi[r8]) throw new Error(`${r8} is not registered.`);
          const { klass: n6 } = Gi[r8], i6 = n6.serialize ? n6.serialize(t5, e6) : {};
          if (n6.serialize) {
            if (e6 && i6 === e6[e6.length - 1]) throw new Error("statically serialized object won't survive transfer of $name property");
          } else {
            for (const n7 in t5) {
              if (!t5.hasOwnProperty(n7)) continue;
              if (Gi[r8].omit.indexOf(n7) >= 0) continue;
              const s4 = t5[n7];
              i6[n7] = Gi[r8].shallow.indexOf(n7) >= 0 ? s4 : Yi(s4, e6);
            }
            t5 instanceof Error && (i6.message = t5.message);
          }
          if (i6.$name) throw new Error("$name property is reserved for worker serialization logic.");
          return "Object" !== r8 && (i6.$name = r8), i6;
        }
        function Ji(t5) {
          if (Hi(t5)) return t5;
          if (Array.isArray(t5)) return t5.map(Ji);
          if ("object" != typeof t5) throw new Error("can't deserialize object of type " + typeof t5);
          const e6 = Xi(t5) || "Object";
          if (!Gi[e6]) throw new Error(`can't deserialize unregistered class ${e6}`);
          const { klass: r8 } = Gi[e6];
          if (!r8) throw new Error(`can't deserialize unregistered class ${e6}`);
          if (r8.deserialize) return r8.deserialize(t5);
          const n6 = Object.create(r8.prototype);
          for (const r9 of Object.keys(t5)) {
            if ("$name" === r9) continue;
            const i6 = t5[r9];
            n6[r9] = Gi[e6].shallow.indexOf(r9) >= 0 ? i6 : Ji(i6);
          }
          return n6;
        }
        class Wi {
          constructor() {
            this.first = true;
          }
          update(t5, e6) {
            const r8 = Math.floor(t5);
            return this.first ? (this.first = false, this.lastIntegerZoom = r8, this.lastIntegerZoomTime = 0, this.lastZoom = t5, this.lastFloorZoom = r8, true) : (this.lastFloorZoom > r8 ? (this.lastIntegerZoom = r8 + 1, this.lastIntegerZoomTime = e6) : this.lastFloorZoom < r8 && (this.lastIntegerZoom = r8, this.lastIntegerZoomTime = e6), t5 !== this.lastZoom && (this.lastZoom = t5, this.lastFloorZoom = r8, true));
          }
        }
        const Qi = { "Latin-1 Supplement": (t5) => t5 >= 128 && t5 <= 255, "Hangul Jamo": (t5) => t5 >= 4352 && t5 <= 4607, Khmer: (t5) => t5 >= 6016 && t5 <= 6143, "General Punctuation": (t5) => t5 >= 8192 && t5 <= 8303, "Letterlike Symbols": (t5) => t5 >= 8448 && t5 <= 8527, "Number Forms": (t5) => t5 >= 8528 && t5 <= 8591, "Miscellaneous Technical": (t5) => t5 >= 8960 && t5 <= 9215, "Control Pictures": (t5) => t5 >= 9216 && t5 <= 9279, "Optical Character Recognition": (t5) => t5 >= 9280 && t5 <= 9311, "Enclosed Alphanumerics": (t5) => t5 >= 9312 && t5 <= 9471, "Geometric Shapes": (t5) => t5 >= 9632 && t5 <= 9727, "Miscellaneous Symbols": (t5) => t5 >= 9728 && t5 <= 9983, "Miscellaneous Symbols and Arrows": (t5) => t5 >= 11008 && t5 <= 11263, "Ideographic Description Characters": (t5) => t5 >= 12272 && t5 <= 12287, "CJK Symbols and Punctuation": (t5) => t5 >= 12288 && t5 <= 12351, Hiragana: (t5) => t5 >= 12352 && t5 <= 12447, Katakana: (t5) => t5 >= 12448 && t5 <= 12543, Kanbun: (t5) => t5 >= 12688 && t5 <= 12703, "CJK Strokes": (t5) => t5 >= 12736 && t5 <= 12783, "Enclosed CJK Letters and Months": (t5) => t5 >= 12800 && t5 <= 13055, "CJK Compatibility": (t5) => t5 >= 13056 && t5 <= 13311, "Yijing Hexagram Symbols": (t5) => t5 >= 19904 && t5 <= 19967, "CJK Unified Ideographs": (t5) => t5 >= 19968 && t5 <= 40959, "Hangul Syllables": (t5) => t5 >= 44032 && t5 <= 55215, "Private Use Area": (t5) => t5 >= 57344 && t5 <= 63743, "Vertical Forms": (t5) => t5 >= 65040 && t5 <= 65055, "CJK Compatibility Forms": (t5) => t5 >= 65072 && t5 <= 65103, "Small Form Variants": (t5) => t5 >= 65104 && t5 <= 65135, "Halfwidth and Fullwidth Forms": (t5) => t5 >= 65280 && t5 <= 65519 };
        function ts(t5) {
          for (const e6 of t5) if (as(e6.charCodeAt(0))) return true;
          return false;
        }
        function es(t5) {
          for (const e6 of t5) if (!is(e6.charCodeAt(0))) return false;
          return true;
        }
        function rs(t5) {
          const e6 = t5.map((t6) => {
            try {
              return new RegExp(`\\p{sc=${t6}}`, "u").source;
            } catch (t7) {
              return null;
            }
          }).filter((t6) => t6);
          return new RegExp(e6.join("|"), "u");
        }
        const ns = rs(["Arab", "Dupl", "Mong", "Ougr", "Syrc"]);
        function is(t5) {
          return !ns.test(String.fromCodePoint(t5));
        }
        const ss = rs(["Bopo", "Hani", "Hira", "Kana", "Kits", "Nshu", "Tang", "Yiii"]);
        function as(t5) {
          return !(746 !== t5 && 747 !== t5 && (t5 < 4352 || !(Qi["CJK Compatibility Forms"](t5) && !(t5 >= 65097 && t5 <= 65103) || Qi["CJK Compatibility"](t5) || Qi["CJK Strokes"](t5) || !(!Qi["CJK Symbols and Punctuation"](t5) || t5 >= 12296 && t5 <= 12305 || t5 >= 12308 && t5 <= 12319 || 12336 === t5) || Qi["Enclosed CJK Letters and Months"](t5) || Qi["Ideographic Description Characters"](t5) || Qi.Kanbun(t5) || Qi.Katakana(t5) && 12540 !== t5 || !(!Qi["Halfwidth and Fullwidth Forms"](t5) || 65288 === t5 || 65289 === t5 || 65293 === t5 || t5 >= 65306 && t5 <= 65310 || 65339 === t5 || 65341 === t5 || 65343 === t5 || t5 >= 65371 && t5 <= 65503 || 65507 === t5 || t5 >= 65512 && t5 <= 65519) || !(!Qi["Small Form Variants"](t5) || t5 >= 65112 && t5 <= 65118 || t5 >= 65123 && t5 <= 65126) || Qi["Vertical Forms"](t5) || Qi["Yijing Hexagram Symbols"](t5) || /\p{sc=Cans}/u.test(String.fromCodePoint(t5)) || /\p{sc=Hang}/u.test(String.fromCodePoint(t5)) || ss.test(String.fromCodePoint(t5)))));
        }
        function os(t5) {
          return !(as(t5) || function(t6) {
            return !!(Qi["Latin-1 Supplement"](t6) && (167 === t6 || 169 === t6 || 174 === t6 || 177 === t6 || 188 === t6 || 189 === t6 || 190 === t6 || 215 === t6 || 247 === t6) || Qi["General Punctuation"](t6) && (8214 === t6 || 8224 === t6 || 8225 === t6 || 8240 === t6 || 8241 === t6 || 8251 === t6 || 8252 === t6 || 8258 === t6 || 8263 === t6 || 8264 === t6 || 8265 === t6 || 8273 === t6) || Qi["Letterlike Symbols"](t6) || Qi["Number Forms"](t6) || Qi["Miscellaneous Technical"](t6) && (t6 >= 8960 && t6 <= 8967 || t6 >= 8972 && t6 <= 8991 || t6 >= 8996 && t6 <= 9e3 || 9003 === t6 || t6 >= 9085 && t6 <= 9114 || t6 >= 9150 && t6 <= 9165 || 9167 === t6 || t6 >= 9169 && t6 <= 9179 || t6 >= 9186 && t6 <= 9215) || Qi["Control Pictures"](t6) && 9251 !== t6 || Qi["Optical Character Recognition"](t6) || Qi["Enclosed Alphanumerics"](t6) || Qi["Geometric Shapes"](t6) || Qi["Miscellaneous Symbols"](t6) && !(t6 >= 9754 && t6 <= 9759) || Qi["Miscellaneous Symbols and Arrows"](t6) && (t6 >= 11026 && t6 <= 11055 || t6 >= 11088 && t6 <= 11097 || t6 >= 11192 && t6 <= 11243) || Qi["CJK Symbols and Punctuation"](t6) || Qi.Katakana(t6) || Qi["Private Use Area"](t6) || Qi["CJK Compatibility Forms"](t6) || Qi["Small Form Variants"](t6) || Qi["Halfwidth and Fullwidth Forms"](t6) || 8734 === t6 || 8756 === t6 || 8757 === t6 || t6 >= 9984 && t6 <= 10087 || t6 >= 10102 && t6 <= 10131 || 65532 === t6 || 65533 === t6);
          }(t5));
        }
        const ls = rs(["Adlm", "Arab", "Armi", "Avst", "Chrs", "Cprt", "Egyp", "Elym", "Gara", "Hatr", "Hebr", "Hung", "Khar", "Lydi", "Mand", "Mani", "Mend", "Merc", "Mero", "Narb", "Nbat", "Nkoo", "Orkh", "Palm", "Phli", "Phlp", "Phnx", "Prti", "Rohg", "Samr", "Sarb", "Sogo", "Syrc", "Thaa", "Todr", "Yezi"]);
        function us(t5) {
          return ls.test(String.fromCodePoint(t5));
        }
        function cs(t5, e6) {
          return !(!e6 && us(t5) || t5 >= 2304 && t5 <= 3583 || t5 >= 3840 && t5 <= 4255 || Qi.Khmer(t5));
        }
        function hs(t5) {
          for (const e6 of t5) if (us(e6.charCodeAt(0))) return true;
          return false;
        }
        const ps = new class {
          constructor() {
            this.TIMEOUT = 5e3, this.applyArabicShaping = null, this.processBidirectionalText = null, this.processStyledBidirectionalText = null, this.pluginStatus = "unavailable", this.pluginURL = null, this.loadScriptResolve = () => {
            };
          }
          setState(t5) {
            this.pluginStatus = t5.pluginStatus, this.pluginURL = t5.pluginURL;
          }
          getState() {
            return { pluginStatus: this.pluginStatus, pluginURL: this.pluginURL };
          }
          setMethods(t5) {
            if (ps.isParsed()) throw new Error("RTL text plugin already registered.");
            this.applyArabicShaping = t5.applyArabicShaping, this.processBidirectionalText = t5.processBidirectionalText, this.processStyledBidirectionalText = t5.processStyledBidirectionalText, this.loadScriptResolve();
          }
          isParsed() {
            return null != this.applyArabicShaping && null != this.processBidirectionalText && null != this.processStyledBidirectionalText;
          }
          getRTLTextPluginStatus() {
            return this.pluginStatus;
          }
          syncState(t5, r8) {
            return e5(this, void 0, void 0, function* () {
              if (this.isParsed()) return this.getState();
              if ("loading" !== t5.pluginStatus) return this.setState(t5), t5;
              const e6 = t5.pluginURL, n6 = new Promise((t6) => {
                this.loadScriptResolve = t6;
              });
              r8(e6);
              const i6 = new Promise((t6) => setTimeout(() => t6(), this.TIMEOUT));
              if (yield Promise.race([n6, i6]), this.isParsed()) {
                const t6 = { pluginStatus: "loaded", pluginURL: e6 };
                return this.setState(t6), t6;
              }
              throw this.setState({ pluginStatus: "error", pluginURL: "" }), new Error(`RTL Text Plugin failed to import scripts from ${e6}`);
            });
          }
        }();
        class fs {
          constructor(t5, e6) {
            this.zoom = t5, e6 ? (this.now = e6.now, this.fadeDuration = e6.fadeDuration, this.zoomHistory = e6.zoomHistory, this.transition = e6.transition) : (this.now = 0, this.fadeDuration = 0, this.zoomHistory = new Wi(), this.transition = {});
          }
          isSupportedScript(t5) {
            return function(t6, e6) {
              for (const r8 of t6) if (!cs(r8.charCodeAt(0), e6)) return false;
              return true;
            }(t5, "loaded" === ps.getRTLTextPluginStatus());
          }
          crossFadingFactor() {
            return 0 === this.fadeDuration ? 1 : Math.min((this.now - this.zoomHistory.lastIntegerZoomTime) / this.fadeDuration, 1);
          }
          getCrossfadeParameters() {
            const t5 = this.zoom, e6 = t5 - Math.floor(t5), r8 = this.crossFadingFactor();
            return t5 > this.zoomHistory.lastIntegerZoom ? { fromScale: 2, toScale: 1, t: e6 + (1 - e6) * r8 } : { fromScale: 0.5, toScale: 1, t: 1 - (1 - r8) * e6 };
          }
        }
        class ds {
          constructor(t5, e6) {
            this.property = t5, this.value = e6, this.expression = function(t6, e7) {
              if (Fn(t6)) return new Hn(t6, e7);
              if (qn(t6)) {
                const r8 = Xn(t6, e7);
                if ("error" === r8.result) throw new Error(r8.value.map((t7) => `${t7.key}: ${t7.message}`).join(", "));
                return r8.value;
              }
              {
                let r8 = t6;
                return "color" === e7.type && "string" == typeof t6 ? r8 = xe.parse(t6) : "padding" !== e7.type || "number" != typeof t6 && !Array.isArray(t6) ? "variableAnchorOffsetCollection" === e7.type && Array.isArray(t6) ? r8 = Me.parse(t6) : "projectionDefinition" === e7.type && "string" == typeof t6 && (r8 = ze.parse(t6)) : r8 = Se.parse(t6), { kind: "constant", evaluate: () => r8 };
              }
            }(void 0 === e6 ? t5.specification.default : e6, t5.specification);
          }
          isDataDriven() {
            return "source" === this.expression.kind || "composite" === this.expression.kind;
          }
          possiblyEvaluate(t5, e6, r8) {
            return this.property.possiblyEvaluate(this, t5, e6, r8);
          }
        }
        class ys {
          constructor(t5) {
            this.property = t5, this.value = new ds(t5, void 0);
          }
          transitioned(t5, e6) {
            return new gs(this.property, this.value, e6, F2({}, t5.transition, this.transition), t5.now);
          }
          untransitioned() {
            return new gs(this.property, this.value, null, {}, 0);
          }
        }
        class ms {
          constructor(t5) {
            this._properties = t5, this._values = Object.create(t5.defaultTransitionablePropertyValues);
          }
          getValue(t5) {
            return D2(this._values[t5].value.value);
          }
          setValue(t5, e6) {
            Object.prototype.hasOwnProperty.call(this._values, t5) || (this._values[t5] = new ys(this._values[t5].property)), this._values[t5].value = new ds(this._values[t5].property, null === e6 ? void 0 : D2(e6));
          }
          getTransition(t5) {
            return D2(this._values[t5].transition);
          }
          setTransition(t5, e6) {
            Object.prototype.hasOwnProperty.call(this._values, t5) || (this._values[t5] = new ys(this._values[t5].property)), this._values[t5].transition = D2(e6) || void 0;
          }
          serialize() {
            const t5 = {};
            for (const e6 of Object.keys(this._values)) {
              const r8 = this.getValue(e6);
              void 0 !== r8 && (t5[e6] = r8);
              const n6 = this.getTransition(e6);
              void 0 !== n6 && (t5[`${e6}-transition`] = n6);
            }
            return t5;
          }
          transitioned(t5, e6) {
            const r8 = new xs(this._properties);
            for (const n6 of Object.keys(this._values)) r8._values[n6] = this._values[n6].transitioned(t5, e6._values[n6]);
            return r8;
          }
          untransitioned() {
            const t5 = new xs(this._properties);
            for (const e6 of Object.keys(this._values)) t5._values[e6] = this._values[e6].untransitioned();
            return t5;
          }
        }
        class gs {
          constructor(t5, e6, r8, n6, i6) {
            this.property = t5, this.value = e6, this.begin = i6 + n6.delay || 0, this.end = this.begin + n6.duration || 0, t5.specification.transition && (n6.delay || n6.duration) && (this.prior = r8);
          }
          possiblyEvaluate(t5, e6, r8) {
            const n6 = t5.now || 0, i6 = this.value.possiblyEvaluate(t5, e6, r8), s4 = this.prior;
            if (s4) {
              if (n6 > this.end) return this.prior = null, i6;
              if (this.value.isDataDriven()) return this.prior = null, i6;
              if (n6 < this.begin) return s4.possiblyEvaluate(t5, e6, r8);
              {
                const a4 = (n6 - this.begin) / (this.end - this.begin);
                return this.property.interpolate(s4.possiblyEvaluate(t5, e6, r8), i6, C3(a4));
              }
            }
            return i6;
          }
        }
        class xs {
          constructor(t5) {
            this._properties = t5, this._values = Object.create(t5.defaultTransitioningPropertyValues);
          }
          possiblyEvaluate(t5, e6, r8) {
            const n6 = new ws(this._properties);
            for (const i6 of Object.keys(this._values)) n6._values[i6] = this._values[i6].possiblyEvaluate(t5, e6, r8);
            return n6;
          }
          hasTransition() {
            for (const t5 of Object.keys(this._values)) if (this._values[t5].prior) return true;
            return false;
          }
        }
        class vs {
          constructor(t5) {
            this._properties = t5, this._values = Object.create(t5.defaultPropertyValues);
          }
          hasValue(t5) {
            return void 0 !== this._values[t5].value;
          }
          getValue(t5) {
            return D2(this._values[t5].value);
          }
          setValue(t5, e6) {
            this._values[t5] = new ds(this._values[t5].property, null === e6 ? void 0 : D2(e6));
          }
          serialize() {
            const t5 = {};
            for (const e6 of Object.keys(this._values)) {
              const r8 = this.getValue(e6);
              void 0 !== r8 && (t5[e6] = r8);
            }
            return t5;
          }
          possiblyEvaluate(t5, e6, r8) {
            const n6 = new ws(this._properties);
            for (const i6 of Object.keys(this._values)) n6._values[i6] = this._values[i6].possiblyEvaluate(t5, e6, r8);
            return n6;
          }
        }
        class bs {
          constructor(t5, e6, r8) {
            this.property = t5, this.value = e6, this.parameters = r8;
          }
          isConstant() {
            return "constant" === this.value.kind;
          }
          constantOr(t5) {
            return "constant" === this.value.kind ? this.value.value : t5;
          }
          evaluate(t5, e6, r8, n6) {
            return this.property.evaluate(this.value, this.parameters, t5, e6, r8, n6);
          }
        }
        class ws {
          constructor(t5) {
            this._properties = t5, this._values = Object.create(t5.defaultPossiblyEvaluatedValues);
          }
          get(t5) {
            return this._values[t5];
          }
        }
        class _s {
          constructor(t5) {
            this.specification = t5;
          }
          possiblyEvaluate(t5, e6) {
            if (t5.isDataDriven()) throw new Error("Value should not be data driven");
            return t5.expression.evaluate(e6);
          }
          interpolate(t5, e6, r8) {
            const n6 = ir[this.specification.type];
            return n6 ? n6(t5, e6, r8) : t5;
          }
        }
        class Ss {
          constructor(t5, e6) {
            this.specification = t5, this.overrides = e6;
          }
          possiblyEvaluate(t5, e6, r8, n6) {
            return new bs(this, "constant" === t5.expression.kind || "camera" === t5.expression.kind ? { kind: "constant", value: t5.expression.evaluate(e6, null, {}, r8, n6) } : t5.expression, e6);
          }
          interpolate(t5, e6, r8) {
            if ("constant" !== t5.value.kind || "constant" !== e6.value.kind) return t5;
            if (void 0 === t5.value.value || void 0 === e6.value.value) return new bs(this, { kind: "constant", value: void 0 }, t5.parameters);
            const n6 = ir[this.specification.type];
            if (n6) {
              const i6 = n6(t5.value.value, e6.value.value, r8);
              return new bs(this, { kind: "constant", value: i6 }, t5.parameters);
            }
            return t5;
          }
          evaluate(t5, e6, r8, n6, i6, s4) {
            return "constant" === t5.kind ? t5.value : t5.evaluate(e6, r8, n6, i6, s4);
          }
        }
        class As extends Ss {
          possiblyEvaluate(t5, e6, r8, n6) {
            if (void 0 === t5.value) return new bs(this, { kind: "constant", value: void 0 }, e6);
            if ("constant" === t5.expression.kind) {
              const i6 = t5.expression.evaluate(e6, null, {}, r8, n6), s4 = "resolvedImage" === t5.property.specification.type && "string" != typeof i6 ? i6.name : i6, a4 = this._calculate(s4, s4, s4, e6);
              return new bs(this, { kind: "constant", value: a4 }, e6);
            }
            if ("camera" === t5.expression.kind) {
              const r9 = this._calculate(t5.expression.evaluate({ zoom: e6.zoom - 1 }), t5.expression.evaluate({ zoom: e6.zoom }), t5.expression.evaluate({ zoom: e6.zoom + 1 }), e6);
              return new bs(this, { kind: "constant", value: r9 }, e6);
            }
            return new bs(this, t5.expression, e6);
          }
          evaluate(t5, e6, r8, n6, i6, s4) {
            if ("source" === t5.kind) {
              const a4 = t5.evaluate(e6, r8, n6, i6, s4);
              return this._calculate(a4, a4, a4, e6);
            }
            return "composite" === t5.kind ? this._calculate(t5.evaluate({ zoom: Math.floor(e6.zoom) - 1 }, r8, n6), t5.evaluate({ zoom: Math.floor(e6.zoom) }, r8, n6), t5.evaluate({ zoom: Math.floor(e6.zoom) + 1 }, r8, n6), e6) : t5.value;
          }
          _calculate(t5, e6, r8, n6) {
            return n6.zoom > n6.zoomHistory.lastIntegerZoom ? { from: t5, to: e6 } : { from: r8, to: e6 };
          }
          interpolate(t5) {
            return t5;
          }
        }
        class ks {
          constructor(t5) {
            this.specification = t5;
          }
          possiblyEvaluate(t5, e6, r8, n6) {
            if (void 0 !== t5.value) {
              if ("constant" === t5.expression.kind) {
                const i6 = t5.expression.evaluate(e6, null, {}, r8, n6);
                return this._calculate(i6, i6, i6, e6);
              }
              return this._calculate(t5.expression.evaluate(new fs(Math.floor(e6.zoom - 1), e6)), t5.expression.evaluate(new fs(Math.floor(e6.zoom), e6)), t5.expression.evaluate(new fs(Math.floor(e6.zoom + 1), e6)), e6);
            }
          }
          _calculate(t5, e6, r8, n6) {
            return n6.zoom > n6.zoomHistory.lastIntegerZoom ? { from: t5, to: e6 } : { from: r8, to: e6 };
          }
          interpolate(t5) {
            return t5;
          }
        }
        class Ms {
          constructor(t5) {
            this.specification = t5;
          }
          possiblyEvaluate(t5, e6, r8, n6) {
            return !!t5.expression.evaluate(e6, null, {}, r8, n6);
          }
          interpolate() {
            return false;
          }
        }
        class Is {
          constructor(t5) {
            this.properties = t5, this.defaultPropertyValues = {}, this.defaultTransitionablePropertyValues = {}, this.defaultTransitioningPropertyValues = {}, this.defaultPossiblyEvaluatedValues = {}, this.overridableProperties = [];
            for (const e6 in t5) {
              const r8 = t5[e6];
              r8.specification.overridable && this.overridableProperties.push(e6);
              const n6 = this.defaultPropertyValues[e6] = new ds(r8, void 0), i6 = this.defaultTransitionablePropertyValues[e6] = new ys(r8);
              this.defaultTransitioningPropertyValues[e6] = i6.untransitioned(), this.defaultPossiblyEvaluatedValues[e6] = n6.possiblyEvaluate({});
            }
          }
        }
        Zi("DataDrivenProperty", Ss), Zi("DataConstantProperty", _s), Zi("CrossFadedDataDrivenProperty", As), Zi("CrossFadedProperty", ks), Zi("ColorRampProperty", Ms);
        const zs = "-transition";
        class Ps extends ft {
          constructor(t5, e6) {
            if (super(), this.id = t5.id, this.type = t5.type, this._featureFilter = { filter: () => true, needGeometry: false }, "custom" !== t5.type && (this.metadata = t5.metadata, this.minzoom = t5.minzoom, this.maxzoom = t5.maxzoom, "background" !== t5.type && (this.source = t5.source, this.sourceLayer = t5["source-layer"], this.filter = t5.filter), e6.layout && (this._unevaluatedLayout = new vs(e6.layout)), e6.paint)) {
              this._transitionablePaint = new ms(e6.paint);
              for (const e7 in t5.paint) this.setPaintProperty(e7, t5.paint[e7], { validate: false });
              for (const e7 in t5.layout) this.setLayoutProperty(e7, t5.layout[e7], { validate: false });
              this._transitioningPaint = this._transitionablePaint.untransitioned(), this.paint = new ws(e6.paint);
            }
          }
          getCrossfadeParameters() {
            return this._crossfadeParameters;
          }
          getLayoutProperty(t5) {
            return "visibility" === t5 ? this.visibility : this._unevaluatedLayout.getValue(t5);
          }
          setLayoutProperty(t5, e6, r8 = {}) {
            null != e6 && this._validate(Ni, `layers.${this.id}.layout.${t5}`, t5, e6, r8) || ("visibility" !== t5 ? this._unevaluatedLayout.setValue(t5, e6) : this.visibility = e6);
          }
          getPaintProperty(t5) {
            return t5.endsWith(zs) ? this._transitionablePaint.getTransition(t5.slice(0, -11)) : this._transitionablePaint.getValue(t5);
          }
          setPaintProperty(t5, e6, r8 = {}) {
            if (null != e6 && this._validate(ji, `layers.${this.id}.paint.${t5}`, t5, e6, r8)) return false;
            if (t5.endsWith(zs)) return this._transitionablePaint.setTransition(t5.slice(0, -11), e6 || void 0), false;
            {
              const r9 = this._transitionablePaint._values[t5], n6 = "cross-faded-data-driven" === r9.property.specification["property-type"], i6 = r9.value.isDataDriven(), s4 = r9.value;
              this._transitionablePaint.setValue(t5, e6), this._handleSpecialPaintPropertyUpdate(t5);
              const a4 = this._transitionablePaint._values[t5].value;
              return a4.isDataDriven() || i6 || n6 || this._handleOverridablePaintPropertyUpdate(t5, s4, a4);
            }
          }
          _handleSpecialPaintPropertyUpdate(t5) {
          }
          _handleOverridablePaintPropertyUpdate(t5, e6, r8) {
            return false;
          }
          isHidden(t5) {
            return !!(this.minzoom && t5 < this.minzoom) || !!(this.maxzoom && t5 >= this.maxzoom) || "none" === this.visibility;
          }
          updateTransitions(t5) {
            this._transitioningPaint = this._transitionablePaint.transitioned(t5, this._transitioningPaint);
          }
          hasTransition() {
            return this._transitioningPaint.hasTransition();
          }
          recalculate(t5, e6) {
            t5.getCrossfadeParameters && (this._crossfadeParameters = t5.getCrossfadeParameters()), this._unevaluatedLayout && (this.layout = this._unevaluatedLayout.possiblyEvaluate(t5, void 0, e6)), this.paint = this._transitioningPaint.possiblyEvaluate(t5, void 0, e6);
          }
          serialize() {
            const t5 = { id: this.id, type: this.type, source: this.source, "source-layer": this.sourceLayer, metadata: this.metadata, minzoom: this.minzoom, maxzoom: this.maxzoom, filter: this.filter, layout: this._unevaluatedLayout && this._unevaluatedLayout.serialize(), paint: this._transitionablePaint && this._transitionablePaint.serialize() };
            return this.visibility && (t5.layout = t5.layout || {}, t5.layout.visibility = this.visibility), O2(t5, (t6, e6) => !(void 0 === t6 || "layout" === e6 && !Object.keys(t6).length || "paint" === e6 && !Object.keys(t6).length));
          }
          _validate(t5, e6, r8, n6, i6 = {}) {
            return (!i6 || false !== i6.validate) && Ui(this, t5.call(Oi, { key: e6, layerType: this.type, objectKey: r8, value: n6, styleSpec: dt, style: { glyphs: true, sprite: true } }));
          }
          is3D() {
            return false;
          }
          isTileClipped() {
            return false;
          }
          hasOffscreenPass() {
            return false;
          }
          resize() {
          }
          isStateDependent() {
            for (const t5 in this.paint._values) {
              const e6 = this.paint.get(t5);
              if (e6 instanceof bs && Bn(e6.property.specification) && ("source" === e6.value.kind || "composite" === e6.value.kind) && e6.value.isStateDependent) return true;
            }
            return false;
          }
        }
        const Cs = { Int8: Int8Array, Uint8: Uint8Array, Int16: Int16Array, Uint16: Uint16Array, Int32: Int32Array, Uint32: Uint32Array, Float32: Float32Array };
        class Bs {
          constructor(t5, e6) {
            this._structArray = t5, this._pos1 = e6 * this.size, this._pos2 = this._pos1 / 2, this._pos4 = this._pos1 / 4, this._pos8 = this._pos1 / 8;
          }
        }
        class Vs {
          constructor() {
            this.isTransferred = false, this.capacity = -1, this.resize(0);
          }
          static serialize(t5, e6) {
            return t5._trim(), e6 && (t5.isTransferred = true, e6.push(t5.arrayBuffer)), { length: t5.length, arrayBuffer: t5.arrayBuffer };
          }
          static deserialize(t5) {
            const e6 = Object.create(this.prototype);
            return e6.arrayBuffer = t5.arrayBuffer, e6.length = t5.length, e6.capacity = t5.arrayBuffer.byteLength / e6.bytesPerElement, e6._refreshViews(), e6;
          }
          _trim() {
            this.length !== this.capacity && (this.capacity = this.length, this.arrayBuffer = this.arrayBuffer.slice(0, this.length * this.bytesPerElement), this._refreshViews());
          }
          clear() {
            this.length = 0;
          }
          resize(t5) {
            this.reserve(t5), this.length = t5;
          }
          reserve(t5) {
            if (t5 > this.capacity) {
              this.capacity = Math.max(t5, Math.floor(5 * this.capacity), 128), this.arrayBuffer = new ArrayBuffer(this.capacity * this.bytesPerElement);
              const e6 = this.uint8;
              this._refreshViews(), e6 && this.uint8.set(e6);
            }
          }
          _refreshViews() {
            throw new Error("_refreshViews() must be implemented by each concrete StructArray layout");
          }
        }
        function Es(t5, e6 = 1) {
          let r8 = 0, n6 = 0;
          return { members: t5.map((t6) => {
            const i6 = Cs[t6.type].BYTES_PER_ELEMENT, s4 = r8 = Ts(r8, Math.max(e6, i6)), a4 = t6.components || 1;
            return n6 = Math.max(n6, i6), r8 += i6 * a4, { name: t6.name, type: t6.type, components: a4, offset: s4 };
          }), size: Ts(r8, Math.max(n6, e6)), alignment: e6 };
        }
        function Ts(t5, e6) {
          return Math.ceil(t5 / e6) * e6;
        }
        class Fs extends Vs {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
          }
          emplaceBack(t5, e6) {
            const r8 = this.length;
            return this.resize(r8 + 1), this.emplace(r8, t5, e6);
          }
          emplace(t5, e6, r8) {
            const n6 = 2 * t5;
            return this.int16[n6 + 0] = e6, this.int16[n6 + 1] = r8, t5;
          }
        }
        Fs.prototype.bytesPerElement = 4, Zi("StructArrayLayout2i4", Fs);
        class $s extends Vs {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
          }
          emplaceBack(t5, e6, r8) {
            const n6 = this.length;
            return this.resize(n6 + 1), this.emplace(n6, t5, e6, r8);
          }
          emplace(t5, e6, r8, n6) {
            const i6 = 3 * t5;
            return this.int16[i6 + 0] = e6, this.int16[i6 + 1] = r8, this.int16[i6 + 2] = n6, t5;
          }
        }
        $s.prototype.bytesPerElement = 6, Zi("StructArrayLayout3i6", $s);
        class Ls extends Vs {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
          }
          emplaceBack(t5, e6, r8, n6) {
            const i6 = this.length;
            return this.resize(i6 + 1), this.emplace(i6, t5, e6, r8, n6);
          }
          emplace(t5, e6, r8, n6, i6) {
            const s4 = 4 * t5;
            return this.int16[s4 + 0] = e6, this.int16[s4 + 1] = r8, this.int16[s4 + 2] = n6, this.int16[s4 + 3] = i6, t5;
          }
        }
        Ls.prototype.bytesPerElement = 8, Zi("StructArrayLayout4i8", Ls);
        class Os extends Vs {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
          }
          emplaceBack(t5, e6, r8, n6, i6, s4) {
            const a4 = this.length;
            return this.resize(a4 + 1), this.emplace(a4, t5, e6, r8, n6, i6, s4);
          }
          emplace(t5, e6, r8, n6, i6, s4, a4) {
            const o6 = 6 * t5;
            return this.int16[o6 + 0] = e6, this.int16[o6 + 1] = r8, this.int16[o6 + 2] = n6, this.int16[o6 + 3] = i6, this.int16[o6 + 4] = s4, this.int16[o6 + 5] = a4, t5;
          }
        }
        Os.prototype.bytesPerElement = 12, Zi("StructArrayLayout2i4i12", Os);
        class Ds extends Vs {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
          }
          emplaceBack(t5, e6, r8, n6, i6, s4) {
            const a4 = this.length;
            return this.resize(a4 + 1), this.emplace(a4, t5, e6, r8, n6, i6, s4);
          }
          emplace(t5, e6, r8, n6, i6, s4, a4) {
            const o6 = 4 * t5, l5 = 8 * t5;
            return this.int16[o6 + 0] = e6, this.int16[o6 + 1] = r8, this.uint8[l5 + 4] = n6, this.uint8[l5 + 5] = i6, this.uint8[l5 + 6] = s4, this.uint8[l5 + 7] = a4, t5;
          }
        }
        Ds.prototype.bytesPerElement = 8, Zi("StructArrayLayout2i4ub8", Ds);
        class Rs extends Vs {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }
          emplaceBack(t5, e6) {
            const r8 = this.length;
            return this.resize(r8 + 1), this.emplace(r8, t5, e6);
          }
          emplace(t5, e6, r8) {
            const n6 = 2 * t5;
            return this.float32[n6 + 0] = e6, this.float32[n6 + 1] = r8, t5;
          }
        }
        Rs.prototype.bytesPerElement = 8, Zi("StructArrayLayout2f8", Rs);
        class js extends Vs {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
          }
          emplaceBack(t5, e6, r8, n6, i6, s4, a4, o6, l5, u4) {
            const c5 = this.length;
            return this.resize(c5 + 1), this.emplace(c5, t5, e6, r8, n6, i6, s4, a4, o6, l5, u4);
          }
          emplace(t5, e6, r8, n6, i6, s4, a4, o6, l5, u4, c5) {
            const h4 = 10 * t5;
            return this.uint16[h4 + 0] = e6, this.uint16[h4 + 1] = r8, this.uint16[h4 + 2] = n6, this.uint16[h4 + 3] = i6, this.uint16[h4 + 4] = s4, this.uint16[h4 + 5] = a4, this.uint16[h4 + 6] = o6, this.uint16[h4 + 7] = l5, this.uint16[h4 + 8] = u4, this.uint16[h4 + 9] = c5, t5;
          }
        }
        js.prototype.bytesPerElement = 20, Zi("StructArrayLayout10ui20", js);
        class Ns extends Vs {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
          }
          emplaceBack(t5, e6, r8, n6, i6, s4, a4, o6, l5, u4, c5, h4) {
            const p4 = this.length;
            return this.resize(p4 + 1), this.emplace(p4, t5, e6, r8, n6, i6, s4, a4, o6, l5, u4, c5, h4);
          }
          emplace(t5, e6, r8, n6, i6, s4, a4, o6, l5, u4, c5, h4, p4) {
            const f4 = 12 * t5;
            return this.int16[f4 + 0] = e6, this.int16[f4 + 1] = r8, this.int16[f4 + 2] = n6, this.int16[f4 + 3] = i6, this.uint16[f4 + 4] = s4, this.uint16[f4 + 5] = a4, this.uint16[f4 + 6] = o6, this.uint16[f4 + 7] = l5, this.int16[f4 + 8] = u4, this.int16[f4 + 9] = c5, this.int16[f4 + 10] = h4, this.int16[f4 + 11] = p4, t5;
          }
        }
        Ns.prototype.bytesPerElement = 24, Zi("StructArrayLayout4i4ui4i24", Ns);
        class Us extends Vs {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }
          emplaceBack(t5, e6, r8) {
            const n6 = this.length;
            return this.resize(n6 + 1), this.emplace(n6, t5, e6, r8);
          }
          emplace(t5, e6, r8, n6) {
            const i6 = 3 * t5;
            return this.float32[i6 + 0] = e6, this.float32[i6 + 1] = r8, this.float32[i6 + 2] = n6, t5;
          }
        }
        Us.prototype.bytesPerElement = 12, Zi("StructArrayLayout3f12", Us);
        class qs extends Vs {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer);
          }
          emplaceBack(t5) {
            const e6 = this.length;
            return this.resize(e6 + 1), this.emplace(e6, t5);
          }
          emplace(t5, e6) {
            return this.uint32[1 * t5 + 0] = e6, t5;
          }
        }
        qs.prototype.bytesPerElement = 4, Zi("StructArrayLayout1ul4", qs);
        class Gs extends Vs {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
          }
          emplaceBack(t5, e6, r8, n6, i6, s4, a4, o6, l5) {
            const u4 = this.length;
            return this.resize(u4 + 1), this.emplace(u4, t5, e6, r8, n6, i6, s4, a4, o6, l5);
          }
          emplace(t5, e6, r8, n6, i6, s4, a4, o6, l5, u4) {
            const c5 = 10 * t5, h4 = 5 * t5;
            return this.int16[c5 + 0] = e6, this.int16[c5 + 1] = r8, this.int16[c5 + 2] = n6, this.int16[c5 + 3] = i6, this.int16[c5 + 4] = s4, this.int16[c5 + 5] = a4, this.uint32[h4 + 3] = o6, this.uint16[c5 + 8] = l5, this.uint16[c5 + 9] = u4, t5;
          }
        }
        Gs.prototype.bytesPerElement = 20, Zi("StructArrayLayout6i1ul2ui20", Gs);
        class Zs extends Vs {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
          }
          emplaceBack(t5, e6, r8, n6, i6, s4) {
            const a4 = this.length;
            return this.resize(a4 + 1), this.emplace(a4, t5, e6, r8, n6, i6, s4);
          }
          emplace(t5, e6, r8, n6, i6, s4, a4) {
            const o6 = 6 * t5;
            return this.int16[o6 + 0] = e6, this.int16[o6 + 1] = r8, this.int16[o6 + 2] = n6, this.int16[o6 + 3] = i6, this.int16[o6 + 4] = s4, this.int16[o6 + 5] = a4, t5;
          }
        }
        Zs.prototype.bytesPerElement = 12, Zi("StructArrayLayout2i2i2i12", Zs);
        class Ks extends Vs {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
          }
          emplaceBack(t5, e6, r8, n6, i6) {
            const s4 = this.length;
            return this.resize(s4 + 1), this.emplace(s4, t5, e6, r8, n6, i6);
          }
          emplace(t5, e6, r8, n6, i6, s4) {
            const a4 = 4 * t5, o6 = 8 * t5;
            return this.float32[a4 + 0] = e6, this.float32[a4 + 1] = r8, this.float32[a4 + 2] = n6, this.int16[o6 + 6] = i6, this.int16[o6 + 7] = s4, t5;
          }
        }
        Ks.prototype.bytesPerElement = 16, Zi("StructArrayLayout2f1f2i16", Ks);
        class Xs extends Vs {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
          }
          emplaceBack(t5, e6, r8, n6, i6, s4) {
            const a4 = this.length;
            return this.resize(a4 + 1), this.emplace(a4, t5, e6, r8, n6, i6, s4);
          }
          emplace(t5, e6, r8, n6, i6, s4, a4) {
            const o6 = 16 * t5, l5 = 4 * t5, u4 = 8 * t5;
            return this.uint8[o6 + 0] = e6, this.uint8[o6 + 1] = r8, this.float32[l5 + 1] = n6, this.float32[l5 + 2] = i6, this.int16[u4 + 6] = s4, this.int16[u4 + 7] = a4, t5;
          }
        }
        Xs.prototype.bytesPerElement = 16, Zi("StructArrayLayout2ub2f2i16", Xs);
        class Hs extends Vs {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
          }
          emplaceBack(t5, e6, r8) {
            const n6 = this.length;
            return this.resize(n6 + 1), this.emplace(n6, t5, e6, r8);
          }
          emplace(t5, e6, r8, n6) {
            const i6 = 3 * t5;
            return this.uint16[i6 + 0] = e6, this.uint16[i6 + 1] = r8, this.uint16[i6 + 2] = n6, t5;
          }
        }
        Hs.prototype.bytesPerElement = 6, Zi("StructArrayLayout3ui6", Hs);
        class Ys extends Vs {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }
          emplaceBack(t5, e6, r8, n6, i6, s4, a4, o6, l5, u4, c5, h4, p4, f4, d4, y4, m4) {
            const g4 = this.length;
            return this.resize(g4 + 1), this.emplace(g4, t5, e6, r8, n6, i6, s4, a4, o6, l5, u4, c5, h4, p4, f4, d4, y4, m4);
          }
          emplace(t5, e6, r8, n6, i6, s4, a4, o6, l5, u4, c5, h4, p4, f4, d4, y4, m4, g4) {
            const x4 = 24 * t5, v4 = 12 * t5, b5 = 48 * t5;
            return this.int16[x4 + 0] = e6, this.int16[x4 + 1] = r8, this.uint16[x4 + 2] = n6, this.uint16[x4 + 3] = i6, this.uint32[v4 + 2] = s4, this.uint32[v4 + 3] = a4, this.uint32[v4 + 4] = o6, this.uint16[x4 + 10] = l5, this.uint16[x4 + 11] = u4, this.uint16[x4 + 12] = c5, this.float32[v4 + 7] = h4, this.float32[v4 + 8] = p4, this.uint8[b5 + 36] = f4, this.uint8[b5 + 37] = d4, this.uint8[b5 + 38] = y4, this.uint32[v4 + 10] = m4, this.int16[x4 + 22] = g4, t5;
          }
        }
        Ys.prototype.bytesPerElement = 48, Zi("StructArrayLayout2i2ui3ul3ui2f3ub1ul1i48", Ys);
        class Js extends Vs {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }
          emplaceBack(t5, e6, r8, n6, i6, s4, a4, o6, l5, u4, c5, h4, p4, f4, d4, y4, m4, g4, x4, v4, b5, w4, _4, S5, A5, k4, M5, I4) {
            const z4 = this.length;
            return this.resize(z4 + 1), this.emplace(z4, t5, e6, r8, n6, i6, s4, a4, o6, l5, u4, c5, h4, p4, f4, d4, y4, m4, g4, x4, v4, b5, w4, _4, S5, A5, k4, M5, I4);
          }
          emplace(t5, e6, r8, n6, i6, s4, a4, o6, l5, u4, c5, h4, p4, f4, d4, y4, m4, g4, x4, v4, b5, w4, _4, S5, A5, k4, M5, I4, z4) {
            const P4 = 32 * t5, C4 = 16 * t5;
            return this.int16[P4 + 0] = e6, this.int16[P4 + 1] = r8, this.int16[P4 + 2] = n6, this.int16[P4 + 3] = i6, this.int16[P4 + 4] = s4, this.int16[P4 + 5] = a4, this.int16[P4 + 6] = o6, this.int16[P4 + 7] = l5, this.uint16[P4 + 8] = u4, this.uint16[P4 + 9] = c5, this.uint16[P4 + 10] = h4, this.uint16[P4 + 11] = p4, this.uint16[P4 + 12] = f4, this.uint16[P4 + 13] = d4, this.uint16[P4 + 14] = y4, this.uint16[P4 + 15] = m4, this.uint16[P4 + 16] = g4, this.uint16[P4 + 17] = x4, this.uint16[P4 + 18] = v4, this.uint16[P4 + 19] = b5, this.uint16[P4 + 20] = w4, this.uint16[P4 + 21] = _4, this.uint16[P4 + 22] = S5, this.uint32[C4 + 12] = A5, this.float32[C4 + 13] = k4, this.float32[C4 + 14] = M5, this.uint16[P4 + 30] = I4, this.uint16[P4 + 31] = z4, t5;
          }
        }
        Js.prototype.bytesPerElement = 64, Zi("StructArrayLayout8i15ui1ul2f2ui64", Js);
        class Ws extends Vs {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }
          emplaceBack(t5) {
            const e6 = this.length;
            return this.resize(e6 + 1), this.emplace(e6, t5);
          }
          emplace(t5, e6) {
            return this.float32[1 * t5 + 0] = e6, t5;
          }
        }
        Ws.prototype.bytesPerElement = 4, Zi("StructArrayLayout1f4", Ws);
        class Qs extends Vs {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }
          emplaceBack(t5, e6, r8) {
            const n6 = this.length;
            return this.resize(n6 + 1), this.emplace(n6, t5, e6, r8);
          }
          emplace(t5, e6, r8, n6) {
            const i6 = 3 * t5;
            return this.uint16[6 * t5 + 0] = e6, this.float32[i6 + 1] = r8, this.float32[i6 + 2] = n6, t5;
          }
        }
        Qs.prototype.bytesPerElement = 12, Zi("StructArrayLayout1ui2f12", Qs);
        class ta extends Vs {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
          }
          emplaceBack(t5, e6, r8) {
            const n6 = this.length;
            return this.resize(n6 + 1), this.emplace(n6, t5, e6, r8);
          }
          emplace(t5, e6, r8, n6) {
            const i6 = 4 * t5;
            return this.uint32[2 * t5 + 0] = e6, this.uint16[i6 + 2] = r8, this.uint16[i6 + 3] = n6, t5;
          }
        }
        ta.prototype.bytesPerElement = 8, Zi("StructArrayLayout1ul2ui8", ta);
        class ea extends Vs {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
          }
          emplaceBack(t5, e6) {
            const r8 = this.length;
            return this.resize(r8 + 1), this.emplace(r8, t5, e6);
          }
          emplace(t5, e6, r8) {
            const n6 = 2 * t5;
            return this.uint16[n6 + 0] = e6, this.uint16[n6 + 1] = r8, t5;
          }
        }
        ea.prototype.bytesPerElement = 4, Zi("StructArrayLayout2ui4", ea);
        class ra extends Vs {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
          }
          emplaceBack(t5) {
            const e6 = this.length;
            return this.resize(e6 + 1), this.emplace(e6, t5);
          }
          emplace(t5, e6) {
            return this.uint16[1 * t5 + 0] = e6, t5;
          }
        }
        ra.prototype.bytesPerElement = 2, Zi("StructArrayLayout1ui2", ra);
        class na extends Vs {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }
          emplaceBack(t5, e6, r8, n6) {
            const i6 = this.length;
            return this.resize(i6 + 1), this.emplace(i6, t5, e6, r8, n6);
          }
          emplace(t5, e6, r8, n6, i6) {
            const s4 = 4 * t5;
            return this.float32[s4 + 0] = e6, this.float32[s4 + 1] = r8, this.float32[s4 + 2] = n6, this.float32[s4 + 3] = i6, t5;
          }
        }
        na.prototype.bytesPerElement = 16, Zi("StructArrayLayout4f16", na);
        class ia extends Bs {
          get anchorPointX() {
            return this._structArray.int16[this._pos2 + 0];
          }
          get anchorPointY() {
            return this._structArray.int16[this._pos2 + 1];
          }
          get x1() {
            return this._structArray.int16[this._pos2 + 2];
          }
          get y1() {
            return this._structArray.int16[this._pos2 + 3];
          }
          get x2() {
            return this._structArray.int16[this._pos2 + 4];
          }
          get y2() {
            return this._structArray.int16[this._pos2 + 5];
          }
          get featureIndex() {
            return this._structArray.uint32[this._pos4 + 3];
          }
          get sourceLayerIndex() {
            return this._structArray.uint16[this._pos2 + 8];
          }
          get bucketIndex() {
            return this._structArray.uint16[this._pos2 + 9];
          }
          get anchorPoint() {
            return new l4(this.anchorPointX, this.anchorPointY);
          }
        }
        ia.prototype.size = 20;
        class sa extends Gs {
          get(t5) {
            return new ia(this, t5);
          }
        }
        Zi("CollisionBoxArray", sa);
        class aa extends Bs {
          get anchorX() {
            return this._structArray.int16[this._pos2 + 0];
          }
          get anchorY() {
            return this._structArray.int16[this._pos2 + 1];
          }
          get glyphStartIndex() {
            return this._structArray.uint16[this._pos2 + 2];
          }
          get numGlyphs() {
            return this._structArray.uint16[this._pos2 + 3];
          }
          get vertexStartIndex() {
            return this._structArray.uint32[this._pos4 + 2];
          }
          get lineStartIndex() {
            return this._structArray.uint32[this._pos4 + 3];
          }
          get lineLength() {
            return this._structArray.uint32[this._pos4 + 4];
          }
          get segment() {
            return this._structArray.uint16[this._pos2 + 10];
          }
          get lowerSize() {
            return this._structArray.uint16[this._pos2 + 11];
          }
          get upperSize() {
            return this._structArray.uint16[this._pos2 + 12];
          }
          get lineOffsetX() {
            return this._structArray.float32[this._pos4 + 7];
          }
          get lineOffsetY() {
            return this._structArray.float32[this._pos4 + 8];
          }
          get writingMode() {
            return this._structArray.uint8[this._pos1 + 36];
          }
          get placedOrientation() {
            return this._structArray.uint8[this._pos1 + 37];
          }
          set placedOrientation(t5) {
            this._structArray.uint8[this._pos1 + 37] = t5;
          }
          get hidden() {
            return this._structArray.uint8[this._pos1 + 38];
          }
          set hidden(t5) {
            this._structArray.uint8[this._pos1 + 38] = t5;
          }
          get crossTileID() {
            return this._structArray.uint32[this._pos4 + 10];
          }
          set crossTileID(t5) {
            this._structArray.uint32[this._pos4 + 10] = t5;
          }
          get associatedIconIndex() {
            return this._structArray.int16[this._pos2 + 22];
          }
        }
        aa.prototype.size = 48;
        class oa extends Ys {
          get(t5) {
            return new aa(this, t5);
          }
        }
        Zi("PlacedSymbolArray", oa);
        class la extends Bs {
          get anchorX() {
            return this._structArray.int16[this._pos2 + 0];
          }
          get anchorY() {
            return this._structArray.int16[this._pos2 + 1];
          }
          get rightJustifiedTextSymbolIndex() {
            return this._structArray.int16[this._pos2 + 2];
          }
          get centerJustifiedTextSymbolIndex() {
            return this._structArray.int16[this._pos2 + 3];
          }
          get leftJustifiedTextSymbolIndex() {
            return this._structArray.int16[this._pos2 + 4];
          }
          get verticalPlacedTextSymbolIndex() {
            return this._structArray.int16[this._pos2 + 5];
          }
          get placedIconSymbolIndex() {
            return this._structArray.int16[this._pos2 + 6];
          }
          get verticalPlacedIconSymbolIndex() {
            return this._structArray.int16[this._pos2 + 7];
          }
          get key() {
            return this._structArray.uint16[this._pos2 + 8];
          }
          get textBoxStartIndex() {
            return this._structArray.uint16[this._pos2 + 9];
          }
          get textBoxEndIndex() {
            return this._structArray.uint16[this._pos2 + 10];
          }
          get verticalTextBoxStartIndex() {
            return this._structArray.uint16[this._pos2 + 11];
          }
          get verticalTextBoxEndIndex() {
            return this._structArray.uint16[this._pos2 + 12];
          }
          get iconBoxStartIndex() {
            return this._structArray.uint16[this._pos2 + 13];
          }
          get iconBoxEndIndex() {
            return this._structArray.uint16[this._pos2 + 14];
          }
          get verticalIconBoxStartIndex() {
            return this._structArray.uint16[this._pos2 + 15];
          }
          get verticalIconBoxEndIndex() {
            return this._structArray.uint16[this._pos2 + 16];
          }
          get featureIndex() {
            return this._structArray.uint16[this._pos2 + 17];
          }
          get numHorizontalGlyphVertices() {
            return this._structArray.uint16[this._pos2 + 18];
          }
          get numVerticalGlyphVertices() {
            return this._structArray.uint16[this._pos2 + 19];
          }
          get numIconVertices() {
            return this._structArray.uint16[this._pos2 + 20];
          }
          get numVerticalIconVertices() {
            return this._structArray.uint16[this._pos2 + 21];
          }
          get useRuntimeCollisionCircles() {
            return this._structArray.uint16[this._pos2 + 22];
          }
          get crossTileID() {
            return this._structArray.uint32[this._pos4 + 12];
          }
          set crossTileID(t5) {
            this._structArray.uint32[this._pos4 + 12] = t5;
          }
          get textBoxScale() {
            return this._structArray.float32[this._pos4 + 13];
          }
          get collisionCircleDiameter() {
            return this._structArray.float32[this._pos4 + 14];
          }
          get textAnchorOffsetStartIndex() {
            return this._structArray.uint16[this._pos2 + 30];
          }
          get textAnchorOffsetEndIndex() {
            return this._structArray.uint16[this._pos2 + 31];
          }
        }
        la.prototype.size = 64;
        class ua extends Js {
          get(t5) {
            return new la(this, t5);
          }
        }
        Zi("SymbolInstanceArray", ua);
        class ca extends Ws {
          getoffsetX(t5) {
            return this.float32[1 * t5 + 0];
          }
        }
        Zi("GlyphOffsetArray", ca);
        class ha extends $s {
          getx(t5) {
            return this.int16[3 * t5 + 0];
          }
          gety(t5) {
            return this.int16[3 * t5 + 1];
          }
          gettileUnitDistanceFromAnchor(t5) {
            return this.int16[3 * t5 + 2];
          }
        }
        Zi("SymbolLineVertexArray", ha);
        class pa extends Bs {
          get textAnchor() {
            return this._structArray.uint16[this._pos2 + 0];
          }
          get textOffset0() {
            return this._structArray.float32[this._pos4 + 1];
          }
          get textOffset1() {
            return this._structArray.float32[this._pos4 + 2];
          }
        }
        pa.prototype.size = 12;
        class fa extends Qs {
          get(t5) {
            return new pa(this, t5);
          }
        }
        Zi("TextAnchorOffsetArray", fa);
        class da extends Bs {
          get featureIndex() {
            return this._structArray.uint32[this._pos4 + 0];
          }
          get sourceLayerIndex() {
            return this._structArray.uint16[this._pos2 + 2];
          }
          get bucketIndex() {
            return this._structArray.uint16[this._pos2 + 3];
          }
        }
        da.prototype.size = 8;
        class ya extends ta {
          get(t5) {
            return new da(this, t5);
          }
        }
        Zi("FeatureIndexArray", ya);
        class ma extends Fs {
        }
        class ga extends Fs {
        }
        class xa extends Fs {
        }
        class va extends Os {
        }
        class ba extends Ds {
        }
        class wa extends Rs {
        }
        class _a6 extends js {
        }
        class Sa extends Ns {
        }
        class Aa extends Us {
        }
        class ka extends qs {
        }
        class Ma extends Zs {
        }
        class Ia extends Xs {
        }
        class za extends Hs {
        }
        class Pa extends ea {
        }
        const Ca = Es([{ name: "a_pos", components: 2, type: "Int16" }], 4), { members: Ba } = Ca;
        class Va {
          constructor(t5 = []) {
            this._forceNewSegmentOnNextPrepare = false, this.segments = t5;
          }
          prepareSegment(t5, e6, r8, n6) {
            const i6 = this.segments[this.segments.length - 1];
            return t5 > Va.MAX_VERTEX_ARRAY_LENGTH && j3(`Max vertices per segment is ${Va.MAX_VERTEX_ARRAY_LENGTH}: bucket requested ${t5}. Consider using the \`fillLargeMeshArrays\` function if you require meshes with more than ${Va.MAX_VERTEX_ARRAY_LENGTH} vertices.`), this._forceNewSegmentOnNextPrepare || !i6 || i6.vertexLength + t5 > Va.MAX_VERTEX_ARRAY_LENGTH || i6.sortKey !== n6 ? this.createNewSegment(e6, r8, n6) : i6;
          }
          createNewSegment(t5, e6, r8) {
            const n6 = { vertexOffset: t5.length, primitiveOffset: e6.length, vertexLength: 0, primitiveLength: 0, vaos: {} };
            return void 0 !== r8 && (n6.sortKey = r8), this._forceNewSegmentOnNextPrepare = false, this.segments.push(n6), n6;
          }
          getOrCreateLatestSegment(t5, e6, r8) {
            return this.prepareSegment(0, t5, e6, r8);
          }
          forceNewSegmentOnNextPrepare() {
            this._forceNewSegmentOnNextPrepare = true;
          }
          get() {
            return this.segments;
          }
          destroy() {
            for (const t5 of this.segments) for (const e6 in t5.vaos) t5.vaos[e6].destroy();
          }
          static simpleSegment(t5, e6, r8, n6) {
            return new Va([{ vertexOffset: t5, primitiveOffset: e6, vertexLength: r8, primitiveLength: n6, vaos: {}, sortKey: 0 }]);
          }
        }
        function Ea(t5, e6) {
          return 256 * (t5 = E3(Math.floor(t5), 0, 255)) + E3(Math.floor(e6), 0, 255);
        }
        Va.MAX_VERTEX_ARRAY_LENGTH = Math.pow(2, 16) - 1, Zi("SegmentVector", Va);
        const Ta = Es([{ name: "a_pattern_from", components: 4, type: "Uint16" }, { name: "a_pattern_to", components: 4, type: "Uint16" }, { name: "a_pixel_ratio_from", components: 1, type: "Uint16" }, { name: "a_pixel_ratio_to", components: 1, type: "Uint16" }]);
        var Fa, $a, La, Oa = { exports: {} }, Da = { exports: {} }, Ra = { exports: {} }, ja = function() {
          if (La) return Oa.exports;
          La = 1;
          var t5 = (Fa || (Fa = 1, Da.exports = function(t6, e7) {
            var r8, n6, i6, s4, a4, o6, l5, u4;
            for (n6 = t6.length - (r8 = 3 & t6.length), i6 = e7, a4 = 3432918353, o6 = 461845907, u4 = 0; u4 < n6; ) l5 = 255 & t6.charCodeAt(u4) | (255 & t6.charCodeAt(++u4)) << 8 | (255 & t6.charCodeAt(++u4)) << 16 | (255 & t6.charCodeAt(++u4)) << 24, ++u4, i6 = 27492 + (65535 & (s4 = 5 * (65535 & (i6 = (i6 ^= l5 = (65535 & (l5 = (l5 = (65535 & l5) * a4 + (((l5 >>> 16) * a4 & 65535) << 16) & 4294967295) << 15 | l5 >>> 17)) * o6 + (((l5 >>> 16) * o6 & 65535) << 16) & 4294967295) << 13 | i6 >>> 19)) + ((5 * (i6 >>> 16) & 65535) << 16) & 4294967295)) + ((58964 + (s4 >>> 16) & 65535) << 16);
            switch (l5 = 0, r8) {
              case 3:
                l5 ^= (255 & t6.charCodeAt(u4 + 2)) << 16;
              case 2:
                l5 ^= (255 & t6.charCodeAt(u4 + 1)) << 8;
              case 1:
                i6 ^= l5 = (65535 & (l5 = (l5 = (65535 & (l5 ^= 255 & t6.charCodeAt(u4))) * a4 + (((l5 >>> 16) * a4 & 65535) << 16) & 4294967295) << 15 | l5 >>> 17)) * o6 + (((l5 >>> 16) * o6 & 65535) << 16) & 4294967295;
            }
            return i6 ^= t6.length, i6 = 2246822507 * (65535 & (i6 ^= i6 >>> 16)) + ((2246822507 * (i6 >>> 16) & 65535) << 16) & 4294967295, i6 = 3266489909 * (65535 & (i6 ^= i6 >>> 13)) + ((3266489909 * (i6 >>> 16) & 65535) << 16) & 4294967295, (i6 ^= i6 >>> 16) >>> 0;
          }), Da.exports), e6 = ($a || ($a = 1, Ra.exports = function(t6, e7) {
            for (var r8, n6 = t6.length, i6 = e7 ^ n6, s4 = 0; n6 >= 4; ) r8 = 1540483477 * (65535 & (r8 = 255 & t6.charCodeAt(s4) | (255 & t6.charCodeAt(++s4)) << 8 | (255 & t6.charCodeAt(++s4)) << 16 | (255 & t6.charCodeAt(++s4)) << 24)) + ((1540483477 * (r8 >>> 16) & 65535) << 16), i6 = 1540483477 * (65535 & i6) + ((1540483477 * (i6 >>> 16) & 65535) << 16) ^ (r8 = 1540483477 * (65535 & (r8 ^= r8 >>> 24)) + ((1540483477 * (r8 >>> 16) & 65535) << 16)), n6 -= 4, ++s4;
            switch (n6) {
              case 3:
                i6 ^= (255 & t6.charCodeAt(s4 + 2)) << 16;
              case 2:
                i6 ^= (255 & t6.charCodeAt(s4 + 1)) << 8;
              case 1:
                i6 = 1540483477 * (65535 & (i6 ^= 255 & t6.charCodeAt(s4))) + ((1540483477 * (i6 >>> 16) & 65535) << 16);
            }
            return i6 = 1540483477 * (65535 & (i6 ^= i6 >>> 13)) + ((1540483477 * (i6 >>> 16) & 65535) << 16), (i6 ^= i6 >>> 15) >>> 0;
          }), Ra.exports);
          return Oa.exports = t5, Oa.exports.murmur3 = t5, Oa.exports.murmur2 = e6, Oa.exports;
        }(), Na = r7(ja);
        class Ua {
          constructor() {
            this.ids = [], this.positions = [], this.indexed = false;
          }
          add(t5, e6, r8, n6) {
            this.ids.push(qa(t5)), this.positions.push(e6, r8, n6);
          }
          getPositions(t5) {
            if (!this.indexed) throw new Error("Trying to get index, but feature positions are not indexed");
            const e6 = qa(t5);
            let r8 = 0, n6 = this.ids.length - 1;
            for (; r8 < n6; ) {
              const t6 = r8 + n6 >> 1;
              this.ids[t6] >= e6 ? n6 = t6 : r8 = t6 + 1;
            }
            const i6 = [];
            for (; this.ids[r8] === e6; ) i6.push({ index: this.positions[3 * r8], start: this.positions[3 * r8 + 1], end: this.positions[3 * r8 + 2] }), r8++;
            return i6;
          }
          static serialize(t5, e6) {
            const r8 = new Float64Array(t5.ids), n6 = new Uint32Array(t5.positions);
            return Ga(r8, n6, 0, r8.length - 1), e6 && e6.push(r8.buffer, n6.buffer), { ids: r8, positions: n6 };
          }
          static deserialize(t5) {
            const e6 = new Ua();
            return e6.ids = t5.ids, e6.positions = t5.positions, e6.indexed = true, e6;
          }
        }
        function qa(t5) {
          const e6 = +t5;
          return !isNaN(e6) && e6 <= Number.MAX_SAFE_INTEGER ? e6 : Na(String(t5));
        }
        function Ga(t5, e6, r8, n6) {
          for (; r8 < n6; ) {
            const i6 = t5[r8 + n6 >> 1];
            let s4 = r8 - 1, a4 = n6 + 1;
            for (; ; ) {
              do {
                s4++;
              } while (t5[s4] < i6);
              do {
                a4--;
              } while (t5[a4] > i6);
              if (s4 >= a4) break;
              Za(t5, s4, a4), Za(e6, 3 * s4, 3 * a4), Za(e6, 3 * s4 + 1, 3 * a4 + 1), Za(e6, 3 * s4 + 2, 3 * a4 + 2);
            }
            a4 - r8 < n6 - a4 ? (Ga(t5, e6, r8, a4), r8 = a4 + 1) : (Ga(t5, e6, a4 + 1, n6), n6 = a4);
          }
        }
        function Za(t5, e6, r8) {
          const n6 = t5[e6];
          t5[e6] = t5[r8], t5[r8] = n6;
        }
        Zi("FeaturePositionMap", Ua);
        class Ka {
          constructor(t5, e6) {
            this.gl = t5.gl, this.location = e6;
          }
        }
        class Xa extends Ka {
          constructor(t5, e6) {
            super(t5, e6), this.current = 0;
          }
          set(t5) {
            this.current !== t5 && (this.current = t5, this.gl.uniform1f(this.location, t5));
          }
        }
        class Ha extends Ka {
          constructor(t5, e6) {
            super(t5, e6), this.current = [0, 0, 0, 0];
          }
          set(t5) {
            t5[0] === this.current[0] && t5[1] === this.current[1] && t5[2] === this.current[2] && t5[3] === this.current[3] || (this.current = t5, this.gl.uniform4f(this.location, t5[0], t5[1], t5[2], t5[3]));
          }
        }
        class Ya extends Ka {
          constructor(t5, e6) {
            super(t5, e6), this.current = xe.transparent;
          }
          set(t5) {
            t5.r === this.current.r && t5.g === this.current.g && t5.b === this.current.b && t5.a === this.current.a || (this.current = t5, this.gl.uniform4f(this.location, t5.r, t5.g, t5.b, t5.a));
          }
        }
        const Ja = new Float32Array(16);
        function Wa(t5) {
          return [Ea(255 * t5.r, 255 * t5.g), Ea(255 * t5.b, 255 * t5.a)];
        }
        class Qa {
          constructor(t5, e6, r8) {
            this.value = t5, this.uniformNames = e6.map((t6) => `u_${t6}`), this.type = r8;
          }
          setUniform(t5, e6, r8) {
            t5.set(r8.constantOr(this.value));
          }
          getBinding(t5, e6, r8) {
            return "color" === this.type ? new Ya(t5, e6) : new Xa(t5, e6);
          }
        }
        class to {
          constructor(t5, e6) {
            this.uniformNames = e6.map((t6) => `u_${t6}`), this.patternFrom = null, this.patternTo = null, this.pixelRatioFrom = 1, this.pixelRatioTo = 1;
          }
          setConstantPatternPositions(t5, e6) {
            this.pixelRatioFrom = e6.pixelRatio, this.pixelRatioTo = t5.pixelRatio, this.patternFrom = e6.tlbr, this.patternTo = t5.tlbr;
          }
          setUniform(t5, e6, r8, n6) {
            const i6 = "u_pattern_to" === n6 ? this.patternTo : "u_pattern_from" === n6 ? this.patternFrom : "u_pixel_ratio_to" === n6 ? this.pixelRatioTo : "u_pixel_ratio_from" === n6 ? this.pixelRatioFrom : null;
            i6 && t5.set(i6);
          }
          getBinding(t5, e6, r8) {
            return "u_pattern" === r8.substr(0, 9) ? new Ha(t5, e6) : new Xa(t5, e6);
          }
        }
        class eo {
          constructor(t5, e6, r8, n6) {
            this.expression = t5, this.type = r8, this.maxValue = 0, this.paintVertexAttributes = e6.map((t6) => ({ name: `a_${t6}`, type: "Float32", components: "color" === r8 ? 2 : 1, offset: 0 })), this.paintVertexArray = new n6();
          }
          populatePaintArray(t5, e6, r8, n6, i6) {
            const s4 = this.paintVertexArray.length, a4 = this.expression.evaluate(new fs(0), e6, {}, n6, [], i6);
            this.paintVertexArray.resize(t5), this._setPaintValue(s4, t5, a4);
          }
          updatePaintArray(t5, e6, r8, n6) {
            const i6 = this.expression.evaluate({ zoom: 0 }, r8, n6);
            this._setPaintValue(t5, e6, i6);
          }
          _setPaintValue(t5, e6, r8) {
            if ("color" === this.type) {
              const n6 = Wa(r8);
              for (let r9 = t5; r9 < e6; r9++) this.paintVertexArray.emplace(r9, n6[0], n6[1]);
            } else {
              for (let n6 = t5; n6 < e6; n6++) this.paintVertexArray.emplace(n6, r8);
              this.maxValue = Math.max(this.maxValue, Math.abs(r8));
            }
          }
          upload(t5) {
            this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer && this.paintVertexBuffer.buffer ? this.paintVertexBuffer.updateData(this.paintVertexArray) : this.paintVertexBuffer = t5.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent));
          }
          destroy() {
            this.paintVertexBuffer && this.paintVertexBuffer.destroy();
          }
        }
        class ro {
          constructor(t5, e6, r8, n6, i6, s4) {
            this.expression = t5, this.uniformNames = e6.map((t6) => `u_${t6}_t`), this.type = r8, this.useIntegerZoom = n6, this.zoom = i6, this.maxValue = 0, this.paintVertexAttributes = e6.map((t6) => ({ name: `a_${t6}`, type: "Float32", components: "color" === r8 ? 4 : 2, offset: 0 })), this.paintVertexArray = new s4();
          }
          populatePaintArray(t5, e6, r8, n6, i6) {
            const s4 = this.expression.evaluate(new fs(this.zoom), e6, {}, n6, [], i6), a4 = this.expression.evaluate(new fs(this.zoom + 1), e6, {}, n6, [], i6), o6 = this.paintVertexArray.length;
            this.paintVertexArray.resize(t5), this._setPaintValue(o6, t5, s4, a4);
          }
          updatePaintArray(t5, e6, r8, n6) {
            const i6 = this.expression.evaluate({ zoom: this.zoom }, r8, n6), s4 = this.expression.evaluate({ zoom: this.zoom + 1 }, r8, n6);
            this._setPaintValue(t5, e6, i6, s4);
          }
          _setPaintValue(t5, e6, r8, n6) {
            if ("color" === this.type) {
              const i6 = Wa(r8), s4 = Wa(n6);
              for (let r9 = t5; r9 < e6; r9++) this.paintVertexArray.emplace(r9, i6[0], i6[1], s4[0], s4[1]);
            } else {
              for (let i6 = t5; i6 < e6; i6++) this.paintVertexArray.emplace(i6, r8, n6);
              this.maxValue = Math.max(this.maxValue, Math.abs(r8), Math.abs(n6));
            }
          }
          upload(t5) {
            this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer && this.paintVertexBuffer.buffer ? this.paintVertexBuffer.updateData(this.paintVertexArray) : this.paintVertexBuffer = t5.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent));
          }
          destroy() {
            this.paintVertexBuffer && this.paintVertexBuffer.destroy();
          }
          setUniform(t5, e6) {
            const r8 = this.useIntegerZoom ? Math.floor(e6.zoom) : e6.zoom, n6 = E3(this.expression.interpolationFactor(r8, this.zoom, this.zoom + 1), 0, 1);
            t5.set(n6);
          }
          getBinding(t5, e6, r8) {
            return new Xa(t5, e6);
          }
        }
        class no {
          constructor(t5, e6, r8, n6, i6, s4) {
            this.expression = t5, this.type = e6, this.useIntegerZoom = r8, this.zoom = n6, this.layerId = s4, this.zoomInPaintVertexArray = new i6(), this.zoomOutPaintVertexArray = new i6();
          }
          populatePaintArray(t5, e6, r8) {
            const n6 = this.zoomInPaintVertexArray.length;
            this.zoomInPaintVertexArray.resize(t5), this.zoomOutPaintVertexArray.resize(t5), this._setPaintValues(n6, t5, e6.patterns && e6.patterns[this.layerId], r8);
          }
          updatePaintArray(t5, e6, r8, n6, i6) {
            this._setPaintValues(t5, e6, r8.patterns && r8.patterns[this.layerId], i6);
          }
          _setPaintValues(t5, e6, r8, n6) {
            if (!n6 || !r8) return;
            const { min: i6, mid: s4, max: a4 } = r8, o6 = n6[i6], l5 = n6[s4], u4 = n6[a4];
            if (o6 && l5 && u4) for (let r9 = t5; r9 < e6; r9++) this.zoomInPaintVertexArray.emplace(r9, l5.tl[0], l5.tl[1], l5.br[0], l5.br[1], o6.tl[0], o6.tl[1], o6.br[0], o6.br[1], l5.pixelRatio, o6.pixelRatio), this.zoomOutPaintVertexArray.emplace(r9, l5.tl[0], l5.tl[1], l5.br[0], l5.br[1], u4.tl[0], u4.tl[1], u4.br[0], u4.br[1], l5.pixelRatio, u4.pixelRatio);
          }
          upload(t5) {
            this.zoomInPaintVertexArray && this.zoomInPaintVertexArray.arrayBuffer && this.zoomOutPaintVertexArray && this.zoomOutPaintVertexArray.arrayBuffer && (this.zoomInPaintVertexBuffer = t5.createVertexBuffer(this.zoomInPaintVertexArray, Ta.members, this.expression.isStateDependent), this.zoomOutPaintVertexBuffer = t5.createVertexBuffer(this.zoomOutPaintVertexArray, Ta.members, this.expression.isStateDependent));
          }
          destroy() {
            this.zoomOutPaintVertexBuffer && this.zoomOutPaintVertexBuffer.destroy(), this.zoomInPaintVertexBuffer && this.zoomInPaintVertexBuffer.destroy();
          }
        }
        class io {
          constructor(t5, e6, r8) {
            this.binders = {}, this._buffers = [];
            const n6 = [];
            for (const i6 in t5.paint._values) {
              if (!r8(i6)) continue;
              const s4 = t5.paint.get(i6);
              if (!(s4 instanceof bs && Bn(s4.property.specification))) continue;
              const a4 = ao(i6, t5.type), o6 = s4.value, l5 = s4.property.specification.type, u4 = s4.property.useIntegerZoom, c5 = s4.property.specification["property-type"], h4 = "cross-faded" === c5 || "cross-faded-data-driven" === c5;
              if ("constant" === o6.kind) this.binders[i6] = h4 ? new to(o6.value, a4) : new Qa(o6.value, a4, l5), n6.push(`/u_${i6}`);
              else if ("source" === o6.kind || h4) {
                const r9 = oo(i6, l5, "source");
                this.binders[i6] = h4 ? new no(o6, l5, u4, e6, r9, t5.id) : new eo(o6, a4, l5, r9), n6.push(`/a_${i6}`);
              } else {
                const t6 = oo(i6, l5, "composite");
                this.binders[i6] = new ro(o6, a4, l5, u4, e6, t6), n6.push(`/z_${i6}`);
              }
            }
            this.cacheKey = n6.sort().join("");
          }
          getMaxValue(t5) {
            const e6 = this.binders[t5];
            return e6 instanceof eo || e6 instanceof ro ? e6.maxValue : 0;
          }
          populatePaintArrays(t5, e6, r8, n6, i6) {
            for (const s4 in this.binders) {
              const a4 = this.binders[s4];
              (a4 instanceof eo || a4 instanceof ro || a4 instanceof no) && a4.populatePaintArray(t5, e6, r8, n6, i6);
            }
          }
          setConstantPatternPositions(t5, e6) {
            for (const r8 in this.binders) {
              const n6 = this.binders[r8];
              n6 instanceof to && n6.setConstantPatternPositions(t5, e6);
            }
          }
          updatePaintArrays(t5, e6, r8, n6, i6) {
            let s4 = false;
            for (const a4 in t5) {
              const o6 = e6.getPositions(a4);
              for (const e7 of o6) {
                const o7 = r8.feature(e7.index);
                for (const r9 in this.binders) {
                  const l5 = this.binders[r9];
                  if ((l5 instanceof eo || l5 instanceof ro || l5 instanceof no) && true === l5.expression.isStateDependent) {
                    const u4 = n6.paint.get(r9);
                    l5.expression = u4.value, l5.updatePaintArray(e7.start, e7.end, o7, t5[a4], i6), s4 = true;
                  }
                }
              }
            }
            return s4;
          }
          defines() {
            const t5 = [];
            for (const e6 in this.binders) {
              const r8 = this.binders[e6];
              (r8 instanceof Qa || r8 instanceof to) && t5.push(...r8.uniformNames.map((t6) => `#define HAS_UNIFORM_${t6}`));
            }
            return t5;
          }
          getBinderAttributes() {
            const t5 = [];
            for (const e6 in this.binders) {
              const r8 = this.binders[e6];
              if (r8 instanceof eo || r8 instanceof ro) for (let e7 = 0; e7 < r8.paintVertexAttributes.length; e7++) t5.push(r8.paintVertexAttributes[e7].name);
              else if (r8 instanceof no) for (let e7 = 0; e7 < Ta.members.length; e7++) t5.push(Ta.members[e7].name);
            }
            return t5;
          }
          getBinderUniforms() {
            const t5 = [];
            for (const e6 in this.binders) {
              const r8 = this.binders[e6];
              if (r8 instanceof Qa || r8 instanceof to || r8 instanceof ro) for (const e7 of r8.uniformNames) t5.push(e7);
            }
            return t5;
          }
          getPaintVertexBuffers() {
            return this._buffers;
          }
          getUniforms(t5, e6) {
            const r8 = [];
            for (const n6 in this.binders) {
              const i6 = this.binders[n6];
              if (i6 instanceof Qa || i6 instanceof to || i6 instanceof ro) {
                for (const s4 of i6.uniformNames) if (e6[s4]) {
                  const a4 = i6.getBinding(t5, e6[s4], s4);
                  r8.push({ name: s4, property: n6, binding: a4 });
                }
              }
            }
            return r8;
          }
          setUniforms(t5, e6, r8, n6) {
            for (const { name: t6, property: i6, binding: s4 } of e6) this.binders[i6].setUniform(s4, n6, r8.get(i6), t6);
          }
          updatePaintBuffers(t5) {
            this._buffers = [];
            for (const e6 in this.binders) {
              const r8 = this.binders[e6];
              if (t5 && r8 instanceof no) {
                const e7 = 2 === t5.fromScale ? r8.zoomInPaintVertexBuffer : r8.zoomOutPaintVertexBuffer;
                e7 && this._buffers.push(e7);
              } else (r8 instanceof eo || r8 instanceof ro) && r8.paintVertexBuffer && this._buffers.push(r8.paintVertexBuffer);
            }
          }
          upload(t5) {
            for (const e6 in this.binders) {
              const r8 = this.binders[e6];
              (r8 instanceof eo || r8 instanceof ro || r8 instanceof no) && r8.upload(t5);
            }
            this.updatePaintBuffers();
          }
          destroy() {
            for (const t5 in this.binders) {
              const e6 = this.binders[t5];
              (e6 instanceof eo || e6 instanceof ro || e6 instanceof no) && e6.destroy();
            }
          }
        }
        class so {
          constructor(t5, e6, r8 = () => true) {
            this.programConfigurations = {};
            for (const n6 of t5) this.programConfigurations[n6.id] = new io(n6, e6, r8);
            this.needsUpload = false, this._featureMap = new Ua(), this._bufferOffset = 0;
          }
          populatePaintArrays(t5, e6, r8, n6, i6, s4) {
            for (const r9 in this.programConfigurations) this.programConfigurations[r9].populatePaintArrays(t5, e6, n6, i6, s4);
            void 0 !== e6.id && this._featureMap.add(e6.id, r8, this._bufferOffset, t5), this._bufferOffset = t5, this.needsUpload = true;
          }
          updatePaintArrays(t5, e6, r8, n6) {
            for (const i6 of r8) this.needsUpload = this.programConfigurations[i6.id].updatePaintArrays(t5, this._featureMap, e6, i6, n6) || this.needsUpload;
          }
          get(t5) {
            return this.programConfigurations[t5];
          }
          upload(t5) {
            if (this.needsUpload) {
              for (const e6 in this.programConfigurations) this.programConfigurations[e6].upload(t5);
              this.needsUpload = false;
            }
          }
          destroy() {
            for (const t5 in this.programConfigurations) this.programConfigurations[t5].destroy();
          }
        }
        function ao(t5, e6) {
          return { "text-opacity": ["opacity"], "icon-opacity": ["opacity"], "text-color": ["fill_color"], "icon-color": ["fill_color"], "text-halo-color": ["halo_color"], "icon-halo-color": ["halo_color"], "text-halo-blur": ["halo_blur"], "icon-halo-blur": ["halo_blur"], "text-halo-width": ["halo_width"], "icon-halo-width": ["halo_width"], "line-gap-width": ["gapwidth"], "line-pattern": ["pattern_to", "pattern_from", "pixel_ratio_to", "pixel_ratio_from"], "fill-pattern": ["pattern_to", "pattern_from", "pixel_ratio_to", "pixel_ratio_from"], "fill-extrusion-pattern": ["pattern_to", "pattern_from", "pixel_ratio_to", "pixel_ratio_from"] }[t5] || [t5.replace(`${e6}-`, "").replace(/-/g, "_")];
        }
        function oo(t5, e6, r8) {
          const n6 = { color: { source: Rs, composite: na }, number: { source: Ws, composite: Rs } }, i6 = function(t6) {
            return { "line-pattern": { source: _a6, composite: _a6 }, "fill-pattern": { source: _a6, composite: _a6 }, "fill-extrusion-pattern": { source: _a6, composite: _a6 } }[t6];
          }(t5);
          return i6 && i6[r8] || n6[e6][r8];
        }
        Zi("ConstantBinder", Qa), Zi("CrossFadedConstantBinder", to), Zi("SourceExpressionBinder", eo), Zi("CrossFadedCompositeBinder", no), Zi("CompositeExpressionBinder", ro), Zi("ProgramConfiguration", io, { omit: ["_buffers"] }), Zi("ProgramConfigurationSet", so);
        const lo = Math.pow(2, 14) - 1, uo = -lo - 1;
        function co(t5) {
          const e6 = M4 / t5.extent, r8 = t5.loadGeometry();
          for (let t6 = 0; t6 < r8.length; t6++) {
            const n6 = r8[t6];
            for (let t7 = 0; t7 < n6.length; t7++) {
              const r9 = n6[t7], i6 = Math.round(r9.x * e6), s4 = Math.round(r9.y * e6);
              r9.x = E3(i6, uo, lo), r9.y = E3(s4, uo, lo), (i6 < r9.x || i6 > r9.x + 1 || s4 < r9.y || s4 > r9.y + 1) && j3("Geometry exceeds allowed extent, reduce your vector tile buffer size");
            }
          }
          return r8;
        }
        function ho(t5, e6) {
          return { type: t5.type, id: t5.id, properties: t5.properties, geometry: e6 ? co(t5) : [] };
        }
        const po = -32768;
        function fo(t5, e6, r8, n6, i6) {
          t5.emplaceBack(po + 8 * e6 + n6, po + 8 * r8 + i6);
        }
        class yo {
          constructor(t5) {
            this.zoom = t5.zoom, this.overscaling = t5.overscaling, this.layers = t5.layers, this.layerIds = this.layers.map((t6) => t6.id), this.index = t5.index, this.hasPattern = false, this.layoutVertexArray = new ga(), this.indexArray = new za(), this.segments = new Va(), this.programConfigurations = new so(t5.layers, t5.zoom), this.stateDependentLayerIds = this.layers.filter((t6) => t6.isStateDependent()).map((t6) => t6.id);
          }
          populate(t5, e6, r8) {
            const n6 = this.layers[0], i6 = [];
            let s4 = null, a4 = false, o6 = "heatmap" === n6.type;
            if ("circle" === n6.type) {
              const t6 = n6;
              s4 = t6.layout.get("circle-sort-key"), a4 = !s4.isConstant(), o6 = o6 || "map" === t6.paint.get("circle-pitch-alignment");
            }
            const l5 = o6 ? e6.subdivisionGranularity.circle : 1;
            for (const { feature: e7, id: n7, index: o7, sourceLayerIndex: l6 } of t5) {
              const t6 = this.layers[0]._featureFilter.needGeometry, u4 = ho(e7, t6);
              if (!this.layers[0]._featureFilter.filter(new fs(this.zoom), u4, r8)) continue;
              const c5 = a4 ? s4.evaluate(u4, {}, r8) : void 0, h4 = { id: n7, properties: e7.properties, type: e7.type, sourceLayerIndex: l6, index: o7, geometry: t6 ? u4.geometry : co(e7), patterns: {}, sortKey: c5 };
              i6.push(h4);
            }
            a4 && i6.sort((t6, e7) => t6.sortKey - e7.sortKey);
            for (const n7 of i6) {
              const { geometry: i7, index: s5, sourceLayerIndex: a5 } = n7, o7 = t5[s5].feature;
              this.addFeature(n7, i7, s5, r8, l5), e6.featureIndex.insert(o7, i7, s5, a5, this.index);
            }
          }
          update(t5, e6, r8) {
            this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t5, e6, this.stateDependentLayers, r8);
          }
          isEmpty() {
            return 0 === this.layoutVertexArray.length;
          }
          uploadPending() {
            return !this.uploaded || this.programConfigurations.needsUpload;
          }
          upload(t5) {
            this.uploaded || (this.layoutVertexBuffer = t5.createVertexBuffer(this.layoutVertexArray, Ba), this.indexBuffer = t5.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(t5), this.uploaded = true;
          }
          destroy() {
            this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy());
          }
          addFeature(t5, e6, r8, n6, i6 = 1) {
            let s4;
            switch (i6) {
              case 1:
                s4 = [0, 7];
                break;
              case 3:
                s4 = [0, 2, 5, 7];
                break;
              case 5:
                s4 = [0, 1, 3, 4, 6, 7];
                break;
              case 7:
                s4 = [0, 1, 2, 3, 4, 5, 6, 7];
                break;
              default:
                throw new Error(`Invalid circle bucket granularity: ${i6}; valid values are 1, 3, 5, 7.`);
            }
            const a4 = s4.length;
            for (const r9 of e6) for (const e7 of r9) {
              const r10 = e7.x, n7 = e7.y;
              if (r10 < 0 || r10 >= M4 || n7 < 0 || n7 >= M4) continue;
              const i7 = this.segments.prepareSegment(a4 * a4, this.layoutVertexArray, this.indexArray, t5.sortKey), o6 = i7.vertexLength;
              for (let t6 = 0; t6 < a4; t6++) for (let e8 = 0; e8 < a4; e8++) fo(this.layoutVertexArray, r10, n7, s4[e8], s4[t6]);
              for (let t6 = 0; t6 < a4 - 1; t6++) for (let e8 = 0; e8 < a4 - 1; e8++) {
                const r11 = o6 + t6 * a4 + e8, n8 = o6 + (t6 + 1) * a4 + e8;
                this.indexArray.emplaceBack(r11, n8 + 1, r11 + 1), this.indexArray.emplaceBack(r11, n8, n8 + 1);
              }
              i7.vertexLength += a4 * a4, i7.primitiveLength += (a4 - 1) * (a4 - 1) * 2;
            }
            this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t5, r8, {}, n6);
          }
        }
        function mo(t5, e6) {
          for (let r8 = 0; r8 < t5.length; r8++) if (ko(e6, t5[r8])) return true;
          for (let r8 = 0; r8 < e6.length; r8++) if (ko(t5, e6[r8])) return true;
          return !!bo(t5, e6);
        }
        function go(t5, e6, r8) {
          return !!ko(t5, e6) || !!_o(e6, t5, r8);
        }
        function xo(t5, e6) {
          if (1 === t5.length) return Ao(e6, t5[0]);
          for (let r8 = 0; r8 < e6.length; r8++) {
            const n6 = e6[r8];
            for (let e7 = 0; e7 < n6.length; e7++) if (ko(t5, n6[e7])) return true;
          }
          for (let r8 = 0; r8 < t5.length; r8++) if (Ao(e6, t5[r8])) return true;
          for (let r8 = 0; r8 < e6.length; r8++) if (bo(t5, e6[r8])) return true;
          return false;
        }
        function vo(t5, e6, r8) {
          if (t5.length > 1) {
            if (bo(t5, e6)) return true;
            for (let n6 = 0; n6 < e6.length; n6++) if (_o(e6[n6], t5, r8)) return true;
          }
          for (let n6 = 0; n6 < t5.length; n6++) if (_o(t5[n6], e6, r8)) return true;
          return false;
        }
        function bo(t5, e6) {
          if (0 === t5.length || 0 === e6.length) return false;
          for (let r8 = 0; r8 < t5.length - 1; r8++) {
            const n6 = t5[r8], i6 = t5[r8 + 1];
            for (let t6 = 0; t6 < e6.length - 1; t6++) if (wo(n6, i6, e6[t6], e6[t6 + 1])) return true;
          }
          return false;
        }
        function wo(t5, e6, r8, n6) {
          return N3(t5, r8, n6) !== N3(e6, r8, n6) && N3(t5, e6, r8) !== N3(t5, e6, n6);
        }
        function _o(t5, e6, r8) {
          const n6 = r8 * r8;
          if (1 === e6.length) return t5.distSqr(e6[0]) < n6;
          for (let r9 = 1; r9 < e6.length; r9++) if (So(t5, e6[r9 - 1], e6[r9]) < n6) return true;
          return false;
        }
        function So(t5, e6, r8) {
          const n6 = e6.distSqr(r8);
          if (0 === n6) return t5.distSqr(e6);
          const i6 = ((t5.x - e6.x) * (r8.x - e6.x) + (t5.y - e6.y) * (r8.y - e6.y)) / n6;
          return t5.distSqr(i6 < 0 ? e6 : i6 > 1 ? r8 : r8.sub(e6)._mult(i6)._add(e6));
        }
        function Ao(t5, e6) {
          for (let r8 = 0; r8 < t5.length; r8++) if (ko(t5[r8], e6)) return true;
          return false;
        }
        function ko(t5, e6) {
          let r8 = false;
          for (let n6 = 0, i6 = t5.length - 1; n6 < t5.length; i6 = n6++) {
            const s4 = t5[n6], a4 = t5[i6];
            s4.y > e6.y != a4.y > e6.y && e6.x < (a4.x - s4.x) * (e6.y - s4.y) / (a4.y - s4.y) + s4.x && (r8 = !r8);
          }
          return r8;
        }
        function Mo(t5, e6, r8) {
          const n6 = r8[0], i6 = r8[2];
          if (t5.x < n6.x && e6.x < n6.x || t5.x > i6.x && e6.x > i6.x || t5.y < n6.y && e6.y < n6.y || t5.y > i6.y && e6.y > i6.y) return false;
          const s4 = N3(t5, e6, r8[0]);
          return s4 !== N3(t5, e6, r8[1]) || s4 !== N3(t5, e6, r8[2]) || s4 !== N3(t5, e6, r8[3]);
        }
        function Io(t5, e6, r8) {
          const n6 = e6.paint.get(t5).value;
          return "constant" === n6.kind ? n6.value : r8.programConfigurations.get(e6.id).getMaxValue(t5);
        }
        function zo(t5) {
          return Math.sqrt(t5[0] * t5[0] + t5[1] * t5[1]);
        }
        function Po(t5, e6, r8, n6, i6) {
          if (!e6[0] && !e6[1]) return t5;
          const s4 = l4.convert(e6)._mult(i6);
          "viewport" === r8 && s4._rotate(-n6);
          const a4 = [];
          for (let e7 = 0; e7 < t5.length; e7++) a4.push(t5[e7].sub(s4));
          return a4;
        }
        let Co, Bo;
        Zi("CircleBucket", yo, { omit: ["layers"] });
        var Vo = { get paint() {
          return Bo = Bo || new Is({ "circle-radius": new Ss(dt.paint_circle["circle-radius"]), "circle-color": new Ss(dt.paint_circle["circle-color"]), "circle-blur": new Ss(dt.paint_circle["circle-blur"]), "circle-opacity": new Ss(dt.paint_circle["circle-opacity"]), "circle-translate": new _s(dt.paint_circle["circle-translate"]), "circle-translate-anchor": new _s(dt.paint_circle["circle-translate-anchor"]), "circle-pitch-scale": new _s(dt.paint_circle["circle-pitch-scale"]), "circle-pitch-alignment": new _s(dt.paint_circle["circle-pitch-alignment"]), "circle-stroke-width": new Ss(dt.paint_circle["circle-stroke-width"]), "circle-stroke-color": new Ss(dt.paint_circle["circle-stroke-color"]), "circle-stroke-opacity": new Ss(dt.paint_circle["circle-stroke-opacity"]) });
        }, get layout() {
          return Co = Co || new Is({ "circle-sort-key": new Ss(dt.layout_circle["circle-sort-key"]) });
        } };
        class Eo extends Ps {
          constructor(t5) {
            super(t5, Vo);
          }
          createBucket(t5) {
            return new yo(t5);
          }
          queryRadius(t5) {
            const e6 = t5;
            return Io("circle-radius", this, e6) + Io("circle-stroke-width", this, e6) + zo(this.paint.get("circle-translate"));
          }
          queryIntersectsFeature({ queryGeometry: t5, feature: e6, featureState: r8, geometry: n6, transform: i6, pixelsToTileUnits: s4, unwrappedTileID: a4, getElevation: o6 }) {
            const l5 = Po(t5, this.paint.get("circle-translate"), this.paint.get("circle-translate-anchor"), -i6.bearingInRadians, s4), u4 = this.paint.get("circle-radius").evaluate(e6, r8) + this.paint.get("circle-stroke-width").evaluate(e6, r8), c5 = "map" === this.paint.get("circle-pitch-alignment"), h4 = c5 ? l5 : function(t6, e7, r9, n7) {
              return t6.map((t7) => To(t7, e7, r9, n7));
            }(l5, i6, a4, o6), p4 = c5 ? u4 * s4 : u4;
            for (const t6 of n6) for (const e7 of t6) {
              const t7 = c5 ? e7 : To(e7, i6, a4, o6);
              let r9 = p4;
              const n7 = i6.projectTileCoordinates(e7.x, e7.y, a4, o6).signedDistanceFromCamera;
              if ("viewport" === this.paint.get("circle-pitch-scale") && "map" === this.paint.get("circle-pitch-alignment") ? r9 *= n7 / i6.cameraToCenterDistance : "map" === this.paint.get("circle-pitch-scale") && "viewport" === this.paint.get("circle-pitch-alignment") && (r9 *= i6.cameraToCenterDistance / n7), go(h4, t7, r9)) return true;
            }
            return false;
          }
        }
        function To(t5, e6, r8, n6) {
          const i6 = e6.projectTileCoordinates(t5.x, t5.y, r8, n6).point;
          return new l4((0.5 * i6.x + 0.5) * e6.width, (0.5 * -i6.y + 0.5) * e6.height);
        }
        class Fo extends yo {
        }
        let $o;
        Zi("HeatmapBucket", Fo, { omit: ["layers"] });
        var Lo = { get paint() {
          return $o = $o || new Is({ "heatmap-radius": new Ss(dt.paint_heatmap["heatmap-radius"]), "heatmap-weight": new Ss(dt.paint_heatmap["heatmap-weight"]), "heatmap-intensity": new _s(dt.paint_heatmap["heatmap-intensity"]), "heatmap-color": new Ms(dt.paint_heatmap["heatmap-color"]), "heatmap-opacity": new _s(dt.paint_heatmap["heatmap-opacity"]) });
        } };
        function Oo(t5, { width: e6, height: r8 }, n6, i6) {
          if (i6) {
            if (i6 instanceof Uint8ClampedArray) i6 = new Uint8Array(i6.buffer);
            else if (i6.length !== e6 * r8 * n6) throw new RangeError(`mismatched image size. expected: ${i6.length} but got: ${e6 * r8 * n6}`);
          } else i6 = new Uint8Array(e6 * r8 * n6);
          return t5.width = e6, t5.height = r8, t5.data = i6, t5;
        }
        function Do(t5, { width: e6, height: r8 }, n6) {
          if (e6 === t5.width && r8 === t5.height) return;
          const i6 = Oo({}, { width: e6, height: r8 }, n6);
          Ro(t5, i6, { x: 0, y: 0 }, { x: 0, y: 0 }, { width: Math.min(t5.width, e6), height: Math.min(t5.height, r8) }, n6), t5.width = e6, t5.height = r8, t5.data = i6.data;
        }
        function Ro(t5, e6, r8, n6, i6, s4) {
          if (0 === i6.width || 0 === i6.height) return e6;
          if (i6.width > t5.width || i6.height > t5.height || r8.x > t5.width - i6.width || r8.y > t5.height - i6.height) throw new RangeError("out of range source coordinates for image copy");
          if (i6.width > e6.width || i6.height > e6.height || n6.x > e6.width - i6.width || n6.y > e6.height - i6.height) throw new RangeError("out of range destination coordinates for image copy");
          const a4 = t5.data, o6 = e6.data;
          if (a4 === o6) throw new Error("srcData equals dstData, so image is already copied");
          for (let l5 = 0; l5 < i6.height; l5++) {
            const u4 = ((r8.y + l5) * t5.width + r8.x) * s4, c5 = ((n6.y + l5) * e6.width + n6.x) * s4;
            for (let t6 = 0; t6 < i6.width * s4; t6++) o6[c5 + t6] = a4[u4 + t6];
          }
          return e6;
        }
        class jo {
          constructor(t5, e6) {
            Oo(this, t5, 1, e6);
          }
          resize(t5) {
            Do(this, t5, 1);
          }
          clone() {
            return new jo({ width: this.width, height: this.height }, new Uint8Array(this.data));
          }
          static copy(t5, e6, r8, n6, i6) {
            Ro(t5, e6, r8, n6, i6, 1);
          }
        }
        class No {
          constructor(t5, e6) {
            Oo(this, t5, 4, e6);
          }
          resize(t5) {
            Do(this, t5, 4);
          }
          replace(t5, e6) {
            e6 ? this.data.set(t5) : this.data = t5 instanceof Uint8ClampedArray ? new Uint8Array(t5.buffer) : t5;
          }
          clone() {
            return new No({ width: this.width, height: this.height }, new Uint8Array(this.data));
          }
          static copy(t5, e6, r8, n6, i6) {
            Ro(t5, e6, r8, n6, i6, 4);
          }
        }
        function Uo(t5) {
          const e6 = {}, r8 = t5.resolution || 256, n6 = t5.clips ? t5.clips.length : 1, i6 = t5.image || new No({ width: r8, height: n6 });
          if (Math.log(r8) / Math.LN2 % 1 != 0) throw new Error(`width is not a power of 2 - ${r8}`);
          const s4 = (r9, n7, s5) => {
            e6[t5.evaluationKey] = s5;
            const a4 = t5.expression.evaluate(e6);
            i6.data[r9 + n7 + 0] = Math.floor(255 * a4.r / a4.a), i6.data[r9 + n7 + 1] = Math.floor(255 * a4.g / a4.a), i6.data[r9 + n7 + 2] = Math.floor(255 * a4.b / a4.a), i6.data[r9 + n7 + 3] = Math.floor(255 * a4.a);
          };
          if (t5.clips) for (let e7 = 0, i7 = 0; e7 < n6; ++e7, i7 += 4 * r8) for (let n7 = 0, a4 = 0; n7 < r8; n7++, a4 += 4) {
            const o6 = n7 / (r8 - 1), { start: l5, end: u4 } = t5.clips[e7];
            s4(i7, a4, l5 * (1 - o6) + u4 * o6);
          }
          else for (let t6 = 0, e7 = 0; t6 < r8; t6++, e7 += 4) s4(0, e7, t6 / (r8 - 1));
          return i6;
        }
        Zi("AlphaImage", jo), Zi("RGBAImage", No);
        const qo = "big-fb";
        class Go extends Ps {
          createBucket(t5) {
            return new Fo(t5);
          }
          constructor(t5) {
            super(t5, Lo), this.heatmapFbos = /* @__PURE__ */ new Map(), this._updateColorRamp();
          }
          _handleSpecialPaintPropertyUpdate(t5) {
            "heatmap-color" === t5 && this._updateColorRamp();
          }
          _updateColorRamp() {
            this.colorRamp = Uo({ expression: this._transitionablePaint._values["heatmap-color"].value.expression, evaluationKey: "heatmapDensity", image: this.colorRamp }), this.colorRampTexture = null;
          }
          resize() {
            this.heatmapFbos.has(qo) && this.heatmapFbos.delete(qo);
          }
          queryRadius() {
            return 0;
          }
          queryIntersectsFeature() {
            return false;
          }
          hasOffscreenPass() {
            return 0 !== this.paint.get("heatmap-opacity") && "none" !== this.visibility;
          }
        }
        let Zo;
        var Ko = { get paint() {
          return Zo = Zo || new Is({ "hillshade-illumination-direction": new _s(dt.paint_hillshade["hillshade-illumination-direction"]), "hillshade-illumination-anchor": new _s(dt.paint_hillshade["hillshade-illumination-anchor"]), "hillshade-exaggeration": new _s(dt.paint_hillshade["hillshade-exaggeration"]), "hillshade-shadow-color": new _s(dt.paint_hillshade["hillshade-shadow-color"]), "hillshade-highlight-color": new _s(dt.paint_hillshade["hillshade-highlight-color"]), "hillshade-accent-color": new _s(dt.paint_hillshade["hillshade-accent-color"]) });
        } };
        class Xo extends Ps {
          constructor(t5) {
            super(t5, Ko);
          }
          hasOffscreenPass() {
            return 0 !== this.paint.get("hillshade-exaggeration") && "none" !== this.visibility;
          }
        }
        const Ho = Es([{ name: "a_pos", components: 2, type: "Int16" }], 4), { members: Yo } = Ho;
        function Jo(t5, e6, r8) {
          const n6 = r8.patternDependencies;
          let i6 = false;
          for (const r9 of e6) {
            const e7 = r9.paint.get(`${t5}-pattern`);
            e7.isConstant() || (i6 = true);
            const s4 = e7.constantOr(null);
            s4 && (i6 = true, n6[s4.to] = true, n6[s4.from] = true);
          }
          return i6;
        }
        function Wo(t5, e6, r8, n6, i6) {
          const s4 = i6.patternDependencies;
          for (const a4 of e6) {
            const e7 = a4.paint.get(`${t5}-pattern`).value;
            if ("constant" !== e7.kind) {
              let t6 = e7.evaluate({ zoom: n6 - 1 }, r8, {}, i6.availableImages), o6 = e7.evaluate({ zoom: n6 }, r8, {}, i6.availableImages), l5 = e7.evaluate({ zoom: n6 + 1 }, r8, {}, i6.availableImages);
              t6 = t6 && t6.name ? t6.name : t6, o6 = o6 && o6.name ? o6.name : o6, l5 = l5 && l5.name ? l5.name : l5, s4[t6] = true, s4[o6] = true, s4[l5] = true, r8.patterns[a4.id] = { min: t6, mid: o6, max: l5 };
            }
          }
          return r8;
        }
        function Qo(t5, e6, r8, n6, i6) {
          let s4;
          if (i6 === function(t6, e7, r9, n7) {
            let i7 = 0;
            for (let s5 = e7, a4 = r9 - n7; s5 < r9; s5 += n7) i7 += (t6[a4] - t6[s5]) * (t6[s5 + 1] + t6[a4 + 1]), a4 = s5;
            return i7;
          }(t5, e6, r8, n6) > 0) for (let i7 = e6; i7 < r8; i7 += n6) s4 = wl(i7 / n6 | 0, t5[i7], t5[i7 + 1], s4);
          else for (let i7 = r8 - n6; i7 >= e6; i7 -= n6) s4 = wl(i7 / n6 | 0, t5[i7], t5[i7 + 1], s4);
          return s4 && yl(s4, s4.next) && (_l(s4), s4 = s4.next), s4;
        }
        function tl(t5, e6) {
          if (!t5) return t5;
          e6 || (e6 = t5);
          let r8, n6 = t5;
          do {
            if (r8 = false, n6.steiner || !yl(n6, n6.next) && 0 !== dl(n6.prev, n6, n6.next)) n6 = n6.next;
            else {
              if (_l(n6), n6 = e6 = n6.prev, n6 === n6.next) break;
              r8 = true;
            }
          } while (r8 || n6 !== e6);
          return e6;
        }
        function el(t5, e6, r8, n6, i6, s4, a4) {
          if (!t5) return;
          !a4 && s4 && function(t6, e7, r9, n7) {
            let i7 = t6;
            do {
              0 === i7.z && (i7.z = ul(i7.x, i7.y, e7, r9, n7)), i7.prevZ = i7.prev, i7.nextZ = i7.next, i7 = i7.next;
            } while (i7 !== t6);
            i7.prevZ.nextZ = null, i7.prevZ = null, function(t7) {
              let e8, r10 = 1;
              do {
                let n8, i8 = t7;
                t7 = null;
                let s5 = null;
                for (e8 = 0; i8; ) {
                  e8++;
                  let a5 = i8, o7 = 0;
                  for (let t8 = 0; t8 < r10 && (o7++, a5 = a5.nextZ, a5); t8++) ;
                  let l5 = r10;
                  for (; o7 > 0 || l5 > 0 && a5; ) 0 !== o7 && (0 === l5 || !a5 || i8.z <= a5.z) ? (n8 = i8, i8 = i8.nextZ, o7--) : (n8 = a5, a5 = a5.nextZ, l5--), s5 ? s5.nextZ = n8 : t7 = n8, n8.prevZ = s5, s5 = n8;
                  i8 = a5;
                }
                s5.nextZ = null, r10 *= 2;
              } while (e8 > 1);
            }(i7);
          }(t5, n6, i6, s4);
          let o6 = t5;
          for (; t5.prev !== t5.next; ) {
            const l5 = t5.prev, u4 = t5.next;
            if (s4 ? nl(t5, n6, i6, s4) : rl(t5)) e6.push(l5.i, t5.i, u4.i), _l(t5), t5 = u4.next, o6 = u4.next;
            else if ((t5 = u4) === o6) {
              a4 ? 1 === a4 ? el(t5 = il(tl(t5), e6), e6, r8, n6, i6, s4, 2) : 2 === a4 && sl(t5, e6, r8, n6, i6, s4) : el(tl(t5), e6, r8, n6, i6, s4, 1);
              break;
            }
          }
        }
        function rl(t5) {
          const e6 = t5.prev, r8 = t5, n6 = t5.next;
          if (dl(e6, r8, n6) >= 0) return false;
          const i6 = e6.x, s4 = r8.x, a4 = n6.x, o6 = e6.y, l5 = r8.y, u4 = n6.y, c5 = Math.min(i6, s4, a4), h4 = Math.min(o6, l5, u4), p4 = Math.max(i6, s4, a4), f4 = Math.max(o6, l5, u4);
          let d4 = n6.next;
          for (; d4 !== e6; ) {
            if (d4.x >= c5 && d4.x <= p4 && d4.y >= h4 && d4.y <= f4 && pl(i6, o6, s4, l5, a4, u4, d4.x, d4.y) && dl(d4.prev, d4, d4.next) >= 0) return false;
            d4 = d4.next;
          }
          return true;
        }
        function nl(t5, e6, r8, n6) {
          const i6 = t5.prev, s4 = t5, a4 = t5.next;
          if (dl(i6, s4, a4) >= 0) return false;
          const o6 = i6.x, l5 = s4.x, u4 = a4.x, c5 = i6.y, h4 = s4.y, p4 = a4.y, f4 = Math.min(o6, l5, u4), d4 = Math.min(c5, h4, p4), y4 = Math.max(o6, l5, u4), m4 = Math.max(c5, h4, p4), g4 = ul(f4, d4, e6, r8, n6), x4 = ul(y4, m4, e6, r8, n6);
          let v4 = t5.prevZ, b5 = t5.nextZ;
          for (; v4 && v4.z >= g4 && b5 && b5.z <= x4; ) {
            if (v4.x >= f4 && v4.x <= y4 && v4.y >= d4 && v4.y <= m4 && v4 !== i6 && v4 !== a4 && pl(o6, c5, l5, h4, u4, p4, v4.x, v4.y) && dl(v4.prev, v4, v4.next) >= 0) return false;
            if (v4 = v4.prevZ, b5.x >= f4 && b5.x <= y4 && b5.y >= d4 && b5.y <= m4 && b5 !== i6 && b5 !== a4 && pl(o6, c5, l5, h4, u4, p4, b5.x, b5.y) && dl(b5.prev, b5, b5.next) >= 0) return false;
            b5 = b5.nextZ;
          }
          for (; v4 && v4.z >= g4; ) {
            if (v4.x >= f4 && v4.x <= y4 && v4.y >= d4 && v4.y <= m4 && v4 !== i6 && v4 !== a4 && pl(o6, c5, l5, h4, u4, p4, v4.x, v4.y) && dl(v4.prev, v4, v4.next) >= 0) return false;
            v4 = v4.prevZ;
          }
          for (; b5 && b5.z <= x4; ) {
            if (b5.x >= f4 && b5.x <= y4 && b5.y >= d4 && b5.y <= m4 && b5 !== i6 && b5 !== a4 && pl(o6, c5, l5, h4, u4, p4, b5.x, b5.y) && dl(b5.prev, b5, b5.next) >= 0) return false;
            b5 = b5.nextZ;
          }
          return true;
        }
        function il(t5, e6) {
          let r8 = t5;
          do {
            const n6 = r8.prev, i6 = r8.next.next;
            !yl(n6, i6) && ml(n6, r8, r8.next, i6) && vl(n6, i6) && vl(i6, n6) && (e6.push(n6.i, r8.i, i6.i), _l(r8), _l(r8.next), r8 = t5 = i6), r8 = r8.next;
          } while (r8 !== t5);
          return tl(r8);
        }
        function sl(t5, e6, r8, n6, i6, s4) {
          let a4 = t5;
          do {
            let t6 = a4.next.next;
            for (; t6 !== a4.prev; ) {
              if (a4.i !== t6.i && fl2(a4, t6)) {
                let o6 = bl(a4, t6);
                return a4 = tl(a4, a4.next), o6 = tl(o6, o6.next), el(a4, e6, r8, n6, i6, s4, 0), void el(o6, e6, r8, n6, i6, s4, 0);
              }
              t6 = t6.next;
            }
            a4 = a4.next;
          } while (a4 !== t5);
        }
        function al(t5, e6) {
          let r8 = t5.x - e6.x;
          return 0 === r8 && (r8 = t5.y - e6.y, 0 === r8) && (r8 = (t5.next.y - t5.y) / (t5.next.x - t5.x) - (e6.next.y - e6.y) / (e6.next.x - e6.x)), r8;
        }
        function ol(t5, e6) {
          const r8 = function(t6, e7) {
            let r9 = e7;
            const n7 = t6.x, i6 = t6.y;
            let s4, a4 = -1 / 0;
            if (yl(t6, r9)) return r9;
            do {
              if (yl(t6, r9.next)) return r9.next;
              if (i6 <= r9.y && i6 >= r9.next.y && r9.next.y !== r9.y) {
                const t7 = r9.x + (i6 - r9.y) * (r9.next.x - r9.x) / (r9.next.y - r9.y);
                if (t7 <= n7 && t7 > a4 && (a4 = t7, s4 = r9.x < r9.next.x ? r9 : r9.next, t7 === n7)) return s4;
              }
              r9 = r9.next;
            } while (r9 !== e7);
            if (!s4) return null;
            const o6 = s4, l5 = s4.x, u4 = s4.y;
            let c5 = 1 / 0;
            r9 = s4;
            do {
              if (n7 >= r9.x && r9.x >= l5 && n7 !== r9.x && hl(i6 < u4 ? n7 : a4, i6, l5, u4, i6 < u4 ? a4 : n7, i6, r9.x, r9.y)) {
                const e8 = Math.abs(i6 - r9.y) / (n7 - r9.x);
                vl(r9, t6) && (e8 < c5 || e8 === c5 && (r9.x > s4.x || r9.x === s4.x && ll(s4, r9))) && (s4 = r9, c5 = e8);
              }
              r9 = r9.next;
            } while (r9 !== o6);
            return s4;
          }(t5, e6);
          if (!r8) return e6;
          const n6 = bl(r8, t5);
          return tl(n6, n6.next), tl(r8, r8.next);
        }
        function ll(t5, e6) {
          return dl(t5.prev, t5, e6.prev) < 0 && dl(e6.next, t5, t5.next) < 0;
        }
        function ul(t5, e6, r8, n6, i6) {
          return (t5 = 1431655765 & ((t5 = 858993459 & ((t5 = 252645135 & ((t5 = 16711935 & ((t5 = (t5 - r8) * i6 | 0) | t5 << 8)) | t5 << 4)) | t5 << 2)) | t5 << 1)) | (e6 = 1431655765 & ((e6 = 858993459 & ((e6 = 252645135 & ((e6 = 16711935 & ((e6 = (e6 - n6) * i6 | 0) | e6 << 8)) | e6 << 4)) | e6 << 2)) | e6 << 1)) << 1;
        }
        function cl(t5) {
          let e6 = t5, r8 = t5;
          do {
            (e6.x < r8.x || e6.x === r8.x && e6.y < r8.y) && (r8 = e6), e6 = e6.next;
          } while (e6 !== t5);
          return r8;
        }
        function hl(t5, e6, r8, n6, i6, s4, a4, o6) {
          return (i6 - a4) * (e6 - o6) >= (t5 - a4) * (s4 - o6) && (t5 - a4) * (n6 - o6) >= (r8 - a4) * (e6 - o6) && (r8 - a4) * (s4 - o6) >= (i6 - a4) * (n6 - o6);
        }
        function pl(t5, e6, r8, n6, i6, s4, a4, o6) {
          return !(t5 === a4 && e6 === o6) && hl(t5, e6, r8, n6, i6, s4, a4, o6);
        }
        function fl2(t5, e6) {
          return t5.next.i !== e6.i && t5.prev.i !== e6.i && !function(t6, e7) {
            let r8 = t6;
            do {
              if (r8.i !== t6.i && r8.next.i !== t6.i && r8.i !== e7.i && r8.next.i !== e7.i && ml(r8, r8.next, t6, e7)) return true;
              r8 = r8.next;
            } while (r8 !== t6);
            return false;
          }(t5, e6) && (vl(t5, e6) && vl(e6, t5) && function(t6, e7) {
            let r8 = t6, n6 = false;
            const i6 = (t6.x + e7.x) / 2, s4 = (t6.y + e7.y) / 2;
            do {
              r8.y > s4 != r8.next.y > s4 && r8.next.y !== r8.y && i6 < (r8.next.x - r8.x) * (s4 - r8.y) / (r8.next.y - r8.y) + r8.x && (n6 = !n6), r8 = r8.next;
            } while (r8 !== t6);
            return n6;
          }(t5, e6) && (dl(t5.prev, t5, e6.prev) || dl(t5, e6.prev, e6)) || yl(t5, e6) && dl(t5.prev, t5, t5.next) > 0 && dl(e6.prev, e6, e6.next) > 0);
        }
        function dl(t5, e6, r8) {
          return (e6.y - t5.y) * (r8.x - e6.x) - (e6.x - t5.x) * (r8.y - e6.y);
        }
        function yl(t5, e6) {
          return t5.x === e6.x && t5.y === e6.y;
        }
        function ml(t5, e6, r8, n6) {
          const i6 = xl(dl(t5, e6, r8)), s4 = xl(dl(t5, e6, n6)), a4 = xl(dl(r8, n6, t5)), o6 = xl(dl(r8, n6, e6));
          return i6 !== s4 && a4 !== o6 || !(0 !== i6 || !gl(t5, r8, e6)) || !(0 !== s4 || !gl(t5, n6, e6)) || !(0 !== a4 || !gl(r8, t5, n6)) || !(0 !== o6 || !gl(r8, e6, n6));
        }
        function gl(t5, e6, r8) {
          return e6.x <= Math.max(t5.x, r8.x) && e6.x >= Math.min(t5.x, r8.x) && e6.y <= Math.max(t5.y, r8.y) && e6.y >= Math.min(t5.y, r8.y);
        }
        function xl(t5) {
          return t5 > 0 ? 1 : t5 < 0 ? -1 : 0;
        }
        function vl(t5, e6) {
          return dl(t5.prev, t5, t5.next) < 0 ? dl(t5, e6, t5.next) >= 0 && dl(t5, t5.prev, e6) >= 0 : dl(t5, e6, t5.prev) < 0 || dl(t5, t5.next, e6) < 0;
        }
        function bl(t5, e6) {
          const r8 = Sl(t5.i, t5.x, t5.y), n6 = Sl(e6.i, e6.x, e6.y), i6 = t5.next, s4 = e6.prev;
          return t5.next = e6, e6.prev = t5, r8.next = i6, i6.prev = r8, n6.next = r8, r8.prev = n6, s4.next = n6, n6.prev = s4, n6;
        }
        function wl(t5, e6, r8, n6) {
          const i6 = Sl(t5, e6, r8);
          return n6 ? (i6.next = n6.next, i6.prev = n6, n6.next.prev = i6, n6.next = i6) : (i6.prev = i6, i6.next = i6), i6;
        }
        function _l(t5) {
          t5.next.prev = t5.prev, t5.prev.next = t5.next, t5.prevZ && (t5.prevZ.nextZ = t5.nextZ), t5.nextZ && (t5.nextZ.prevZ = t5.prevZ);
        }
        function Sl(t5, e6, r8) {
          return { i: t5, x: e6, y: r8, prev: null, next: null, z: 0, prevZ: null, nextZ: null, steiner: false };
        }
        class Al {
          constructor(t5, e6) {
            if (e6 > t5) throw new Error("Min granularity must not be greater than base granularity.");
            this._baseZoomGranularity = t5, this._minGranularity = e6;
          }
          getGranularityForZoomLevel(t5) {
            return Math.max(Math.floor(this._baseZoomGranularity / (1 << t5)), this._minGranularity, 1);
          }
        }
        class kl {
          constructor(t5) {
            this.fill = t5.fill, this.line = t5.line, this.tile = t5.tile, this.stencil = t5.stencil, this.circle = t5.circle;
          }
        }
        kl.noSubdivision = new kl({ fill: new Al(0, 0), line: new Al(0, 0), tile: new Al(0, 0), stencil: new Al(0, 0), circle: 1 }), Zi("SubdivisionGranularityExpression", Al), Zi("SubdivisionGranularitySetting", kl);
        const Ml = -32768, Il = 32767;
        class zl {
          constructor(t5, e6) {
            this._vertexBuffer = [], this._vertexDictionary = /* @__PURE__ */ new Map(), this._used = false, this._granularity = t5, this._granularityCellSize = M4 / t5, this._canonical = e6;
          }
          _getKey(t5, e6) {
            return (t5 += 32768) << 16 | (e6 += 32768) << 0;
          }
          _vertexToIndex(t5, e6) {
            if (t5 < -32768 || e6 < -32768 || t5 > 32767 || e6 > 32767) throw new Error("Vertex coordinates are out of signed 16 bit integer range.");
            const r8 = 0 | Math.round(t5), n6 = 0 | Math.round(e6), i6 = this._getKey(r8, n6);
            if (this._vertexDictionary.has(i6)) return this._vertexDictionary.get(i6);
            const s4 = this._vertexBuffer.length / 2;
            return this._vertexDictionary.set(i6, s4), this._vertexBuffer.push(r8, n6), s4;
          }
          _subdivideTrianglesScanline(t5) {
            if (this._granularity < 2) return function(t6, e7) {
              const r9 = [];
              for (let n6 = 0; n6 < e7.length; n6 += 3) {
                const i6 = e7[n6], s4 = e7[n6 + 1], a4 = e7[n6 + 2], o6 = t6[2 * i6], l5 = t6[2 * i6 + 1];
                (t6[2 * s4] - o6) * (t6[2 * a4 + 1] - l5) - (t6[2 * s4 + 1] - l5) * (t6[2 * a4] - o6) > 0 ? (r9.push(i6), r9.push(a4), r9.push(s4)) : (r9.push(i6), r9.push(s4), r9.push(a4));
              }
              return r9;
            }(this._vertexBuffer, t5);
            const e6 = [], r8 = t5.length;
            for (let n6 = 0; n6 < r8; n6 += 3) {
              const r9 = [t5[n6 + 0], t5[n6 + 1], t5[n6 + 2]], i6 = [this._vertexBuffer[2 * t5[n6 + 0] + 0], this._vertexBuffer[2 * t5[n6 + 0] + 1], this._vertexBuffer[2 * t5[n6 + 1] + 0], this._vertexBuffer[2 * t5[n6 + 1] + 1], this._vertexBuffer[2 * t5[n6 + 2] + 0], this._vertexBuffer[2 * t5[n6 + 2] + 1]];
              let s4 = 1 / 0, a4 = 1 / 0, o6 = -1 / 0, l5 = -1 / 0;
              for (let t6 = 0; t6 < 3; t6++) {
                const e7 = i6[2 * t6], r10 = i6[2 * t6 + 1];
                s4 = Math.min(s4, e7), o6 = Math.max(o6, e7), a4 = Math.min(a4, r10), l5 = Math.max(l5, r10);
              }
              if (s4 === o6 || a4 === l5) continue;
              const u4 = Math.floor(s4 / this._granularityCellSize), c5 = Math.ceil(o6 / this._granularityCellSize), h4 = Math.floor(a4 / this._granularityCellSize), p4 = Math.ceil(l5 / this._granularityCellSize);
              if (u4 !== c5 || h4 !== p4) for (let t6 = h4; t6 < p4; t6++) {
                const n7 = this._scanlineGenerateVertexRingForCellRow(t6, i6, r9);
                Bl(this._vertexBuffer, n7, e6);
              }
              else e6.push(...r9);
            }
            return e6;
          }
          _scanlineGenerateVertexRingForCellRow(t5, e6, r8) {
            const n6 = t5 * this._granularityCellSize, i6 = n6 + this._granularityCellSize, s4 = [];
            for (let t6 = 0; t6 < 3; t6++) {
              const a4 = e6[2 * t6], o6 = e6[2 * t6 + 1], l5 = e6[2 * (t6 + 1) % 6], u4 = e6[(2 * (t6 + 1) + 1) % 6], c5 = e6[2 * (t6 + 2) % 6], h4 = e6[(2 * (t6 + 2) + 1) % 6], p4 = l5 - a4, f4 = u4 - o6, d4 = 0 === p4, y4 = 0 === f4, m4 = (n6 - o6) / f4, g4 = (i6 - o6) / f4, x4 = Math.min(m4, g4), v4 = Math.max(m4, g4);
              if (!y4 && (x4 >= 1 || v4 <= 0) || y4 && (o6 < n6 || o6 > i6)) {
                u4 >= n6 && u4 <= i6 && s4.push(r8[(t6 + 1) % 3]);
                continue;
              }
              !y4 && x4 > 0 && s4.push(this._vertexToIndex(a4 + p4 * x4, o6 + f4 * x4));
              const b5 = a4 + p4 * Math.max(x4, 0), w4 = a4 + p4 * Math.min(v4, 1);
              d4 || this._generateIntraEdgeVertices(s4, a4, o6, l5, u4, b5, w4), !y4 && v4 < 1 && s4.push(this._vertexToIndex(a4 + p4 * v4, o6 + f4 * v4)), (y4 || u4 >= n6 && u4 <= i6) && s4.push(r8[(t6 + 1) % 3]), !y4 && (u4 <= n6 || u4 >= i6) && this._generateInterEdgeVertices(s4, a4, o6, l5, u4, c5, h4, w4, n6, i6);
            }
            return s4;
          }
          _generateIntraEdgeVertices(t5, e6, r8, n6, i6, s4, a4) {
            const o6 = n6 - e6, l5 = i6 - r8, u4 = 0 === l5, c5 = u4 ? Math.min(e6, n6) : Math.min(s4, a4), h4 = u4 ? Math.max(e6, n6) : Math.max(s4, a4), p4 = Math.floor(c5 / this._granularityCellSize) + 1, f4 = Math.ceil(h4 / this._granularityCellSize) - 1;
            if (u4 ? e6 < n6 : s4 < a4) for (let n7 = p4; n7 <= f4; n7++) {
              const i7 = n7 * this._granularityCellSize;
              t5.push(this._vertexToIndex(i7, r8 + l5 * (i7 - e6) / o6));
            }
            else for (let n7 = f4; n7 >= p4; n7--) {
              const i7 = n7 * this._granularityCellSize;
              t5.push(this._vertexToIndex(i7, r8 + l5 * (i7 - e6) / o6));
            }
          }
          _generateInterEdgeVertices(t5, e6, r8, n6, i6, s4, a4, o6, l5, u4) {
            const c5 = i6 - r8, h4 = s4 - n6, p4 = a4 - i6, f4 = (l5 - i6) / p4, d4 = (u4 - i6) / p4, y4 = Math.min(f4, d4), m4 = Math.max(f4, d4), g4 = n6 + h4 * y4;
            let x4 = Math.floor(Math.min(g4, o6) / this._granularityCellSize) + 1, v4 = Math.ceil(Math.max(g4, o6) / this._granularityCellSize) - 1, b5 = o6 < g4;
            const w4 = 0 === p4;
            if (w4 && (a4 === l5 || a4 === u4)) return;
            if (w4 || y4 >= 1 || m4 <= 0) {
              const t6 = r8 - a4, n7 = s4 + (e6 - s4) * Math.min((l5 - a4) / t6, (u4 - a4) / t6);
              x4 = Math.floor(Math.min(n7, o6) / this._granularityCellSize) + 1, v4 = Math.ceil(Math.max(n7, o6) / this._granularityCellSize) - 1, b5 = o6 < n7;
            }
            const _4 = c5 > 0 ? u4 : l5;
            if (b5) for (let e7 = x4; e7 <= v4; e7++) t5.push(this._vertexToIndex(e7 * this._granularityCellSize, _4));
            else for (let e7 = v4; e7 >= x4; e7--) t5.push(this._vertexToIndex(e7 * this._granularityCellSize, _4));
          }
          _generateOutline(t5) {
            const e6 = [];
            for (const r8 of t5) {
              const t6 = Cl(r8, this._granularity, true), n6 = this._pointArrayToIndices(t6), i6 = [];
              for (let t7 = 1; t7 < n6.length; t7++) i6.push(n6[t7 - 1]), i6.push(n6[t7]);
              e6.push(i6);
            }
            return e6;
          }
          _handlePoles(t5) {
            let e6 = false, r8 = false;
            this._canonical && (0 === this._canonical.y && (e6 = true), this._canonical.y === (1 << this._canonical.z) - 1 && (r8 = true)), (e6 || r8) && this._fillPoles(t5, e6, r8);
          }
          _ensureNoPoleVertices() {
            const t5 = this._vertexBuffer;
            for (let e6 = 0; e6 < t5.length; e6 += 2) {
              const r8 = t5[e6 + 1];
              r8 === Ml && (t5[e6 + 1] = -32767), r8 === Il && (t5[e6 + 1] = 32766);
            }
          }
          _generatePoleQuad(t5, e6, r8, n6, i6, s4) {
            n6 > i6 != (s4 === Ml) ? (t5.push(e6), t5.push(r8), t5.push(this._vertexToIndex(n6, s4)), t5.push(r8), t5.push(this._vertexToIndex(i6, s4)), t5.push(this._vertexToIndex(n6, s4))) : (t5.push(r8), t5.push(e6), t5.push(this._vertexToIndex(n6, s4)), t5.push(this._vertexToIndex(i6, s4)), t5.push(r8), t5.push(this._vertexToIndex(n6, s4)));
          }
          _fillPoles(t5, e6, r8) {
            const n6 = this._vertexBuffer, i6 = M4, s4 = t5.length;
            for (let a4 = 2; a4 < s4; a4 += 3) {
              const s5 = t5[a4 - 2], o6 = t5[a4 - 1], l5 = t5[a4], u4 = n6[2 * s5], c5 = n6[2 * s5 + 1], h4 = n6[2 * o6], p4 = n6[2 * o6 + 1], f4 = n6[2 * l5], d4 = n6[2 * l5 + 1];
              e6 && (0 === c5 && 0 === p4 && this._generatePoleQuad(t5, s5, o6, u4, h4, Ml), 0 === p4 && 0 === d4 && this._generatePoleQuad(t5, o6, l5, h4, f4, Ml), 0 === d4 && 0 === c5 && this._generatePoleQuad(t5, l5, s5, f4, u4, Ml)), r8 && (c5 === i6 && p4 === i6 && this._generatePoleQuad(t5, s5, o6, u4, h4, Il), p4 === i6 && d4 === i6 && this._generatePoleQuad(t5, o6, l5, h4, f4, Il), d4 === i6 && c5 === i6 && this._generatePoleQuad(t5, l5, s5, f4, u4, Il));
            }
          }
          _initializeVertices(t5) {
            for (let e6 = 0; e6 < t5.length; e6 += 2) this._vertexToIndex(t5[e6], t5[e6 + 1]);
          }
          subdividePolygonInternal(t5, e6) {
            if (this._used) throw new Error("Subdivision: multiple use not allowed.");
            this._used = true;
            const { flattened: r8, holeIndices: n6 } = function(t6) {
              const e7 = [], r9 = [];
              for (const n7 of t6) if (0 !== n7.length) {
                n7 !== t6[0] && e7.push(r9.length / 2);
                for (let t7 = 0; t7 < n7.length; t7++) r9.push(n7[t7].x), r9.push(n7[t7].y);
              }
              return { flattened: r9, holeIndices: e7 };
            }(t5);
            let i6;
            this._initializeVertices(r8);
            try {
              const t6 = function(t7, e8, r9 = 2) {
                const n7 = e8 && e8.length, i7 = n7 ? e8[0] * r9 : t7.length;
                let s5 = Qo(t7, 0, i7, r9, true);
                const a4 = [];
                if (!s5 || s5.next === s5.prev) return a4;
                let o6, l5, u4;
                if (n7 && (s5 = function(t8, e9, r10, n8) {
                  const i8 = [];
                  for (let r11 = 0, s6 = e9.length; r11 < s6; r11++) {
                    const a5 = Qo(t8, e9[r11] * n8, r11 < s6 - 1 ? e9[r11 + 1] * n8 : t8.length, n8, false);
                    a5 === a5.next && (a5.steiner = true), i8.push(cl(a5));
                  }
                  i8.sort(al);
                  for (let t9 = 0; t9 < i8.length; t9++) r10 = ol(i8[t9], r10);
                  return r10;
                }(t7, e8, s5, r9)), t7.length > 80 * r9) {
                  o6 = 1 / 0, l5 = 1 / 0;
                  let e9 = -1 / 0, n8 = -1 / 0;
                  for (let s6 = r9; s6 < i7; s6 += r9) {
                    const r10 = t7[s6], i8 = t7[s6 + 1];
                    r10 < o6 && (o6 = r10), i8 < l5 && (l5 = i8), r10 > e9 && (e9 = r10), i8 > n8 && (n8 = i8);
                  }
                  u4 = Math.max(e9 - o6, n8 - l5), u4 = 0 !== u4 ? 32767 / u4 : 0;
                }
                return el(s5, a4, r9, o6, l5, u4, 0), a4;
              }(r8, n6), e7 = this._convertIndices(r8, t6);
              i6 = this._subdivideTrianglesScanline(e7);
            } catch (t6) {
              console.error(t6);
            }
            let s4 = [];
            return e6 && (s4 = this._generateOutline(t5)), this._ensureNoPoleVertices(), this._handlePoles(i6), { verticesFlattened: this._vertexBuffer, indicesTriangles: i6, indicesLineList: s4 };
          }
          _convertIndices(t5, e6) {
            const r8 = [];
            for (let n6 = 0; n6 < e6.length; n6++) r8.push(this._vertexToIndex(t5[2 * e6[n6]], t5[2 * e6[n6] + 1]));
            return r8;
          }
          _pointArrayToIndices(t5) {
            const e6 = [];
            for (let r8 = 0; r8 < t5.length; r8++) {
              const n6 = t5[r8];
              e6.push(this._vertexToIndex(n6.x, n6.y));
            }
            return e6;
          }
        }
        function Pl(t5, e6, r8, n6 = true) {
          return new zl(r8, e6).subdividePolygonInternal(t5, n6);
        }
        function Cl(t5, e6, r8 = false) {
          if (!t5 || t5.length < 1) return [];
          if (t5.length < 2) return [];
          const n6 = t5[0], i6 = t5[t5.length - 1], s4 = r8 && (n6.x !== i6.x || n6.y !== i6.y);
          if (e6 < 2) return s4 ? [...t5, t5[0]] : [...t5];
          const a4 = Math.floor(M4 / e6), o6 = [];
          o6.push(new l4(t5[0].x, t5[0].y));
          const u4 = t5.length, c5 = s4 ? u4 : u4 - 1;
          for (let e7 = 0; e7 < c5; e7++) {
            const r9 = t5[e7], n7 = e7 < u4 - 1 ? t5[e7 + 1] : t5[0], i7 = r9.x, s5 = r9.y, c6 = n7.x, h4 = n7.y, p4 = i7 !== c6, f4 = s5 !== h4;
            if (!p4 && !f4) continue;
            const d4 = c6 - i7, y4 = h4 - s5, m4 = Math.abs(d4), g4 = Math.abs(y4);
            let x4 = i7, v4 = s5;
            for (; ; ) {
              const t6 = d4 > 0 ? (Math.floor(x4 / a4) + 1) * a4 : (Math.ceil(x4 / a4) - 1) * a4, e8 = y4 > 0 ? (Math.floor(v4 / a4) + 1) * a4 : (Math.ceil(v4 / a4) - 1) * a4, r10 = Math.abs(x4 - t6), n8 = Math.abs(v4 - e8), i8 = Math.abs(x4 - c6), s6 = Math.abs(v4 - h4), u5 = p4 ? r10 / m4 : Number.POSITIVE_INFINITY, b6 = f4 ? n8 / g4 : Number.POSITIVE_INFINITY;
              if ((i8 <= r10 || !p4) && (s6 <= n8 || !f4)) break;
              if (u5 < b6 && p4 || !f4) {
                x4 = t6, v4 += y4 * u5;
                const e9 = new l4(x4, Math.round(v4));
                o6[o6.length - 1].x === e9.x && o6[o6.length - 1].y === e9.y || o6.push(e9);
              } else {
                x4 += d4 * b6, v4 = e8;
                const t7 = new l4(Math.round(x4), v4);
                o6[o6.length - 1].x === t7.x && o6[o6.length - 1].y === t7.y || o6.push(t7);
              }
            }
            const b5 = new l4(c6, h4);
            o6[o6.length - 1].x === b5.x && o6[o6.length - 1].y === b5.y || o6.push(b5);
          }
          return o6;
        }
        function Bl(t5, e6, r8) {
          if (0 === e6.length) throw new Error("Subdivision vertex ring is empty.");
          let n6 = 0, i6 = t5[2 * e6[0]];
          for (let r9 = 1; r9 < e6.length; r9++) {
            const s5 = t5[2 * e6[r9]];
            s5 < i6 && (i6 = s5, n6 = r9);
          }
          const s4 = e6.length;
          let a4 = n6, o6 = (a4 + 1) % s4;
          for (; ; ) {
            const n7 = a4 - 1 >= 0 ? a4 - 1 : s4 - 1, i7 = (o6 + 1) % s4, l5 = t5[2 * e6[n7]], u4 = t5[2 * e6[i7]], c5 = t5[2 * e6[a4]], h4 = t5[2 * e6[a4] + 1], p4 = t5[2 * e6[o6] + 1];
            let f4 = false;
            if (l5 < u4) f4 = true;
            else if (l5 > u4) f4 = false;
            else {
              const r9 = p4 - h4, s5 = -(t5[2 * e6[o6]] - c5), a5 = h4 < p4 ? 1 : -1;
              ((l5 - c5) * r9 + (t5[2 * e6[n7] + 1] - h4) * s5) * a5 > ((u4 - c5) * r9 + (t5[2 * e6[i7] + 1] - h4) * s5) * a5 && (f4 = true);
            }
            if (f4) {
              const t6 = e6[n7], i8 = e6[a4], l6 = e6[o6];
              t6 !== i8 && t6 !== l6 && i8 !== l6 && r8.push(l6, i8, t6), a4--, a4 < 0 && (a4 = s4 - 1);
            } else {
              const t6 = e6[i7], n8 = e6[a4], l6 = e6[o6];
              t6 !== n8 && t6 !== l6 && n8 !== l6 && r8.push(l6, n8, t6), o6++, o6 >= s4 && (o6 = 0);
            }
            if (n7 === i7) break;
          }
        }
        function Vl(t5, e6, r8, n6, i6, s4, a4, o6, l5) {
          const u4 = i6.length / 2, c5 = a4 && o6 && l5;
          if (u4 < Va.MAX_VERTEX_ARRAY_LENGTH) {
            const h4 = e6.prepareSegment(u4, r8, n6), p4 = h4.vertexLength;
            for (let t6 = 0; t6 < s4.length; t6 += 3) n6.emplaceBack(p4 + s4[t6], p4 + s4[t6 + 1], p4 + s4[t6 + 2]);
            let f4, d4;
            h4.vertexLength += u4, h4.primitiveLength += s4.length / 3, c5 && (d4 = a4.prepareSegment(u4, r8, o6), f4 = d4.vertexLength, d4.vertexLength += u4);
            for (let e7 = 0; e7 < i6.length; e7 += 2) t5(i6[e7], i6[e7 + 1]);
            if (c5) for (let t6 = 0; t6 < l5.length; t6++) {
              const e7 = l5[t6];
              for (let t7 = 1; t7 < e7.length; t7 += 2) o6.emplaceBack(f4 + e7[t7 - 1], f4 + e7[t7]);
              d4.primitiveLength += e7.length / 2;
            }
          } else !function(t6, e7, r9, n7, i7, s5) {
            const a5 = [];
            for (let t7 = 0; t7 < n7.length / 2; t7++) a5.push(-1);
            const o7 = { count: 0 };
            let l6 = 0, u5 = t6.getOrCreateLatestSegment(e7, r9), c6 = u5.vertexLength;
            for (let h4 = 2; h4 < i7.length; h4 += 3) {
              const p4 = i7[h4 - 2], f4 = i7[h4 - 1], d4 = i7[h4];
              let y4 = a5[p4] < l6, m4 = a5[f4] < l6, g4 = a5[d4] < l6;
              u5.vertexLength + ((y4 ? 1 : 0) + (m4 ? 1 : 0) + (g4 ? 1 : 0)) > Va.MAX_VERTEX_ARRAY_LENGTH && (u5 = t6.createNewSegment(e7, r9), l6 = o7.count, y4 = true, m4 = true, g4 = true, c6 = 0);
              const x4 = El(a5, n7, s5, o7, p4, y4, u5), v4 = El(a5, n7, s5, o7, f4, m4, u5), b5 = El(a5, n7, s5, o7, d4, g4, u5);
              r9.emplaceBack(c6 + x4 - l6, c6 + v4 - l6, c6 + b5 - l6), u5.primitiveLength++;
            }
          }(e6, r8, n6, i6, s4, t5), c5 && function(t6, e7, r9, n7, i7, s5) {
            const a5 = [];
            for (let t7 = 0; t7 < n7.length / 2; t7++) a5.push(-1);
            const o7 = { count: 0 };
            let l6 = 0, u5 = t6.getOrCreateLatestSegment(e7, r9), c6 = u5.vertexLength;
            for (let h4 = 0; h4 < i7.length; h4++) {
              const p4 = i7[h4];
              for (let f4 = 1; f4 < i7[h4].length; f4 += 2) {
                const i8 = p4[f4 - 1], h5 = p4[f4];
                let d4 = a5[i8] < l6, y4 = a5[h5] < l6;
                u5.vertexLength + ((d4 ? 1 : 0) + (y4 ? 1 : 0)) > Va.MAX_VERTEX_ARRAY_LENGTH && (u5 = t6.createNewSegment(e7, r9), l6 = o7.count, d4 = true, y4 = true, c6 = 0);
                const m4 = El(a5, n7, s5, o7, i8, d4, u5), g4 = El(a5, n7, s5, o7, h5, y4, u5);
                r9.emplaceBack(c6 + m4 - l6, c6 + g4 - l6), u5.primitiveLength++;
              }
            }
          }(a4, r8, o6, i6, l5, t5), e6.forceNewSegmentOnNextPrepare(), null == a4 || a4.forceNewSegmentOnNextPrepare();
        }
        function El(t5, e6, r8, n6, i6, s4, a4) {
          if (s4) {
            const s5 = n6.count;
            return r8(e6[2 * i6], e6[2 * i6 + 1]), t5[i6] = n6.count, n6.count++, a4.vertexLength++, s5;
          }
          return t5[i6];
        }
        class Tl {
          constructor(t5) {
            this.zoom = t5.zoom, this.overscaling = t5.overscaling, this.layers = t5.layers, this.layerIds = this.layers.map((t6) => t6.id), this.index = t5.index, this.hasPattern = false, this.patternFeatures = [], this.layoutVertexArray = new xa(), this.indexArray = new za(), this.indexArray2 = new Pa(), this.programConfigurations = new so(t5.layers, t5.zoom), this.segments = new Va(), this.segments2 = new Va(), this.stateDependentLayerIds = this.layers.filter((t6) => t6.isStateDependent()).map((t6) => t6.id);
          }
          populate(t5, e6, r8) {
            this.hasPattern = Jo("fill", this.layers, e6);
            const n6 = this.layers[0].layout.get("fill-sort-key"), i6 = !n6.isConstant(), s4 = [];
            for (const { feature: a4, id: o6, index: l5, sourceLayerIndex: u4 } of t5) {
              const t6 = this.layers[0]._featureFilter.needGeometry, c5 = ho(a4, t6);
              if (!this.layers[0]._featureFilter.filter(new fs(this.zoom), c5, r8)) continue;
              const h4 = i6 ? n6.evaluate(c5, {}, r8, e6.availableImages) : void 0, p4 = { id: o6, properties: a4.properties, type: a4.type, sourceLayerIndex: u4, index: l5, geometry: t6 ? c5.geometry : co(a4), patterns: {}, sortKey: h4 };
              s4.push(p4);
            }
            i6 && s4.sort((t6, e7) => t6.sortKey - e7.sortKey);
            for (const n7 of s4) {
              const { geometry: i7, index: s5, sourceLayerIndex: a4 } = n7;
              if (this.hasPattern) {
                const t6 = Wo("fill", this.layers, n7, this.zoom, e6);
                this.patternFeatures.push(t6);
              } else this.addFeature(n7, i7, s5, r8, {}, e6.subdivisionGranularity);
              e6.featureIndex.insert(t5[s5].feature, i7, s5, a4, this.index);
            }
          }
          update(t5, e6, r8) {
            this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t5, e6, this.stateDependentLayers, r8);
          }
          addFeatures(t5, e6, r8) {
            for (const n6 of this.patternFeatures) this.addFeature(n6, n6.geometry, n6.index, e6, r8, t5.subdivisionGranularity);
          }
          isEmpty() {
            return 0 === this.layoutVertexArray.length;
          }
          uploadPending() {
            return !this.uploaded || this.programConfigurations.needsUpload;
          }
          upload(t5) {
            this.uploaded || (this.layoutVertexBuffer = t5.createVertexBuffer(this.layoutVertexArray, Yo), this.indexBuffer = t5.createIndexBuffer(this.indexArray), this.indexBuffer2 = t5.createIndexBuffer(this.indexArray2)), this.programConfigurations.upload(t5), this.uploaded = true;
          }
          destroy() {
            this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.indexBuffer2.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.segments2.destroy());
          }
          addFeature(t5, e6, r8, n6, i6, s4) {
            for (const t6 of Ur(e6, 500)) {
              const e7 = Pl(t6, n6, s4.fill.getGranularityForZoomLevel(n6.z)), r9 = this.layoutVertexArray;
              Vl((t7, e8) => {
                r9.emplaceBack(t7, e8);
              }, this.segments, this.layoutVertexArray, this.indexArray, e7.verticesFlattened, e7.indicesTriangles, this.segments2, this.indexArray2, e7.indicesLineList);
            }
            this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t5, r8, i6, n6);
          }
        }
        let Fl, $l;
        Zi("FillBucket", Tl, { omit: ["layers", "patternFeatures"] });
        var Ll = { get paint() {
          return $l = $l || new Is({ "fill-antialias": new _s(dt.paint_fill["fill-antialias"]), "fill-opacity": new Ss(dt.paint_fill["fill-opacity"]), "fill-color": new Ss(dt.paint_fill["fill-color"]), "fill-outline-color": new Ss(dt.paint_fill["fill-outline-color"]), "fill-translate": new _s(dt.paint_fill["fill-translate"]), "fill-translate-anchor": new _s(dt.paint_fill["fill-translate-anchor"]), "fill-pattern": new As(dt.paint_fill["fill-pattern"]) });
        }, get layout() {
          return Fl = Fl || new Is({ "fill-sort-key": new Ss(dt.layout_fill["fill-sort-key"]) });
        } };
        class Ol extends Ps {
          constructor(t5) {
            super(t5, Ll);
          }
          recalculate(t5, e6) {
            super.recalculate(t5, e6);
            const r8 = this.paint._values["fill-outline-color"];
            "constant" === r8.value.kind && void 0 === r8.value.value && (this.paint._values["fill-outline-color"] = this.paint._values["fill-color"]);
          }
          createBucket(t5) {
            return new Tl(t5);
          }
          queryRadius() {
            return zo(this.paint.get("fill-translate"));
          }
          queryIntersectsFeature({ queryGeometry: t5, geometry: e6, transform: r8, pixelsToTileUnits: n6 }) {
            return xo(Po(t5, this.paint.get("fill-translate"), this.paint.get("fill-translate-anchor"), -r8.bearingInRadians, n6), e6);
          }
          isTileClipped() {
            return true;
          }
        }
        const Dl = Es([{ name: "a_pos", components: 2, type: "Int16" }, { name: "a_normal_ed", components: 4, type: "Int16" }], 4), Rl = Es([{ name: "a_centroid", components: 2, type: "Int16" }], 4), { members: jl } = Dl;
        var Nl, Ul, ql, Gl, Zl, Kl, Xl, Hl = {};
        function Yl() {
          if (Ul) return Nl;
          Ul = 1;
          var t5 = s3();
          function e6(t6, e7, n7, i6, s4) {
            this.properties = {}, this.extent = n7, this.type = 0, this._pbf = t6, this._geometry = -1, this._keys = i6, this._values = s4, t6.readFields(r8, this, e7);
          }
          function r8(t6, e7, r9) {
            1 == t6 ? e7.id = r9.readVarint() : 2 == t6 ? function(t7, e8) {
              for (var r10 = t7.readVarint() + t7.pos; t7.pos < r10; ) {
                var n7 = e8._keys[t7.readVarint()], i6 = e8._values[t7.readVarint()];
                e8.properties[n7] = i6;
              }
            }(r9, e7) : 3 == t6 ? e7.type = r9.readVarint() : 4 == t6 && (e7._geometry = r9.pos);
          }
          function n6(t6) {
            for (var e7, r9, n7 = 0, i6 = 0, s4 = t6.length, a4 = s4 - 1; i6 < s4; a4 = i6++) n7 += ((r9 = t6[a4]).x - (e7 = t6[i6]).x) * (e7.y + r9.y);
            return n7;
          }
          return Nl = e6, e6.types = ["Unknown", "Point", "LineString", "Polygon"], e6.prototype.loadGeometry = function() {
            var e7 = this._pbf;
            e7.pos = this._geometry;
            for (var r9, n7 = e7.readVarint() + e7.pos, i6 = 1, s4 = 0, a4 = 0, o6 = 0, l5 = []; e7.pos < n7; ) {
              if (s4 <= 0) {
                var u4 = e7.readVarint();
                i6 = 7 & u4, s4 = u4 >> 3;
              }
              if (s4--, 1 === i6 || 2 === i6) a4 += e7.readSVarint(), o6 += e7.readSVarint(), 1 === i6 && (r9 && l5.push(r9), r9 = []), r9.push(new t5(a4, o6));
              else {
                if (7 !== i6) throw new Error("unknown command " + i6);
                r9 && r9.push(r9[0].clone());
              }
            }
            return r9 && l5.push(r9), l5;
          }, e6.prototype.bbox = function() {
            var t6 = this._pbf;
            t6.pos = this._geometry;
            for (var e7 = t6.readVarint() + t6.pos, r9 = 1, n7 = 0, i6 = 0, s4 = 0, a4 = 1 / 0, o6 = -1 / 0, l5 = 1 / 0, u4 = -1 / 0; t6.pos < e7; ) {
              if (n7 <= 0) {
                var c5 = t6.readVarint();
                r9 = 7 & c5, n7 = c5 >> 3;
              }
              if (n7--, 1 === r9 || 2 === r9) (i6 += t6.readSVarint()) < a4 && (a4 = i6), i6 > o6 && (o6 = i6), (s4 += t6.readSVarint()) < l5 && (l5 = s4), s4 > u4 && (u4 = s4);
              else if (7 !== r9) throw new Error("unknown command " + r9);
            }
            return [a4, l5, o6, u4];
          }, e6.prototype.toGeoJSON = function(t6, r9, i6) {
            var s4, a4, o6 = this.extent * Math.pow(2, i6), l5 = this.extent * t6, u4 = this.extent * r9, c5 = this.loadGeometry(), h4 = e6.types[this.type];
            function p4(t7) {
              for (var e7 = 0; e7 < t7.length; e7++) {
                var r10 = t7[e7];
                t7[e7] = [360 * (r10.x + l5) / o6 - 180, 360 / Math.PI * Math.atan(Math.exp((180 - 360 * (r10.y + u4) / o6) * Math.PI / 180)) - 90];
              }
            }
            switch (this.type) {
              case 1:
                var f4 = [];
                for (s4 = 0; s4 < c5.length; s4++) f4[s4] = c5[s4][0];
                p4(c5 = f4);
                break;
              case 2:
                for (s4 = 0; s4 < c5.length; s4++) p4(c5[s4]);
                break;
              case 3:
                for (c5 = function(t7) {
                  var e7 = t7.length;
                  if (e7 <= 1) return [t7];
                  for (var r10, i7, s5 = [], a5 = 0; a5 < e7; a5++) {
                    var o7 = n6(t7[a5]);
                    0 !== o7 && (void 0 === i7 && (i7 = o7 < 0), i7 === o7 < 0 ? (r10 && s5.push(r10), r10 = [t7[a5]]) : r10.push(t7[a5]));
                  }
                  return r10 && s5.push(r10), s5;
                }(c5), s4 = 0; s4 < c5.length; s4++) for (a4 = 0; a4 < c5[s4].length; a4++) p4(c5[s4][a4]);
            }
            1 === c5.length ? c5 = c5[0] : h4 = "Multi" + h4;
            var d4 = { type: "Feature", geometry: { type: h4, coordinates: c5 }, properties: this.properties };
            return "id" in this && (d4.id = this.id), d4;
          }, Nl;
        }
        function Jl() {
          if (Gl) return ql;
          Gl = 1;
          var t5 = Yl();
          function e6(t6, e7) {
            this.version = 1, this.name = null, this.extent = 4096, this.length = 0, this._pbf = t6, this._keys = [], this._values = [], this._features = [], t6.readFields(r8, this, e7), this.length = this._features.length;
          }
          function r8(t6, e7, r9) {
            15 === t6 ? e7.version = r9.readVarint() : 1 === t6 ? e7.name = r9.readString() : 5 === t6 ? e7.extent = r9.readVarint() : 2 === t6 ? e7._features.push(r9.pos) : 3 === t6 ? e7._keys.push(r9.readString()) : 4 === t6 && e7._values.push(function(t7) {
              for (var e8 = null, r10 = t7.readVarint() + t7.pos; t7.pos < r10; ) {
                var n6 = t7.readVarint() >> 3;
                e8 = 1 === n6 ? t7.readString() : 2 === n6 ? t7.readFloat() : 3 === n6 ? t7.readDouble() : 4 === n6 ? t7.readVarint64() : 5 === n6 ? t7.readVarint() : 6 === n6 ? t7.readSVarint() : 7 === n6 ? t7.readBoolean() : null;
              }
              return e8;
            }(r9));
          }
          return ql = e6, e6.prototype.feature = function(e7) {
            if (e7 < 0 || e7 >= this._features.length) throw new Error("feature index out of bounds");
            this._pbf.pos = this._features[e7];
            var r9 = this._pbf.readVarint() + this._pbf.pos;
            return new t5(this._pbf, r9, this.extent, this._keys, this._values);
          }, ql;
        }
        function Wl() {
          return Xl || (Xl = 1, Hl.VectorTile = function() {
            if (Kl) return Zl;
            Kl = 1;
            var t5 = Jl();
            function e6(e7, r8, n6) {
              if (3 === e7) {
                var i6 = new t5(n6, n6.readVarint() + n6.pos);
                i6.length && (r8[i6.name] = i6);
              }
            }
            return Zl = function(t6, r8) {
              this.layers = t6.readFields(e6, {}, r8);
            }, Zl;
          }(), Hl.VectorTileFeature = Yl(), Hl.VectorTileLayer = Jl()), Hl;
        }
        var Ql = r7(Wl());
        const tu = Ql.VectorTileFeature.types, eu = Math.pow(2, 13);
        function ru(t5, e6, r8, n6, i6, s4, a4, o6) {
          t5.emplaceBack(e6, r8, 2 * Math.floor(n6 * eu) + a4, i6 * eu * 2, s4 * eu * 2, Math.round(o6));
        }
        class nu {
          constructor(t5) {
            this.zoom = t5.zoom, this.overscaling = t5.overscaling, this.layers = t5.layers, this.layerIds = this.layers.map((t6) => t6.id), this.index = t5.index, this.hasPattern = false, this.layoutVertexArray = new va(), this.centroidVertexArray = new ma(), this.indexArray = new za(), this.programConfigurations = new so(t5.layers, t5.zoom), this.segments = new Va(), this.stateDependentLayerIds = this.layers.filter((t6) => t6.isStateDependent()).map((t6) => t6.id);
          }
          populate(t5, e6, r8) {
            this.features = [], this.hasPattern = Jo("fill-extrusion", this.layers, e6);
            for (const { feature: n6, id: i6, index: s4, sourceLayerIndex: a4 } of t5) {
              const t6 = this.layers[0]._featureFilter.needGeometry, o6 = ho(n6, t6);
              if (!this.layers[0]._featureFilter.filter(new fs(this.zoom), o6, r8)) continue;
              const l5 = { id: i6, sourceLayerIndex: a4, index: s4, geometry: t6 ? o6.geometry : co(n6), properties: n6.properties, type: n6.type, patterns: {} };
              this.hasPattern ? this.features.push(Wo("fill-extrusion", this.layers, l5, this.zoom, e6)) : this.addFeature(l5, l5.geometry, s4, r8, {}, e6.subdivisionGranularity), e6.featureIndex.insert(n6, l5.geometry, s4, a4, this.index, true);
            }
          }
          addFeatures(t5, e6, r8) {
            for (const n6 of this.features) {
              const { geometry: i6 } = n6;
              this.addFeature(n6, i6, n6.index, e6, r8, t5.subdivisionGranularity);
            }
          }
          update(t5, e6, r8) {
            this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t5, e6, this.stateDependentLayers, r8);
          }
          isEmpty() {
            return 0 === this.layoutVertexArray.length && 0 === this.centroidVertexArray.length;
          }
          uploadPending() {
            return !this.uploaded || this.programConfigurations.needsUpload;
          }
          upload(t5) {
            this.uploaded || (this.layoutVertexBuffer = t5.createVertexBuffer(this.layoutVertexArray, jl), this.centroidVertexBuffer = t5.createVertexBuffer(this.centroidVertexArray, Rl.members, true), this.indexBuffer = t5.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(t5), this.uploaded = true;
          }
          destroy() {
            this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.centroidVertexBuffer.destroy());
          }
          addFeature(t5, e6, r8, n6, i6, s4) {
            for (const r9 of Ur(e6, 500)) {
              const e7 = { x: 0, y: 0, sampleCount: 0 }, i7 = this.layoutVertexArray.length;
              this.processPolygon(e7, n6, t5, r9, s4);
              const a4 = this.layoutVertexArray.length - i7, o6 = Math.floor(e7.x / e7.sampleCount), l5 = Math.floor(e7.y / e7.sampleCount);
              for (let t6 = 0; t6 < a4; t6++) this.centroidVertexArray.emplaceBack(o6, l5);
            }
            this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t5, r8, i6, n6);
          }
          processPolygon(t5, e6, r8, n6, i6) {
            if (n6.length < 1) return;
            if (au(n6[0])) return;
            for (const e7 of n6) 0 !== e7.length && iu(t5, e7);
            const s4 = { segment: this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray) }, a4 = i6.fill.getGranularityForZoomLevel(e6.z), o6 = "Polygon" === tu[r8.type];
            for (const t6 of n6) {
              if (0 === t6.length) continue;
              if (au(t6)) continue;
              const e7 = Cl(t6, a4, o6);
              this._generateSideFaces(e7, s4);
            }
            if (!o6) return;
            const l5 = Pl(n6, e6, a4, false), u4 = this.layoutVertexArray;
            Vl((t6, e7) => {
              ru(u4, t6, e7, 0, 0, 1, 1, 0);
            }, this.segments, this.layoutVertexArray, this.indexArray, l5.verticesFlattened, l5.indicesTriangles);
          }
          _generateSideFaces(t5, e6) {
            let r8 = 0;
            for (let n6 = 1; n6 < t5.length; n6++) {
              const i6 = t5[n6], s4 = t5[n6 - 1];
              if (su(i6, s4)) continue;
              e6.segment.vertexLength + 4 > Va.MAX_VERTEX_ARRAY_LENGTH && (e6.segment = this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray));
              const a4 = i6.sub(s4)._perp()._unit(), o6 = s4.dist(i6);
              r8 + o6 > 32768 && (r8 = 0), ru(this.layoutVertexArray, i6.x, i6.y, a4.x, a4.y, 0, 0, r8), ru(this.layoutVertexArray, i6.x, i6.y, a4.x, a4.y, 0, 1, r8), r8 += o6, ru(this.layoutVertexArray, s4.x, s4.y, a4.x, a4.y, 0, 0, r8), ru(this.layoutVertexArray, s4.x, s4.y, a4.x, a4.y, 0, 1, r8);
              const l5 = e6.segment.vertexLength;
              this.indexArray.emplaceBack(l5, l5 + 2, l5 + 1), this.indexArray.emplaceBack(l5 + 1, l5 + 2, l5 + 3), e6.segment.vertexLength += 4, e6.segment.primitiveLength += 2;
            }
          }
        }
        function iu(t5, e6) {
          for (let r8 = 0; r8 < e6.length; r8++) {
            const n6 = e6[r8];
            r8 === e6.length - 1 && e6[0].x === n6.x && e6[0].y === n6.y || (t5.x += n6.x, t5.y += n6.y, t5.sampleCount++);
          }
        }
        function su(t5, e6) {
          return t5.x === e6.x && (t5.x < 0 || t5.x > M4) || t5.y === e6.y && (t5.y < 0 || t5.y > M4);
        }
        function au(t5) {
          return t5.every((t6) => t6.x < 0) || t5.every((t6) => t6.x > M4) || t5.every((t6) => t6.y < 0) || t5.every((t6) => t6.y > M4);
        }
        let ou;
        Zi("FillExtrusionBucket", nu, { omit: ["layers", "features"] });
        var lu = { get paint() {
          return ou = ou || new Is({ "fill-extrusion-opacity": new _s(dt["paint_fill-extrusion"]["fill-extrusion-opacity"]), "fill-extrusion-color": new Ss(dt["paint_fill-extrusion"]["fill-extrusion-color"]), "fill-extrusion-translate": new _s(dt["paint_fill-extrusion"]["fill-extrusion-translate"]), "fill-extrusion-translate-anchor": new _s(dt["paint_fill-extrusion"]["fill-extrusion-translate-anchor"]), "fill-extrusion-pattern": new As(dt["paint_fill-extrusion"]["fill-extrusion-pattern"]), "fill-extrusion-height": new Ss(dt["paint_fill-extrusion"]["fill-extrusion-height"]), "fill-extrusion-base": new Ss(dt["paint_fill-extrusion"]["fill-extrusion-base"]), "fill-extrusion-vertical-gradient": new _s(dt["paint_fill-extrusion"]["fill-extrusion-vertical-gradient"]) });
        } };
        class uu extends Ps {
          constructor(t5) {
            super(t5, lu);
          }
          createBucket(t5) {
            return new nu(t5);
          }
          queryRadius() {
            return zo(this.paint.get("fill-extrusion-translate"));
          }
          is3D() {
            return true;
          }
          queryIntersectsFeature({ queryGeometry: t5, feature: e6, featureState: r8, geometry: n6, transform: i6, pixelsToTileUnits: s4, pixelPosMatrix: a4 }) {
            const o6 = Po(t5, this.paint.get("fill-extrusion-translate"), this.paint.get("fill-extrusion-translate-anchor"), -i6.bearingInRadians, s4), u4 = this.paint.get("fill-extrusion-height").evaluate(e6, r8), c5 = this.paint.get("fill-extrusion-base").evaluate(e6, r8), h4 = function(t6, e7, r9) {
              const n7 = [];
              for (const r10 of t6) {
                const t7 = [r10.x, r10.y, 0, 1];
                _3(t7, t7, e7), n7.push(new l4(t7[0] / t7[3], t7[1] / t7[3]));
              }
              return n7;
            }(o6, a4), p4 = function(t6, e7, r9, n7) {
              const i7 = [], s5 = [], a5 = n7[8] * e7, o7 = n7[9] * e7, u5 = n7[10] * e7, c6 = n7[11] * e7, h5 = n7[8] * r9, p5 = n7[9] * r9, f4 = n7[10] * r9, d4 = n7[11] * r9;
              for (const e8 of t6) {
                const t7 = [], r10 = [];
                for (const i8 of e8) {
                  const e9 = i8.x, s6 = i8.y, y4 = n7[0] * e9 + n7[4] * s6 + n7[12], m4 = n7[1] * e9 + n7[5] * s6 + n7[13], g4 = n7[2] * e9 + n7[6] * s6 + n7[14], x4 = n7[3] * e9 + n7[7] * s6 + n7[15], v4 = g4 + u5, b5 = x4 + c6, w4 = y4 + h5, _4 = m4 + p5, S5 = g4 + f4, A5 = x4 + d4, k4 = new l4((y4 + a5) / b5, (m4 + o7) / b5);
                  k4.z = v4 / b5, t7.push(k4);
                  const M5 = new l4(w4 / A5, _4 / A5);
                  M5.z = S5 / A5, r10.push(M5);
                }
                i7.push(t7), s5.push(r10);
              }
              return [i7, s5];
            }(n6, c5, u4, a4);
            return function(t6, e7, r9) {
              let n7 = 1 / 0;
              xo(r9, e7) && (n7 = hu(r9, e7[0]));
              for (let i7 = 0; i7 < e7.length; i7++) {
                const s5 = e7[i7], a5 = t6[i7];
                for (let t7 = 0; t7 < s5.length - 1; t7++) {
                  const e8 = s5[t7], i8 = [e8, s5[t7 + 1], a5[t7 + 1], a5[t7], e8];
                  mo(r9, i8) && (n7 = Math.min(n7, hu(r9, i8)));
                }
              }
              return n7 !== 1 / 0 && n7;
            }(p4[0], p4[1], h4);
          }
        }
        function cu(t5, e6) {
          return t5.x * e6.x + t5.y * e6.y;
        }
        function hu(t5, e6) {
          if (1 === t5.length) {
            let r8 = 0;
            const n6 = e6[r8++];
            let i6;
            for (; !i6 || n6.equals(i6); ) if (i6 = e6[r8++], !i6) return 1 / 0;
            for (; r8 < e6.length; r8++) {
              const s4 = e6[r8], a4 = t5[0], o6 = i6.sub(n6), l5 = s4.sub(n6), u4 = a4.sub(n6), c5 = cu(o6, o6), h4 = cu(o6, l5), p4 = cu(l5, l5), f4 = cu(u4, o6), d4 = cu(u4, l5), y4 = c5 * p4 - h4 * h4, m4 = (p4 * f4 - h4 * d4) / y4, g4 = (c5 * d4 - h4 * f4) / y4, x4 = n6.z * (1 - m4 - g4) + i6.z * m4 + s4.z * g4;
              if (isFinite(x4)) return x4;
            }
            return 1 / 0;
          }
          {
            let t6 = 1 / 0;
            for (const r8 of e6) t6 = Math.min(t6, r8.z);
            return t6;
          }
        }
        const pu = Es([{ name: "a_pos_normal", components: 2, type: "Int16" }, { name: "a_data", components: 4, type: "Uint8" }], 4), { members: fu } = pu, du = Es([{ name: "a_uv_x", components: 1, type: "Float32" }, { name: "a_split_index", components: 1, type: "Float32" }]), { members: yu } = du, mu = Ql.VectorTileFeature.types, gu = Math.cos(Math.PI / 180 * 37.5), xu = Math.pow(2, 14) / 0.5;
        class vu {
          constructor(t5) {
            this.zoom = t5.zoom, this.overscaling = t5.overscaling, this.layers = t5.layers, this.layerIds = this.layers.map((t6) => t6.id), this.index = t5.index, this.hasPattern = false, this.patternFeatures = [], this.lineClipsArray = [], this.gradients = {}, this.layers.forEach((t6) => {
              this.gradients[t6.id] = {};
            }), this.layoutVertexArray = new ba(), this.layoutVertexArray2 = new wa(), this.indexArray = new za(), this.programConfigurations = new so(t5.layers, t5.zoom), this.segments = new Va(), this.maxLineLength = 0, this.stateDependentLayerIds = this.layers.filter((t6) => t6.isStateDependent()).map((t6) => t6.id);
          }
          populate(t5, e6, r8) {
            this.hasPattern = Jo("line", this.layers, e6);
            const n6 = this.layers[0].layout.get("line-sort-key"), i6 = !n6.isConstant(), s4 = [];
            for (const { feature: e7, id: a4, index: o6, sourceLayerIndex: l5 } of t5) {
              const t6 = this.layers[0]._featureFilter.needGeometry, u4 = ho(e7, t6);
              if (!this.layers[0]._featureFilter.filter(new fs(this.zoom), u4, r8)) continue;
              const c5 = i6 ? n6.evaluate(u4, {}, r8) : void 0, h4 = { id: a4, properties: e7.properties, type: e7.type, sourceLayerIndex: l5, index: o6, geometry: t6 ? u4.geometry : co(e7), patterns: {}, sortKey: c5 };
              s4.push(h4);
            }
            i6 && s4.sort((t6, e7) => t6.sortKey - e7.sortKey);
            for (const n7 of s4) {
              const { geometry: i7, index: s5, sourceLayerIndex: a4 } = n7;
              if (this.hasPattern) {
                const t6 = Wo("line", this.layers, n7, this.zoom, e6);
                this.patternFeatures.push(t6);
              } else this.addFeature(n7, i7, s5, r8, {}, e6.subdivisionGranularity);
              e6.featureIndex.insert(t5[s5].feature, i7, s5, a4, this.index);
            }
          }
          update(t5, e6, r8) {
            this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t5, e6, this.stateDependentLayers, r8);
          }
          addFeatures(t5, e6, r8) {
            for (const n6 of this.patternFeatures) this.addFeature(n6, n6.geometry, n6.index, e6, r8, t5.subdivisionGranularity);
          }
          isEmpty() {
            return 0 === this.layoutVertexArray.length;
          }
          uploadPending() {
            return !this.uploaded || this.programConfigurations.needsUpload;
          }
          upload(t5) {
            this.uploaded || (0 !== this.layoutVertexArray2.length && (this.layoutVertexBuffer2 = t5.createVertexBuffer(this.layoutVertexArray2, yu)), this.layoutVertexBuffer = t5.createVertexBuffer(this.layoutVertexArray, fu), this.indexBuffer = t5.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(t5), this.uploaded = true;
          }
          destroy() {
            this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy());
          }
          lineFeatureClips(t5) {
            if (t5.properties && Object.prototype.hasOwnProperty.call(t5.properties, "mapbox_clip_start") && Object.prototype.hasOwnProperty.call(t5.properties, "mapbox_clip_end")) return { start: +t5.properties.mapbox_clip_start, end: +t5.properties.mapbox_clip_end };
          }
          addFeature(t5, e6, r8, n6, i6, s4) {
            const a4 = this.layers[0].layout, o6 = a4.get("line-join").evaluate(t5, {}), l5 = a4.get("line-cap"), u4 = a4.get("line-miter-limit"), c5 = a4.get("line-round-limit");
            this.lineClips = this.lineFeatureClips(t5);
            for (const r9 of e6) this.addLine(r9, t5, o6, l5, u4, c5, n6, s4);
            this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t5, r8, i6, n6);
          }
          addLine(t5, e6, r8, n6, i6, s4, a4, o6) {
            if (this.distance = 0, this.scaledDistance = 0, this.totalDistance = 0, t5 = Cl(t5, a4 ? o6.line.getGranularityForZoomLevel(a4.z) : 1), this.lineClips) {
              this.lineClipsArray.push(this.lineClips);
              for (let e7 = 0; e7 < t5.length - 1; e7++) this.totalDistance += t5[e7].dist(t5[e7 + 1]);
              this.updateScaledDistance(), this.maxLineLength = Math.max(this.maxLineLength, this.totalDistance);
            }
            const l5 = "Polygon" === mu[e6.type];
            let u4 = t5.length;
            for (; u4 >= 2 && t5[u4 - 1].equals(t5[u4 - 2]); ) u4--;
            let c5 = 0;
            for (; c5 < u4 - 1 && t5[c5].equals(t5[c5 + 1]); ) c5++;
            if (u4 < (l5 ? 3 : 2)) return;
            "bevel" === r8 && (i6 = 1.05);
            const h4 = this.overscaling <= 16 ? 15 * M4 / (512 * this.overscaling) : 0, p4 = this.segments.prepareSegment(10 * u4, this.layoutVertexArray, this.indexArray);
            let f4, d4, y4, m4, g4;
            this.e1 = this.e2 = -1, l5 && (f4 = t5[u4 - 2], g4 = t5[c5].sub(f4)._unit()._perp());
            for (let e7 = c5; e7 < u4; e7++) {
              if (y4 = e7 === u4 - 1 ? l5 ? t5[c5 + 1] : void 0 : t5[e7 + 1], y4 && t5[e7].equals(y4)) continue;
              g4 && (m4 = g4), f4 && (d4 = f4), f4 = t5[e7], g4 = y4 ? y4.sub(f4)._unit()._perp() : m4, m4 = m4 || g4;
              let a5 = m4.add(g4);
              0 === a5.x && 0 === a5.y || a5._unit();
              const o7 = m4.x * g4.x + m4.y * g4.y, x4 = a5.x * g4.x + a5.y * g4.y, v4 = 0 !== x4 ? 1 / x4 : 1 / 0, b5 = 2 * Math.sqrt(2 - 2 * x4), w4 = x4 < gu && d4 && y4, _4 = m4.x * g4.y - m4.y * g4.x > 0;
              if (w4 && e7 > c5) {
                const t6 = f4.dist(d4);
                if (t6 > 2 * h4) {
                  const e8 = f4.sub(f4.sub(d4)._mult(h4 / t6)._round());
                  this.updateDistance(d4, e8), this.addCurrentVertex(e8, m4, 0, 0, p4), d4 = e8;
                }
              }
              const S5 = d4 && y4;
              let A5 = S5 ? r8 : l5 ? "butt" : n6;
              if (S5 && "round" === A5 && (v4 < s4 ? A5 = "miter" : v4 <= 2 && (A5 = "fakeround")), "miter" === A5 && v4 > i6 && (A5 = "bevel"), "bevel" === A5 && (v4 > 2 && (A5 = "flipbevel"), v4 < i6 && (A5 = "miter")), d4 && this.updateDistance(d4, f4), "miter" === A5) a5._mult(v4), this.addCurrentVertex(f4, a5, 0, 0, p4);
              else if ("flipbevel" === A5) {
                if (v4 > 100) a5 = g4.mult(-1);
                else {
                  const t6 = v4 * m4.add(g4).mag() / m4.sub(g4).mag();
                  a5._perp()._mult(t6 * (_4 ? -1 : 1));
                }
                this.addCurrentVertex(f4, a5, 0, 0, p4), this.addCurrentVertex(f4, a5.mult(-1), 0, 0, p4);
              } else if ("bevel" === A5 || "fakeround" === A5) {
                const t6 = -Math.sqrt(v4 * v4 - 1), e8 = _4 ? t6 : 0, r9 = _4 ? 0 : t6;
                if (d4 && this.addCurrentVertex(f4, m4, e8, r9, p4), "fakeround" === A5) {
                  const t7 = Math.round(180 * b5 / Math.PI / 20);
                  for (let e9 = 1; e9 < t7; e9++) {
                    let r10 = e9 / t7;
                    if (0.5 !== r10) {
                      const t8 = r10 - 0.5;
                      r10 += r10 * t8 * (r10 - 1) * ((1.0904 + o7 * (o7 * (3.55645 - 1.43519 * o7) - 3.2452)) * t8 * t8 + (0.848013 + o7 * (0.215638 * o7 - 1.06021)));
                    }
                    const n7 = g4.sub(m4)._mult(r10)._add(m4)._unit()._mult(_4 ? -1 : 1);
                    this.addHalfVertex(f4, n7.x, n7.y, false, _4, 0, p4);
                  }
                }
                y4 && this.addCurrentVertex(f4, g4, -e8, -r9, p4);
              } else if ("butt" === A5) this.addCurrentVertex(f4, a5, 0, 0, p4);
              else if ("square" === A5) {
                const t6 = d4 ? 1 : -1;
                this.addCurrentVertex(f4, a5, t6, t6, p4);
              } else "round" === A5 && (d4 && (this.addCurrentVertex(f4, m4, 0, 0, p4), this.addCurrentVertex(f4, m4, 1, 1, p4, true)), y4 && (this.addCurrentVertex(f4, g4, -1, -1, p4, true), this.addCurrentVertex(f4, g4, 0, 0, p4)));
              if (w4 && e7 < u4 - 1) {
                const t6 = f4.dist(y4);
                if (t6 > 2 * h4) {
                  const e8 = f4.add(y4.sub(f4)._mult(h4 / t6)._round());
                  this.updateDistance(f4, e8), this.addCurrentVertex(e8, g4, 0, 0, p4), f4 = e8;
                }
              }
            }
          }
          addCurrentVertex(t5, e6, r8, n6, i6, s4 = false) {
            const a4 = e6.y * n6 - e6.x, o6 = -e6.y - e6.x * n6;
            this.addHalfVertex(t5, e6.x + e6.y * r8, e6.y - e6.x * r8, s4, false, r8, i6), this.addHalfVertex(t5, a4, o6, s4, true, -n6, i6), this.distance > xu / 2 && 0 === this.totalDistance && (this.distance = 0, this.updateScaledDistance(), this.addCurrentVertex(t5, e6, r8, n6, i6, s4));
          }
          addHalfVertex({ x: t5, y: e6 }, r8, n6, i6, s4, a4, o6) {
            const l5 = 0.5 * (this.lineClips ? this.scaledDistance * (xu - 1) : this.scaledDistance);
            this.layoutVertexArray.emplaceBack((t5 << 1) + (i6 ? 1 : 0), (e6 << 1) + (s4 ? 1 : 0), Math.round(63 * r8) + 128, Math.round(63 * n6) + 128, 1 + (0 === a4 ? 0 : a4 < 0 ? -1 : 1) | (63 & l5) << 2, l5 >> 6), this.lineClips && this.layoutVertexArray2.emplaceBack((this.scaledDistance - this.lineClips.start) / (this.lineClips.end - this.lineClips.start), this.lineClipsArray.length);
            const u4 = o6.vertexLength++;
            this.e1 >= 0 && this.e2 >= 0 && (this.indexArray.emplaceBack(this.e1, u4, this.e2), o6.primitiveLength++), s4 ? this.e2 = u4 : this.e1 = u4;
          }
          updateScaledDistance() {
            this.scaledDistance = this.lineClips ? this.lineClips.start + (this.lineClips.end - this.lineClips.start) * this.distance / this.totalDistance : this.distance;
          }
          updateDistance(t5, e6) {
            this.distance += t5.dist(e6), this.updateScaledDistance();
          }
        }
        let bu, wu;
        Zi("LineBucket", vu, { omit: ["layers", "patternFeatures"] });
        var _u = { get paint() {
          return wu = wu || new Is({ "line-opacity": new Ss(dt.paint_line["line-opacity"]), "line-color": new Ss(dt.paint_line["line-color"]), "line-translate": new _s(dt.paint_line["line-translate"]), "line-translate-anchor": new _s(dt.paint_line["line-translate-anchor"]), "line-width": new Ss(dt.paint_line["line-width"]), "line-gap-width": new Ss(dt.paint_line["line-gap-width"]), "line-offset": new Ss(dt.paint_line["line-offset"]), "line-blur": new Ss(dt.paint_line["line-blur"]), "line-dasharray": new ks(dt.paint_line["line-dasharray"]), "line-pattern": new As(dt.paint_line["line-pattern"]), "line-gradient": new Ms(dt.paint_line["line-gradient"]) });
        }, get layout() {
          return bu = bu || new Is({ "line-cap": new _s(dt.layout_line["line-cap"]), "line-join": new Ss(dt.layout_line["line-join"]), "line-miter-limit": new _s(dt.layout_line["line-miter-limit"]), "line-round-limit": new _s(dt.layout_line["line-round-limit"]), "line-sort-key": new Ss(dt.layout_line["line-sort-key"]) });
        } };
        class Su extends Ss {
          possiblyEvaluate(t5, e6) {
            return e6 = new fs(Math.floor(e6.zoom), { now: e6.now, fadeDuration: e6.fadeDuration, zoomHistory: e6.zoomHistory, transition: e6.transition }), super.possiblyEvaluate(t5, e6);
          }
          evaluate(t5, e6, r8, n6) {
            return e6 = F2({}, e6, { zoom: Math.floor(e6.zoom) }), super.evaluate(t5, e6, r8, n6);
          }
        }
        let Au;
        class ku extends Ps {
          constructor(t5) {
            super(t5, _u), this.gradientVersion = 0, Au || (Au = new Su(_u.paint.properties["line-width"].specification), Au.useIntegerZoom = true);
          }
          _handleSpecialPaintPropertyUpdate(t5) {
            if ("line-gradient" === t5) {
              const t6 = this.gradientExpression();
              this.stepInterpolant = !!function(t7) {
                return void 0 !== t7._styleExpression;
              }(t6) && t6._styleExpression.expression instanceof Ye, this.gradientVersion = (this.gradientVersion + 1) % Number.MAX_SAFE_INTEGER;
            }
          }
          gradientExpression() {
            return this._transitionablePaint._values["line-gradient"].value.expression;
          }
          recalculate(t5, e6) {
            super.recalculate(t5, e6), this.paint._values["line-floorwidth"] = Au.possiblyEvaluate(this._transitioningPaint._values["line-width"].value, t5);
          }
          createBucket(t5) {
            return new vu(t5);
          }
          queryRadius(t5) {
            const e6 = t5, r8 = Mu(Io("line-width", this, e6), Io("line-gap-width", this, e6)), n6 = Io("line-offset", this, e6);
            return r8 / 2 + Math.abs(n6) + zo(this.paint.get("line-translate"));
          }
          queryIntersectsFeature({ queryGeometry: t5, feature: e6, featureState: r8, geometry: n6, transform: i6, pixelsToTileUnits: s4 }) {
            const a4 = Po(t5, this.paint.get("line-translate"), this.paint.get("line-translate-anchor"), -i6.bearingInRadians, s4), o6 = s4 / 2 * Mu(this.paint.get("line-width").evaluate(e6, r8), this.paint.get("line-gap-width").evaluate(e6, r8)), u4 = this.paint.get("line-offset").evaluate(e6, r8);
            return u4 && (n6 = function(t6, e7) {
              const r9 = [];
              for (let n7 = 0; n7 < t6.length; n7++) {
                const i7 = t6[n7], s5 = [];
                for (let t7 = 0; t7 < i7.length; t7++) {
                  const r10 = i7[t7 - 1], n8 = i7[t7], a5 = i7[t7 + 1], o7 = 0 === t7 ? new l4(0, 0) : n8.sub(r10)._unit()._perp(), u5 = t7 === i7.length - 1 ? new l4(0, 0) : a5.sub(n8)._unit()._perp(), c5 = o7._add(u5)._unit(), h4 = c5.x * u5.x + c5.y * u5.y;
                  0 !== h4 && c5._mult(1 / h4), s5.push(c5._mult(e7)._add(n8));
                }
                r9.push(s5);
              }
              return r9;
            }(n6, u4 * s4)), function(t6, e7, r9) {
              for (let n7 = 0; n7 < e7.length; n7++) {
                const i7 = e7[n7];
                if (t6.length >= 3) {
                  for (let e8 = 0; e8 < i7.length; e8++) if (ko(t6, i7[e8])) return true;
                }
                if (vo(t6, i7, r9)) return true;
              }
              return false;
            }(a4, n6, o6);
          }
          isTileClipped() {
            return true;
          }
        }
        function Mu(t5, e6) {
          return e6 > 0 ? e6 + 2 * t5 : t5;
        }
        const Iu = Es([{ name: "a_pos_offset", components: 4, type: "Int16" }, { name: "a_data", components: 4, type: "Uint16" }, { name: "a_pixeloffset", components: 4, type: "Int16" }], 4), zu = Es([{ name: "a_projected_pos", components: 3, type: "Float32" }], 4);
        Es([{ name: "a_fade_opacity", components: 1, type: "Uint32" }], 4);
        const Pu = Es([{ name: "a_placed", components: 2, type: "Uint8" }, { name: "a_shift", components: 2, type: "Float32" }, { name: "a_box_real", components: 2, type: "Int16" }]);
        Es([{ type: "Int16", name: "anchorPointX" }, { type: "Int16", name: "anchorPointY" }, { type: "Int16", name: "x1" }, { type: "Int16", name: "y1" }, { type: "Int16", name: "x2" }, { type: "Int16", name: "y2" }, { type: "Uint32", name: "featureIndex" }, { type: "Uint16", name: "sourceLayerIndex" }, { type: "Uint16", name: "bucketIndex" }]);
        const Cu = Es([{ name: "a_pos", components: 2, type: "Int16" }, { name: "a_anchor_pos", components: 2, type: "Int16" }, { name: "a_extrude", components: 2, type: "Int16" }], 4), Bu = Es([{ name: "a_pos", components: 2, type: "Float32" }, { name: "a_radius", components: 1, type: "Float32" }, { name: "a_flags", components: 2, type: "Int16" }], 4);
        function Vu(t5, e6, r8) {
          return t5.sections.forEach((t6) => {
            t6.text = function(t7, e7, r9) {
              const n6 = e7.layout.get("text-transform").evaluate(r9, {});
              return "uppercase" === n6 ? t7 = t7.toLocaleUpperCase() : "lowercase" === n6 && (t7 = t7.toLocaleLowerCase()), ps.applyArabicShaping && (t7 = ps.applyArabicShaping(t7)), t7;
            }(t6.text, e6, r8);
          }), t5;
        }
        Es([{ name: "triangle", components: 3, type: "Uint16" }]), Es([{ type: "Int16", name: "anchorX" }, { type: "Int16", name: "anchorY" }, { type: "Uint16", name: "glyphStartIndex" }, { type: "Uint16", name: "numGlyphs" }, { type: "Uint32", name: "vertexStartIndex" }, { type: "Uint32", name: "lineStartIndex" }, { type: "Uint32", name: "lineLength" }, { type: "Uint16", name: "segment" }, { type: "Uint16", name: "lowerSize" }, { type: "Uint16", name: "upperSize" }, { type: "Float32", name: "lineOffsetX" }, { type: "Float32", name: "lineOffsetY" }, { type: "Uint8", name: "writingMode" }, { type: "Uint8", name: "placedOrientation" }, { type: "Uint8", name: "hidden" }, { type: "Uint32", name: "crossTileID" }, { type: "Int16", name: "associatedIconIndex" }]), Es([{ type: "Int16", name: "anchorX" }, { type: "Int16", name: "anchorY" }, { type: "Int16", name: "rightJustifiedTextSymbolIndex" }, { type: "Int16", name: "centerJustifiedTextSymbolIndex" }, { type: "Int16", name: "leftJustifiedTextSymbolIndex" }, { type: "Int16", name: "verticalPlacedTextSymbolIndex" }, { type: "Int16", name: "placedIconSymbolIndex" }, { type: "Int16", name: "verticalPlacedIconSymbolIndex" }, { type: "Uint16", name: "key" }, { type: "Uint16", name: "textBoxStartIndex" }, { type: "Uint16", name: "textBoxEndIndex" }, { type: "Uint16", name: "verticalTextBoxStartIndex" }, { type: "Uint16", name: "verticalTextBoxEndIndex" }, { type: "Uint16", name: "iconBoxStartIndex" }, { type: "Uint16", name: "iconBoxEndIndex" }, { type: "Uint16", name: "verticalIconBoxStartIndex" }, { type: "Uint16", name: "verticalIconBoxEndIndex" }, { type: "Uint16", name: "featureIndex" }, { type: "Uint16", name: "numHorizontalGlyphVertices" }, { type: "Uint16", name: "numVerticalGlyphVertices" }, { type: "Uint16", name: "numIconVertices" }, { type: "Uint16", name: "numVerticalIconVertices" }, { type: "Uint16", name: "useRuntimeCollisionCircles" }, { type: "Uint32", name: "crossTileID" }, { type: "Float32", name: "textBoxScale" }, { type: "Float32", name: "collisionCircleDiameter" }, { type: "Uint16", name: "textAnchorOffsetStartIndex" }, { type: "Uint16", name: "textAnchorOffsetEndIndex" }]), Es([{ type: "Float32", name: "offsetX" }]), Es([{ type: "Int16", name: "x" }, { type: "Int16", name: "y" }, { type: "Int16", name: "tileUnitDistanceFromAnchor" }]), Es([{ type: "Uint16", name: "textAnchor" }, { type: "Float32", components: 2, name: "textOffset" }]);
        const Eu = { "!": "\uFE15", "#": "\uFF03", $: "\uFF04", "%": "\uFF05", "&": "\uFF06", "(": "\uFE35", ")": "\uFE36", "*": "\uFF0A", "+": "\uFF0B", ",": "\uFE10", "-": "\uFE32", ".": "\u30FB", "/": "\uFF0F", ":": "\uFE13", ";": "\uFE14", "<": "\uFE3F", "=": "\uFF1D", ">": "\uFE40", "?": "\uFE16", "@": "\uFF20", "[": "\uFE47", "\\": "\uFF3C", "]": "\uFE48", "^": "\uFF3E", _: "\uFE33", "`": "\uFF40", "{": "\uFE37", "|": "\u2015", "}": "\uFE38", "~": "\uFF5E", "\xA2": "\uFFE0", "\xA3": "\uFFE1", "\xA5": "\uFFE5", "\xA6": "\uFFE4", "\xAC": "\uFFE2", "\xAF": "\uFFE3", "\u2013": "\uFE32", "\u2014": "\uFE31", "\u2018": "\uFE43", "\u2019": "\uFE44", "\u201C": "\uFE41", "\u201D": "\uFE42", "\u2026": "\uFE19", "\u2027": "\u30FB", "\u20A9": "\uFFE6", "\u3001": "\uFE11", "\u3002": "\uFE12", "\u3008": "\uFE3F", "\u3009": "\uFE40", "\u300A": "\uFE3D", "\u300B": "\uFE3E", "\u300C": "\uFE41", "\u300D": "\uFE42", "\u300E": "\uFE43", "\u300F": "\uFE44", "\u3010": "\uFE3B", "\u3011": "\uFE3C", "\u3014": "\uFE39", "\u3015": "\uFE3A", "\u3016": "\uFE17", "\u3017": "\uFE18", "\uFF01": "\uFE15", "\uFF08": "\uFE35", "\uFF09": "\uFE36", "\uFF0C": "\uFE10", "\uFF0D": "\uFE32", "\uFF0E": "\u30FB", "\uFF1A": "\uFE13", "\uFF1B": "\uFE14", "\uFF1C": "\uFE3F", "\uFF1E": "\uFE40", "\uFF1F": "\uFE16", "\uFF3B": "\uFE47", "\uFF3D": "\uFE48", "\uFF3F": "\uFE33", "\uFF5B": "\uFE37", "\uFF5C": "\u2015", "\uFF5D": "\uFE38", "\uFF5F": "\uFE35", "\uFF60": "\uFE36", "\uFF61": "\uFE12", "\uFF62": "\uFE41", "\uFF63": "\uFE42" };
        var Tu, Fu, $u, Lu = 24, Ou = {};
        function Du() {
          return Tu || (Tu = 1, Ou.read = function(t5, e6, r8, n6, i6) {
            var s4, a4, o6 = 8 * i6 - n6 - 1, l5 = (1 << o6) - 1, u4 = l5 >> 1, c5 = -7, h4 = r8 ? i6 - 1 : 0, p4 = r8 ? -1 : 1, f4 = t5[e6 + h4];
            for (h4 += p4, s4 = f4 & (1 << -c5) - 1, f4 >>= -c5, c5 += o6; c5 > 0; s4 = 256 * s4 + t5[e6 + h4], h4 += p4, c5 -= 8) ;
            for (a4 = s4 & (1 << -c5) - 1, s4 >>= -c5, c5 += n6; c5 > 0; a4 = 256 * a4 + t5[e6 + h4], h4 += p4, c5 -= 8) ;
            if (0 === s4) s4 = 1 - u4;
            else {
              if (s4 === l5) return a4 ? NaN : 1 / 0 * (f4 ? -1 : 1);
              a4 += Math.pow(2, n6), s4 -= u4;
            }
            return (f4 ? -1 : 1) * a4 * Math.pow(2, s4 - n6);
          }, Ou.write = function(t5, e6, r8, n6, i6, s4) {
            var a4, o6, l5, u4 = 8 * s4 - i6 - 1, c5 = (1 << u4) - 1, h4 = c5 >> 1, p4 = 23 === i6 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, f4 = n6 ? 0 : s4 - 1, d4 = n6 ? 1 : -1, y4 = e6 < 0 || 0 === e6 && 1 / e6 < 0 ? 1 : 0;
            for (e6 = Math.abs(e6), isNaN(e6) || e6 === 1 / 0 ? (o6 = isNaN(e6) ? 1 : 0, a4 = c5) : (a4 = Math.floor(Math.log(e6) / Math.LN2), e6 * (l5 = Math.pow(2, -a4)) < 1 && (a4--, l5 *= 2), (e6 += a4 + h4 >= 1 ? p4 / l5 : p4 * Math.pow(2, 1 - h4)) * l5 >= 2 && (a4++, l5 /= 2), a4 + h4 >= c5 ? (o6 = 0, a4 = c5) : a4 + h4 >= 1 ? (o6 = (e6 * l5 - 1) * Math.pow(2, i6), a4 += h4) : (o6 = e6 * Math.pow(2, h4 - 1) * Math.pow(2, i6), a4 = 0)); i6 >= 8; t5[r8 + f4] = 255 & o6, f4 += d4, o6 /= 256, i6 -= 8) ;
            for (a4 = a4 << i6 | o6, u4 += i6; u4 > 0; t5[r8 + f4] = 255 & a4, f4 += d4, a4 /= 256, u4 -= 8) ;
            t5[r8 + f4 - d4] |= 128 * y4;
          }), Ou;
        }
        function Ru() {
          if ($u) return Fu;
          $u = 1, Fu = e6;
          var t5 = Du();
          function e6(t6) {
            this.buf = ArrayBuffer.isView && ArrayBuffer.isView(t6) ? t6 : new Uint8Array(t6 || 0), this.pos = 0, this.type = 0, this.length = this.buf.length;
          }
          e6.Varint = 0, e6.Fixed64 = 1, e6.Bytes = 2, e6.Fixed32 = 5;
          var r8 = 4294967296, n6 = 1 / r8, i6 = "undefined" == typeof TextDecoder ? null : new TextDecoder("utf-8");
          function s4(t6) {
            return t6.type === e6.Bytes ? t6.readVarint() + t6.pos : t6.pos + 1;
          }
          function a4(t6, e7, r9) {
            return r9 ? 4294967296 * e7 + (t6 >>> 0) : 4294967296 * (e7 >>> 0) + (t6 >>> 0);
          }
          function o6(t6, e7, r9) {
            var n7 = e7 <= 16383 ? 1 : e7 <= 2097151 ? 2 : e7 <= 268435455 ? 3 : Math.floor(Math.log(e7) / (7 * Math.LN2));
            r9.realloc(n7);
            for (var i7 = r9.pos - 1; i7 >= t6; i7--) r9.buf[i7 + n7] = r9.buf[i7];
          }
          function l5(t6, e7) {
            for (var r9 = 0; r9 < t6.length; r9++) e7.writeVarint(t6[r9]);
          }
          function u4(t6, e7) {
            for (var r9 = 0; r9 < t6.length; r9++) e7.writeSVarint(t6[r9]);
          }
          function c5(t6, e7) {
            for (var r9 = 0; r9 < t6.length; r9++) e7.writeFloat(t6[r9]);
          }
          function h4(t6, e7) {
            for (var r9 = 0; r9 < t6.length; r9++) e7.writeDouble(t6[r9]);
          }
          function p4(t6, e7) {
            for (var r9 = 0; r9 < t6.length; r9++) e7.writeBoolean(t6[r9]);
          }
          function f4(t6, e7) {
            for (var r9 = 0; r9 < t6.length; r9++) e7.writeFixed32(t6[r9]);
          }
          function d4(t6, e7) {
            for (var r9 = 0; r9 < t6.length; r9++) e7.writeSFixed32(t6[r9]);
          }
          function y4(t6, e7) {
            for (var r9 = 0; r9 < t6.length; r9++) e7.writeFixed64(t6[r9]);
          }
          function m4(t6, e7) {
            for (var r9 = 0; r9 < t6.length; r9++) e7.writeSFixed64(t6[r9]);
          }
          function g4(t6, e7) {
            return (t6[e7] | t6[e7 + 1] << 8 | t6[e7 + 2] << 16) + 16777216 * t6[e7 + 3];
          }
          function x4(t6, e7, r9) {
            t6[r9] = e7, t6[r9 + 1] = e7 >>> 8, t6[r9 + 2] = e7 >>> 16, t6[r9 + 3] = e7 >>> 24;
          }
          function v4(t6, e7) {
            return (t6[e7] | t6[e7 + 1] << 8 | t6[e7 + 2] << 16) + (t6[e7 + 3] << 24);
          }
          return e6.prototype = { destroy: function() {
            this.buf = null;
          }, readFields: function(t6, e7, r9) {
            for (r9 = r9 || this.length; this.pos < r9; ) {
              var n7 = this.readVarint(), i7 = n7 >> 3, s5 = this.pos;
              this.type = 7 & n7, t6(i7, e7, this), this.pos === s5 && this.skip(n7);
            }
            return e7;
          }, readMessage: function(t6, e7) {
            return this.readFields(t6, e7, this.readVarint() + this.pos);
          }, readFixed32: function() {
            var t6 = g4(this.buf, this.pos);
            return this.pos += 4, t6;
          }, readSFixed32: function() {
            var t6 = v4(this.buf, this.pos);
            return this.pos += 4, t6;
          }, readFixed64: function() {
            var t6 = g4(this.buf, this.pos) + g4(this.buf, this.pos + 4) * r8;
            return this.pos += 8, t6;
          }, readSFixed64: function() {
            var t6 = g4(this.buf, this.pos) + v4(this.buf, this.pos + 4) * r8;
            return this.pos += 8, t6;
          }, readFloat: function() {
            var e7 = t5.read(this.buf, this.pos, true, 23, 4);
            return this.pos += 4, e7;
          }, readDouble: function() {
            var e7 = t5.read(this.buf, this.pos, true, 52, 8);
            return this.pos += 8, e7;
          }, readVarint: function(t6) {
            var e7, r9, n7 = this.buf;
            return e7 = 127 & (r9 = n7[this.pos++]), r9 < 128 ? e7 : (e7 |= (127 & (r9 = n7[this.pos++])) << 7, r9 < 128 ? e7 : (e7 |= (127 & (r9 = n7[this.pos++])) << 14, r9 < 128 ? e7 : (e7 |= (127 & (r9 = n7[this.pos++])) << 21, r9 < 128 ? e7 : function(t7, e8, r10) {
              var n8, i7, s5 = r10.buf;
              if (n8 = (112 & (i7 = s5[r10.pos++])) >> 4, i7 < 128) return a4(t7, n8, e8);
              if (n8 |= (127 & (i7 = s5[r10.pos++])) << 3, i7 < 128) return a4(t7, n8, e8);
              if (n8 |= (127 & (i7 = s5[r10.pos++])) << 10, i7 < 128) return a4(t7, n8, e8);
              if (n8 |= (127 & (i7 = s5[r10.pos++])) << 17, i7 < 128) return a4(t7, n8, e8);
              if (n8 |= (127 & (i7 = s5[r10.pos++])) << 24, i7 < 128) return a4(t7, n8, e8);
              if (n8 |= (1 & (i7 = s5[r10.pos++])) << 31, i7 < 128) return a4(t7, n8, e8);
              throw new Error("Expected varint not more than 10 bytes");
            }(e7 |= (15 & (r9 = n7[this.pos])) << 28, t6, this))));
          }, readVarint64: function() {
            return this.readVarint(true);
          }, readSVarint: function() {
            var t6 = this.readVarint();
            return t6 % 2 == 1 ? (t6 + 1) / -2 : t6 / 2;
          }, readBoolean: function() {
            return Boolean(this.readVarint());
          }, readString: function() {
            var t6 = this.readVarint() + this.pos, e7 = this.pos;
            return this.pos = t6, t6 - e7 >= 12 && i6 ? function(t7, e8, r9) {
              return i6.decode(t7.subarray(e8, r9));
            }(this.buf, e7, t6) : function(t7, e8, r9) {
              for (var n7 = "", i7 = e8; i7 < r9; ) {
                var s5, a5, o7, l6 = t7[i7], u5 = null, c6 = l6 > 239 ? 4 : l6 > 223 ? 3 : l6 > 191 ? 2 : 1;
                if (i7 + c6 > r9) break;
                1 === c6 ? l6 < 128 && (u5 = l6) : 2 === c6 ? 128 == (192 & (s5 = t7[i7 + 1])) && (u5 = (31 & l6) << 6 | 63 & s5) <= 127 && (u5 = null) : 3 === c6 ? (a5 = t7[i7 + 2], 128 == (192 & (s5 = t7[i7 + 1])) && 128 == (192 & a5) && ((u5 = (15 & l6) << 12 | (63 & s5) << 6 | 63 & a5) <= 2047 || u5 >= 55296 && u5 <= 57343) && (u5 = null)) : 4 === c6 && (a5 = t7[i7 + 2], o7 = t7[i7 + 3], 128 == (192 & (s5 = t7[i7 + 1])) && 128 == (192 & a5) && 128 == (192 & o7) && ((u5 = (15 & l6) << 18 | (63 & s5) << 12 | (63 & a5) << 6 | 63 & o7) <= 65535 || u5 >= 1114112) && (u5 = null)), null === u5 ? (u5 = 65533, c6 = 1) : u5 > 65535 && (u5 -= 65536, n7 += String.fromCharCode(u5 >>> 10 & 1023 | 55296), u5 = 56320 | 1023 & u5), n7 += String.fromCharCode(u5), i7 += c6;
              }
              return n7;
            }(this.buf, e7, t6);
          }, readBytes: function() {
            var t6 = this.readVarint() + this.pos, e7 = this.buf.subarray(this.pos, t6);
            return this.pos = t6, e7;
          }, readPackedVarint: function(t6, r9) {
            if (this.type !== e6.Bytes) return t6.push(this.readVarint(r9));
            var n7 = s4(this);
            for (t6 = t6 || []; this.pos < n7; ) t6.push(this.readVarint(r9));
            return t6;
          }, readPackedSVarint: function(t6) {
            if (this.type !== e6.Bytes) return t6.push(this.readSVarint());
            var r9 = s4(this);
            for (t6 = t6 || []; this.pos < r9; ) t6.push(this.readSVarint());
            return t6;
          }, readPackedBoolean: function(t6) {
            if (this.type !== e6.Bytes) return t6.push(this.readBoolean());
            var r9 = s4(this);
            for (t6 = t6 || []; this.pos < r9; ) t6.push(this.readBoolean());
            return t6;
          }, readPackedFloat: function(t6) {
            if (this.type !== e6.Bytes) return t6.push(this.readFloat());
            var r9 = s4(this);
            for (t6 = t6 || []; this.pos < r9; ) t6.push(this.readFloat());
            return t6;
          }, readPackedDouble: function(t6) {
            if (this.type !== e6.Bytes) return t6.push(this.readDouble());
            var r9 = s4(this);
            for (t6 = t6 || []; this.pos < r9; ) t6.push(this.readDouble());
            return t6;
          }, readPackedFixed32: function(t6) {
            if (this.type !== e6.Bytes) return t6.push(this.readFixed32());
            var r9 = s4(this);
            for (t6 = t6 || []; this.pos < r9; ) t6.push(this.readFixed32());
            return t6;
          }, readPackedSFixed32: function(t6) {
            if (this.type !== e6.Bytes) return t6.push(this.readSFixed32());
            var r9 = s4(this);
            for (t6 = t6 || []; this.pos < r9; ) t6.push(this.readSFixed32());
            return t6;
          }, readPackedFixed64: function(t6) {
            if (this.type !== e6.Bytes) return t6.push(this.readFixed64());
            var r9 = s4(this);
            for (t6 = t6 || []; this.pos < r9; ) t6.push(this.readFixed64());
            return t6;
          }, readPackedSFixed64: function(t6) {
            if (this.type !== e6.Bytes) return t6.push(this.readSFixed64());
            var r9 = s4(this);
            for (t6 = t6 || []; this.pos < r9; ) t6.push(this.readSFixed64());
            return t6;
          }, skip: function(t6) {
            var r9 = 7 & t6;
            if (r9 === e6.Varint) for (; this.buf[this.pos++] > 127; ) ;
            else if (r9 === e6.Bytes) this.pos = this.readVarint() + this.pos;
            else if (r9 === e6.Fixed32) this.pos += 4;
            else {
              if (r9 !== e6.Fixed64) throw new Error("Unimplemented type: " + r9);
              this.pos += 8;
            }
          }, writeTag: function(t6, e7) {
            this.writeVarint(t6 << 3 | e7);
          }, realloc: function(t6) {
            for (var e7 = this.length || 16; e7 < this.pos + t6; ) e7 *= 2;
            if (e7 !== this.length) {
              var r9 = new Uint8Array(e7);
              r9.set(this.buf), this.buf = r9, this.length = e7;
            }
          }, finish: function() {
            return this.length = this.pos, this.pos = 0, this.buf.subarray(0, this.length);
          }, writeFixed32: function(t6) {
            this.realloc(4), x4(this.buf, t6, this.pos), this.pos += 4;
          }, writeSFixed32: function(t6) {
            this.realloc(4), x4(this.buf, t6, this.pos), this.pos += 4;
          }, writeFixed64: function(t6) {
            this.realloc(8), x4(this.buf, -1 & t6, this.pos), x4(this.buf, Math.floor(t6 * n6), this.pos + 4), this.pos += 8;
          }, writeSFixed64: function(t6) {
            this.realloc(8), x4(this.buf, -1 & t6, this.pos), x4(this.buf, Math.floor(t6 * n6), this.pos + 4), this.pos += 8;
          }, writeVarint: function(t6) {
            (t6 = +t6 || 0) > 268435455 || t6 < 0 ? function(t7, e7) {
              var r9, n7;
              if (t7 >= 0 ? (r9 = t7 % 4294967296 | 0, n7 = t7 / 4294967296 | 0) : (n7 = ~(-t7 / 4294967296), 4294967295 ^ (r9 = ~(-t7 % 4294967296)) ? r9 = r9 + 1 | 0 : (r9 = 0, n7 = n7 + 1 | 0)), t7 >= 18446744073709552e3 || t7 < -18446744073709552e3) throw new Error("Given varint doesn't fit into 10 bytes");
              e7.realloc(10), function(t8, e8, r10) {
                r10.buf[r10.pos++] = 127 & t8 | 128, t8 >>>= 7, r10.buf[r10.pos++] = 127 & t8 | 128, t8 >>>= 7, r10.buf[r10.pos++] = 127 & t8 | 128, t8 >>>= 7, r10.buf[r10.pos++] = 127 & t8 | 128, r10.buf[r10.pos] = 127 & (t8 >>>= 7);
              }(r9, 0, e7), function(t8, e8) {
                var r10 = (7 & t8) << 4;
                e8.buf[e8.pos++] |= r10 | ((t8 >>>= 3) ? 128 : 0), t8 && (e8.buf[e8.pos++] = 127 & t8 | ((t8 >>>= 7) ? 128 : 0), t8 && (e8.buf[e8.pos++] = 127 & t8 | ((t8 >>>= 7) ? 128 : 0), t8 && (e8.buf[e8.pos++] = 127 & t8 | ((t8 >>>= 7) ? 128 : 0), t8 && (e8.buf[e8.pos++] = 127 & t8 | ((t8 >>>= 7) ? 128 : 0), t8 && (e8.buf[e8.pos++] = 127 & t8)))));
              }(n7, e7);
            }(t6, this) : (this.realloc(4), this.buf[this.pos++] = 127 & t6 | (t6 > 127 ? 128 : 0), t6 <= 127 || (this.buf[this.pos++] = 127 & (t6 >>>= 7) | (t6 > 127 ? 128 : 0), t6 <= 127 || (this.buf[this.pos++] = 127 & (t6 >>>= 7) | (t6 > 127 ? 128 : 0), t6 <= 127 || (this.buf[this.pos++] = t6 >>> 7 & 127))));
          }, writeSVarint: function(t6) {
            this.writeVarint(t6 < 0 ? 2 * -t6 - 1 : 2 * t6);
          }, writeBoolean: function(t6) {
            this.writeVarint(Boolean(t6));
          }, writeString: function(t6) {
            t6 = String(t6), this.realloc(4 * t6.length), this.pos++;
            var e7 = this.pos;
            this.pos = function(t7, e8, r10) {
              for (var n7, i7, s5 = 0; s5 < e8.length; s5++) {
                if ((n7 = e8.charCodeAt(s5)) > 55295 && n7 < 57344) {
                  if (!i7) {
                    n7 > 56319 || s5 + 1 === e8.length ? (t7[r10++] = 239, t7[r10++] = 191, t7[r10++] = 189) : i7 = n7;
                    continue;
                  }
                  if (n7 < 56320) {
                    t7[r10++] = 239, t7[r10++] = 191, t7[r10++] = 189, i7 = n7;
                    continue;
                  }
                  n7 = i7 - 55296 << 10 | n7 - 56320 | 65536, i7 = null;
                } else i7 && (t7[r10++] = 239, t7[r10++] = 191, t7[r10++] = 189, i7 = null);
                n7 < 128 ? t7[r10++] = n7 : (n7 < 2048 ? t7[r10++] = n7 >> 6 | 192 : (n7 < 65536 ? t7[r10++] = n7 >> 12 | 224 : (t7[r10++] = n7 >> 18 | 240, t7[r10++] = n7 >> 12 & 63 | 128), t7[r10++] = n7 >> 6 & 63 | 128), t7[r10++] = 63 & n7 | 128);
              }
              return r10;
            }(this.buf, t6, this.pos);
            var r9 = this.pos - e7;
            r9 >= 128 && o6(e7, r9, this), this.pos = e7 - 1, this.writeVarint(r9), this.pos += r9;
          }, writeFloat: function(e7) {
            this.realloc(4), t5.write(this.buf, e7, this.pos, true, 23, 4), this.pos += 4;
          }, writeDouble: function(e7) {
            this.realloc(8), t5.write(this.buf, e7, this.pos, true, 52, 8), this.pos += 8;
          }, writeBytes: function(t6) {
            var e7 = t6.length;
            this.writeVarint(e7), this.realloc(e7);
            for (var r9 = 0; r9 < e7; r9++) this.buf[this.pos++] = t6[r9];
          }, writeRawMessage: function(t6, e7) {
            this.pos++;
            var r9 = this.pos;
            t6(e7, this);
            var n7 = this.pos - r9;
            n7 >= 128 && o6(r9, n7, this), this.pos = r9 - 1, this.writeVarint(n7), this.pos += n7;
          }, writeMessage: function(t6, r9, n7) {
            this.writeTag(t6, e6.Bytes), this.writeRawMessage(r9, n7);
          }, writePackedVarint: function(t6, e7) {
            e7.length && this.writeMessage(t6, l5, e7);
          }, writePackedSVarint: function(t6, e7) {
            e7.length && this.writeMessage(t6, u4, e7);
          }, writePackedBoolean: function(t6, e7) {
            e7.length && this.writeMessage(t6, p4, e7);
          }, writePackedFloat: function(t6, e7) {
            e7.length && this.writeMessage(t6, c5, e7);
          }, writePackedDouble: function(t6, e7) {
            e7.length && this.writeMessage(t6, h4, e7);
          }, writePackedFixed32: function(t6, e7) {
            e7.length && this.writeMessage(t6, f4, e7);
          }, writePackedSFixed32: function(t6, e7) {
            e7.length && this.writeMessage(t6, d4, e7);
          }, writePackedFixed64: function(t6, e7) {
            e7.length && this.writeMessage(t6, y4, e7);
          }, writePackedSFixed64: function(t6, e7) {
            e7.length && this.writeMessage(t6, m4, e7);
          }, writeBytesField: function(t6, r9) {
            this.writeTag(t6, e6.Bytes), this.writeBytes(r9);
          }, writeFixed32Field: function(t6, r9) {
            this.writeTag(t6, e6.Fixed32), this.writeFixed32(r9);
          }, writeSFixed32Field: function(t6, r9) {
            this.writeTag(t6, e6.Fixed32), this.writeSFixed32(r9);
          }, writeFixed64Field: function(t6, r9) {
            this.writeTag(t6, e6.Fixed64), this.writeFixed64(r9);
          }, writeSFixed64Field: function(t6, r9) {
            this.writeTag(t6, e6.Fixed64), this.writeSFixed64(r9);
          }, writeVarintField: function(t6, r9) {
            this.writeTag(t6, e6.Varint), this.writeVarint(r9);
          }, writeSVarintField: function(t6, r9) {
            this.writeTag(t6, e6.Varint), this.writeSVarint(r9);
          }, writeStringField: function(t6, r9) {
            this.writeTag(t6, e6.Bytes), this.writeString(r9);
          }, writeFloatField: function(t6, r9) {
            this.writeTag(t6, e6.Fixed32), this.writeFloat(r9);
          }, writeDoubleField: function(t6, r9) {
            this.writeTag(t6, e6.Fixed64), this.writeDouble(r9);
          }, writeBooleanField: function(t6, e7) {
            this.writeVarintField(t6, Boolean(e7));
          } }, Fu;
        }
        var ju = r7(Ru());
        const Nu = 3;
        function Uu(t5, e6, r8) {
          1 === t5 && r8.readMessage(qu, e6);
        }
        function qu(t5, e6, r8) {
          if (3 === t5) {
            const { id: t6, bitmap: n6, width: i6, height: s4, left: a4, top: o6, advance: l5 } = r8.readMessage(Gu, {});
            e6.push({ id: t6, bitmap: new jo({ width: i6 + 2 * Nu, height: s4 + 2 * Nu }, n6), metrics: { width: i6, height: s4, left: a4, top: o6, advance: l5 } });
          }
        }
        function Gu(t5, e6, r8) {
          1 === t5 ? e6.id = r8.readVarint() : 2 === t5 ? e6.bitmap = r8.readBytes() : 3 === t5 ? e6.width = r8.readVarint() : 4 === t5 ? e6.height = r8.readVarint() : 5 === t5 ? e6.left = r8.readSVarint() : 6 === t5 ? e6.top = r8.readSVarint() : 7 === t5 && (e6.advance = r8.readVarint());
        }
        const Zu = Nu;
        function Ku(t5) {
          let e6 = 0, r8 = 0;
          for (const n7 of t5) e6 += n7.w * n7.h, r8 = Math.max(r8, n7.w);
          t5.sort((t6, e7) => e7.h - t6.h);
          const n6 = [{ x: 0, y: 0, w: Math.max(Math.ceil(Math.sqrt(e6 / 0.95)), r8), h: 1 / 0 }];
          let i6 = 0, s4 = 0;
          for (const e7 of t5) for (let t6 = n6.length - 1; t6 >= 0; t6--) {
            const r9 = n6[t6];
            if (!(e7.w > r9.w || e7.h > r9.h)) {
              if (e7.x = r9.x, e7.y = r9.y, s4 = Math.max(s4, e7.y + e7.h), i6 = Math.max(i6, e7.x + e7.w), e7.w === r9.w && e7.h === r9.h) {
                const e8 = n6.pop();
                t6 < n6.length && (n6[t6] = e8);
              } else e7.h === r9.h ? (r9.x += e7.w, r9.w -= e7.w) : e7.w === r9.w ? (r9.y += e7.h, r9.h -= e7.h) : (n6.push({ x: r9.x + e7.w, y: r9.y, w: r9.w - e7.w, h: e7.h }), r9.y += e7.h, r9.h -= e7.h);
              break;
            }
          }
          return { w: i6, h: s4, fill: e6 / (i6 * s4) || 0 };
        }
        const Xu = 1;
        class Hu {
          constructor(t5, { pixelRatio: e6, version: r8, stretchX: n6, stretchY: i6, content: s4, textFitWidth: a4, textFitHeight: o6 }) {
            this.paddedRect = t5, this.pixelRatio = e6, this.stretchX = n6, this.stretchY = i6, this.content = s4, this.version = r8, this.textFitWidth = a4, this.textFitHeight = o6;
          }
          get tl() {
            return [this.paddedRect.x + Xu, this.paddedRect.y + Xu];
          }
          get br() {
            return [this.paddedRect.x + this.paddedRect.w - Xu, this.paddedRect.y + this.paddedRect.h - Xu];
          }
          get tlbr() {
            return this.tl.concat(this.br);
          }
          get displaySize() {
            return [(this.paddedRect.w - 2 * Xu) / this.pixelRatio, (this.paddedRect.h - 2 * Xu) / this.pixelRatio];
          }
        }
        class Yu {
          constructor(t5, e6) {
            const r8 = {}, n6 = {};
            this.haveRenderCallbacks = [];
            const i6 = [];
            this.addImages(t5, r8, i6), this.addImages(e6, n6, i6);
            const { w: s4, h: a4 } = Ku(i6), o6 = new No({ width: s4 || 1, height: a4 || 1 });
            for (const e7 in t5) {
              const n7 = t5[e7], i7 = r8[e7].paddedRect;
              No.copy(n7.data, o6, { x: 0, y: 0 }, { x: i7.x + Xu, y: i7.y + Xu }, n7.data);
            }
            for (const t6 in e6) {
              const r9 = e6[t6], i7 = n6[t6].paddedRect, s5 = i7.x + Xu, a5 = i7.y + Xu, l5 = r9.data.width, u4 = r9.data.height;
              No.copy(r9.data, o6, { x: 0, y: 0 }, { x: s5, y: a5 }, r9.data), No.copy(r9.data, o6, { x: 0, y: u4 - 1 }, { x: s5, y: a5 - 1 }, { width: l5, height: 1 }), No.copy(r9.data, o6, { x: 0, y: 0 }, { x: s5, y: a5 + u4 }, { width: l5, height: 1 }), No.copy(r9.data, o6, { x: l5 - 1, y: 0 }, { x: s5 - 1, y: a5 }, { width: 1, height: u4 }), No.copy(r9.data, o6, { x: 0, y: 0 }, { x: s5 + l5, y: a5 }, { width: 1, height: u4 });
            }
            this.image = o6, this.iconPositions = r8, this.patternPositions = n6;
          }
          addImages(t5, e6, r8) {
            for (const n6 in t5) {
              const i6 = t5[n6], s4 = { x: 0, y: 0, w: i6.data.width + 2 * Xu, h: i6.data.height + 2 * Xu };
              r8.push(s4), e6[n6] = new Hu(s4, i6), i6.hasRenderCallback && this.haveRenderCallbacks.push(n6);
            }
          }
          patchUpdatedImages(t5, e6) {
            t5.dispatchRenderCallbacks(this.haveRenderCallbacks);
            for (const r8 in t5.updatedImages) this.patchUpdatedImage(this.iconPositions[r8], t5.getImage(r8), e6), this.patchUpdatedImage(this.patternPositions[r8], t5.getImage(r8), e6);
          }
          patchUpdatedImage(t5, e6, r8) {
            if (!t5 || !e6) return;
            if (t5.version === e6.version) return;
            t5.version = e6.version;
            const [n6, i6] = t5.tl;
            r8.update(e6.data, void 0, { x: n6, y: i6 });
          }
        }
        var Ju;
        Zi("ImagePosition", Hu), Zi("ImageAtlas", Yu), t4.ah = void 0, (Ju = t4.ah || (t4.ah = {}))[Ju.none = 0] = "none", Ju[Ju.horizontal = 1] = "horizontal", Ju[Ju.vertical = 2] = "vertical", Ju[Ju.horizontalOnly = 3] = "horizontalOnly";
        const Wu = -17;
        class Qu {
          constructor() {
            this.scale = 1, this.fontStack = "", this.imageName = null, this.verticalAlign = "bottom";
          }
          static forText(t5, e6, r8) {
            const n6 = new Qu();
            return n6.scale = t5 || 1, n6.fontStack = e6, n6.verticalAlign = r8 || "bottom", n6;
          }
          static forImage(t5, e6) {
            const r8 = new Qu();
            return r8.imageName = t5, r8.verticalAlign = e6 || "bottom", r8;
          }
        }
        class tc {
          constructor() {
            this.text = "", this.sectionIndex = [], this.sections = [], this.imageSectionID = null;
          }
          static fromFeature(t5, e6) {
            const r8 = new tc();
            for (let n6 = 0; n6 < t5.sections.length; n6++) {
              const i6 = t5.sections[n6];
              i6.image ? r8.addImageSection(i6) : r8.addTextSection(i6, e6);
            }
            return r8;
          }
          length() {
            return this.text.length;
          }
          getSection(t5) {
            return this.sections[this.sectionIndex[t5]];
          }
          getSectionIndex(t5) {
            return this.sectionIndex[t5];
          }
          getCharCode(t5) {
            return this.text.charCodeAt(t5);
          }
          verticalizePunctuation() {
            this.text = function(t5) {
              let e6 = "";
              for (let r8 = 0; r8 < t5.length; r8++) {
                const n6 = t5.charCodeAt(r8 + 1) || null, i6 = t5.charCodeAt(r8 - 1) || null;
                e6 += n6 && os(n6) && !Eu[t5[r8 + 1]] || i6 && os(i6) && !Eu[t5[r8 - 1]] || !Eu[t5[r8]] ? t5[r8] : Eu[t5[r8]];
              }
              return e6;
            }(this.text);
          }
          trim() {
            let t5 = 0;
            for (let e7 = 0; e7 < this.text.length && rc[this.text.charCodeAt(e7)]; e7++) t5++;
            let e6 = this.text.length;
            for (let r8 = this.text.length - 1; r8 >= 0 && r8 >= t5 && rc[this.text.charCodeAt(r8)]; r8--) e6--;
            this.text = this.text.substring(t5, e6), this.sectionIndex = this.sectionIndex.slice(t5, e6);
          }
          substring(t5, e6) {
            const r8 = new tc();
            return r8.text = this.text.substring(t5, e6), r8.sectionIndex = this.sectionIndex.slice(t5, e6), r8.sections = this.sections, r8;
          }
          toString() {
            return this.text;
          }
          getMaxScale() {
            return this.sectionIndex.reduce((t5, e6) => Math.max(t5, this.sections[e6].scale), 0);
          }
          getMaxImageSize(t5) {
            let e6 = 0, r8 = 0;
            for (let n6 = 0; n6 < this.length(); n6++) {
              const i6 = this.getSection(n6);
              if (i6.imageName) {
                const n7 = t5[i6.imageName];
                if (!n7) continue;
                const s4 = n7.displaySize;
                e6 = Math.max(e6, s4[0]), r8 = Math.max(r8, s4[1]);
              }
            }
            return { maxImageWidth: e6, maxImageHeight: r8 };
          }
          addTextSection(t5, e6) {
            this.text += t5.text, this.sections.push(Qu.forText(t5.scale, t5.fontStack || e6, t5.verticalAlign));
            const r8 = this.sections.length - 1;
            for (let e7 = 0; e7 < t5.text.length; ++e7) this.sectionIndex.push(r8);
          }
          addImageSection(t5) {
            const e6 = t5.image ? t5.image.name : "";
            if (0 === e6.length) return void j3("Can't add FormattedSection with an empty image.");
            const r8 = this.getNextImageSectionCharCode();
            r8 ? (this.text += String.fromCharCode(r8), this.sections.push(Qu.forImage(e6, t5.verticalAlign)), this.sectionIndex.push(this.sections.length - 1)) : j3("Reached maximum number of images 6401");
          }
          getNextImageSectionCharCode() {
            return this.imageSectionID ? this.imageSectionID >= 63743 ? null : ++this.imageSectionID : (this.imageSectionID = 57344, this.imageSectionID);
          }
        }
        function ec2(e6, r8, n6, i6, s4, a4, o6, l5, u4, c5, h4, p4, f4, d4, y4) {
          const m4 = tc.fromFeature(e6, s4);
          let g4;
          p4 === t4.ah.vertical && m4.verticalizePunctuation();
          const { processBidirectionalText: x4, processStyledBidirectionalText: v4 } = ps;
          if (x4 && 1 === m4.sections.length) {
            g4 = [];
            const t5 = x4(m4.toString(), cc(m4, c5, a4, r8, i6, d4));
            for (const e7 of t5) {
              const t6 = new tc();
              t6.text = e7, t6.sections = m4.sections;
              for (let r9 = 0; r9 < e7.length; r9++) t6.sectionIndex.push(0);
              g4.push(t6);
            }
          } else if (v4) {
            g4 = [];
            const t5 = v4(m4.text, m4.sectionIndex, cc(m4, c5, a4, r8, i6, d4));
            for (const e7 of t5) {
              const t6 = new tc();
              t6.text = e7[0], t6.sectionIndex = e7[1], t6.sections = m4.sections, g4.push(t6);
            }
          } else g4 = function(t5, e7) {
            const r9 = [], n7 = t5.text;
            let i7 = 0;
            for (const n8 of e7) r9.push(t5.substring(i7, n8)), i7 = n8;
            return i7 < n7.length && r9.push(t5.substring(i7, n7.length)), r9;
          }(m4, cc(m4, c5, a4, r8, i6, d4));
          const b5 = [], w4 = { positionedLines: b5, text: m4.toString(), top: h4[1], bottom: h4[1], left: h4[0], right: h4[0], writingMode: p4, iconsInText: false, verticalizable: false };
          return function(t5, e7, r9, n7, i7, s5, a5, o7, l6, u5, c6, h5) {
            let p5 = 0, f5 = 0, d5 = 0, y5 = 0;
            const m5 = "right" === o7 ? 1 : "left" === o7 ? 0 : 0.5, g5 = Lu / h5;
            let x5 = 0;
            for (const a6 of i7) {
              a6.trim();
              const i8 = a6.getMaxScale(), o8 = { positionedGlyphs: [], lineOffset: 0 };
              t5.positionedLines[x5] = o8;
              const h6 = o8.positionedGlyphs;
              let v6 = 0;
              if (!a6.length()) {
                f5 += s5, ++x5;
                continue;
              }
              const b7 = pc(n7, a6, g5);
              for (let s6 = 0; s6 < a6.length(); s6++) {
                const o9 = a6.getSection(s6), d6 = a6.getSectionIndex(s6), y6 = a6.getCharCode(s6), m6 = dc(l6, c6, y6);
                let x6;
                if (o9.imageName) {
                  if (t5.iconsInText = true, o9.scale = o9.scale * g5, x6 = mc(o9, m6, i8, b7, n7), !x6) continue;
                  v6 = Math.max(v6, x6.imageOffset);
                } else if (x6 = yc(o9, y6, m6, b7, e7, r9), !x6) continue;
                const { rect: w6, metrics: _4, baselineOffset: S5 } = x6;
                h6.push({ glyph: y6, imageName: o9.imageName, x: p5, y: f5 + S5 + Wu, vertical: m6, scale: o9.scale, fontStack: o9.fontStack, sectionIndex: d6, metrics: _4, rect: w6 }), m6 ? (t5.verticalizable = true, p5 += (o9.imageName ? _4.advance : Lu) * o9.scale + u5) : p5 += _4.advance * o9.scale + u5;
              }
              0 !== h6.length && (d5 = Math.max(p5 - u5, d5), gc(h6, 0, h6.length - 1, m5)), p5 = 0, o8.lineOffset = Math.max(v6, (i8 - 1) * Lu);
              const w5 = s5 * i8 + v6;
              f5 += w5, y5 = Math.max(w5, y5), ++x5;
            }
            const { horizontalAlign: v5, verticalAlign: b6 } = hc(a5);
            (function(t6, e8, r10, n8, i8, s6, a6, o8, l7) {
              const u6 = (e8 - r10) * i8;
              let c7 = 0;
              c7 = s6 !== a6 ? -o8 * n8 - Wu : -n8 * l7 * a6 + 0.5 * a6;
              for (const e9 of t6) for (const t7 of e9.positionedGlyphs) t7.x += u6, t7.y += c7;
            })(t5.positionedLines, m5, v5, b6, d5, y5, s5, f5, i7.length), t5.top += -b6 * f5, t5.bottom = t5.top + f5, t5.left += -v5 * d5, t5.right = t5.left + d5;
          }(w4, r8, n6, i6, g4, o6, l5, u4, p4, c5, f4, y4), !function(t5) {
            for (const e7 of t5) if (0 !== e7.positionedGlyphs.length) return false;
            return true;
          }(b5) && w4;
        }
        const rc = { 9: true, 10: true, 11: true, 12: true, 13: true, 32: true }, nc = { 10: true, 32: true, 38: true, 41: true, 43: true, 45: true, 47: true, 173: true, 183: true, 8203: true, 8208: true, 8211: true, 8231: true }, ic = { 40: true };
        function sc(t5, e6, r8, n6, i6, s4) {
          if (e6.imageName) {
            const t6 = n6[e6.imageName];
            return t6 ? t6.displaySize[0] * e6.scale * Lu / s4 + i6 : 0;
          }
          {
            const n7 = r8[e6.fontStack], s5 = n7 && n7[t5];
            return s5 ? s5.metrics.advance * e6.scale + i6 : 0;
          }
        }
        function ac(t5, e6, r8, n6) {
          const i6 = Math.pow(t5 - e6, 2);
          return n6 ? t5 < e6 ? i6 / 2 : 2 * i6 : i6 + Math.abs(r8) * r8;
        }
        function oc(t5, e6, r8) {
          let n6 = 0;
          return 10 === t5 && (n6 -= 1e4), r8 && (n6 += 150), 40 !== t5 && 65288 !== t5 || (n6 += 50), 41 !== e6 && 65289 !== e6 || (n6 += 50), n6;
        }
        function lc(t5, e6, r8, n6, i6, s4) {
          let a4 = null, o6 = ac(e6, r8, i6, s4);
          for (const t6 of n6) {
            const n7 = ac(e6 - t6.x, r8, i6, s4) + t6.badness;
            n7 <= o6 && (a4 = t6, o6 = n7);
          }
          return { index: t5, x: e6, priorBreak: a4, badness: o6 };
        }
        function uc(t5) {
          return t5 ? uc(t5.priorBreak).concat(t5.index) : [];
        }
        function cc(t5, e6, r8, n6, i6, s4) {
          if (!t5) return [];
          const a4 = [], o6 = function(t6, e7, r9, n7, i7, s5) {
            let a5 = 0;
            for (let r10 = 0; r10 < t6.length(); r10++) {
              const o7 = t6.getSection(r10);
              a5 += sc(t6.getCharCode(r10), o7, n7, i7, e7, s5);
            }
            return a5 / Math.max(1, Math.ceil(a5 / r9));
          }(t5, e6, r8, n6, i6, s4), l5 = t5.text.indexOf("\u200B") >= 0;
          let u4 = 0;
          for (let r9 = 0; r9 < t5.length(); r9++) {
            const h4 = t5.getSection(r9), p4 = t5.getCharCode(r9);
            if (rc[p4] || (u4 += sc(p4, h4, n6, i6, e6, s4)), r9 < t5.length() - 1) {
              const e7 = !((c5 = p4) < 11904) && (!!Qi["CJK Compatibility Forms"](c5) || !!Qi["CJK Compatibility"](c5) || !!Qi["CJK Strokes"](c5) || !!Qi["CJK Symbols and Punctuation"](c5) || !!Qi["Enclosed CJK Letters and Months"](c5) || !!Qi["Halfwidth and Fullwidth Forms"](c5) || !!Qi["Ideographic Description Characters"](c5) || !!Qi["Vertical Forms"](c5) || ss.test(String.fromCodePoint(c5)));
              (nc[p4] || e7 || h4.imageName || r9 !== t5.length() - 2 && ic[t5.getCharCode(r9 + 1)]) && a4.push(lc(r9 + 1, u4, o6, a4, oc(p4, t5.getCharCode(r9 + 1), e7 && l5), false));
            }
          }
          var c5;
          return uc(lc(t5.length(), u4, o6, a4, 0, true));
        }
        function hc(t5) {
          let e6 = 0.5, r8 = 0.5;
          switch (t5) {
            case "right":
            case "top-right":
            case "bottom-right":
              e6 = 1;
              break;
            case "left":
            case "top-left":
            case "bottom-left":
              e6 = 0;
          }
          switch (t5) {
            case "bottom":
            case "bottom-right":
            case "bottom-left":
              r8 = 1;
              break;
            case "top":
            case "top-right":
            case "top-left":
              r8 = 0;
          }
          return { horizontalAlign: e6, verticalAlign: r8 };
        }
        function pc(t5, e6, r8) {
          const n6 = e6.getMaxScale() * Lu, { maxImageWidth: i6, maxImageHeight: s4 } = e6.getMaxImageSize(t5), a4 = Math.max(n6, s4 * r8);
          return { verticalLineContentWidth: Math.max(n6, i6 * r8), horizontalLineContentHeight: a4 };
        }
        function fc(t5) {
          switch (t5) {
            case "top":
              return 0;
            case "center":
              return 0.5;
            default:
              return 1;
          }
        }
        function dc(e6, r8, n6) {
          return !(e6 === t4.ah.horizontal || !r8 && !as(n6) || r8 && (rc[n6] || (i6 = n6, /\p{sc=Arab}/u.test(String.fromCodePoint(i6)))));
          var i6;
        }
        function yc(t5, e6, r8, n6, i6, s4) {
          const a4 = s4[t5.fontStack], o6 = function(t6, e7, r9, n7) {
            if (t6 && t6.rect) return t6;
            const i7 = e7[r9.fontStack], s5 = i7 && i7[n7];
            return s5 ? { rect: null, metrics: s5.metrics } : null;
          }(a4 && a4[e6], i6, t5, e6);
          if (null === o6) return null;
          let l5;
          if (r8) l5 = n6.verticalLineContentWidth - t5.scale * Lu;
          else {
            const e7 = fc(t5.verticalAlign);
            l5 = (n6.horizontalLineContentHeight - t5.scale * Lu) * e7;
          }
          return { rect: o6.rect, metrics: o6.metrics, baselineOffset: l5 };
        }
        function mc(t5, e6, r8, n6, i6) {
          const s4 = i6[t5.imageName];
          if (!s4) return null;
          const a4 = s4.paddedRect, o6 = s4.displaySize, l5 = { width: o6[0], height: o6[1], left: Xu, top: -3, advance: e6 ? o6[1] : o6[0] };
          let u4;
          if (e6) u4 = n6.verticalLineContentWidth - o6[1] * t5.scale;
          else {
            const e7 = fc(t5.verticalAlign);
            u4 = (n6.horizontalLineContentHeight - o6[1] * t5.scale) * e7;
          }
          return { rect: a4, metrics: l5, baselineOffset: u4, imageOffset: (e6 ? o6[0] : o6[1]) * t5.scale - Lu * r8 };
        }
        function gc(t5, e6, r8, n6) {
          if (0 === n6) return;
          const i6 = t5[r8], s4 = (t5[r8].x + i6.metrics.advance * i6.scale) * n6;
          for (let n7 = e6; n7 <= r8; n7++) t5[n7].x -= s4;
        }
        function xc(t5, e6, r8) {
          const { horizontalAlign: n6, verticalAlign: i6 } = hc(r8), s4 = e6[0] - t5.displaySize[0] * n6, a4 = e6[1] - t5.displaySize[1] * i6;
          return { image: t5, top: a4, bottom: a4 + t5.displaySize[1], left: s4, right: s4 + t5.displaySize[0] };
        }
        function vc(t5) {
          var e6, r8;
          let n6 = t5.left, i6 = t5.top, s4 = t5.right - n6, a4 = t5.bottom - i6;
          const o6 = null !== (e6 = t5.image.textFitWidth) && void 0 !== e6 ? e6 : "stretchOrShrink", l5 = null !== (r8 = t5.image.textFitHeight) && void 0 !== r8 ? r8 : "stretchOrShrink", u4 = (t5.image.content[2] - t5.image.content[0]) / (t5.image.content[3] - t5.image.content[1]);
          if ("proportional" === l5) {
            if ("stretchOnly" === o6 && s4 / a4 < u4 || "proportional" === o6) {
              const t6 = Math.ceil(a4 * u4);
              n6 *= t6 / s4, s4 = t6;
            }
          } else if ("proportional" === o6 && "stretchOnly" === l5 && 0 !== u4 && s4 / a4 > u4) {
            const t6 = Math.ceil(s4 / u4);
            i6 *= t6 / a4, a4 = t6;
          }
          return { x1: n6, y1: i6, x2: n6 + s4, y2: i6 + a4 };
        }
        function bc(t5, e6, r8, n6, i6, s4) {
          const a4 = t5.image;
          let o6;
          if (a4.content) {
            const t6 = a4.content, e7 = a4.pixelRatio || 1;
            o6 = [t6[0] / e7, t6[1] / e7, a4.displaySize[0] - t6[2] / e7, a4.displaySize[1] - t6[3] / e7];
          }
          const l5 = e6.left * s4, u4 = e6.right * s4;
          let c5, h4, p4, f4;
          "width" === r8 || "both" === r8 ? (f4 = i6[0] + l5 - n6[3], h4 = i6[0] + u4 + n6[1]) : (f4 = i6[0] + (l5 + u4 - a4.displaySize[0]) / 2, h4 = f4 + a4.displaySize[0]);
          const d4 = e6.top * s4, y4 = e6.bottom * s4;
          return "height" === r8 || "both" === r8 ? (c5 = i6[1] + d4 - n6[0], p4 = i6[1] + y4 + n6[2]) : (c5 = i6[1] + (d4 + y4 - a4.displaySize[1]) / 2, p4 = c5 + a4.displaySize[1]), { image: a4, top: c5, right: h4, bottom: p4, left: f4, collisionPadding: o6 };
        }
        const wc = 255, _c = 128, Sc = wc * _c;
        function Ac(t5, e6) {
          const { expression: r8 } = e6;
          if ("constant" === r8.kind) return { kind: "constant", layoutSize: r8.evaluate(new fs(t5 + 1)) };
          if ("source" === r8.kind) return { kind: "source" };
          {
            const { zoomStops: e7, interpolationType: n6 } = r8;
            let i6 = 0;
            for (; i6 < e7.length && e7[i6] <= t5; ) i6++;
            i6 = Math.max(0, i6 - 1);
            let s4 = i6;
            for (; s4 < e7.length && e7[s4] < t5 + 1; ) s4++;
            s4 = Math.min(e7.length - 1, s4);
            const a4 = e7[i6], o6 = e7[s4];
            return "composite" === r8.kind ? { kind: "composite", minZoom: a4, maxZoom: o6, interpolationType: n6 } : { kind: "camera", minZoom: a4, maxZoom: o6, minSize: r8.evaluate(new fs(a4)), maxSize: r8.evaluate(new fs(o6)), interpolationType: n6 };
          }
        }
        function kc(t5, e6, r8) {
          let n6 = "never";
          const i6 = t5.get(e6);
          return i6 ? n6 = i6 : t5.get(r8) && (n6 = "always"), n6;
        }
        const Mc = Ql.VectorTileFeature.types, Ic = [{ name: "a_fade_opacity", components: 1, type: "Uint8", offset: 0 }];
        function zc(t5, e6, r8, n6, i6, s4, a4, o6, l5, u4, c5, h4, p4) {
          const f4 = o6 ? Math.min(Sc, Math.round(o6[0])) : 0, d4 = o6 ? Math.min(Sc, Math.round(o6[1])) : 0;
          t5.emplaceBack(e6, r8, Math.round(32 * n6), Math.round(32 * i6), s4, a4, (f4 << 1) + (l5 ? 1 : 0), d4, 16 * u4, 16 * c5, 256 * h4, 256 * p4);
        }
        function Pc(t5, e6, r8) {
          t5.emplaceBack(e6.x, e6.y, r8), t5.emplaceBack(e6.x, e6.y, r8), t5.emplaceBack(e6.x, e6.y, r8), t5.emplaceBack(e6.x, e6.y, r8);
        }
        function Cc(t5) {
          for (const e6 of t5.sections) if (hs(e6.text)) return true;
          return false;
        }
        class Bc {
          constructor(t5) {
            this.layoutVertexArray = new Sa(), this.indexArray = new za(), this.programConfigurations = t5, this.segments = new Va(), this.dynamicLayoutVertexArray = new Aa(), this.opacityVertexArray = new ka(), this.hasVisibleVertices = false, this.placedSymbolArray = new oa();
          }
          isEmpty() {
            return 0 === this.layoutVertexArray.length && 0 === this.indexArray.length && 0 === this.dynamicLayoutVertexArray.length && 0 === this.opacityVertexArray.length;
          }
          upload(t5, e6, r8, n6) {
            this.isEmpty() || (r8 && (this.layoutVertexBuffer = t5.createVertexBuffer(this.layoutVertexArray, Iu.members), this.indexBuffer = t5.createIndexBuffer(this.indexArray, e6), this.dynamicLayoutVertexBuffer = t5.createVertexBuffer(this.dynamicLayoutVertexArray, zu.members, true), this.opacityVertexBuffer = t5.createVertexBuffer(this.opacityVertexArray, Ic, true), this.opacityVertexBuffer.itemSize = 1), (r8 || n6) && this.programConfigurations.upload(t5));
          }
          destroy() {
            this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.dynamicLayoutVertexBuffer.destroy(), this.opacityVertexBuffer.destroy());
          }
        }
        Zi("SymbolBuffers", Bc);
        class Vc {
          constructor(t5, e6, r8) {
            this.layoutVertexArray = new t5(), this.layoutAttributes = e6, this.indexArray = new r8(), this.segments = new Va(), this.collisionVertexArray = new Ia();
          }
          upload(t5) {
            this.layoutVertexBuffer = t5.createVertexBuffer(this.layoutVertexArray, this.layoutAttributes), this.indexBuffer = t5.createIndexBuffer(this.indexArray), this.collisionVertexBuffer = t5.createVertexBuffer(this.collisionVertexArray, Pu.members, true);
          }
          destroy() {
            this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.segments.destroy(), this.collisionVertexBuffer.destroy());
          }
        }
        Zi("CollisionBuffers", Vc);
        class Ec {
          constructor(e6) {
            this.collisionBoxArray = e6.collisionBoxArray, this.zoom = e6.zoom, this.overscaling = e6.overscaling, this.layers = e6.layers, this.layerIds = this.layers.map((t5) => t5.id), this.index = e6.index, this.pixelRatio = e6.pixelRatio, this.sourceLayerIndex = e6.sourceLayerIndex, this.hasPattern = false, this.hasRTLText = false, this.sortKeyRanges = [], this.collisionCircleArray = [];
            const r8 = this.layers[0]._unevaluatedLayout._values;
            this.textSizeData = Ac(this.zoom, r8["text-size"]), this.iconSizeData = Ac(this.zoom, r8["icon-size"]);
            const n6 = this.layers[0].layout, i6 = n6.get("symbol-sort-key"), s4 = n6.get("symbol-z-order");
            this.canOverlap = "never" !== kc(n6, "text-overlap", "text-allow-overlap") || "never" !== kc(n6, "icon-overlap", "icon-allow-overlap") || n6.get("text-ignore-placement") || n6.get("icon-ignore-placement"), this.sortFeaturesByKey = "viewport-y" !== s4 && !i6.isConstant(), this.sortFeaturesByY = ("viewport-y" === s4 || "auto" === s4 && !this.sortFeaturesByKey) && this.canOverlap, "point" === n6.get("symbol-placement") && (this.writingModes = n6.get("text-writing-mode").map((e7) => t4.ah[e7])), this.stateDependentLayerIds = this.layers.filter((t5) => t5.isStateDependent()).map((t5) => t5.id), this.sourceID = e6.sourceID;
          }
          createArrays() {
            this.text = new Bc(new so(this.layers, this.zoom, (t5) => /^text/.test(t5))), this.icon = new Bc(new so(this.layers, this.zoom, (t5) => /^icon/.test(t5))), this.glyphOffsetArray = new ca(), this.lineVertexArray = new ha(), this.symbolInstances = new ua(), this.textAnchorOffsets = new fa();
          }
          calculateGlyphDependencies(t5, e6, r8, n6, i6) {
            for (let s4 = 0; s4 < t5.length; s4++) if (e6[t5.charCodeAt(s4)] = true, (r8 || n6) && i6) {
              const r9 = Eu[t5.charAt(s4)];
              r9 && (e6[r9.charCodeAt(0)] = true);
            }
          }
          populate(e6, r8, n6) {
            const i6 = this.layers[0], s4 = i6.layout, a4 = s4.get("text-font"), o6 = s4.get("text-field"), l5 = s4.get("icon-image"), u4 = ("constant" !== o6.value.kind || o6.value.value instanceof _e && !o6.value.value.isEmpty() || o6.value.value.toString().length > 0) && ("constant" !== a4.value.kind || a4.value.value.length > 0), c5 = "constant" !== l5.value.kind || !!l5.value.value || Object.keys(l5.parameters).length > 0, h4 = s4.get("symbol-sort-key");
            if (this.features = [], !u4 && !c5) return;
            const p4 = r8.iconDependencies, f4 = r8.glyphDependencies, d4 = r8.availableImages, y4 = new fs(this.zoom);
            for (const { feature: r9, id: o7, index: l6, sourceLayerIndex: m4 } of e6) {
              const e7 = i6._featureFilter.needGeometry, g4 = ho(r9, e7);
              if (!i6._featureFilter.filter(y4, g4, n6)) continue;
              let x4, v4;
              if (e7 || (g4.geometry = co(r9)), u4) {
                const t5 = i6.getValueAndResolveTokens("text-field", g4, n6, d4), e8 = _e.factory(t5), r10 = this.hasRTLText = this.hasRTLText || Cc(e8);
                (!r10 || "unavailable" === ps.getRTLTextPluginStatus() || r10 && ps.isParsed()) && (x4 = Vu(e8, i6, g4));
              }
              if (c5) {
                const t5 = i6.getValueAndResolveTokens("icon-image", g4, n6, d4);
                v4 = t5 instanceof Ie ? t5 : Ie.fromString(t5);
              }
              if (!x4 && !v4) continue;
              const b5 = this.sortFeaturesByKey ? h4.evaluate(g4, {}, n6) : void 0;
              if (this.features.push({ id: o7, text: x4, icon: v4, index: l6, sourceLayerIndex: m4, geometry: g4.geometry, properties: r9.properties, type: Mc[r9.type], sortKey: b5 }), v4 && (p4[v4.name] = true), x4) {
                const e8 = a4.evaluate(g4, {}, n6).join(","), r10 = "viewport" !== s4.get("text-rotation-alignment") && "point" !== s4.get("symbol-placement");
                this.allowVerticalPlacement = this.writingModes && this.writingModes.indexOf(t4.ah.vertical) >= 0;
                for (const t5 of x4.sections) if (t5.image) p4[t5.image.name] = true;
                else {
                  const n7 = ts(x4.toString()), i7 = t5.fontStack || e8, s5 = f4[i7] = f4[i7] || {};
                  this.calculateGlyphDependencies(t5.text, s5, r10, this.allowVerticalPlacement, n7);
                }
              }
            }
            "line" === s4.get("symbol-placement") && (this.features = function(t5) {
              const e7 = {}, r9 = {}, n7 = [];
              let i7 = 0;
              function s5(e8) {
                n7.push(t5[e8]), i7++;
              }
              function a5(t6, e8, i8) {
                const s6 = r9[t6];
                return delete r9[t6], r9[e8] = s6, n7[s6].geometry[0].pop(), n7[s6].geometry[0] = n7[s6].geometry[0].concat(i8[0]), s6;
              }
              function o7(t6, r10, i8) {
                const s6 = e7[r10];
                return delete e7[r10], e7[t6] = s6, n7[s6].geometry[0].shift(), n7[s6].geometry[0] = i8[0].concat(n7[s6].geometry[0]), s6;
              }
              function l6(t6, e8, r10) {
                const n8 = r10 ? e8[0][e8[0].length - 1] : e8[0][0];
                return `${t6}:${n8.x}:${n8.y}`;
              }
              for (let u5 = 0; u5 < t5.length; u5++) {
                const c6 = t5[u5], h5 = c6.geometry, p5 = c6.text ? c6.text.toString() : null;
                if (!p5) {
                  s5(u5);
                  continue;
                }
                const f5 = l6(p5, h5), d5 = l6(p5, h5, true);
                if (f5 in r9 && d5 in e7 && r9[f5] !== e7[d5]) {
                  const t6 = o7(f5, d5, h5), i8 = a5(f5, d5, n7[t6].geometry);
                  delete e7[f5], delete r9[d5], r9[l6(p5, n7[i8].geometry, true)] = i8, n7[t6].geometry = null;
                } else f5 in r9 ? a5(f5, d5, h5) : d5 in e7 ? o7(f5, d5, h5) : (s5(u5), e7[f5] = i7 - 1, r9[d5] = i7 - 1);
              }
              return n7.filter((t6) => t6.geometry);
            }(this.features)), this.sortFeaturesByKey && this.features.sort((t5, e7) => t5.sortKey - e7.sortKey);
          }
          update(t5, e6, r8) {
            this.stateDependentLayers.length && (this.text.programConfigurations.updatePaintArrays(t5, e6, this.layers, r8), this.icon.programConfigurations.updatePaintArrays(t5, e6, this.layers, r8));
          }
          isEmpty() {
            return 0 === this.symbolInstances.length && !this.hasRTLText;
          }
          uploadPending() {
            return !this.uploaded || this.text.programConfigurations.needsUpload || this.icon.programConfigurations.needsUpload;
          }
          upload(t5) {
            !this.uploaded && this.hasDebugData() && (this.textCollisionBox.upload(t5), this.iconCollisionBox.upload(t5)), this.text.upload(t5, this.sortFeaturesByY, !this.uploaded, this.text.programConfigurations.needsUpload), this.icon.upload(t5, this.sortFeaturesByY, !this.uploaded, this.icon.programConfigurations.needsUpload), this.uploaded = true;
          }
          destroyDebugData() {
            this.textCollisionBox.destroy(), this.iconCollisionBox.destroy();
          }
          destroy() {
            this.text.destroy(), this.icon.destroy(), this.hasDebugData() && this.destroyDebugData();
          }
          addToLineVertexArray(t5, e6) {
            const r8 = this.lineVertexArray.length;
            if (void 0 !== t5.segment) {
              let r9 = t5.dist(e6[t5.segment + 1]), n6 = t5.dist(e6[t5.segment]);
              const i6 = {};
              for (let n7 = t5.segment + 1; n7 < e6.length; n7++) i6[n7] = { x: e6[n7].x, y: e6[n7].y, tileUnitDistanceFromAnchor: r9 }, n7 < e6.length - 1 && (r9 += e6[n7 + 1].dist(e6[n7]));
              for (let r10 = t5.segment || 0; r10 >= 0; r10--) i6[r10] = { x: e6[r10].x, y: e6[r10].y, tileUnitDistanceFromAnchor: n6 }, r10 > 0 && (n6 += e6[r10 - 1].dist(e6[r10]));
              for (let t6 = 0; t6 < e6.length; t6++) {
                const e7 = i6[t6];
                this.lineVertexArray.emplaceBack(e7.x, e7.y, e7.tileUnitDistanceFromAnchor);
              }
            }
            return { lineStartIndex: r8, lineLength: this.lineVertexArray.length - r8 };
          }
          addSymbols(e6, r8, n6, i6, s4, a4, o6, l5, u4, c5, h4, p4) {
            const f4 = e6.indexArray, d4 = e6.layoutVertexArray, y4 = e6.segments.prepareSegment(4 * r8.length, d4, f4, this.canOverlap ? a4.sortKey : void 0), m4 = this.glyphOffsetArray.length, g4 = y4.vertexLength, x4 = this.allowVerticalPlacement && o6 === t4.ah.vertical ? Math.PI / 2 : 0, v4 = a4.text && a4.text.sections;
            for (let t5 = 0; t5 < r8.length; t5++) {
              const { tl: i7, tr: s5, bl: o7, br: u5, tex: c6, pixelOffsetTL: h5, pixelOffsetBR: m5, minFontScaleX: g5, minFontScaleY: b5, glyphOffset: w4, isSDF: _4, sectionIndex: S5 } = r8[t5], A5 = y4.vertexLength, k4 = w4[1];
              zc(d4, l5.x, l5.y, i7.x, k4 + i7.y, c6.x, c6.y, n6, _4, h5.x, h5.y, g5, b5), zc(d4, l5.x, l5.y, s5.x, k4 + s5.y, c6.x + c6.w, c6.y, n6, _4, m5.x, h5.y, g5, b5), zc(d4, l5.x, l5.y, o7.x, k4 + o7.y, c6.x, c6.y + c6.h, n6, _4, h5.x, m5.y, g5, b5), zc(d4, l5.x, l5.y, u5.x, k4 + u5.y, c6.x + c6.w, c6.y + c6.h, n6, _4, m5.x, m5.y, g5, b5), Pc(e6.dynamicLayoutVertexArray, l5, x4), f4.emplaceBack(A5, A5 + 2, A5 + 1), f4.emplaceBack(A5 + 1, A5 + 2, A5 + 3), y4.vertexLength += 4, y4.primitiveLength += 2, this.glyphOffsetArray.emplaceBack(w4[0]), t5 !== r8.length - 1 && S5 === r8[t5 + 1].sectionIndex || e6.programConfigurations.populatePaintArrays(d4.length, a4, a4.index, {}, p4, v4 && v4[S5]);
            }
            e6.placedSymbolArray.emplaceBack(l5.x, l5.y, m4, this.glyphOffsetArray.length - m4, g4, u4, c5, l5.segment, n6 ? n6[0] : 0, n6 ? n6[1] : 0, i6[0], i6[1], o6, 0, false, 0, h4);
          }
          _addCollisionDebugVertex(t5, e6, r8, n6, i6, s4) {
            return e6.emplaceBack(0, 0), t5.emplaceBack(r8.x, r8.y, n6, i6, Math.round(s4.x), Math.round(s4.y));
          }
          addCollisionDebugVertices(t5, e6, r8, n6, i6, s4, a4) {
            const o6 = i6.segments.prepareSegment(4, i6.layoutVertexArray, i6.indexArray), u4 = o6.vertexLength, c5 = i6.layoutVertexArray, h4 = i6.collisionVertexArray, p4 = a4.anchorX, f4 = a4.anchorY;
            this._addCollisionDebugVertex(c5, h4, s4, p4, f4, new l4(t5, e6)), this._addCollisionDebugVertex(c5, h4, s4, p4, f4, new l4(r8, e6)), this._addCollisionDebugVertex(c5, h4, s4, p4, f4, new l4(r8, n6)), this._addCollisionDebugVertex(c5, h4, s4, p4, f4, new l4(t5, n6)), o6.vertexLength += 4;
            const d4 = i6.indexArray;
            d4.emplaceBack(u4, u4 + 1), d4.emplaceBack(u4 + 1, u4 + 2), d4.emplaceBack(u4 + 2, u4 + 3), d4.emplaceBack(u4 + 3, u4), o6.primitiveLength += 4;
          }
          addDebugCollisionBoxes(t5, e6, r8, n6) {
            for (let i6 = t5; i6 < e6; i6++) {
              const t6 = this.collisionBoxArray.get(i6);
              this.addCollisionDebugVertices(t6.x1, t6.y1, t6.x2, t6.y2, n6 ? this.textCollisionBox : this.iconCollisionBox, t6.anchorPoint, r8);
            }
          }
          generateCollisionDebugBuffers() {
            this.hasDebugData() && this.destroyDebugData(), this.textCollisionBox = new Vc(Ma, Cu.members, Pa), this.iconCollisionBox = new Vc(Ma, Cu.members, Pa);
            for (let t5 = 0; t5 < this.symbolInstances.length; t5++) {
              const e6 = this.symbolInstances.get(t5);
              this.addDebugCollisionBoxes(e6.textBoxStartIndex, e6.textBoxEndIndex, e6, true), this.addDebugCollisionBoxes(e6.verticalTextBoxStartIndex, e6.verticalTextBoxEndIndex, e6, true), this.addDebugCollisionBoxes(e6.iconBoxStartIndex, e6.iconBoxEndIndex, e6, false), this.addDebugCollisionBoxes(e6.verticalIconBoxStartIndex, e6.verticalIconBoxEndIndex, e6, false);
            }
          }
          _deserializeCollisionBoxesForSymbol(t5, e6, r8, n6, i6, s4, a4, o6, l5) {
            const u4 = {};
            for (let n7 = e6; n7 < r8; n7++) {
              const e7 = t5.get(n7);
              u4.textBox = { x1: e7.x1, y1: e7.y1, x2: e7.x2, y2: e7.y2, anchorPointX: e7.anchorPointX, anchorPointY: e7.anchorPointY }, u4.textFeatureIndex = e7.featureIndex;
              break;
            }
            for (let e7 = n6; e7 < i6; e7++) {
              const r9 = t5.get(e7);
              u4.verticalTextBox = { x1: r9.x1, y1: r9.y1, x2: r9.x2, y2: r9.y2, anchorPointX: r9.anchorPointX, anchorPointY: r9.anchorPointY }, u4.verticalTextFeatureIndex = r9.featureIndex;
              break;
            }
            for (let e7 = s4; e7 < a4; e7++) {
              const r9 = t5.get(e7);
              u4.iconBox = { x1: r9.x1, y1: r9.y1, x2: r9.x2, y2: r9.y2, anchorPointX: r9.anchorPointX, anchorPointY: r9.anchorPointY }, u4.iconFeatureIndex = r9.featureIndex;
              break;
            }
            for (let e7 = o6; e7 < l5; e7++) {
              const r9 = t5.get(e7);
              u4.verticalIconBox = { x1: r9.x1, y1: r9.y1, x2: r9.x2, y2: r9.y2, anchorPointX: r9.anchorPointX, anchorPointY: r9.anchorPointY }, u4.verticalIconFeatureIndex = r9.featureIndex;
              break;
            }
            return u4;
          }
          deserializeCollisionBoxes(t5) {
            this.collisionArrays = [];
            for (let e6 = 0; e6 < this.symbolInstances.length; e6++) {
              const r8 = this.symbolInstances.get(e6);
              this.collisionArrays.push(this._deserializeCollisionBoxesForSymbol(t5, r8.textBoxStartIndex, r8.textBoxEndIndex, r8.verticalTextBoxStartIndex, r8.verticalTextBoxEndIndex, r8.iconBoxStartIndex, r8.iconBoxEndIndex, r8.verticalIconBoxStartIndex, r8.verticalIconBoxEndIndex));
            }
          }
          hasTextData() {
            return this.text.segments.get().length > 0;
          }
          hasIconData() {
            return this.icon.segments.get().length > 0;
          }
          hasDebugData() {
            return this.textCollisionBox && this.iconCollisionBox;
          }
          hasTextCollisionBoxData() {
            return this.hasDebugData() && this.textCollisionBox.segments.get().length > 0;
          }
          hasIconCollisionBoxData() {
            return this.hasDebugData() && this.iconCollisionBox.segments.get().length > 0;
          }
          addIndicesForPlacedSymbol(t5, e6) {
            const r8 = t5.placedSymbolArray.get(e6), n6 = r8.vertexStartIndex + 4 * r8.numGlyphs;
            for (let e7 = r8.vertexStartIndex; e7 < n6; e7 += 4) t5.indexArray.emplaceBack(e7, e7 + 2, e7 + 1), t5.indexArray.emplaceBack(e7 + 1, e7 + 2, e7 + 3);
          }
          getSortedSymbolIndexes(t5) {
            if (this.sortedAngle === t5 && void 0 !== this.symbolInstanceIndexes) return this.symbolInstanceIndexes;
            const e6 = Math.sin(t5), r8 = Math.cos(t5), n6 = [], i6 = [], s4 = [];
            for (let t6 = 0; t6 < this.symbolInstances.length; ++t6) {
              s4.push(t6);
              const a4 = this.symbolInstances.get(t6);
              n6.push(0 | Math.round(e6 * a4.anchorX + r8 * a4.anchorY)), i6.push(a4.featureIndex);
            }
            return s4.sort((t6, e7) => n6[t6] - n6[e7] || i6[e7] - i6[t6]), s4;
          }
          addToSortKeyRanges(t5, e6) {
            const r8 = this.sortKeyRanges[this.sortKeyRanges.length - 1];
            r8 && r8.sortKey === e6 ? r8.symbolInstanceEnd = t5 + 1 : this.sortKeyRanges.push({ sortKey: e6, symbolInstanceStart: t5, symbolInstanceEnd: t5 + 1 });
          }
          sortFeatures(t5) {
            if (this.sortFeaturesByY && this.sortedAngle !== t5 && !(this.text.segments.get().length > 1 || this.icon.segments.get().length > 1)) {
              this.symbolInstanceIndexes = this.getSortedSymbolIndexes(t5), this.sortedAngle = t5, this.text.indexArray.clear(), this.icon.indexArray.clear(), this.featureSortOrder = [];
              for (const t6 of this.symbolInstanceIndexes) {
                const e6 = this.symbolInstances.get(t6);
                this.featureSortOrder.push(e6.featureIndex), [e6.rightJustifiedTextSymbolIndex, e6.centerJustifiedTextSymbolIndex, e6.leftJustifiedTextSymbolIndex].forEach((t7, e7, r8) => {
                  t7 >= 0 && r8.indexOf(t7) === e7 && this.addIndicesForPlacedSymbol(this.text, t7);
                }), e6.verticalPlacedTextSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.text, e6.verticalPlacedTextSymbolIndex), e6.placedIconSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.icon, e6.placedIconSymbolIndex), e6.verticalPlacedIconSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.icon, e6.verticalPlacedIconSymbolIndex);
              }
              this.text.indexBuffer && this.text.indexBuffer.updateData(this.text.indexArray), this.icon.indexBuffer && this.icon.indexBuffer.updateData(this.icon.indexArray);
            }
          }
        }
        let Tc, Fc;
        Zi("SymbolBucket", Ec, { omit: ["layers", "collisionBoxArray", "features", "compareText"] }), Ec.MAX_GLYPHS = 65535, Ec.addDynamicAttributes = Pc;
        var $c = { get paint() {
          return Fc = Fc || new Is({ "icon-opacity": new Ss(dt.paint_symbol["icon-opacity"]), "icon-color": new Ss(dt.paint_symbol["icon-color"]), "icon-halo-color": new Ss(dt.paint_symbol["icon-halo-color"]), "icon-halo-width": new Ss(dt.paint_symbol["icon-halo-width"]), "icon-halo-blur": new Ss(dt.paint_symbol["icon-halo-blur"]), "icon-translate": new _s(dt.paint_symbol["icon-translate"]), "icon-translate-anchor": new _s(dt.paint_symbol["icon-translate-anchor"]), "text-opacity": new Ss(dt.paint_symbol["text-opacity"]), "text-color": new Ss(dt.paint_symbol["text-color"], { runtimeType: Tt, getOverride: (t5) => t5.textColor, hasOverride: (t5) => !!t5.textColor }), "text-halo-color": new Ss(dt.paint_symbol["text-halo-color"]), "text-halo-width": new Ss(dt.paint_symbol["text-halo-width"]), "text-halo-blur": new Ss(dt.paint_symbol["text-halo-blur"]), "text-translate": new _s(dt.paint_symbol["text-translate"]), "text-translate-anchor": new _s(dt.paint_symbol["text-translate-anchor"]) });
        }, get layout() {
          return Tc = Tc || new Is({ "symbol-placement": new _s(dt.layout_symbol["symbol-placement"]), "symbol-spacing": new _s(dt.layout_symbol["symbol-spacing"]), "symbol-avoid-edges": new _s(dt.layout_symbol["symbol-avoid-edges"]), "symbol-sort-key": new Ss(dt.layout_symbol["symbol-sort-key"]), "symbol-z-order": new _s(dt.layout_symbol["symbol-z-order"]), "icon-allow-overlap": new _s(dt.layout_symbol["icon-allow-overlap"]), "icon-overlap": new _s(dt.layout_symbol["icon-overlap"]), "icon-ignore-placement": new _s(dt.layout_symbol["icon-ignore-placement"]), "icon-optional": new _s(dt.layout_symbol["icon-optional"]), "icon-rotation-alignment": new _s(dt.layout_symbol["icon-rotation-alignment"]), "icon-size": new Ss(dt.layout_symbol["icon-size"]), "icon-text-fit": new _s(dt.layout_symbol["icon-text-fit"]), "icon-text-fit-padding": new _s(dt.layout_symbol["icon-text-fit-padding"]), "icon-image": new Ss(dt.layout_symbol["icon-image"]), "icon-rotate": new Ss(dt.layout_symbol["icon-rotate"]), "icon-padding": new Ss(dt.layout_symbol["icon-padding"]), "icon-keep-upright": new _s(dt.layout_symbol["icon-keep-upright"]), "icon-offset": new Ss(dt.layout_symbol["icon-offset"]), "icon-anchor": new Ss(dt.layout_symbol["icon-anchor"]), "icon-pitch-alignment": new _s(dt.layout_symbol["icon-pitch-alignment"]), "text-pitch-alignment": new _s(dt.layout_symbol["text-pitch-alignment"]), "text-rotation-alignment": new _s(dt.layout_symbol["text-rotation-alignment"]), "text-field": new Ss(dt.layout_symbol["text-field"]), "text-font": new Ss(dt.layout_symbol["text-font"]), "text-size": new Ss(dt.layout_symbol["text-size"]), "text-max-width": new Ss(dt.layout_symbol["text-max-width"]), "text-line-height": new _s(dt.layout_symbol["text-line-height"]), "text-letter-spacing": new Ss(dt.layout_symbol["text-letter-spacing"]), "text-justify": new Ss(dt.layout_symbol["text-justify"]), "text-radial-offset": new Ss(dt.layout_symbol["text-radial-offset"]), "text-variable-anchor": new _s(dt.layout_symbol["text-variable-anchor"]), "text-variable-anchor-offset": new Ss(dt.layout_symbol["text-variable-anchor-offset"]), "text-anchor": new Ss(dt.layout_symbol["text-anchor"]), "text-max-angle": new _s(dt.layout_symbol["text-max-angle"]), "text-writing-mode": new _s(dt.layout_symbol["text-writing-mode"]), "text-rotate": new Ss(dt.layout_symbol["text-rotate"]), "text-padding": new _s(dt.layout_symbol["text-padding"]), "text-keep-upright": new _s(dt.layout_symbol["text-keep-upright"]), "text-transform": new Ss(dt.layout_symbol["text-transform"]), "text-offset": new Ss(dt.layout_symbol["text-offset"]), "text-allow-overlap": new _s(dt.layout_symbol["text-allow-overlap"]), "text-overlap": new _s(dt.layout_symbol["text-overlap"]), "text-ignore-placement": new _s(dt.layout_symbol["text-ignore-placement"]), "text-optional": new _s(dt.layout_symbol["text-optional"]) });
        } };
        class Lc {
          constructor(t5) {
            if (void 0 === t5.property.overrides) throw new Error("overrides must be provided to instantiate FormatSectionOverride class");
            this.type = t5.property.overrides ? t5.property.overrides.runtimeType : Ct, this.defaultValue = t5;
          }
          evaluate(t5) {
            if (t5.formattedSection) {
              const e6 = this.defaultValue.property.overrides;
              if (e6 && e6.hasOverride(t5.formattedSection)) return e6.getOverride(t5.formattedSection);
            }
            return t5.feature && t5.featureState ? this.defaultValue.evaluate(t5.feature, t5.featureState) : this.defaultValue.property.specification.default;
          }
          eachChild(t5) {
            this.defaultValue.isConstant() || t5(this.defaultValue.value._styleExpression.expression);
          }
          outputDefined() {
            return false;
          }
          serialize() {
            return null;
          }
        }
        Zi("FormatSectionOverride", Lc, { omit: ["defaultValue"] });
        class Oc extends Ps {
          constructor(t5) {
            super(t5, $c);
          }
          recalculate(t5, e6) {
            if (super.recalculate(t5, e6), "auto" === this.layout.get("icon-rotation-alignment") && (this.layout._values["icon-rotation-alignment"] = "point" !== this.layout.get("symbol-placement") ? "map" : "viewport"), "auto" === this.layout.get("text-rotation-alignment") && (this.layout._values["text-rotation-alignment"] = "point" !== this.layout.get("symbol-placement") ? "map" : "viewport"), "auto" === this.layout.get("text-pitch-alignment") && (this.layout._values["text-pitch-alignment"] = "map" === this.layout.get("text-rotation-alignment") ? "map" : "viewport"), "auto" === this.layout.get("icon-pitch-alignment") && (this.layout._values["icon-pitch-alignment"] = this.layout.get("icon-rotation-alignment")), "point" === this.layout.get("symbol-placement")) {
              const t6 = this.layout.get("text-writing-mode");
              if (t6) {
                const e7 = [];
                for (const r8 of t6) e7.indexOf(r8) < 0 && e7.push(r8);
                this.layout._values["text-writing-mode"] = e7;
              } else this.layout._values["text-writing-mode"] = ["horizontal"];
            }
            this._setPaintOverrides();
          }
          getValueAndResolveTokens(t5, e6, r8, n6) {
            const i6 = this.layout.get(t5).evaluate(e6, {}, r8, n6), s4 = this._unevaluatedLayout._values[t5];
            return s4.isDataDriven() || qn(s4.value) || !i6 ? i6 : function(t6, e7) {
              return e7.replace(/{([^{}]+)}/g, (e8, r9) => t6 && r9 in t6 ? String(t6[r9]) : "");
            }(e6.properties, i6);
          }
          createBucket(t5) {
            return new Ec(t5);
          }
          queryRadius() {
            return 0;
          }
          queryIntersectsFeature() {
            throw new Error("Should take a different path in FeatureIndex");
          }
          _setPaintOverrides() {
            for (const t5 of $c.paint.overridableProperties) {
              if (!Oc.hasPaintOverride(this.layout, t5)) continue;
              const e6 = this.paint.get(t5), r8 = new Lc(e6), n6 = new Un(r8, e6.property.specification);
              let i6 = null;
              i6 = "constant" === e6.value.kind || "source" === e6.value.kind ? new Zn("source", n6) : new Kn("composite", n6, e6.value.zoomStops), this.paint._values[t5] = new bs(e6.property, i6, e6.parameters);
            }
          }
          _handleOverridablePaintPropertyUpdate(t5, e6, r8) {
            return !(!this.layout || e6.isDataDriven() || r8.isDataDriven()) && Oc.hasPaintOverride(this.layout, t5);
          }
          static hasPaintOverride(t5, e6) {
            const r8 = t5.get("text-field"), n6 = $c.paint.properties[e6];
            let i6 = false;
            const s4 = (t6) => {
              for (const e7 of t6) if (n6.overrides && n6.overrides.hasOverride(e7)) return void (i6 = true);
            };
            if ("constant" === r8.value.kind && r8.value.value instanceof _e) s4(r8.value.value.sections);
            else if ("source" === r8.value.kind) {
              const t6 = (e8) => {
                i6 || (e8 instanceof Ee && Be(e8.value) === Dt ? s4(e8.value.sections) : e8 instanceof gr ? s4(e8.sections) : e8.eachChild(t6));
              }, e7 = r8.value;
              e7._styleExpression && t6(e7._styleExpression.expression);
            }
            return i6;
          }
        }
        let Dc;
        var Rc = { get paint() {
          return Dc = Dc || new Is({ "background-color": new _s(dt.paint_background["background-color"]), "background-pattern": new ks(dt.paint_background["background-pattern"]), "background-opacity": new _s(dt.paint_background["background-opacity"]) });
        } };
        class jc extends Ps {
          constructor(t5) {
            super(t5, Rc);
          }
        }
        let Nc;
        var Uc = { get paint() {
          return Nc = Nc || new Is({ "raster-opacity": new _s(dt.paint_raster["raster-opacity"]), "raster-hue-rotate": new _s(dt.paint_raster["raster-hue-rotate"]), "raster-brightness-min": new _s(dt.paint_raster["raster-brightness-min"]), "raster-brightness-max": new _s(dt.paint_raster["raster-brightness-max"]), "raster-saturation": new _s(dt.paint_raster["raster-saturation"]), "raster-contrast": new _s(dt.paint_raster["raster-contrast"]), "raster-resampling": new _s(dt.paint_raster["raster-resampling"]), "raster-fade-duration": new _s(dt.paint_raster["raster-fade-duration"]) });
        } };
        class qc extends Ps {
          constructor(t5) {
            super(t5, Uc);
          }
        }
        class Gc extends Ps {
          constructor(t5) {
            super(t5, {}), this.onAdd = (t6) => {
              this.implementation.onAdd && this.implementation.onAdd(t6, t6.painter.context.gl);
            }, this.onRemove = (t6) => {
              this.implementation.onRemove && this.implementation.onRemove(t6, t6.painter.context.gl);
            }, this.implementation = t5;
          }
          is3D() {
            return "3d" === this.implementation.renderingMode;
          }
          hasOffscreenPass() {
            return void 0 !== this.implementation.prerender;
          }
          recalculate() {
          }
          updateTransitions() {
          }
          hasTransition() {
            return false;
          }
          serialize() {
            throw new Error("Custom layers cannot be serialized");
          }
        }
        class Zc {
          constructor(t5) {
            this._methodToThrottle = t5, this._triggered = false, "undefined" != typeof MessageChannel && (this._channel = new MessageChannel(), this._channel.port2.onmessage = () => {
              this._triggered = false, this._methodToThrottle();
            });
          }
          trigger() {
            this._triggered || (this._triggered = true, this._channel ? this._channel.port1.postMessage(true) : setTimeout(() => {
              this._triggered = false, this._methodToThrottle();
            }, 0));
          }
          remove() {
            delete this._channel, this._methodToThrottle = () => {
            };
          }
        }
        const Kc = { once: true }, Xc = 63710088e-1;
        class Hc {
          constructor(t5, e6) {
            if (isNaN(t5) || isNaN(e6)) throw new Error(`Invalid LngLat object: (${t5}, ${e6})`);
            if (this.lng = +t5, this.lat = +e6, this.lat > 90 || this.lat < -90) throw new Error("Invalid LngLat latitude value: must be between -90 and 90");
          }
          wrap() {
            return new Hc(T4(this.lng, -180, 180), this.lat);
          }
          toArray() {
            return [this.lng, this.lat];
          }
          toString() {
            return `LngLat(${this.lng}, ${this.lat})`;
          }
          distanceTo(t5) {
            const e6 = Math.PI / 180, r8 = this.lat * e6, n6 = t5.lat * e6, i6 = Math.sin(r8) * Math.sin(n6) + Math.cos(r8) * Math.cos(n6) * Math.cos((t5.lng - this.lng) * e6);
            return Xc * Math.acos(Math.min(i6, 1));
          }
          static convert(t5) {
            if (t5 instanceof Hc) return t5;
            if (Array.isArray(t5) && (2 === t5.length || 3 === t5.length)) return new Hc(Number(t5[0]), Number(t5[1]));
            if (!Array.isArray(t5) && "object" == typeof t5 && null !== t5) return new Hc(Number("lng" in t5 ? t5.lng : t5.lon), Number(t5.lat));
            throw new Error("`LngLatLike` argument must be specified as a LngLat instance, an object {lng: <lng>, lat: <lat>}, an object {lon: <lng>, lat: <lat>}, or an array of [<lng>, <lat>]");
          }
        }
        const Yc = 2 * Math.PI * Xc;
        function Jc(t5) {
          return Yc * Math.cos(t5 * Math.PI / 180);
        }
        function Wc(t5) {
          return (180 + t5) / 360;
        }
        function Qc(t5) {
          return (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + t5 * Math.PI / 360))) / 360;
        }
        function th(t5, e6) {
          return t5 / Jc(e6);
        }
        function eh(t5) {
          return 360 / Math.PI * Math.atan(Math.exp((180 - 360 * t5) * Math.PI / 180)) - 90;
        }
        function rh(t5, e6) {
          return t5 * Jc(eh(e6));
        }
        class nh {
          constructor(t5, e6, r8 = 0) {
            this.x = +t5, this.y = +e6, this.z = +r8;
          }
          static fromLngLat(t5, e6 = 0) {
            const r8 = Hc.convert(t5);
            return new nh(Wc(r8.lng), Qc(r8.lat), th(e6, r8.lat));
          }
          toLngLat() {
            return new Hc(360 * this.x - 180, eh(this.y));
          }
          toAltitude() {
            return rh(this.z, this.y);
          }
          meterInMercatorCoordinateUnits() {
            return 1 / Yc * (t5 = eh(this.y), 1 / Math.cos(t5 * Math.PI / 180));
            var t5;
          }
        }
        function ih(t5, e6, r8) {
          var n6 = 2 * Math.PI * 6378137 / 256 / Math.pow(2, r8);
          return [t5 * n6 - 2 * Math.PI * 6378137 / 2, e6 * n6 - 2 * Math.PI * 6378137 / 2];
        }
        class sh {
          constructor(t5, e6, r8) {
            if (!function(t6, e7, r9) {
              return !(t6 < 0 || t6 > 25 || r9 < 0 || r9 >= Math.pow(2, t6) || e7 < 0 || e7 >= Math.pow(2, t6));
            }(t5, e6, r8)) throw new Error(`x=${e6}, y=${r8}, z=${t5} outside of bounds. 0<=x<${Math.pow(2, t5)}, 0<=y<${Math.pow(2, t5)} 0<=z<=25 `);
            this.z = t5, this.x = e6, this.y = r8, this.key = lh(0, t5, t5, e6, r8);
          }
          equals(t5) {
            return this.z === t5.z && this.x === t5.x && this.y === t5.y;
          }
          url(t5, e6, r8) {
            const n6 = (s4 = this.y, a4 = this.z, o6 = ih(256 * (i6 = this.x), 256 * (s4 = Math.pow(2, a4) - s4 - 1), a4), l5 = ih(256 * (i6 + 1), 256 * (s4 + 1), a4), o6[0] + "," + o6[1] + "," + l5[0] + "," + l5[1]);
            var i6, s4, a4, o6, l5;
            const u4 = function(t6, e7, r9) {
              let n7, i7 = "";
              for (let s5 = t6; s5 > 0; s5--) n7 = 1 << s5 - 1, i7 += (e7 & n7 ? 1 : 0) + (r9 & n7 ? 2 : 0);
              return i7;
            }(this.z, this.x, this.y);
            return t5[(this.x + this.y) % t5.length].replace(/{prefix}/g, (this.x % 16).toString(16) + (this.y % 16).toString(16)).replace(/{z}/g, String(this.z)).replace(/{x}/g, String(this.x)).replace(/{y}/g, String("tms" === r8 ? Math.pow(2, this.z) - this.y - 1 : this.y)).replace(/{ratio}/g, e6 > 1 ? "@2x" : "").replace(/{quadkey}/g, u4).replace(/{bbox-epsg-3857}/g, n6);
          }
          isChildOf(t5) {
            const e6 = this.z - t5.z;
            return e6 > 0 && t5.x === this.x >> e6 && t5.y === this.y >> e6;
          }
          getTilePoint(t5) {
            const e6 = Math.pow(2, this.z);
            return new l4((t5.x * e6 - this.x) * M4, (t5.y * e6 - this.y) * M4);
          }
          toString() {
            return `${this.z}/${this.x}/${this.y}`;
          }
        }
        class ah {
          constructor(t5, e6) {
            this.wrap = t5, this.canonical = e6, this.key = lh(t5, e6.z, e6.z, e6.x, e6.y);
          }
        }
        class oh {
          constructor(t5, e6, r8, n6, i6) {
            if (this.terrainRttPosMatrix32f = null, t5 < r8) throw new Error(`overscaledZ should be >= z; overscaledZ = ${t5}; z = ${r8}`);
            this.overscaledZ = t5, this.wrap = e6, this.canonical = new sh(r8, +n6, +i6), this.key = lh(e6, t5, r8, n6, i6);
          }
          clone() {
            return new oh(this.overscaledZ, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y);
          }
          equals(t5) {
            return this.overscaledZ === t5.overscaledZ && this.wrap === t5.wrap && this.canonical.equals(t5.canonical);
          }
          scaledTo(t5) {
            if (t5 > this.overscaledZ) throw new Error(`targetZ > this.overscaledZ; targetZ = ${t5}; overscaledZ = ${this.overscaledZ}`);
            const e6 = this.canonical.z - t5;
            return t5 > this.canonical.z ? new oh(t5, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y) : new oh(t5, this.wrap, t5, this.canonical.x >> e6, this.canonical.y >> e6);
          }
          calculateScaledKey(t5, e6) {
            if (t5 > this.overscaledZ) throw new Error(`targetZ > this.overscaledZ; targetZ = ${t5}; overscaledZ = ${this.overscaledZ}`);
            const r8 = this.canonical.z - t5;
            return t5 > this.canonical.z ? lh(this.wrap * +e6, t5, this.canonical.z, this.canonical.x, this.canonical.y) : lh(this.wrap * +e6, t5, t5, this.canonical.x >> r8, this.canonical.y >> r8);
          }
          isChildOf(t5) {
            if (t5.wrap !== this.wrap) return false;
            const e6 = this.canonical.z - t5.canonical.z;
            return 0 === t5.overscaledZ || t5.overscaledZ < this.overscaledZ && t5.canonical.x === this.canonical.x >> e6 && t5.canonical.y === this.canonical.y >> e6;
          }
          children(t5) {
            if (this.overscaledZ >= t5) return [new oh(this.overscaledZ + 1, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y)];
            const e6 = this.canonical.z + 1, r8 = 2 * this.canonical.x, n6 = 2 * this.canonical.y;
            return [new oh(e6, this.wrap, e6, r8, n6), new oh(e6, this.wrap, e6, r8 + 1, n6), new oh(e6, this.wrap, e6, r8, n6 + 1), new oh(e6, this.wrap, e6, r8 + 1, n6 + 1)];
          }
          isLessThan(t5) {
            return this.wrap < t5.wrap || !(this.wrap > t5.wrap) && (this.overscaledZ < t5.overscaledZ || !(this.overscaledZ > t5.overscaledZ) && (this.canonical.x < t5.canonical.x || !(this.canonical.x > t5.canonical.x) && this.canonical.y < t5.canonical.y));
          }
          wrapped() {
            return new oh(this.overscaledZ, 0, this.canonical.z, this.canonical.x, this.canonical.y);
          }
          unwrapTo(t5) {
            return new oh(this.overscaledZ, t5, this.canonical.z, this.canonical.x, this.canonical.y);
          }
          overscaleFactor() {
            return Math.pow(2, this.overscaledZ - this.canonical.z);
          }
          toUnwrapped() {
            return new ah(this.wrap, this.canonical);
          }
          toString() {
            return `${this.overscaledZ}/${this.canonical.x}/${this.canonical.y}`;
          }
          getTilePoint(t5) {
            return this.canonical.getTilePoint(new nh(t5.x - this.wrap, t5.y));
          }
        }
        function lh(t5, e6, r8, n6, i6) {
          (t5 *= 2) < 0 && (t5 = -1 * t5 - 1);
          const s4 = 1 << r8;
          return (s4 * s4 * t5 + s4 * i6 + n6).toString(36) + r8.toString(36) + e6.toString(36);
        }
        Zi("CanonicalTileID", sh), Zi("OverscaledTileID", oh, { omit: ["terrainRttPosMatrix32f"] });
        class uh {
          constructor(t5, e6, r8, n6 = 1, i6 = 1, s4 = 1, a4 = 0) {
            if (this.uid = t5, e6.height !== e6.width) throw new RangeError("DEM tiles must be square");
            if (r8 && !["mapbox", "terrarium", "custom"].includes(r8)) return void j3(`"${r8}" is not a valid encoding type. Valid types include "mapbox", "terrarium" and "custom".`);
            this.stride = e6.height;
            const o6 = this.dim = e6.height - 2;
            switch (this.data = new Uint32Array(e6.data.buffer), r8) {
              case "terrarium":
                this.redFactor = 256, this.greenFactor = 1, this.blueFactor = 1 / 256, this.baseShift = 32768;
                break;
              case "custom":
                this.redFactor = n6, this.greenFactor = i6, this.blueFactor = s4, this.baseShift = a4;
                break;
              default:
                this.redFactor = 6553.6, this.greenFactor = 25.6, this.blueFactor = 0.1, this.baseShift = 1e4;
            }
            for (let t6 = 0; t6 < o6; t6++) this.data[this._idx(-1, t6)] = this.data[this._idx(0, t6)], this.data[this._idx(o6, t6)] = this.data[this._idx(o6 - 1, t6)], this.data[this._idx(t6, -1)] = this.data[this._idx(t6, 0)], this.data[this._idx(t6, o6)] = this.data[this._idx(t6, o6 - 1)];
            this.data[this._idx(-1, -1)] = this.data[this._idx(0, 0)], this.data[this._idx(o6, -1)] = this.data[this._idx(o6 - 1, 0)], this.data[this._idx(-1, o6)] = this.data[this._idx(0, o6 - 1)], this.data[this._idx(o6, o6)] = this.data[this._idx(o6 - 1, o6 - 1)], this.min = Number.MAX_SAFE_INTEGER, this.max = Number.MIN_SAFE_INTEGER;
            for (let t6 = 0; t6 < o6; t6++) for (let e7 = 0; e7 < o6; e7++) {
              const r9 = this.get(t6, e7);
              r9 > this.max && (this.max = r9), r9 < this.min && (this.min = r9);
            }
          }
          get(t5, e6) {
            const r8 = new Uint8Array(this.data.buffer), n6 = 4 * this._idx(t5, e6);
            return this.unpack(r8[n6], r8[n6 + 1], r8[n6 + 2]);
          }
          getUnpackVector() {
            return [this.redFactor, this.greenFactor, this.blueFactor, this.baseShift];
          }
          _idx(t5, e6) {
            if (t5 < -1 || t5 >= this.dim + 1 || e6 < -1 || e6 >= this.dim + 1) throw new RangeError("out of range source coordinates for DEM data");
            return (e6 + 1) * this.stride + (t5 + 1);
          }
          unpack(t5, e6, r8) {
            return t5 * this.redFactor + e6 * this.greenFactor + r8 * this.blueFactor - this.baseShift;
          }
          getPixels() {
            return new No({ width: this.stride, height: this.stride }, new Uint8Array(this.data.buffer));
          }
          backfillBorder(t5, e6, r8) {
            if (this.dim !== t5.dim) throw new Error("dem dimension mismatch");
            let n6 = e6 * this.dim, i6 = e6 * this.dim + this.dim, s4 = r8 * this.dim, a4 = r8 * this.dim + this.dim;
            switch (e6) {
              case -1:
                n6 = i6 - 1;
                break;
              case 1:
                i6 = n6 + 1;
            }
            switch (r8) {
              case -1:
                s4 = a4 - 1;
                break;
              case 1:
                a4 = s4 + 1;
            }
            const o6 = -e6 * this.dim, l5 = -r8 * this.dim;
            for (let e7 = s4; e7 < a4; e7++) for (let r9 = n6; r9 < i6; r9++) this.data[this._idx(r9, e7)] = t5.data[this._idx(r9 + o6, e7 + l5)];
          }
        }
        Zi("DEMData", uh);
        class ch {
          constructor(t5) {
            this._stringToNumber = {}, this._numberToString = [];
            for (let e6 = 0; e6 < t5.length; e6++) {
              const r8 = t5[e6];
              this._stringToNumber[r8] = e6, this._numberToString[e6] = r8;
            }
          }
          encode(t5) {
            return this._stringToNumber[t5];
          }
          decode(t5) {
            if (t5 >= this._numberToString.length) throw new Error(`Out of bounds. Index requested n=${t5} can't be >= this._numberToString.length ${this._numberToString.length}`);
            return this._numberToString[t5];
          }
        }
        class hh {
          constructor(t5, e6, r8, n6, i6) {
            this.type = "Feature", this._vectorTileFeature = t5, t5._z = e6, t5._x = r8, t5._y = n6, this.properties = t5.properties, this.id = i6;
          }
          get geometry() {
            return void 0 === this._geometry && (this._geometry = this._vectorTileFeature.toGeoJSON(this._vectorTileFeature._x, this._vectorTileFeature._y, this._vectorTileFeature._z).geometry), this._geometry;
          }
          set geometry(t5) {
            this._geometry = t5;
          }
          toJSON() {
            const t5 = { geometry: this.geometry };
            for (const e6 in this) "_geometry" !== e6 && "_vectorTileFeature" !== e6 && (t5[e6] = this[e6]);
            return t5;
          }
        }
        class ph {
          constructor(t5, e6) {
            this.tileID = t5, this.x = t5.canonical.x, this.y = t5.canonical.y, this.z = t5.canonical.z, this.grid = new qi(M4, 16, 0), this.grid3D = new qi(M4, 16, 0), this.featureIndexArray = new ya(), this.promoteId = e6;
          }
          insert(t5, e6, r8, n6, i6, s4) {
            const a4 = this.featureIndexArray.length;
            this.featureIndexArray.emplaceBack(r8, n6, i6);
            const o6 = s4 ? this.grid3D : this.grid;
            for (let t6 = 0; t6 < e6.length; t6++) {
              const r9 = e6[t6], n7 = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
              for (let t7 = 0; t7 < r9.length; t7++) {
                const e7 = r9[t7];
                n7[0] = Math.min(n7[0], e7.x), n7[1] = Math.min(n7[1], e7.y), n7[2] = Math.max(n7[2], e7.x), n7[3] = Math.max(n7[3], e7.y);
              }
              n7[0] < M4 && n7[1] < M4 && n7[2] >= 0 && n7[3] >= 0 && o6.insert(a4, n7[0], n7[1], n7[2], n7[3]);
            }
          }
          loadVTLayers() {
            return this.vtLayers || (this.vtLayers = new Ql.VectorTile(new ju(this.rawTileData)).layers, this.sourceLayerCoder = new ch(this.vtLayers ? Object.keys(this.vtLayers).sort() : ["_geojsonTileLayer"])), this.vtLayers;
          }
          query(t5, e6, r8, n6) {
            this.loadVTLayers();
            const i6 = t5.params, s4 = M4 / t5.tileSize / t5.scale, a4 = Qn(i6.filter), o6 = t5.queryGeometry, u4 = t5.queryPadding * s4, c5 = dh(o6), h4 = this.grid.query(c5.minX - u4, c5.minY - u4, c5.maxX + u4, c5.maxY + u4), p4 = dh(t5.cameraQueryGeometry), f4 = this.grid3D.query(p4.minX - u4, p4.minY - u4, p4.maxX + u4, p4.maxY + u4, (e7, r9, n7, i7) => function(t6, e8, r10, n8, i8) {
              for (const s6 of t6) if (e8 <= s6.x && r10 <= s6.y && n8 >= s6.x && i8 >= s6.y) return true;
              const s5 = [new l4(e8, r10), new l4(e8, i8), new l4(n8, i8), new l4(n8, r10)];
              if (t6.length > 2) {
                for (const e9 of s5) if (ko(t6, e9)) return true;
              }
              for (let e9 = 0; e9 < t6.length - 1; e9++) if (Mo(t6[e9], t6[e9 + 1], s5)) return true;
              return false;
            }(t5.cameraQueryGeometry, e7 - u4, r9 - u4, n7 + u4, i7 + u4));
            for (const t6 of f4) h4.push(t6);
            h4.sort(yh);
            const d4 = {};
            let y4;
            for (let l5 = 0; l5 < h4.length; l5++) {
              const u5 = h4[l5];
              if (u5 === y4) continue;
              y4 = u5;
              const c6 = this.featureIndexArray.get(u5);
              let p5 = null;
              this.loadMatchingFeature(d4, c6.bucketIndex, c6.sourceLayerIndex, c6.featureIndex, a4, i6.layers, i6.availableImages, e6, r8, n6, (e7, r9, n7) => (p5 || (p5 = co(e7)), r9.queryIntersectsFeature({ queryGeometry: o6, feature: e7, featureState: n7, geometry: p5, zoom: this.z, transform: t5.transform, pixelsToTileUnits: s4, pixelPosMatrix: t5.pixelPosMatrix, unwrappedTileID: this.tileID.toUnwrapped(), getElevation: t5.getElevation })));
            }
            return d4;
          }
          loadMatchingFeature(t5, e6, r8, n6, i6, s4, a4, o6, l5, u4, c5) {
            const h4 = this.bucketLayerIDs[e6];
            if (s4 && !h4.some((t6) => s4.has(t6))) return;
            const p4 = this.sourceLayerCoder.decode(r8), f4 = this.vtLayers[p4].feature(n6);
            if (i6.needGeometry) {
              const t6 = ho(f4, true);
              if (!i6.filter(new fs(this.tileID.overscaledZ), t6, this.tileID.canonical)) return;
            } else if (!i6.filter(new fs(this.tileID.overscaledZ), f4)) return;
            const d4 = this.getId(f4, p4);
            for (let e7 = 0; e7 < h4.length; e7++) {
              const r9 = h4[e7];
              if (s4 && !s4.has(r9)) continue;
              const i7 = o6[r9];
              if (!i7) continue;
              let p5 = {};
              d4 && u4 && (p5 = u4.getState(i7.sourceLayer || "_geojsonTileLayer", d4));
              const y4 = F2({}, l5[r9]);
              y4.paint = fh(y4.paint, i7.paint, f4, p5, a4), y4.layout = fh(y4.layout, i7.layout, f4, p5, a4);
              const m4 = !c5 || c5(f4, i7, p5);
              if (!m4) continue;
              const g4 = new hh(f4, this.z, this.x, this.y, d4);
              g4.layer = y4;
              let x4 = t5[r9];
              void 0 === x4 && (x4 = t5[r9] = []), x4.push({ featureIndex: n6, feature: g4, intersectionZ: m4 });
            }
          }
          lookupSymbolFeatures(t5, e6, r8, n6, i6, s4, a4, o6) {
            const l5 = {};
            this.loadVTLayers();
            const u4 = Qn(i6);
            for (const i7 of t5) this.loadMatchingFeature(l5, r8, n6, i7, u4, s4, a4, o6, e6);
            return l5;
          }
          hasLayer(t5) {
            for (const e6 of this.bucketLayerIDs) for (const r8 of e6) if (t5 === r8) return true;
            return false;
          }
          getId(t5, e6) {
            var r8;
            let n6 = t5.id;
            return this.promoteId && (n6 = t5.properties["string" == typeof this.promoteId ? this.promoteId : this.promoteId[e6]], "boolean" == typeof n6 && (n6 = Number(n6)), void 0 === n6 && (null === (r8 = t5.properties) || void 0 === r8 ? void 0 : r8.cluster) && this.promoteId && (n6 = Number(t5.properties.cluster_id))), n6;
          }
        }
        function fh(t5, e6, r8, n6, i6) {
          return L3(t5, (t6, s4) => {
            const a4 = e6 instanceof ws ? e6.get(s4) : null;
            return a4 && a4.evaluate ? a4.evaluate(r8, n6, i6) : a4;
          });
        }
        function dh(t5) {
          let e6 = 1 / 0, r8 = 1 / 0, n6 = -1 / 0, i6 = -1 / 0;
          for (const s4 of t5) e6 = Math.min(e6, s4.x), r8 = Math.min(r8, s4.y), n6 = Math.max(n6, s4.x), i6 = Math.max(i6, s4.y);
          return { minX: e6, minY: r8, maxX: n6, maxY: i6 };
        }
        function yh(t5, e6) {
          return e6 - t5;
        }
        function mh(t5, e6, r8, n6, i6) {
          const s4 = [];
          for (let a4 = 0; a4 < t5.length; a4++) {
            const o6 = t5[a4];
            let u4;
            for (let t6 = 0; t6 < o6.length - 1; t6++) {
              let a5 = o6[t6], c5 = o6[t6 + 1];
              a5.x < e6 && c5.x < e6 || (a5.x < e6 ? a5 = new l4(e6, a5.y + (e6 - a5.x) / (c5.x - a5.x) * (c5.y - a5.y))._round() : c5.x < e6 && (c5 = new l4(e6, a5.y + (e6 - a5.x) / (c5.x - a5.x) * (c5.y - a5.y))._round()), a5.y < r8 && c5.y < r8 || (a5.y < r8 ? a5 = new l4(a5.x + (r8 - a5.y) / (c5.y - a5.y) * (c5.x - a5.x), r8)._round() : c5.y < r8 && (c5 = new l4(a5.x + (r8 - a5.y) / (c5.y - a5.y) * (c5.x - a5.x), r8)._round()), a5.x >= n6 && c5.x >= n6 || (a5.x >= n6 ? a5 = new l4(n6, a5.y + (n6 - a5.x) / (c5.x - a5.x) * (c5.y - a5.y))._round() : c5.x >= n6 && (c5 = new l4(n6, a5.y + (n6 - a5.x) / (c5.x - a5.x) * (c5.y - a5.y))._round()), a5.y >= i6 && c5.y >= i6 || (a5.y >= i6 ? a5 = new l4(a5.x + (i6 - a5.y) / (c5.y - a5.y) * (c5.x - a5.x), i6)._round() : c5.y >= i6 && (c5 = new l4(a5.x + (i6 - a5.y) / (c5.y - a5.y) * (c5.x - a5.x), i6)._round()), u4 && a5.equals(u4[u4.length - 1]) || (u4 = [a5], s4.push(u4)), u4.push(c5)))));
            }
          }
          return s4;
        }
        Zi("FeatureIndex", ph, { omit: ["rawTileData", "sourceLayerCoder"] });
        class gh extends l4 {
          constructor(t5, e6, r8, n6) {
            super(t5, e6), this.angle = r8, void 0 !== n6 && (this.segment = n6);
          }
          clone() {
            return new gh(this.x, this.y, this.angle, this.segment);
          }
        }
        function xh(t5, e6, r8, n6, i6) {
          if (void 0 === e6.segment || 0 === r8) return true;
          let s4 = e6, a4 = e6.segment + 1, o6 = 0;
          for (; o6 > -r8 / 2; ) {
            if (a4--, a4 < 0) return false;
            o6 -= t5[a4].dist(s4), s4 = t5[a4];
          }
          o6 += t5[a4].dist(t5[a4 + 1]), a4++;
          const l5 = [];
          let u4 = 0;
          for (; o6 < r8 / 2; ) {
            const e7 = t5[a4], r9 = t5[a4 + 1];
            if (!r9) return false;
            let s5 = t5[a4 - 1].angleTo(e7) - e7.angleTo(r9);
            for (s5 = Math.abs((s5 + 3 * Math.PI) % (2 * Math.PI) - Math.PI), l5.push({ distance: o6, angleDelta: s5 }), u4 += s5; o6 - l5[0].distance > n6; ) u4 -= l5.shift().angleDelta;
            if (u4 > i6) return false;
            a4++, o6 += e7.dist(r9);
          }
          return true;
        }
        function vh(t5) {
          let e6 = 0;
          for (let r8 = 0; r8 < t5.length - 1; r8++) e6 += t5[r8].dist(t5[r8 + 1]);
          return e6;
        }
        function bh(t5, e6, r8) {
          return t5 ? 0.6 * e6 * r8 : 0;
        }
        function wh(t5, e6) {
          return Math.max(t5 ? t5.right - t5.left : 0, e6 ? e6.right - e6.left : 0);
        }
        function _h(t5, e6, r8, n6, i6, s4) {
          const a4 = bh(r8, i6, s4), o6 = wh(r8, n6) * s4;
          let l5 = 0;
          const u4 = vh(t5) / 2;
          for (let r9 = 0; r9 < t5.length - 1; r9++) {
            const n7 = t5[r9], i7 = t5[r9 + 1], s5 = n7.dist(i7);
            if (l5 + s5 > u4) {
              const c5 = (u4 - l5) / s5, h4 = ir.number(n7.x, i7.x, c5), p4 = ir.number(n7.y, i7.y, c5), f4 = new gh(h4, p4, i7.angleTo(n7), r9);
              return f4._round(), !a4 || xh(t5, f4, o6, a4, e6) ? f4 : void 0;
            }
            l5 += s5;
          }
        }
        function Sh(t5, e6, r8, n6, i6, s4, a4, o6, l5) {
          const u4 = bh(n6, s4, a4), c5 = wh(n6, i6), h4 = c5 * a4, p4 = 0 === t5[0].x || t5[0].x === l5 || 0 === t5[0].y || t5[0].y === l5;
          return e6 - h4 < e6 / 4 && (e6 = h4 + e6 / 4), Ah(t5, p4 ? e6 / 2 * o6 % e6 : (c5 / 2 + 2 * s4) * a4 * o6 % e6, e6, u4, r8, h4, p4, false, l5);
        }
        function Ah(t5, e6, r8, n6, i6, s4, a4, o6, l5) {
          const u4 = s4 / 2, c5 = vh(t5);
          let h4 = 0, p4 = e6 - r8, f4 = [];
          for (let e7 = 0; e7 < t5.length - 1; e7++) {
            const a5 = t5[e7], o7 = t5[e7 + 1], d4 = a5.dist(o7), y4 = o7.angleTo(a5);
            for (; p4 + r8 < h4 + d4; ) {
              p4 += r8;
              const m4 = (p4 - h4) / d4, g4 = ir.number(a5.x, o7.x, m4), x4 = ir.number(a5.y, o7.y, m4);
              if (g4 >= 0 && g4 < l5 && x4 >= 0 && x4 < l5 && p4 - u4 >= 0 && p4 + u4 <= c5) {
                const r9 = new gh(g4, x4, y4, e7);
                r9._round(), n6 && !xh(t5, r9, s4, n6, i6) || f4.push(r9);
              }
            }
            h4 += d4;
          }
          return o6 || f4.length || a4 || (f4 = Ah(t5, h4 / 2, r8, n6, i6, s4, a4, true, l5)), f4;
        }
        Zi("Anchor", gh);
        const kh = Xu;
        function Mh(t5, e6, r8, n6) {
          const i6 = [], s4 = t5.image, a4 = s4.pixelRatio, o6 = s4.paddedRect.w - 2 * kh, u4 = s4.paddedRect.h - 2 * kh;
          let c5 = { x1: t5.left, y1: t5.top, x2: t5.right, y2: t5.bottom };
          const h4 = s4.stretchX || [[0, o6]], p4 = s4.stretchY || [[0, u4]], f4 = (t6, e7) => t6 + e7[1] - e7[0], d4 = h4.reduce(f4, 0), y4 = p4.reduce(f4, 0), m4 = o6 - d4, g4 = u4 - y4;
          let x4 = 0, v4 = d4, b5 = 0, w4 = y4, _4 = 0, S5 = m4, A5 = 0, k4 = g4;
          if (s4.content && n6) {
            const e7 = s4.content, r9 = e7[2] - e7[0], n7 = e7[3] - e7[1];
            (s4.textFitWidth || s4.textFitHeight) && (c5 = vc(t5)), x4 = Ih(h4, 0, e7[0]), b5 = Ih(p4, 0, e7[1]), v4 = Ih(h4, e7[0], e7[2]), w4 = Ih(p4, e7[1], e7[3]), _4 = e7[0] - x4, A5 = e7[1] - b5, S5 = r9 - v4, k4 = n7 - w4;
          }
          const M5 = c5.x1, I4 = c5.y1, z4 = c5.x2 - M5, P4 = c5.y2 - I4, C4 = (t6, n7, i7, o7) => {
            const u5 = Ph(t6.stretch - x4, v4, z4, M5), c6 = Ch(t6.fixed - _4, S5, t6.stretch, d4), h5 = Ph(n7.stretch - b5, w4, P4, I4), p5 = Ch(n7.fixed - A5, k4, n7.stretch, y4), f5 = Ph(i7.stretch - x4, v4, z4, M5), m5 = Ch(i7.fixed - _4, S5, i7.stretch, d4), g5 = Ph(o7.stretch - b5, w4, P4, I4), C5 = Ch(o7.fixed - A5, k4, o7.stretch, y4), B5 = new l4(u5, h5), V3 = new l4(f5, h5), E4 = new l4(f5, g5), T5 = new l4(u5, g5), F3 = new l4(c6 / a4, p5 / a4), $3 = new l4(m5 / a4, C5 / a4), L4 = e6 * Math.PI / 180;
            if (L4) {
              const t7 = Math.sin(L4), e7 = Math.cos(L4), r9 = [e7, -t7, t7, e7];
              B5._matMult(r9), V3._matMult(r9), T5._matMult(r9), E4._matMult(r9);
            }
            const O3 = t6.stretch + t6.fixed, D3 = n7.stretch + n7.fixed;
            return { tl: B5, tr: V3, bl: T5, br: E4, tex: { x: s4.paddedRect.x + kh + O3, y: s4.paddedRect.y + kh + D3, w: i7.stretch + i7.fixed - O3, h: o7.stretch + o7.fixed - D3 }, writingMode: void 0, glyphOffset: [0, 0], sectionIndex: 0, pixelOffsetTL: F3, pixelOffsetBR: $3, minFontScaleX: S5 / a4 / z4, minFontScaleY: k4 / a4 / P4, isSDF: r8 };
          };
          if (n6 && (s4.stretchX || s4.stretchY)) {
            const t6 = zh(h4, m4, d4), e7 = zh(p4, g4, y4);
            for (let r9 = 0; r9 < t6.length - 1; r9++) {
              const n7 = t6[r9], s5 = t6[r9 + 1];
              for (let t7 = 0; t7 < e7.length - 1; t7++) i6.push(C4(n7, e7[t7], s5, e7[t7 + 1]));
            }
          } else i6.push(C4({ fixed: 0, stretch: -1 }, { fixed: 0, stretch: -1 }, { fixed: 0, stretch: o6 + 1 }, { fixed: 0, stretch: u4 + 1 }));
          return i6;
        }
        function Ih(t5, e6, r8) {
          let n6 = 0;
          for (const i6 of t5) n6 += Math.max(e6, Math.min(r8, i6[1])) - Math.max(e6, Math.min(r8, i6[0]));
          return n6;
        }
        function zh(t5, e6, r8) {
          const n6 = [{ fixed: -1, stretch: 0 }];
          for (const [e7, r9] of t5) {
            const t6 = n6[n6.length - 1];
            n6.push({ fixed: e7 - t6.stretch, stretch: t6.stretch }), n6.push({ fixed: e7 - t6.stretch, stretch: t6.stretch + (r9 - e7) });
          }
          return n6.push({ fixed: e6 + kh, stretch: r8 }), n6;
        }
        function Ph(t5, e6, r8, n6) {
          return t5 / e6 * r8 + n6;
        }
        function Ch(t5, e6, r8, n6) {
          return t5 - e6 * r8 / n6;
        }
        class Bh {
          constructor(t5, e6, r8, n6, i6, s4, a4, o6, u4, c5) {
            var h4;
            if (this.boxStartIndex = t5.length, u4) {
              let t6 = s4.top, e7 = s4.bottom;
              const r9 = s4.collisionPadding;
              r9 && (t6 -= r9[1], e7 += r9[3]);
              let n7 = e7 - t6;
              n7 > 0 && (n7 = Math.max(10, n7), this.circleDiameter = n7);
            } else {
              const u5 = (null === (h4 = s4.image) || void 0 === h4 ? void 0 : h4.content) && (s4.image.textFitWidth || s4.image.textFitHeight) ? vc(s4) : { x1: s4.left, y1: s4.top, x2: s4.right, y2: s4.bottom };
              u5.y1 = u5.y1 * a4 - o6[0], u5.y2 = u5.y2 * a4 + o6[2], u5.x1 = u5.x1 * a4 - o6[3], u5.x2 = u5.x2 * a4 + o6[1];
              const p4 = s4.collisionPadding;
              if (p4 && (u5.x1 -= p4[0] * a4, u5.y1 -= p4[1] * a4, u5.x2 += p4[2] * a4, u5.y2 += p4[3] * a4), c5) {
                const t6 = new l4(u5.x1, u5.y1), e7 = new l4(u5.x2, u5.y1), r9 = new l4(u5.x1, u5.y2), n7 = new l4(u5.x2, u5.y2), i7 = c5 * Math.PI / 180;
                t6._rotate(i7), e7._rotate(i7), r9._rotate(i7), n7._rotate(i7), u5.x1 = Math.min(t6.x, e7.x, r9.x, n7.x), u5.x2 = Math.max(t6.x, e7.x, r9.x, n7.x), u5.y1 = Math.min(t6.y, e7.y, r9.y, n7.y), u5.y2 = Math.max(t6.y, e7.y, r9.y, n7.y);
              }
              t5.emplaceBack(e6.x, e6.y, u5.x1, u5.y1, u5.x2, u5.y2, r8, n6, i6);
            }
            this.boxEndIndex = t5.length;
          }
        }
        class Vh {
          constructor(t5 = [], e6 = (t6, e7) => t6 < e7 ? -1 : t6 > e7 ? 1 : 0) {
            if (this.data = t5, this.length = this.data.length, this.compare = e6, this.length > 0) for (let t6 = (this.length >> 1) - 1; t6 >= 0; t6--) this._down(t6);
          }
          push(t5) {
            this.data.push(t5), this._up(this.length++);
          }
          pop() {
            if (0 === this.length) return;
            const t5 = this.data[0], e6 = this.data.pop();
            return --this.length > 0 && (this.data[0] = e6, this._down(0)), t5;
          }
          peek() {
            return this.data[0];
          }
          _up(t5) {
            const { data: e6, compare: r8 } = this, n6 = e6[t5];
            for (; t5 > 0; ) {
              const i6 = t5 - 1 >> 1, s4 = e6[i6];
              if (r8(n6, s4) >= 0) break;
              e6[t5] = s4, t5 = i6;
            }
            e6[t5] = n6;
          }
          _down(t5) {
            const { data: e6, compare: r8 } = this, n6 = this.length >> 1, i6 = e6[t5];
            for (; t5 < n6; ) {
              let n7 = 1 + (t5 << 1);
              const s4 = n7 + 1;
              if (s4 < this.length && r8(e6[s4], e6[n7]) < 0 && (n7 = s4), r8(e6[n7], i6) >= 0) break;
              e6[t5] = e6[n7], t5 = n7;
            }
            e6[t5] = i6;
          }
        }
        function Eh(t5, e6 = 1, r8 = false) {
          let n6 = 1 / 0, i6 = 1 / 0, s4 = -1 / 0, a4 = -1 / 0;
          const o6 = t5[0];
          for (let t6 = 0; t6 < o6.length; t6++) {
            const e7 = o6[t6];
            (!t6 || e7.x < n6) && (n6 = e7.x), (!t6 || e7.y < i6) && (i6 = e7.y), (!t6 || e7.x > s4) && (s4 = e7.x), (!t6 || e7.y > a4) && (a4 = e7.y);
          }
          const u4 = Math.min(s4 - n6, a4 - i6);
          let c5 = u4 / 2;
          const h4 = new Vh([], Th);
          if (0 === u4) return new l4(n6, i6);
          for (let e7 = n6; e7 < s4; e7 += u4) for (let r9 = i6; r9 < a4; r9 += u4) h4.push(new Fh(e7 + c5, r9 + c5, c5, t5));
          let p4 = function(t6) {
            let e7 = 0, r9 = 0, n7 = 0;
            const i7 = t6[0];
            for (let t7 = 0, s5 = i7.length, a5 = s5 - 1; t7 < s5; a5 = t7++) {
              const s6 = i7[t7], o7 = i7[a5], l5 = s6.x * o7.y - o7.x * s6.y;
              r9 += (s6.x + o7.x) * l5, n7 += (s6.y + o7.y) * l5, e7 += 3 * l5;
            }
            return new Fh(r9 / e7, n7 / e7, 0, t6);
          }(t5), f4 = h4.length;
          for (; h4.length; ) {
            const n7 = h4.pop();
            (n7.d > p4.d || !p4.d) && (p4 = n7, r8 && console.log("found best %d after %d probes", Math.round(1e4 * n7.d) / 1e4, f4)), n7.max - p4.d <= e6 || (c5 = n7.h / 2, h4.push(new Fh(n7.p.x - c5, n7.p.y - c5, c5, t5)), h4.push(new Fh(n7.p.x + c5, n7.p.y - c5, c5, t5)), h4.push(new Fh(n7.p.x - c5, n7.p.y + c5, c5, t5)), h4.push(new Fh(n7.p.x + c5, n7.p.y + c5, c5, t5)), f4 += 4);
          }
          return r8 && (console.log(`num probes: ${f4}`), console.log(`best distance: ${p4.d}`)), p4.p;
        }
        function Th(t5, e6) {
          return e6.max - t5.max;
        }
        function Fh(t5, e6, r8, n6) {
          this.p = new l4(t5, e6), this.h = r8, this.d = function(t6, e7) {
            let r9 = false, n7 = 1 / 0;
            for (let i6 = 0; i6 < e7.length; i6++) {
              const s4 = e7[i6];
              for (let e8 = 0, i7 = s4.length, a4 = i7 - 1; e8 < i7; a4 = e8++) {
                const i8 = s4[e8], o6 = s4[a4];
                i8.y > t6.y != o6.y > t6.y && t6.x < (o6.x - i8.x) * (t6.y - i8.y) / (o6.y - i8.y) + i8.x && (r9 = !r9), n7 = Math.min(n7, So(t6, i8, o6));
              }
            }
            return (r9 ? 1 : -1) * Math.sqrt(n7);
          }(this.p, n6), this.max = this.d + this.h * Math.SQRT2;
        }
        var $h;
        t4.ay = void 0, ($h = t4.ay || (t4.ay = {}))[$h.center = 1] = "center", $h[$h.left = 2] = "left", $h[$h.right = 3] = "right", $h[$h.top = 4] = "top", $h[$h.bottom = 5] = "bottom", $h[$h["top-left"] = 6] = "top-left", $h[$h["top-right"] = 7] = "top-right", $h[$h["bottom-left"] = 8] = "bottom-left", $h[$h["bottom-right"] = 9] = "bottom-right";
        const Lh = 7, Oh = Number.POSITIVE_INFINITY;
        function Dh(t5, e6) {
          return e6[1] !== Oh ? function(t6, e7, r8) {
            let n6 = 0, i6 = 0;
            switch (e7 = Math.abs(e7), r8 = Math.abs(r8), t6) {
              case "top-right":
              case "top-left":
              case "top":
                i6 = r8 - Lh;
                break;
              case "bottom-right":
              case "bottom-left":
              case "bottom":
                i6 = -r8 + Lh;
            }
            switch (t6) {
              case "top-right":
              case "bottom-right":
              case "right":
                n6 = -e7;
                break;
              case "top-left":
              case "bottom-left":
              case "left":
                n6 = e7;
            }
            return [n6, i6];
          }(t5, e6[0], e6[1]) : function(t6, e7) {
            let r8 = 0, n6 = 0;
            e7 < 0 && (e7 = 0);
            const i6 = e7 / Math.SQRT2;
            switch (t6) {
              case "top-right":
              case "top-left":
                n6 = i6 - Lh;
                break;
              case "bottom-right":
              case "bottom-left":
                n6 = -i6 + Lh;
                break;
              case "bottom":
                n6 = -e7 + Lh;
                break;
              case "top":
                n6 = e7 - Lh;
            }
            switch (t6) {
              case "top-right":
              case "bottom-right":
                r8 = -i6;
                break;
              case "top-left":
              case "bottom-left":
                r8 = i6;
                break;
              case "left":
                r8 = e7;
                break;
              case "right":
                r8 = -e7;
            }
            return [r8, n6];
          }(t5, e6[0]);
        }
        function Rh(t5, e6, r8) {
          var n6;
          const i6 = t5.layout, s4 = null === (n6 = i6.get("text-variable-anchor-offset")) || void 0 === n6 ? void 0 : n6.evaluate(e6, {}, r8);
          if (s4) {
            const t6 = s4.values, e7 = [];
            for (let r9 = 0; r9 < t6.length; r9 += 2) {
              const n7 = e7[r9] = t6[r9], i7 = t6[r9 + 1].map((t7) => t7 * Lu);
              n7.startsWith("top") ? i7[1] -= Lh : n7.startsWith("bottom") && (i7[1] += Lh), e7[r9 + 1] = i7;
            }
            return new Me(e7);
          }
          const a4 = i6.get("text-variable-anchor");
          if (a4) {
            let n7;
            n7 = void 0 !== t5._unevaluatedLayout.getValue("text-radial-offset") ? [i6.get("text-radial-offset").evaluate(e6, {}, r8) * Lu, Oh] : i6.get("text-offset").evaluate(e6, {}, r8).map((t6) => t6 * Lu);
            const s5 = [];
            for (const t6 of a4) s5.push(t6, Dh(t6, n7));
            return new Me(s5);
          }
          return null;
        }
        function jh(t5) {
          switch (t5) {
            case "right":
            case "top-right":
            case "bottom-right":
              return "right";
            case "left":
            case "top-left":
            case "bottom-left":
              return "left";
          }
          return "center";
        }
        function Nh(e6, r8, n6, i6, s4, a4, o6, l5, u4, c5, h4, p4) {
          let f4 = a4.textMaxSize.evaluate(r8, {});
          void 0 === f4 && (f4 = o6);
          const d4 = e6.layers[0].layout, y4 = d4.get("icon-offset").evaluate(r8, {}, h4), m4 = qh(n6.horizontal), g4 = o6 / 24, x4 = e6.tilePixelRatio * g4, v4 = e6.tilePixelRatio * f4 / 24, b5 = e6.tilePixelRatio * l5, w4 = e6.tilePixelRatio * d4.get("symbol-spacing"), _4 = d4.get("text-padding") * e6.tilePixelRatio, S5 = function(t5, e7, r9, n7 = 1) {
            const i7 = t5.get("icon-padding").evaluate(e7, {}, r9), s5 = i7 && i7.values;
            return [s5[0] * n7, s5[1] * n7, s5[2] * n7, s5[3] * n7];
          }(d4, r8, h4, e6.tilePixelRatio), A5 = d4.get("text-max-angle") / 180 * Math.PI, k4 = "viewport" !== d4.get("text-rotation-alignment") && "point" !== d4.get("symbol-placement"), I4 = "map" === d4.get("icon-rotation-alignment") && "point" !== d4.get("symbol-placement"), z4 = d4.get("symbol-placement"), P4 = w4 / 2, C4 = d4.get("icon-text-fit");
          let B5;
          i6 && "none" !== C4 && (e6.allowVerticalPlacement && n6.vertical && (B5 = bc(i6, n6.vertical, C4, d4.get("icon-text-fit-padding"), y4, g4)), m4 && (i6 = bc(i6, m4, C4, d4.get("icon-text-fit-padding"), y4, g4)));
          const V3 = h4 ? p4.line.getGranularityForZoomLevel(h4.z) : 1, E4 = (l6, p5) => {
            p5.x < 0 || p5.x >= M4 || p5.y < 0 || p5.y >= M4 || function(e7, r9, n7, i7, s5, a5, o7, l7, u5, c6, h5, p6, f5, d5, y5, m5, g5, x5, v5, b6, w5, _5, S6, A6, k5) {
              const M5 = e7.addToLineVertexArray(r9, n7);
              let I5, z5, P5, C5, B6 = 0, V4 = 0, E5 = 0, T5 = 0, F3 = -1, $3 = -1;
              const L4 = {};
              let O3 = Na("");
              if (e7.allowVerticalPlacement && i7.vertical) {
                const t5 = l7.layout.get("text-rotate").evaluate(w5, {}, A6) + 90;
                P5 = new Bh(u5, r9, c6, h5, p6, i7.vertical, f5, d5, y5, t5), o7 && (C5 = new Bh(u5, r9, c6, h5, p6, o7, g5, x5, y5, t5));
              }
              if (s5) {
                const n8 = l7.layout.get("icon-rotate").evaluate(w5, {}), i8 = "none" !== l7.layout.get("icon-text-fit"), a6 = Mh(s5, n8, S6, i8), f6 = o7 ? Mh(o7, n8, S6, i8) : void 0;
                z5 = new Bh(u5, r9, c6, h5, p6, s5, g5, x5, false, n8), B6 = 4 * a6.length;
                const d6 = e7.iconSizeData;
                let y6 = null;
                "source" === d6.kind ? (y6 = [_c * l7.layout.get("icon-size").evaluate(w5, {})], y6[0] > Sc && j3(`${e7.layerIds[0]}: Value for "icon-size" is >= ${wc}. Reduce your "icon-size".`)) : "composite" === d6.kind && (y6 = [_c * _5.compositeIconSizes[0].evaluate(w5, {}, A6), _c * _5.compositeIconSizes[1].evaluate(w5, {}, A6)], (y6[0] > Sc || y6[1] > Sc) && j3(`${e7.layerIds[0]}: Value for "icon-size" is >= ${wc}. Reduce your "icon-size".`)), e7.addSymbols(e7.icon, a6, y6, b6, v5, w5, t4.ah.none, r9, M5.lineStartIndex, M5.lineLength, -1, A6), F3 = e7.icon.placedSymbolArray.length - 1, f6 && (V4 = 4 * f6.length, e7.addSymbols(e7.icon, f6, y6, b6, v5, w5, t4.ah.vertical, r9, M5.lineStartIndex, M5.lineLength, -1, A6), $3 = e7.icon.placedSymbolArray.length - 1);
              }
              const D3 = Object.keys(i7.horizontal);
              for (const n8 of D3) {
                const s6 = i7.horizontal[n8];
                if (!I5) {
                  O3 = Na(s6.text);
                  const t5 = l7.layout.get("text-rotate").evaluate(w5, {}, A6);
                  I5 = new Bh(u5, r9, c6, h5, p6, s6, f5, d5, y5, t5);
                }
                const o8 = 1 === s6.positionedLines.length;
                if (E5 += Uh(e7, r9, s6, a5, l7, y5, w5, m5, M5, i7.vertical ? t4.ah.horizontal : t4.ah.horizontalOnly, o8 ? D3 : [n8], L4, F3, _5, A6), o8) break;
              }
              i7.vertical && (T5 += Uh(e7, r9, i7.vertical, a5, l7, y5, w5, m5, M5, t4.ah.vertical, ["vertical"], L4, $3, _5, A6));
              const R5 = I5 ? I5.boxStartIndex : e7.collisionBoxArray.length, N4 = I5 ? I5.boxEndIndex : e7.collisionBoxArray.length, U4 = P5 ? P5.boxStartIndex : e7.collisionBoxArray.length, q3 = P5 ? P5.boxEndIndex : e7.collisionBoxArray.length, G3 = z5 ? z5.boxStartIndex : e7.collisionBoxArray.length, Z3 = z5 ? z5.boxEndIndex : e7.collisionBoxArray.length, K3 = C5 ? C5.boxStartIndex : e7.collisionBoxArray.length, X3 = C5 ? C5.boxEndIndex : e7.collisionBoxArray.length;
              let H5 = -1;
              const Y3 = (t5, e8) => t5 && t5.circleDiameter ? Math.max(t5.circleDiameter, e8) : e8;
              H5 = Y3(I5, H5), H5 = Y3(P5, H5), H5 = Y3(z5, H5), H5 = Y3(C5, H5);
              const J3 = H5 > -1 ? 1 : 0;
              J3 && (H5 *= k5 / Lu), e7.glyphOffsetArray.length >= Ec.MAX_GLYPHS && j3("Too many glyphs being rendered in a tile. See https://github.com/mapbox/mapbox-gl-js/issues/2907"), void 0 !== w5.sortKey && e7.addToSortKeyRanges(e7.symbolInstances.length, w5.sortKey);
              const W2 = Rh(l7, w5, A6), [Q3, tt2] = function(e8, r10) {
                const n8 = e8.length, i8 = null == r10 ? void 0 : r10.values;
                if ((null == i8 ? void 0 : i8.length) > 0) for (let r11 = 0; r11 < i8.length; r11 += 2) {
                  const n9 = i8[r11 + 1];
                  e8.emplaceBack(t4.ay[i8[r11]], n9[0], n9[1]);
                }
                return [n8, e8.length];
              }(e7.textAnchorOffsets, W2);
              e7.symbolInstances.emplaceBack(r9.x, r9.y, L4.right >= 0 ? L4.right : -1, L4.center >= 0 ? L4.center : -1, L4.left >= 0 ? L4.left : -1, L4.vertical || -1, F3, $3, O3, R5, N4, U4, q3, G3, Z3, K3, X3, c6, E5, T5, B6, V4, J3, 0, f5, H5, Q3, tt2);
            }(e6, p5, l6, n6, i6, s4, B5, e6.layers[0], e6.collisionBoxArray, r8.index, r8.sourceLayerIndex, e6.index, x4, [_4, _4, _4, _4], k4, u4, b5, S5, I4, y4, r8, a4, c5, h4, o6);
          };
          if ("line" === z4) for (const t5 of mh(r8.geometry, 0, 0, M4, M4)) {
            const r9 = Cl(t5, V3), s5 = Sh(r9, w4, A5, n6.vertical || m4, i6, 24, v4, e6.overscaling, M4);
            for (const t6 of s5) m4 && Gh(e6, m4.text, P4, t6) || E4(r9, t6);
          }
          else if ("line-center" === z4) {
            for (const t5 of r8.geometry) if (t5.length > 1) {
              const e7 = Cl(t5, V3), r9 = _h(e7, A5, n6.vertical || m4, i6, 24, v4);
              r9 && E4(e7, r9);
            }
          } else if ("Polygon" === r8.type) for (const t5 of Ur(r8.geometry, 0)) {
            const e7 = Eh(t5, 16);
            E4(Cl(t5[0], V3, true), new gh(e7.x, e7.y, 0));
          }
          else if ("LineString" === r8.type) for (const t5 of r8.geometry) {
            const e7 = Cl(t5, V3);
            E4(e7, new gh(e7[0].x, e7[0].y, 0));
          }
          else if ("Point" === r8.type) for (const t5 of r8.geometry) for (const e7 of t5) E4([e7], new gh(e7.x, e7.y, 0));
        }
        function Uh(t5, e6, r8, n6, i6, s4, a4, o6, u4, c5, h4, p4, f4, d4, y4) {
          const m4 = function(t6, e7, r9, n7, i7, s5, a5, o7) {
            const u5 = n7.layout.get("text-rotate").evaluate(s5, {}) * Math.PI / 180, c6 = [];
            for (const t7 of e7.positionedLines) for (const n8 of t7.positionedGlyphs) {
              if (!n8.rect) continue;
              const s6 = n8.rect || {};
              let h5 = Zu + 1, p5 = true, f5 = 1, d5 = 0;
              const y5 = (i7 || o7) && n8.vertical, m5 = n8.metrics.advance * n8.scale / 2;
              if (o7 && e7.verticalizable && (d5 = t7.lineOffset / 2 - (n8.imageName ? -(Lu - n8.metrics.width * n8.scale) / 2 : (n8.scale - 1) * Lu)), n8.imageName) {
                const t8 = a5[n8.imageName];
                p5 = t8.sdf, f5 = t8.pixelRatio, h5 = Xu / f5;
              }
              const g5 = i7 ? [n8.x + m5, n8.y] : [0, 0];
              let x5 = i7 ? [0, 0] : [n8.x + m5 + r9[0], n8.y + r9[1] - d5], v4 = [0, 0];
              y5 && (v4 = x5, x5 = [0, 0]);
              const b5 = n8.metrics.isDoubleResolution ? 2 : 1, w4 = (n8.metrics.left - h5) * n8.scale - m5 + x5[0], _4 = (-n8.metrics.top - h5) * n8.scale + x5[1], S5 = w4 + s6.w / b5 * n8.scale / f5, A5 = _4 + s6.h / b5 * n8.scale / f5, k4 = new l4(w4, _4), M5 = new l4(S5, _4), I4 = new l4(w4, A5), z4 = new l4(S5, A5);
              if (y5) {
                const t8 = new l4(-m5, m5 - Wu), e8 = -Math.PI / 2, r10 = Lu / 2 - m5, i8 = new l4(5 - Wu - r10, -(n8.imageName ? r10 : 0)), s7 = new l4(...v4);
                k4._rotateAround(e8, t8)._add(i8)._add(s7), M5._rotateAround(e8, t8)._add(i8)._add(s7), I4._rotateAround(e8, t8)._add(i8)._add(s7), z4._rotateAround(e8, t8)._add(i8)._add(s7);
              }
              if (u5) {
                const t8 = Math.sin(u5), e8 = Math.cos(u5), r10 = [e8, -t8, t8, e8];
                k4._matMult(r10), M5._matMult(r10), I4._matMult(r10), z4._matMult(r10);
              }
              const P4 = new l4(0, 0), C4 = new l4(0, 0);
              c6.push({ tl: k4, tr: M5, bl: I4, br: z4, tex: s6, writingMode: e7.writingMode, glyphOffset: g5, sectionIndex: n8.sectionIndex, isSDF: p5, pixelOffsetTL: P4, pixelOffsetBR: C4, minFontScaleX: 0, minFontScaleY: 0 });
            }
            return c6;
          }(0, r8, o6, i6, s4, a4, n6, t5.allowVerticalPlacement), g4 = t5.textSizeData;
          let x4 = null;
          "source" === g4.kind ? (x4 = [_c * i6.layout.get("text-size").evaluate(a4, {})], x4[0] > Sc && j3(`${t5.layerIds[0]}: Value for "text-size" is >= ${wc}. Reduce your "text-size".`)) : "composite" === g4.kind && (x4 = [_c * d4.compositeTextSizes[0].evaluate(a4, {}, y4), _c * d4.compositeTextSizes[1].evaluate(a4, {}, y4)], (x4[0] > Sc || x4[1] > Sc) && j3(`${t5.layerIds[0]}: Value for "text-size" is >= ${wc}. Reduce your "text-size".`)), t5.addSymbols(t5.text, m4, x4, o6, s4, a4, c5, e6, u4.lineStartIndex, u4.lineLength, f4, y4);
          for (const e7 of h4) p4[e7] = t5.text.placedSymbolArray.length - 1;
          return 4 * m4.length;
        }
        function qh(t5) {
          for (const e6 in t5) return t5[e6];
          return null;
        }
        function Gh(t5, e6, r8, n6) {
          const i6 = t5.compareText;
          if (e6 in i6) {
            const t6 = i6[e6];
            for (let e7 = t6.length - 1; e7 >= 0; e7--) if (n6.dist(t6[e7]) < r8) return true;
          } else i6[e6] = [];
          return i6[e6].push(n6), false;
        }
        const Zh = [Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array];
        class Kh {
          static from(t5) {
            if (!(t5 instanceof ArrayBuffer)) throw new Error("Data must be an instance of ArrayBuffer.");
            const [e6, r8] = new Uint8Array(t5, 0, 2);
            if (219 !== e6) throw new Error("Data does not appear to be in a KDBush format.");
            const n6 = r8 >> 4;
            if (1 !== n6) throw new Error(`Got v${n6} data when expected v1.`);
            const i6 = Zh[15 & r8];
            if (!i6) throw new Error("Unrecognized array type.");
            const [s4] = new Uint16Array(t5, 2, 1), [a4] = new Uint32Array(t5, 4, 1);
            return new Kh(a4, s4, i6, t5);
          }
          constructor(t5, e6 = 64, r8 = Float64Array, n6) {
            if (isNaN(t5) || t5 < 0) throw new Error(`Unpexpected numItems value: ${t5}.`);
            this.numItems = +t5, this.nodeSize = Math.min(Math.max(+e6, 2), 65535), this.ArrayType = r8, this.IndexArrayType = t5 < 65536 ? Uint16Array : Uint32Array;
            const i6 = Zh.indexOf(this.ArrayType), s4 = 2 * t5 * this.ArrayType.BYTES_PER_ELEMENT, a4 = t5 * this.IndexArrayType.BYTES_PER_ELEMENT, o6 = (8 - a4 % 8) % 8;
            if (i6 < 0) throw new Error(`Unexpected typed array class: ${r8}.`);
            n6 && n6 instanceof ArrayBuffer ? (this.data = n6, this.ids = new this.IndexArrayType(this.data, 8, t5), this.coords = new this.ArrayType(this.data, 8 + a4 + o6, 2 * t5), this._pos = 2 * t5, this._finished = true) : (this.data = new ArrayBuffer(8 + s4 + a4 + o6), this.ids = new this.IndexArrayType(this.data, 8, t5), this.coords = new this.ArrayType(this.data, 8 + a4 + o6, 2 * t5), this._pos = 0, this._finished = false, new Uint8Array(this.data, 0, 2).set([219, 16 + i6]), new Uint16Array(this.data, 2, 1)[0] = e6, new Uint32Array(this.data, 4, 1)[0] = t5);
          }
          add(t5, e6) {
            const r8 = this._pos >> 1;
            return this.ids[r8] = r8, this.coords[this._pos++] = t5, this.coords[this._pos++] = e6, r8;
          }
          finish() {
            const t5 = this._pos >> 1;
            if (t5 !== this.numItems) throw new Error(`Added ${t5} items when expected ${this.numItems}.`);
            return Xh(this.ids, this.coords, this.nodeSize, 0, this.numItems - 1, 0), this._finished = true, this;
          }
          range(t5, e6, r8, n6) {
            if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
            const { ids: i6, coords: s4, nodeSize: a4 } = this, o6 = [0, i6.length - 1, 0], l5 = [];
            for (; o6.length; ) {
              const u4 = o6.pop() || 0, c5 = o6.pop() || 0, h4 = o6.pop() || 0;
              if (c5 - h4 <= a4) {
                for (let a5 = h4; a5 <= c5; a5++) {
                  const o7 = s4[2 * a5], u5 = s4[2 * a5 + 1];
                  o7 >= t5 && o7 <= r8 && u5 >= e6 && u5 <= n6 && l5.push(i6[a5]);
                }
                continue;
              }
              const p4 = h4 + c5 >> 1, f4 = s4[2 * p4], d4 = s4[2 * p4 + 1];
              f4 >= t5 && f4 <= r8 && d4 >= e6 && d4 <= n6 && l5.push(i6[p4]), (0 === u4 ? t5 <= f4 : e6 <= d4) && (o6.push(h4), o6.push(p4 - 1), o6.push(1 - u4)), (0 === u4 ? r8 >= f4 : n6 >= d4) && (o6.push(p4 + 1), o6.push(c5), o6.push(1 - u4));
            }
            return l5;
          }
          within(t5, e6, r8) {
            if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
            const { ids: n6, coords: i6, nodeSize: s4 } = this, a4 = [0, n6.length - 1, 0], o6 = [], l5 = r8 * r8;
            for (; a4.length; ) {
              const u4 = a4.pop() || 0, c5 = a4.pop() || 0, h4 = a4.pop() || 0;
              if (c5 - h4 <= s4) {
                for (let r9 = h4; r9 <= c5; r9++) Wh(i6[2 * r9], i6[2 * r9 + 1], t5, e6) <= l5 && o6.push(n6[r9]);
                continue;
              }
              const p4 = h4 + c5 >> 1, f4 = i6[2 * p4], d4 = i6[2 * p4 + 1];
              Wh(f4, d4, t5, e6) <= l5 && o6.push(n6[p4]), (0 === u4 ? t5 - r8 <= f4 : e6 - r8 <= d4) && (a4.push(h4), a4.push(p4 - 1), a4.push(1 - u4)), (0 === u4 ? t5 + r8 >= f4 : e6 + r8 >= d4) && (a4.push(p4 + 1), a4.push(c5), a4.push(1 - u4));
            }
            return o6;
          }
        }
        function Xh(t5, e6, r8, n6, i6, s4) {
          if (i6 - n6 <= r8) return;
          const a4 = n6 + i6 >> 1;
          Hh(t5, e6, a4, n6, i6, s4), Xh(t5, e6, r8, n6, a4 - 1, 1 - s4), Xh(t5, e6, r8, a4 + 1, i6, 1 - s4);
        }
        function Hh(t5, e6, r8, n6, i6, s4) {
          for (; i6 > n6; ) {
            if (i6 - n6 > 600) {
              const a5 = i6 - n6 + 1, o7 = r8 - n6 + 1, l6 = Math.log(a5), u4 = 0.5 * Math.exp(2 * l6 / 3), c5 = 0.5 * Math.sqrt(l6 * u4 * (a5 - u4) / a5) * (o7 - a5 / 2 < 0 ? -1 : 1);
              Hh(t5, e6, r8, Math.max(n6, Math.floor(r8 - o7 * u4 / a5 + c5)), Math.min(i6, Math.floor(r8 + (a5 - o7) * u4 / a5 + c5)), s4);
            }
            const a4 = e6[2 * r8 + s4];
            let o6 = n6, l5 = i6;
            for (Yh(t5, e6, n6, r8), e6[2 * i6 + s4] > a4 && Yh(t5, e6, n6, i6); o6 < l5; ) {
              for (Yh(t5, e6, o6, l5), o6++, l5--; e6[2 * o6 + s4] < a4; ) o6++;
              for (; e6[2 * l5 + s4] > a4; ) l5--;
            }
            e6[2 * n6 + s4] === a4 ? Yh(t5, e6, n6, l5) : (l5++, Yh(t5, e6, l5, i6)), l5 <= r8 && (n6 = l5 + 1), r8 <= l5 && (i6 = l5 - 1);
          }
        }
        function Yh(t5, e6, r8, n6) {
          Jh(t5, r8, n6), Jh(e6, 2 * r8, 2 * n6), Jh(e6, 2 * r8 + 1, 2 * n6 + 1);
        }
        function Jh(t5, e6, r8) {
          const n6 = t5[e6];
          t5[e6] = t5[r8], t5[r8] = n6;
        }
        function Wh(t5, e6, r8, n6) {
          const i6 = t5 - r8, s4 = e6 - n6;
          return i6 * i6 + s4 * s4;
        }
        var Qh;
        t4.ck = void 0, (Qh = t4.ck || (t4.ck = {})).create = "create", Qh.load = "load", Qh.fullLoad = "fullLoad";
        let tp = null, ep = [];
        const rp = 1e3 / 60, np = "loadTime", ip = "fullLoadTime", sp = { mark(t5) {
          performance.mark(t5);
        }, frame(t5) {
          const e6 = t5;
          null != tp && ep.push(e6 - tp), tp = e6;
        }, clearMetrics() {
          tp = null, ep = [], performance.clearMeasures(np), performance.clearMeasures(ip);
          for (const e6 in t4.ck) performance.clearMarks(t4.ck[e6]);
        }, getPerformanceMetrics() {
          performance.measure(np, t4.ck.create, t4.ck.load), performance.measure(ip, t4.ck.create, t4.ck.fullLoad);
          const e6 = performance.getEntriesByName(np)[0].duration, r8 = performance.getEntriesByName(ip)[0].duration, n6 = ep.length, i6 = 1 / (ep.reduce((t5, e7) => t5 + e7, 0) / n6 / 1e3), s4 = ep.filter((t5) => t5 > rp).reduce((t5, e7) => t5 + (e7 - rp) / rp, 0);
          return { loadTime: e6, fullLoadTime: r8, fps: i6, percentDroppedFrames: s4 / (n6 + s4) * 100, totalFrames: n6 };
        } };
        t4.$ = nh, t4.A = g3, t4.B = ir, t4.C = fs, t4.D = _s, t4.E = ft, t4.F = Ri, t4.G = function(t5) {
          if (null == q2) {
            const e6 = t5.navigator ? t5.navigator.userAgent : null;
            q2 = !!t5.safari || !(!e6 || !(/\b(iPad|iPhone|iPod)\b/.test(e6) || e6.match("Safari") && !e6.match("Chrome")));
          }
          return q2;
        }, t4.H = class {
          constructor(t5, e6) {
            this.target = t5, this.mapId = e6, this.resolveRejects = {}, this.tasks = {}, this.taskQueue = [], this.abortControllers = {}, this.messageHandlers = {}, this.invoker = new Zc(() => this.process()), this.subscription = Y2(this.target, "message", (t6) => this.receive(t6), false), this.globalScope = U3(self) ? t5 : window;
          }
          registerMessageHandler(t5, e6) {
            this.messageHandlers[t5] = e6;
          }
          sendAsync(t5, e6) {
            return new Promise((r8, n6) => {
              const i6 = Math.round(1e18 * Math.random()).toString(36).substring(0, 10), s4 = e6 ? Y2(e6.signal, "abort", () => {
                null == s4 || s4.unsubscribe(), delete this.resolveRejects[i6];
                const e7 = { id: i6, type: "<cancel>", origin: location.origin, targetMapId: t5.targetMapId, sourceMapId: this.mapId };
                this.target.postMessage(e7);
              }, Kc) : null;
              this.resolveRejects[i6] = { resolve: (t6) => {
                null == s4 || s4.unsubscribe(), r8(t6);
              }, reject: (t6) => {
                null == s4 || s4.unsubscribe(), n6(t6);
              } };
              const a4 = [], o6 = Object.assign(Object.assign({}, t5), { id: i6, sourceMapId: this.mapId, origin: location.origin, data: Yi(t5.data, a4) });
              this.target.postMessage(o6, { transfer: a4 });
            });
          }
          receive(t5) {
            const e6 = t5.data, r8 = e6.id;
            if (!("file://" !== e6.origin && "file://" !== location.origin && "resource://android" !== e6.origin && "resource://android" !== location.origin && e6.origin !== location.origin || e6.targetMapId && this.mapId !== e6.targetMapId)) {
              if ("<cancel>" === e6.type) {
                delete this.tasks[r8];
                const t6 = this.abortControllers[r8];
                return delete this.abortControllers[r8], void (t6 && t6.abort());
              }
              if (U3(self) || e6.mustQueue) return this.tasks[r8] = e6, this.taskQueue.push(r8), void this.invoker.trigger();
              this.processTask(r8, e6);
            }
          }
          process() {
            if (0 === this.taskQueue.length) return;
            const t5 = this.taskQueue.shift(), e6 = this.tasks[t5];
            delete this.tasks[t5], this.taskQueue.length > 0 && this.invoker.trigger(), e6 && this.processTask(t5, e6);
          }
          processTask(t5, r8) {
            return e5(this, void 0, void 0, function* () {
              if ("<response>" === r8.type) {
                const e7 = this.resolveRejects[t5];
                if (delete this.resolveRejects[t5], !e7) return;
                return void (r8.error ? e7.reject(Ji(r8.error)) : e7.resolve(Ji(r8.data)));
              }
              if (!this.messageHandlers[r8.type]) return void this.completeTask(t5, new Error(`Could not find a registered handler for ${r8.type}, map ID: ${this.mapId}, available handlers: ${Object.keys(this.messageHandlers).join(", ")}`));
              const e6 = Ji(r8.data), n6 = new AbortController();
              this.abortControllers[t5] = n6;
              try {
                const i6 = yield this.messageHandlers[r8.type](r8.sourceMapId, e6, n6);
                this.completeTask(t5, null, i6);
              } catch (e7) {
                this.completeTask(t5, e7);
              }
            });
          }
          completeTask(t5, e6, r8) {
            const n6 = [];
            delete this.abortControllers[t5];
            const i6 = { id: t5, type: "<response>", sourceMapId: this.mapId, origin: location.origin, error: e6 ? Yi(e6) : null, data: Yi(r8, n6) };
            this.target.postMessage(i6, { transfer: n6 });
          }
          remove() {
            this.invoker.remove(), this.subscription.unsubscribe();
          }
        }, t4.I = Hu, t4.J = it, t4.K = function() {
          var t5 = new g3(16);
          return g3 != Float32Array && (t5[1] = 0, t5[2] = 0, t5[3] = 0, t5[4] = 0, t5[6] = 0, t5[7] = 0, t5[8] = 0, t5[9] = 0, t5[11] = 0, t5[12] = 0, t5[13] = 0, t5[14] = 0), t5[0] = 1, t5[5] = 1, t5[10] = 1, t5[15] = 1, t5;
        }, t4.L = function(t5, e6, r8) {
          var n6, i6, s4, a4, o6, l5, u4, c5, h4, p4, f4, d4, y4 = r8[0], m4 = r8[1], g4 = r8[2];
          return e6 === t5 ? (t5[12] = e6[0] * y4 + e6[4] * m4 + e6[8] * g4 + e6[12], t5[13] = e6[1] * y4 + e6[5] * m4 + e6[9] * g4 + e6[13], t5[14] = e6[2] * y4 + e6[6] * m4 + e6[10] * g4 + e6[14], t5[15] = e6[3] * y4 + e6[7] * m4 + e6[11] * g4 + e6[15]) : (i6 = e6[1], s4 = e6[2], a4 = e6[3], o6 = e6[4], l5 = e6[5], u4 = e6[6], c5 = e6[7], h4 = e6[8], p4 = e6[9], f4 = e6[10], d4 = e6[11], t5[0] = n6 = e6[0], t5[1] = i6, t5[2] = s4, t5[3] = a4, t5[4] = o6, t5[5] = l5, t5[6] = u4, t5[7] = c5, t5[8] = h4, t5[9] = p4, t5[10] = f4, t5[11] = d4, t5[12] = n6 * y4 + o6 * m4 + h4 * g4 + e6[12], t5[13] = i6 * y4 + l5 * m4 + p4 * g4 + e6[13], t5[14] = s4 * y4 + u4 * m4 + f4 * g4 + e6[14], t5[15] = a4 * y4 + c5 * m4 + d4 * g4 + e6[15]), t5;
        }, t4.M = function(t5, e6, r8) {
          var n6 = r8[0], i6 = r8[1], s4 = r8[2];
          return t5[0] = e6[0] * n6, t5[1] = e6[1] * n6, t5[2] = e6[2] * n6, t5[3] = e6[3] * n6, t5[4] = e6[4] * i6, t5[5] = e6[5] * i6, t5[6] = e6[6] * i6, t5[7] = e6[7] * i6, t5[8] = e6[8] * s4, t5[9] = e6[9] * s4, t5[10] = e6[10] * s4, t5[11] = e6[11] * s4, t5[12] = e6[12], t5[13] = e6[13], t5[14] = e6[14], t5[15] = e6[15], t5;
        }, t4.N = function(t5, e6, r8) {
          var n6 = e6[0], i6 = e6[1], s4 = e6[2], a4 = e6[3], o6 = e6[4], l5 = e6[5], u4 = e6[6], c5 = e6[7], h4 = e6[8], p4 = e6[9], f4 = e6[10], d4 = e6[11], y4 = e6[12], m4 = e6[13], g4 = e6[14], x4 = e6[15], v4 = r8[0], b5 = r8[1], w4 = r8[2], _4 = r8[3];
          return t5[0] = v4 * n6 + b5 * o6 + w4 * h4 + _4 * y4, t5[1] = v4 * i6 + b5 * l5 + w4 * p4 + _4 * m4, t5[2] = v4 * s4 + b5 * u4 + w4 * f4 + _4 * g4, t5[3] = v4 * a4 + b5 * c5 + w4 * d4 + _4 * x4, t5[4] = (v4 = r8[4]) * n6 + (b5 = r8[5]) * o6 + (w4 = r8[6]) * h4 + (_4 = r8[7]) * y4, t5[5] = v4 * i6 + b5 * l5 + w4 * p4 + _4 * m4, t5[6] = v4 * s4 + b5 * u4 + w4 * f4 + _4 * g4, t5[7] = v4 * a4 + b5 * c5 + w4 * d4 + _4 * x4, t5[8] = (v4 = r8[8]) * n6 + (b5 = r8[9]) * o6 + (w4 = r8[10]) * h4 + (_4 = r8[11]) * y4, t5[9] = v4 * i6 + b5 * l5 + w4 * p4 + _4 * m4, t5[10] = v4 * s4 + b5 * u4 + w4 * f4 + _4 * g4, t5[11] = v4 * a4 + b5 * c5 + w4 * d4 + _4 * x4, t5[12] = (v4 = r8[12]) * n6 + (b5 = r8[13]) * o6 + (w4 = r8[14]) * h4 + (_4 = r8[15]) * y4, t5[13] = v4 * i6 + b5 * l5 + w4 * p4 + _4 * m4, t5[14] = v4 * s4 + b5 * u4 + w4 * f4 + _4 * g4, t5[15] = v4 * a4 + b5 * c5 + w4 * d4 + _4 * x4, t5;
        }, t4.O = function(t5, e6) {
          const r8 = {};
          for (let n6 = 0; n6 < e6.length; n6++) {
            const i6 = e6[n6];
            i6 in t5 && (r8[i6] = t5[i6]);
          }
          return r8;
        }, t4.P = l4, t4.Q = Hc, t4.R = No, t4.S = Qc, t4.T = ms, t4.U = Wc, t4.V = f3, t4.W = d3, t4.X = K2, t4.Y = oh, t4.Z = M4, t4._ = e5, t4.a = rt, t4.a$ = function(t5, e6, r8) {
          var n6 = Math.sin(r8), i6 = Math.cos(r8), s4 = e6[4], a4 = e6[5], o6 = e6[6], l5 = e6[7], u4 = e6[8], c5 = e6[9], h4 = e6[10], p4 = e6[11];
          return e6 !== t5 && (t5[0] = e6[0], t5[1] = e6[1], t5[2] = e6[2], t5[3] = e6[3], t5[12] = e6[12], t5[13] = e6[13], t5[14] = e6[14], t5[15] = e6[15]), t5[4] = s4 * i6 + u4 * n6, t5[5] = a4 * i6 + c5 * n6, t5[6] = o6 * i6 + h4 * n6, t5[7] = l5 * i6 + p4 * n6, t5[8] = u4 * i6 - s4 * n6, t5[9] = c5 * i6 - a4 * n6, t5[10] = h4 * i6 - o6 * n6, t5[11] = p4 * i6 - l5 * n6, t5;
        }, t4.a0 = 25, t4.a1 = sh, t4.a2 = (t5) => {
          const e6 = window.document.createElement("video");
          return e6.muted = true, new Promise((r8) => {
            e6.onloadstart = () => {
              r8(e6);
            };
            for (const r9 of t5) {
              const t6 = window.document.createElement("source");
              lt(r9) || (e6.crossOrigin = "Anonymous"), t6.src = r9, e6.appendChild(t6);
            }
          });
        }, t4.a3 = Mt, t4.a4 = function() {
          return $2++;
        }, t4.a5 = sa, t4.a6 = Ec, t4.a7 = Qn, t4.a8 = ho, t4.a9 = hh, t4.aA = jh, t4.aB = hc, t4.aC = Kh, t4.aD = Es, t4.aE = kl, t4.aF = ma, t4.aG = Va, t4.aH = za, t4.aI = function(t5) {
          return Math.pow(2, t5);
        }, t4.aJ = 85.051129, t4.aK = th, t4.aL = T4, t4.aM = J2, t4.aN = rh, t4.aO = function(t5, e6, r8) {
          return t5[0] = e6[0] * r8, t5[1] = e6[1] * r8, t5[2] = e6[2] * r8, t5;
        }, t4.aP = function(t5, e6, r8) {
          return t5[0] = e6[0] + r8[0], t5[1] = e6[1] + r8[1], t5[2] = e6[2] + r8[2], t5;
        }, t4.aQ = function(t5) {
          var e6 = new g3(3);
          return e6[0] = t5[0], e6[1] = t5[1], e6[2] = t5[2], e6;
        }, t4.aR = function(t5, e6, r8) {
          return t5[0] = e6[0] * r8[0], t5[1] = e6[1] * r8[1], t5[2] = e6[2] * r8[2], t5[3] = e6[3] * r8[3], t5;
        }, t4.aS = function(t5, e6, r8) {
          return t5[0] = e6[0] - r8[0], t5[1] = e6[1] - r8[1], t5[2] = e6[2] - r8[2], t5;
        }, t4.aT = function(t5, e6) {
          var r8 = e6[0], n6 = e6[1], i6 = e6[2], s4 = r8 * r8 + n6 * n6 + i6 * i6;
          return s4 > 0 && (s4 = 1 / Math.sqrt(s4)), t5[0] = e6[0] * s4, t5[1] = e6[1] * s4, t5[2] = e6[2] * s4, t5;
        }, t4.aU = function(t5, e6, r8) {
          var n6 = e6[0], i6 = e6[1], s4 = e6[2], a4 = r8[0], o6 = r8[1], l5 = r8[2];
          return t5[0] = i6 * l5 - s4 * o6, t5[1] = s4 * a4 - n6 * l5, t5[2] = n6 * o6 - i6 * a4, t5;
        }, t4.aV = function(t5, e6) {
          return t5[0] * e6[0] + t5[1] * e6[1] + t5[2] * e6[2];
        }, t4.aW = ah, t4.aX = lh, t4.aY = function(t5, e6, r8, n6, i6) {
          var s4, a4 = 1 / Math.tan(e6 / 2);
          return t5[0] = a4 / r8, t5[1] = 0, t5[2] = 0, t5[3] = 0, t5[4] = 0, t5[5] = a4, t5[6] = 0, t5[7] = 0, t5[8] = 0, t5[9] = 0, t5[11] = -1, t5[12] = 0, t5[13] = 0, t5[15] = 0, null != i6 && i6 !== 1 / 0 ? (t5[10] = (i6 + n6) * (s4 = 1 / (n6 - i6)), t5[14] = 2 * i6 * n6 * s4) : (t5[10] = -1, t5[14] = -2 * n6), t5;
        }, t4.aZ = function(t5) {
          var e6 = new g3(16);
          return e6[0] = t5[0], e6[1] = t5[1], e6[2] = t5[2], e6[3] = t5[3], e6[4] = t5[4], e6[5] = t5[5], e6[6] = t5[6], e6[7] = t5[7], e6[8] = t5[8], e6[9] = t5[9], e6[10] = t5[10], e6[11] = t5[11], e6[12] = t5[12], e6[13] = t5[13], e6[14] = t5[14], e6[15] = t5[15], e6;
        }, t4.a_ = function(t5, e6, r8) {
          var n6 = Math.sin(r8), i6 = Math.cos(r8), s4 = e6[0], a4 = e6[1], o6 = e6[2], l5 = e6[3], u4 = e6[4], c5 = e6[5], h4 = e6[6], p4 = e6[7];
          return e6 !== t5 && (t5[8] = e6[8], t5[9] = e6[9], t5[10] = e6[10], t5[11] = e6[11], t5[12] = e6[12], t5[13] = e6[13], t5[14] = e6[14], t5[15] = e6[15]), t5[0] = s4 * i6 + u4 * n6, t5[1] = a4 * i6 + c5 * n6, t5[2] = o6 * i6 + h4 * n6, t5[3] = l5 * i6 + p4 * n6, t5[4] = u4 * i6 - s4 * n6, t5[5] = c5 * i6 - a4 * n6, t5[6] = h4 * i6 - o6 * n6, t5[7] = p4 * i6 - l5 * n6, t5;
        }, t4.aa = function(t5) {
          const e6 = {};
          if (t5.replace(/(?:^|(?:\s*\,\s*))([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)(?:\=(?:([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)|(?:\"((?:[^"\\]|\\.)*)\")))?/g, (t6, r8, n6, i6) => {
            const s4 = n6 || i6;
            return e6[r8] = !s4 || s4.toLowerCase(), "";
          }), e6["max-age"]) {
            const t6 = parseInt(e6["max-age"], 10);
            isNaN(t6) ? delete e6["max-age"] : e6["max-age"] = t6;
          }
          return e6;
        }, t4.ab = function(t5) {
          return Math.log(t5) / Math.LN2;
        }, t4.ac = function(t5) {
          var e6 = t5[0], r8 = t5[1];
          return e6 * e6 + r8 * r8;
        }, t4.ad = function(t5) {
          return t5 * Math.PI / 180;
        }, t4.ae = E3, t4.af = function(t5, e6) {
          const r8 = [];
          for (const n6 in t5) n6 in e6 || r8.push(n6);
          return r8;
        }, t4.ag = function(t5, e6) {
          let r8 = 0, n6 = 0;
          if ("constant" === t5.kind) n6 = t5.layoutSize;
          else if ("source" !== t5.kind) {
            const { interpolationType: i6, minZoom: s4, maxZoom: a4 } = t5, o6 = i6 ? E3(rr.interpolationFactor(i6, e6, s4, a4), 0, 1) : 0;
            "camera" === t5.kind ? n6 = ir.number(t5.minSize, t5.maxSize, o6) : r8 = o6;
          }
          return { uSizeT: r8, uSize: n6 };
        }, t4.ai = function(t5, { uSize: e6, uSizeT: r8 }, { lowerSize: n6, upperSize: i6 }) {
          return "source" === t5.kind ? n6 / _c : "composite" === t5.kind ? ir.number(n6 / _c, i6 / _c, r8) : e6;
        }, t4.aj = function(t5, e6) {
          var r8 = e6[0], n6 = e6[1], i6 = e6[2], s4 = e6[3], a4 = e6[4], o6 = e6[5], l5 = e6[6], u4 = e6[7], c5 = e6[8], h4 = e6[9], p4 = e6[10], f4 = e6[11], d4 = e6[12], y4 = e6[13], m4 = e6[14], g4 = e6[15], x4 = r8 * o6 - n6 * a4, v4 = r8 * l5 - i6 * a4, b5 = r8 * u4 - s4 * a4, w4 = n6 * l5 - i6 * o6, _4 = n6 * u4 - s4 * o6, S5 = i6 * u4 - s4 * l5, A5 = c5 * y4 - h4 * d4, k4 = c5 * m4 - p4 * d4, M5 = c5 * g4 - f4 * d4, I4 = h4 * m4 - p4 * y4, z4 = h4 * g4 - f4 * y4, P4 = p4 * g4 - f4 * m4, C4 = x4 * P4 - v4 * z4 + b5 * I4 + w4 * M5 - _4 * k4 + S5 * A5;
          return C4 ? (t5[0] = (o6 * P4 - l5 * z4 + u4 * I4) * (C4 = 1 / C4), t5[1] = (i6 * z4 - n6 * P4 - s4 * I4) * C4, t5[2] = (y4 * S5 - m4 * _4 + g4 * w4) * C4, t5[3] = (p4 * _4 - h4 * S5 - f4 * w4) * C4, t5[4] = (l5 * M5 - a4 * P4 - u4 * k4) * C4, t5[5] = (r8 * P4 - i6 * M5 + s4 * k4) * C4, t5[6] = (m4 * b5 - d4 * S5 - g4 * v4) * C4, t5[7] = (c5 * S5 - p4 * b5 + f4 * v4) * C4, t5[8] = (a4 * z4 - o6 * M5 + u4 * A5) * C4, t5[9] = (n6 * M5 - r8 * z4 - s4 * A5) * C4, t5[10] = (d4 * _4 - y4 * b5 + g4 * x4) * C4, t5[11] = (h4 * b5 - c5 * _4 - f4 * x4) * C4, t5[12] = (o6 * k4 - a4 * I4 - l5 * A5) * C4, t5[13] = (r8 * I4 - n6 * k4 + i6 * A5) * C4, t5[14] = (y4 * v4 - d4 * w4 - m4 * x4) * C4, t5[15] = (c5 * w4 - h4 * v4 + p4 * x4) * C4, t5) : null;
        }, t4.ak = A4, t4.al = function(t5) {
          return Math.hypot(t5[0], t5[1]);
        }, t4.am = function(t5) {
          return t5[0] = 0, t5[1] = 0, t5;
        }, t4.an = function(t5, e6, r8) {
          return t5[0] = e6[0] * r8, t5[1] = e6[1] * r8, t5;
        }, t4.ao = Pc, t4.ap = _3, t4.aq = function(t5, e6, r8, n6) {
          const i6 = e6.y - t5.y, s4 = e6.x - t5.x, a4 = n6.y - r8.y, o6 = n6.x - r8.x, u4 = a4 * s4 - o6 * i6;
          if (0 === u4) return null;
          const c5 = (o6 * (t5.y - r8.y) - a4 * (t5.x - r8.x)) / u4;
          return new l4(t5.x + c5 * s4, t5.y + c5 * i6);
        }, t4.ar = mh, t4.as = mo, t4.at = v3, t4.au = function(t5) {
          let e6 = 1 / 0, r8 = 1 / 0, n6 = -1 / 0, i6 = -1 / 0;
          for (const s4 of t5) e6 = Math.min(e6, s4.x), r8 = Math.min(r8, s4.y), n6 = Math.max(n6, s4.x), i6 = Math.max(i6, s4.y);
          return [e6, r8, n6, i6];
        }, t4.av = Lu, t4.aw = I3, t4.ax = function(t5, e6, r8, n6, i6 = false) {
          if (!r8[0] && !r8[1]) return [0, 0];
          const s4 = i6 ? "map" === n6 ? -t5.bearingInRadians : 0 : "viewport" === n6 ? t5.bearingInRadians : 0;
          if (s4) {
            const t6 = Math.sin(s4), e7 = Math.cos(s4);
            r8 = [r8[0] * e7 - r8[1] * t6, r8[0] * t6 + r8[1] * e7];
          }
          return [i6 ? r8[0] : I3(e6, r8[0], t5.zoom), i6 ? r8[1] : I3(e6, r8[1], t5.zoom)];
        }, t4.az = kc, t4.b = G2, t4.b$ = (t5) => "symbol" === t5.type, t4.b0 = function() {
          const t5 = new Float32Array(16);
          return v3(t5), t5;
        }, t4.b1 = function() {
          const t5 = new Float64Array(16);
          return v3(t5), t5;
        }, t4.b2 = function() {
          return new Float64Array(16);
        }, t4.b3 = function(t5, e6, r8) {
          const n6 = new Float64Array(4);
          return function(t6, e7, r9, n7) {
            var i6 = 0.5 * Math.PI / 180;
            e7 *= i6, r9 *= i6, n7 *= i6;
            var s4 = Math.sin(e7), a4 = Math.cos(e7), o6 = Math.sin(r9), l5 = Math.cos(r9), u4 = Math.sin(n7), c5 = Math.cos(n7);
            t6[0] = s4 * l5 * c5 - a4 * o6 * u4, t6[1] = a4 * o6 * c5 + s4 * l5 * u4, t6[2] = a4 * l5 * u4 - s4 * o6 * c5, t6[3] = a4 * l5 * c5 + s4 * o6 * u4;
          }(n6, t5, e6 - 90, r8), n6;
        }, t4.b4 = function(t5, e6, r8, n6) {
          var i6, s4, a4, o6, l5, u4 = e6[0], c5 = e6[1], h4 = e6[2], p4 = e6[3], f4 = r8[0], d4 = r8[1], y4 = r8[2], g4 = r8[3];
          return (s4 = u4 * f4 + c5 * d4 + h4 * y4 + p4 * g4) < 0 && (s4 = -s4, f4 = -f4, d4 = -d4, y4 = -y4, g4 = -g4), 1 - s4 > m3 ? (i6 = Math.acos(s4), a4 = Math.sin(i6), o6 = Math.sin((1 - n6) * i6) / a4, l5 = Math.sin(n6 * i6) / a4) : (o6 = 1 - n6, l5 = n6), t5[0] = o6 * u4 + l5 * f4, t5[1] = o6 * c5 + l5 * d4, t5[2] = o6 * h4 + l5 * y4, t5[3] = o6 * p4 + l5 * g4, t5;
        }, t4.b5 = function(t5) {
          const e6 = new Float64Array(9);
          var r8, n6, i6, s4, a4, o6, l5, u4, c5, h4, p4, f4, d4, y4, m4, g4, x4, v4;
          h4 = (i6 = (n6 = t5)[0]) * (l5 = i6 + i6), p4 = (s4 = n6[1]) * l5, d4 = (a4 = n6[2]) * l5, y4 = a4 * (u4 = s4 + s4), g4 = (o6 = n6[3]) * l5, x4 = o6 * u4, v4 = o6 * (c5 = a4 + a4), (r8 = e6)[0] = 1 - (f4 = s4 * u4) - (m4 = a4 * c5), r8[3] = p4 - v4, r8[6] = d4 + x4, r8[1] = p4 + v4, r8[4] = 1 - h4 - m4, r8[7] = y4 - g4, r8[2] = d4 - x4, r8[5] = y4 + g4, r8[8] = 1 - h4 - f4;
          const b5 = J2(-Math.asin(E3(e6[2], -1, 1)));
          let w4, _4;
          return Math.hypot(e6[5], e6[8]) < 1e-3 ? (w4 = 0, _4 = -J2(Math.atan2(e6[3], e6[4]))) : (w4 = J2(0 === e6[5] && 0 === e6[8] ? 0 : Math.atan2(e6[5], e6[8])), _4 = J2(0 === e6[1] && 0 === e6[0] ? 0 : Math.atan2(e6[1], e6[0]))), { roll: w4, pitch: b5 + 90, bearing: _4 };
        }, t4.b6 = function(t5, e6) {
          return t5.roll == e6.roll && t5.pitch == e6.pitch && t5.bearing == e6.bearing;
        }, t4.b7 = xe, t4.b8 = Xa, t4.b9 = Ml, t4.bA = function(t5, e6) {
          if (!t5) return [{ command: "setStyle", args: [e6] }];
          let r8 = [];
          try {
            if (!gt(t5.version, e6.version)) return [{ command: "setStyle", args: [e6] }];
            gt(t5.center, e6.center) || r8.push({ command: "setCenter", args: [e6.center] }), gt(t5.centerAltitude, e6.centerAltitude) || r8.push({ command: "setCenterAltitude", args: [e6.centerAltitude] }), gt(t5.zoom, e6.zoom) || r8.push({ command: "setZoom", args: [e6.zoom] }), gt(t5.bearing, e6.bearing) || r8.push({ command: "setBearing", args: [e6.bearing] }), gt(t5.pitch, e6.pitch) || r8.push({ command: "setPitch", args: [e6.pitch] }), gt(t5.roll, e6.roll) || r8.push({ command: "setRoll", args: [e6.roll] }), gt(t5.sprite, e6.sprite) || r8.push({ command: "setSprite", args: [e6.sprite] }), gt(t5.glyphs, e6.glyphs) || r8.push({ command: "setGlyphs", args: [e6.glyphs] }), gt(t5.transition, e6.transition) || r8.push({ command: "setTransition", args: [e6.transition] }), gt(t5.light, e6.light) || r8.push({ command: "setLight", args: [e6.light] }), gt(t5.terrain, e6.terrain) || r8.push({ command: "setTerrain", args: [e6.terrain] }), gt(t5.sky, e6.sky) || r8.push({ command: "setSky", args: [e6.sky] }), gt(t5.projection, e6.projection) || r8.push({ command: "setProjection", args: [e6.projection] });
            const n6 = {}, i6 = [];
            !function(t6, e7, r9, n7) {
              let i7;
              for (i7 in e7 = e7 || {}, t6 = t6 || {}) Object.prototype.hasOwnProperty.call(t6, i7) && (Object.prototype.hasOwnProperty.call(e7, i7) || bt(i7, r9, n7));
              for (i7 in e7) Object.prototype.hasOwnProperty.call(e7, i7) && (Object.prototype.hasOwnProperty.call(t6, i7) ? gt(t6[i7], e7[i7]) || ("geojson" === t6[i7].type && "geojson" === e7[i7].type && _t(t6, e7, i7) ? xt(r9, { command: "setGeoJSONSourceData", args: [i7, e7[i7].data] }) : wt(i7, e7, r9, n7)) : vt(i7, e7, r9));
            }(t5.sources, e6.sources, i6, n6);
            const s4 = [];
            t5.layers && t5.layers.forEach((t6) => {
              "source" in t6 && n6[t6.source] ? r8.push({ command: "removeLayer", args: [t6.id] }) : s4.push(t6);
            }), r8 = r8.concat(i6), function(t6, e7, r9) {
              e7 = e7 || [];
              const n7 = (t6 = t6 || []).map(At), i7 = e7.map(At), s5 = t6.reduce(kt, {}), a4 = e7.reduce(kt, {}), o6 = n7.slice(), l5 = /* @__PURE__ */ Object.create(null);
              let u4, c5, h4, p4, f4;
              for (let t7 = 0, e8 = 0; t7 < n7.length; t7++) u4 = n7[t7], Object.prototype.hasOwnProperty.call(a4, u4) ? e8++ : (xt(r9, { command: "removeLayer", args: [u4] }), o6.splice(o6.indexOf(u4, e8), 1));
              for (let t7 = 0, e8 = 0; t7 < i7.length; t7++) u4 = i7[i7.length - 1 - t7], o6[o6.length - 1 - t7] !== u4 && (Object.prototype.hasOwnProperty.call(s5, u4) ? (xt(r9, { command: "removeLayer", args: [u4] }), o6.splice(o6.lastIndexOf(u4, o6.length - e8), 1)) : e8++, p4 = o6[o6.length - t7], xt(r9, { command: "addLayer", args: [a4[u4], p4] }), o6.splice(o6.length - t7, 0, u4), l5[u4] = true);
              for (let t7 = 0; t7 < i7.length; t7++) if (u4 = i7[t7], c5 = s5[u4], h4 = a4[u4], !l5[u4] && !gt(c5, h4)) if (gt(c5.source, h4.source) && gt(c5["source-layer"], h4["source-layer"]) && gt(c5.type, h4.type)) {
                for (f4 in St(c5.layout, h4.layout, r9, u4, null, "setLayoutProperty"), St(c5.paint, h4.paint, r9, u4, null, "setPaintProperty"), gt(c5.filter, h4.filter) || xt(r9, { command: "setFilter", args: [u4, h4.filter] }), gt(c5.minzoom, h4.minzoom) && gt(c5.maxzoom, h4.maxzoom) || xt(r9, { command: "setLayerZoomRange", args: [u4, h4.minzoom, h4.maxzoom] }), c5) Object.prototype.hasOwnProperty.call(c5, f4) && "layout" !== f4 && "paint" !== f4 && "filter" !== f4 && "metadata" !== f4 && "minzoom" !== f4 && "maxzoom" !== f4 && (0 === f4.indexOf("paint.") ? St(c5[f4], h4[f4], r9, u4, f4.slice(6), "setPaintProperty") : gt(c5[f4], h4[f4]) || xt(r9, { command: "setLayerProperty", args: [u4, f4, h4[f4]] }));
                for (f4 in h4) Object.prototype.hasOwnProperty.call(h4, f4) && !Object.prototype.hasOwnProperty.call(c5, f4) && "layout" !== f4 && "paint" !== f4 && "filter" !== f4 && "metadata" !== f4 && "minzoom" !== f4 && "maxzoom" !== f4 && (0 === f4.indexOf("paint.") ? St(c5[f4], h4[f4], r9, u4, f4.slice(6), "setPaintProperty") : gt(c5[f4], h4[f4]) || xt(r9, { command: "setLayerProperty", args: [u4, f4, h4[f4]] }));
              } else xt(r9, { command: "removeLayer", args: [u4] }), p4 = o6[o6.lastIndexOf(u4) + 1], xt(r9, { command: "addLayer", args: [h4, p4] });
            }(s4, e6.layers, r8);
          } catch (t6) {
            console.warn("Unable to compute style diff:", t6), r8 = [{ command: "setStyle", args: [e6] }];
          }
          return r8;
        }, t4.bB = function(t5) {
          const e6 = [], r8 = t5.id;
          return void 0 === r8 && e6.push({ message: `layers.${r8}: missing required property "id"` }), void 0 === t5.render && e6.push({ message: `layers.${r8}: missing required method "render"` }), t5.renderingMode && "2d" !== t5.renderingMode && "3d" !== t5.renderingMode && e6.push({ message: `layers.${r8}: property "renderingMode" must be either "2d" or "3d"` }), e6;
        }, t4.bC = function t5(e6, r8) {
          if (Array.isArray(e6)) {
            if (!Array.isArray(r8) || e6.length !== r8.length) return false;
            for (let n6 = 0; n6 < e6.length; n6++) if (!t5(e6[n6], r8[n6])) return false;
            return true;
          }
          if ("object" == typeof e6 && null !== e6 && null !== r8) {
            if ("object" != typeof r8) return false;
            if (Object.keys(e6).length !== Object.keys(r8).length) return false;
            for (const n6 in e6) if (!t5(e6[n6], r8[n6])) return false;
            return true;
          }
          return e6 === r8;
        }, t4.bD = L3, t4.bE = O2, t4.bF = class extends Ka {
          constructor(t5, e6) {
            super(t5, e6), this.current = 0;
          }
          set(t5) {
            this.current !== t5 && (this.current = t5, this.gl.uniform1i(this.location, t5));
          }
        }, t4.bG = Ya, t4.bH = class extends Ka {
          constructor(t5, e6) {
            super(t5, e6), this.current = Ja;
          }
          set(t5) {
            if (t5[12] !== this.current[12] || t5[0] !== this.current[0]) return this.current = t5, void this.gl.uniformMatrix4fv(this.location, false, t5);
            for (let e6 = 1; e6 < 16; e6++) if (t5[e6] !== this.current[e6]) {
              this.current = t5, this.gl.uniformMatrix4fv(this.location, false, t5);
              break;
            }
          }
        }, t4.bI = Ha, t4.bJ = class extends Ka {
          constructor(t5, e6) {
            super(t5, e6), this.current = [0, 0, 0];
          }
          set(t5) {
            t5[0] === this.current[0] && t5[1] === this.current[1] && t5[2] === this.current[2] || (this.current = t5, this.gl.uniform3f(this.location, t5[0], t5[1], t5[2]));
          }
        }, t4.bK = class extends Ka {
          constructor(t5, e6) {
            super(t5, e6), this.current = [0, 0];
          }
          set(t5) {
            t5[0] === this.current[0] && t5[1] === this.current[1] || (this.current = t5, this.gl.uniform2f(this.location, t5[0], t5[1]));
          }
        }, t4.bL = x3, t4.bM = function(t5, e6) {
          var r8 = Math.sin(e6), n6 = Math.cos(e6);
          return t5[0] = n6, t5[1] = r8, t5[2] = 0, t5[3] = -r8, t5[4] = n6, t5[5] = 0, t5[6] = 0, t5[7] = 0, t5[8] = 1, t5;
        }, t4.bN = function(t5, e6, r8) {
          var n6 = e6[0], i6 = e6[1], s4 = e6[2];
          return t5[0] = n6 * r8[0] + i6 * r8[3] + s4 * r8[6], t5[1] = n6 * r8[1] + i6 * r8[4] + s4 * r8[7], t5[2] = n6 * r8[2] + i6 * r8[5] + s4 * r8[8], t5;
        }, t4.bO = function(t5, e6, r8, n6, i6, s4, a4) {
          var o6 = 1 / (e6 - r8), l5 = 1 / (n6 - i6), u4 = 1 / (s4 - a4);
          return t5[0] = -2 * o6, t5[1] = 0, t5[2] = 0, t5[3] = 0, t5[4] = 0, t5[5] = -2 * l5, t5[6] = 0, t5[7] = 0, t5[8] = 0, t5[9] = 0, t5[10] = 2 * u4, t5[11] = 0, t5[12] = (e6 + r8) * o6, t5[13] = (i6 + n6) * l5, t5[14] = (a4 + s4) * u4, t5[15] = 1, t5;
        }, t4.bP = class extends Ks {
        }, t4.bQ = Bu, t4.bR = class extends Hs {
        }, t4.bS = qo, t4.bT = function(t5) {
          return t5 <= 1 ? 1 : Math.pow(2, Math.ceil(Math.log(t5) / Math.LN2));
        }, t4.bU = Uo, t4.bV = function(t5, e6, r8) {
          var n6 = e6[0], i6 = e6[1], s4 = e6[2], a4 = r8[3] * n6 + r8[7] * i6 + r8[11] * s4 + r8[15];
          return t5[0] = (r8[0] * n6 + r8[4] * i6 + r8[8] * s4 + r8[12]) / (a4 = a4 || 1), t5[1] = (r8[1] * n6 + r8[5] * i6 + r8[9] * s4 + r8[13]) / a4, t5[2] = (r8[2] * n6 + r8[6] * i6 + r8[10] * s4 + r8[14]) / a4, t5;
        }, t4.bW = class extends Ls {
        }, t4.bX = class extends ra {
        }, t4.bY = function(t5, e6) {
          return t5[0] === e6[0] && t5[1] === e6[1] && t5[2] === e6[2] && t5[3] === e6[3] && t5[4] === e6[4] && t5[5] === e6[5] && t5[6] === e6[6] && t5[7] === e6[7] && t5[8] === e6[8] && t5[9] === e6[9] && t5[10] === e6[10] && t5[11] === e6[11] && t5[12] === e6[12] && t5[13] === e6[13] && t5[14] === e6[14] && t5[15] === e6[15];
        }, t4.bZ = function(t5, e6) {
          var r8 = t5[0], n6 = t5[1], i6 = t5[2], s4 = t5[3], a4 = t5[4], o6 = t5[5], l5 = t5[6], u4 = t5[7], c5 = t5[8], h4 = t5[9], p4 = t5[10], f4 = t5[11], d4 = t5[12], y4 = t5[13], g4 = t5[14], x4 = t5[15], v4 = e6[0], b5 = e6[1], w4 = e6[2], _4 = e6[3], S5 = e6[4], A5 = e6[5], k4 = e6[6], M5 = e6[7], I4 = e6[8], z4 = e6[9], P4 = e6[10], C4 = e6[11], B5 = e6[12], V3 = e6[13], E4 = e6[14], T5 = e6[15];
          return Math.abs(r8 - v4) <= m3 * Math.max(1, Math.abs(r8), Math.abs(v4)) && Math.abs(n6 - b5) <= m3 * Math.max(1, Math.abs(n6), Math.abs(b5)) && Math.abs(i6 - w4) <= m3 * Math.max(1, Math.abs(i6), Math.abs(w4)) && Math.abs(s4 - _4) <= m3 * Math.max(1, Math.abs(s4), Math.abs(_4)) && Math.abs(a4 - S5) <= m3 * Math.max(1, Math.abs(a4), Math.abs(S5)) && Math.abs(o6 - A5) <= m3 * Math.max(1, Math.abs(o6), Math.abs(A5)) && Math.abs(l5 - k4) <= m3 * Math.max(1, Math.abs(l5), Math.abs(k4)) && Math.abs(u4 - M5) <= m3 * Math.max(1, Math.abs(u4), Math.abs(M5)) && Math.abs(c5 - I4) <= m3 * Math.max(1, Math.abs(c5), Math.abs(I4)) && Math.abs(h4 - z4) <= m3 * Math.max(1, Math.abs(h4), Math.abs(z4)) && Math.abs(p4 - P4) <= m3 * Math.max(1, Math.abs(p4), Math.abs(P4)) && Math.abs(f4 - C4) <= m3 * Math.max(1, Math.abs(f4), Math.abs(C4)) && Math.abs(d4 - B5) <= m3 * Math.max(1, Math.abs(d4), Math.abs(B5)) && Math.abs(y4 - V3) <= m3 * Math.max(1, Math.abs(y4), Math.abs(V3)) && Math.abs(g4 - E4) <= m3 * Math.max(1, Math.abs(g4), Math.abs(E4)) && Math.abs(x4 - T5) <= m3 * Math.max(1, Math.abs(x4), Math.abs(T5));
        }, t4.b_ = function(t5, e6) {
          return t5[0] = e6[0], t5[1] = e6[1], t5[2] = e6[2], t5[3] = e6[3], t5[4] = e6[4], t5[5] = e6[5], t5[6] = e6[6], t5[7] = e6[7], t5[8] = e6[8], t5[9] = e6[9], t5[10] = e6[10], t5[11] = e6[11], t5[12] = e6[12], t5[13] = e6[13], t5[14] = e6[14], t5[15] = e6[15], t5;
        }, t4.ba = Il, t4.bb = Al, t4.bc = P3, t4.bd = C3, t4.be = ze, t4.bf = function(t5, e6, r8, n6, i6) {
          return P3(n6, i6, E3((t5 - e6) / (r8 - e6), 0, 1));
        }, t4.bg = z3, t4.bh = function() {
          return new Float64Array(4);
        }, t4.bi = function() {
          return new Float64Array(3);
        }, t4.bj = function(t5, e6, r8, n6) {
          var i6 = [], s4 = [];
          return i6[0] = e6[0] - r8[0], i6[1] = e6[1] - r8[1], i6[2] = e6[2] - r8[2], s4[0] = i6[0] * Math.cos(n6) - i6[1] * Math.sin(n6), s4[1] = i6[0] * Math.sin(n6) + i6[1] * Math.cos(n6), s4[2] = i6[2], t5[0] = s4[0] + r8[0], t5[1] = s4[1] + r8[1], t5[2] = s4[2] + r8[2], t5;
        }, t4.bk = function(t5, e6, r8, n6) {
          var i6 = [], s4 = [];
          return i6[0] = e6[0] - r8[0], i6[1] = e6[1] - r8[1], i6[2] = e6[2] - r8[2], s4[0] = i6[0], s4[1] = i6[1] * Math.cos(n6) - i6[2] * Math.sin(n6), s4[2] = i6[1] * Math.sin(n6) + i6[2] * Math.cos(n6), t5[0] = s4[0] + r8[0], t5[1] = s4[1] + r8[1], t5[2] = s4[2] + r8[2], t5;
        }, t4.bl = function(t5, e6, r8, n6) {
          var i6 = [], s4 = [];
          return i6[0] = e6[0] - r8[0], i6[1] = e6[1] - r8[1], i6[2] = e6[2] - r8[2], s4[0] = i6[2] * Math.sin(n6) + i6[0] * Math.cos(n6), s4[1] = i6[1], s4[2] = i6[2] * Math.cos(n6) - i6[0] * Math.sin(n6), t5[0] = s4[0] + r8[0], t5[1] = s4[1] + r8[1], t5[2] = s4[2] + r8[2], t5;
        }, t4.bm = function(t5, e6, r8) {
          var n6 = Math.sin(r8), i6 = Math.cos(r8), s4 = e6[0], a4 = e6[1], o6 = e6[2], l5 = e6[3], u4 = e6[8], c5 = e6[9], h4 = e6[10], p4 = e6[11];
          return e6 !== t5 && (t5[4] = e6[4], t5[5] = e6[5], t5[6] = e6[6], t5[7] = e6[7], t5[12] = e6[12], t5[13] = e6[13], t5[14] = e6[14], t5[15] = e6[15]), t5[0] = s4 * i6 - u4 * n6, t5[1] = a4 * i6 - c5 * n6, t5[2] = o6 * i6 - h4 * n6, t5[3] = l5 * i6 - p4 * n6, t5[8] = s4 * n6 + u4 * i6, t5[9] = a4 * n6 + c5 * i6, t5[10] = o6 * n6 + h4 * i6, t5[11] = l5 * n6 + p4 * i6, t5;
        }, t4.bn = function(t5, e6) {
          const r8 = z3(t5, 360), n6 = z3(e6, 360), i6 = n6 - r8, s4 = n6 > r8 ? i6 - 360 : i6 + 360;
          return Math.abs(i6) < Math.abs(s4) ? i6 : s4;
        }, t4.bo = function(t5) {
          return t5[0] = 0, t5[1] = 0, t5[2] = 0, t5;
        }, t4.bp = function(t5, e6, r8, n6) {
          const i6 = Math.sqrt(t5 * t5 + e6 * e6), s4 = Math.sqrt(r8 * r8 + n6 * n6);
          t5 /= i6, e6 /= i6, r8 /= s4, n6 /= s4;
          const a4 = Math.acos(t5 * r8 + e6 * n6);
          return -e6 * r8 + t5 * n6 > 0 ? a4 : -a4;
        }, t4.bq = function(t5, e6) {
          return t5[0] * e6[0] + t5[1] * e6[1] + t5[2] * e6[2] + t5[3];
        }, t4.br = Xc, t4.bs = function(t5, e6) {
          const r8 = z3(t5, 2 * Math.PI), n6 = z3(e6, 2 * Math.PI);
          return Math.min(Math.abs(r8 - n6), Math.abs(r8 - n6 + 2 * Math.PI), Math.abs(r8 - n6 - 2 * Math.PI));
        }, t4.bt = function(t5) {
          return Math.hypot(t5[0], t5[1], t5[2]);
        }, t4.bu = function() {
          const t5 = {}, e6 = dt.$version;
          for (const r8 in dt.$root) {
            const n6 = dt.$root[r8];
            if (n6.required) {
              let i6 = null;
              i6 = "version" === r8 ? e6 : "array" === n6.type ? [] : {}, null != i6 && (t5[r8] = i6);
            }
          }
          return t5;
        }, t4.bv = Wi, t4.bw = at, t4.bx = function(t5) {
          t5 = t5.slice();
          const e6 = /* @__PURE__ */ Object.create(null);
          for (let r8 = 0; r8 < t5.length; r8++) e6[t5[r8].id] = t5[r8];
          for (let r8 = 0; r8 < t5.length; r8++) "ref" in t5[r8] && (t5[r8] = mt(t5[r8], e6[t5[r8].ref]));
          return t5;
        }, t4.by = function(t5) {
          if ("custom" === t5.type) return new Gc(t5);
          switch (t5.type) {
            case "background":
              return new jc(t5);
            case "circle":
              return new Eo(t5);
            case "fill":
              return new Ol(t5);
            case "fill-extrusion":
              return new uu(t5);
            case "heatmap":
              return new Go(t5);
            case "hillshade":
              return new Xo(t5);
            case "line":
              return new ku(t5);
            case "raster":
              return new qc(t5);
            case "symbol":
              return new Oc(t5);
          }
        }, t4.bz = D2, t4.c = et2, t4.c0 = (t5) => "circle" === t5.type, t4.c1 = (t5) => "heatmap" === t5.type, t4.c2 = (t5) => "line" === t5.type, t4.c3 = (t5) => "fill" === t5.type, t4.c4 = (t5) => "fill-extrusion" === t5.type, t4.c5 = (t5) => "hillshade" === t5.type, t4.c6 = (t5) => "raster" === t5.type, t4.c7 = (t5) => "background" === t5.type, t4.c8 = (t5) => "custom" === t5.type, t4.c9 = B4, t4.cA = class {
          constructor(t5) {
            this._marks = { start: [t5.url, "start"].join("#"), end: [t5.url, "end"].join("#"), measure: t5.url.toString() }, performance.mark(this._marks.start);
          }
          finish() {
            performance.mark(this._marks.end);
            let t5 = performance.getEntriesByName(this._marks.measure);
            return 0 === t5.length && (performance.measure(this._marks.measure, this._marks.start, this._marks.end), t5 = performance.getEntriesByName(this._marks.measure), performance.clearMarks(this._marks.start), performance.clearMarks(this._marks.end), performance.clearMeasures(this._marks.measure)), t5;
          }
        }, t4.cB = function(t5, r8, n6, i6, s4) {
          return e5(this, void 0, void 0, function* () {
            if (d3()) try {
              return yield K2(t5, r8, n6, i6, s4);
            } catch (t6) {
            }
            return function(t6, e6, r9, n7, i7) {
              const s5 = t6.width, a4 = t6.height;
              X2 && H4 || (X2 = new OffscreenCanvas(s5, a4), H4 = X2.getContext("2d", { willReadFrequently: true })), X2.width = s5, X2.height = a4, H4.drawImage(t6, 0, 0, s5, a4);
              const o6 = H4.getImageData(e6, r9, n7, i7);
              return H4.clearRect(0, 0, s5, a4), o6.data;
            }(t5, r8, n6, i6, s4);
          });
        }, t4.cC = uh, t4.cD = r7, t4.cE = s3, t4.cF = Wl, t4.cG = Ru, t4.cH = Gn, t4.cI = ps, t4.ca = function(t5, e6, r8) {
          const n6 = k3(e6.x - r8.x, e6.y - r8.y), i6 = k3(t5.x - r8.x, t5.y - r8.y);
          var s4, a4;
          return J2(Math.atan2(n6[0] * i6[1] - n6[1] * i6[0], (s4 = n6)[0] * (a4 = i6)[0] + s4[1] * a4[1]));
        }, t4.cb = V2, t4.cc = function(t5, e6) {
          return Q2[e6] && (t5 instanceof MouseEvent || t5 instanceof WheelEvent);
        }, t4.cd = function(t5, e6) {
          return W[e6] && "touches" in t5;
        }, t4.ce = function(t5) {
          return W[t5] || Q2[t5];
        }, t4.cf = function(t5, e6, r8) {
          var n6 = e6[0], i6 = e6[1];
          return t5[0] = r8[0] * n6 + r8[4] * i6 + r8[12], t5[1] = r8[1] * n6 + r8[5] * i6 + r8[13], t5;
        }, t4.cg = function(t5, e6) {
          const { x: r8, y: n6 } = nh.fromLngLat(e6);
          return !(t5 < 0 || t5 > 25 || n6 < 0 || n6 >= 1 || r8 < 0 || r8 >= 1);
        }, t4.ch = function(t5, e6) {
          return t5[0] = e6[0], t5[1] = 0, t5[2] = 0, t5[3] = 0, t5[4] = 0, t5[5] = e6[1], t5[6] = 0, t5[7] = 0, t5[8] = 0, t5[9] = 0, t5[10] = e6[2], t5[11] = 0, t5[12] = 0, t5[13] = 0, t5[14] = 0, t5[15] = 1, t5;
        }, t4.ci = class extends $s {
        }, t4.cj = sp, t4.cl = function(t5) {
          return t5.message === tt;
        }, t4.cm = st, t4.cn = function(t5, e6) {
          rt.REGISTERED_PROTOCOLS[t5] = e6;
        }, t4.co = function(t5) {
          delete rt.REGISTERED_PROTOCOLS[t5];
        }, t4.cp = function(t5, e6) {
          const r8 = {};
          for (let n7 = 0; n7 < t5.length; n7++) {
            const i6 = e6 && e6[t5[n7].id] || li(t5[n7]);
            e6 && (e6[t5[n7].id] = i6);
            let s4 = r8[i6];
            s4 || (s4 = r8[i6] = []), s4.push(t5[n7]);
          }
          const n6 = [];
          for (const t6 in r8) n6.push(r8[t6]);
          return n6;
        }, t4.cq = Zi, t4.cr = ch, t4.cs = ph, t4.ct = Yu, t4.cu = function(e6) {
          e6.bucket.createArrays(), e6.bucket.tilePixelRatio = M4 / (512 * e6.bucket.overscaling), e6.bucket.compareText = {}, e6.bucket.iconsNeedLinear = false;
          const r8 = e6.bucket.layers[0], n6 = r8.layout, i6 = r8._unevaluatedLayout._values, s4 = { layoutIconSize: i6["icon-size"].possiblyEvaluate(new fs(e6.bucket.zoom + 1), e6.canonical), layoutTextSize: i6["text-size"].possiblyEvaluate(new fs(e6.bucket.zoom + 1), e6.canonical), textMaxSize: i6["text-size"].possiblyEvaluate(new fs(18)) };
          if ("composite" === e6.bucket.textSizeData.kind) {
            const { minZoom: t5, maxZoom: r9 } = e6.bucket.textSizeData;
            s4.compositeTextSizes = [i6["text-size"].possiblyEvaluate(new fs(t5), e6.canonical), i6["text-size"].possiblyEvaluate(new fs(r9), e6.canonical)];
          }
          if ("composite" === e6.bucket.iconSizeData.kind) {
            const { minZoom: t5, maxZoom: r9 } = e6.bucket.iconSizeData;
            s4.compositeIconSizes = [i6["icon-size"].possiblyEvaluate(new fs(t5), e6.canonical), i6["icon-size"].possiblyEvaluate(new fs(r9), e6.canonical)];
          }
          const a4 = n6.get("text-line-height") * Lu, o6 = "viewport" !== n6.get("text-rotation-alignment") && "point" !== n6.get("symbol-placement"), l5 = n6.get("text-keep-upright"), u4 = n6.get("text-size");
          for (const i7 of e6.bucket.features) {
            const c5 = n6.get("text-font").evaluate(i7, {}, e6.canonical).join(","), h4 = u4.evaluate(i7, {}, e6.canonical), p4 = s4.layoutTextSize.evaluate(i7, {}, e6.canonical), f4 = s4.layoutIconSize.evaluate(i7, {}, e6.canonical), d4 = { horizontal: {}, vertical: void 0 }, y4 = i7.text;
            let m4, g4 = [0, 0];
            if (y4) {
              const s5 = y4.toString(), u5 = n6.get("text-letter-spacing").evaluate(i7, {}, e6.canonical) * Lu, f5 = es(s5) ? u5 : 0, m5 = n6.get("text-anchor").evaluate(i7, {}, e6.canonical), x5 = Rh(r8, i7, e6.canonical);
              if (!x5) {
                const t5 = n6.get("text-radial-offset").evaluate(i7, {}, e6.canonical);
                g4 = t5 ? Dh(m5, [t5 * Lu, Oh]) : n6.get("text-offset").evaluate(i7, {}, e6.canonical).map((t6) => t6 * Lu);
              }
              let v5 = o6 ? "center" : n6.get("text-justify").evaluate(i7, {}, e6.canonical);
              const b5 = "point" === n6.get("symbol-placement") ? n6.get("text-max-width").evaluate(i7, {}, e6.canonical) * Lu : 1 / 0, w4 = () => {
                e6.bucket.allowVerticalPlacement && ts(s5) && (d4.vertical = ec2(y4, e6.glyphMap, e6.glyphPositions, e6.imagePositions, c5, b5, a4, m5, "left", f5, g4, t4.ah.vertical, true, p4, h4));
              };
              if (!o6 && x5) {
                const r9 = /* @__PURE__ */ new Set();
                if ("auto" === v5) for (let t5 = 0; t5 < x5.values.length; t5 += 2) r9.add(jh(x5.values[t5]));
                else r9.add(v5);
                let n7 = false;
                for (const i8 of r9) if (!d4.horizontal[i8]) if (n7) d4.horizontal[i8] = d4.horizontal[0];
                else {
                  const r10 = ec2(y4, e6.glyphMap, e6.glyphPositions, e6.imagePositions, c5, b5, a4, "center", i8, f5, g4, t4.ah.horizontal, false, p4, h4);
                  r10 && (d4.horizontal[i8] = r10, n7 = 1 === r10.positionedLines.length);
                }
                w4();
              } else {
                "auto" === v5 && (v5 = jh(m5));
                const r9 = ec2(y4, e6.glyphMap, e6.glyphPositions, e6.imagePositions, c5, b5, a4, m5, v5, f5, g4, t4.ah.horizontal, false, p4, h4);
                r9 && (d4.horizontal[v5] = r9), w4(), ts(s5) && o6 && l5 && (d4.vertical = ec2(y4, e6.glyphMap, e6.glyphPositions, e6.imagePositions, c5, b5, a4, m5, v5, f5, g4, t4.ah.vertical, false, p4, h4));
              }
            }
            let x4 = false;
            if (i7.icon && i7.icon.name) {
              const t5 = e6.imageMap[i7.icon.name];
              t5 && (m4 = xc(e6.imagePositions[i7.icon.name], n6.get("icon-offset").evaluate(i7, {}, e6.canonical), n6.get("icon-anchor").evaluate(i7, {}, e6.canonical)), x4 = !!t5.sdf, void 0 === e6.bucket.sdfIcons ? e6.bucket.sdfIcons = x4 : e6.bucket.sdfIcons !== x4 && j3("Style sheet warning: Cannot mix SDF and non-SDF icons in one buffer"), (t5.pixelRatio !== e6.bucket.pixelRatio || 0 !== n6.get("icon-rotate").constantOr(1)) && (e6.bucket.iconsNeedLinear = true));
            }
            const v4 = qh(d4.horizontal) || d4.vertical;
            e6.bucket.iconsInText = !!v4 && v4.iconsInText, (v4 || m4) && Nh(e6.bucket, i7, d4, m4, e6.imageMap, s4, p4, f4, g4, x4, e6.canonical, e6.subdivisionGranularity);
          }
          e6.showCollisionBoxes && e6.bucket.generateCollisionDebugBuffers();
        }, t4.cv = vu, t4.cw = Tl, t4.cx = nu, t4.cy = Ql, t4.cz = ju, t4.d = lt, t4.e = F2, t4.f = (t5) => e5(void 0, void 0, void 0, function* () {
          if (0 === t5.byteLength) return createImageBitmap(new ImageData(1, 1));
          const e6 = new Blob([new Uint8Array(t5)], { type: "image/png" });
          try {
            return createImageBitmap(e6);
          } catch (t6) {
            throw new Error(`Could not load image because of ${t6.message}. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported.`);
          }
        }), t4.g = nt, t4.h = (t5) => new Promise((e6, r8) => {
          const n6 = new Image();
          n6.onload = () => {
            e6(n6), URL.revokeObjectURL(n6.src), n6.onload = null, window.requestAnimationFrame(() => {
              n6.src = Z2;
            });
          }, n6.onerror = () => r8(new Error("Could not load image. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported."));
          const i6 = new Blob([new Uint8Array(t5)], { type: "image/png" });
          n6.src = t5.byteLength ? URL.createObjectURL(i6) : Z2;
        }), t4.i = U3, t4.j = (t5, e6) => ot(F2(t5, { type: "json" }), e6), t4.k = pt, t4.l = ht, t4.m = ot, t4.n = (t5, e6) => ot(F2(t5, { type: "arrayBuffer" }), e6), t4.o = function(t5) {
          return new ju(t5).readFields(Uu, []);
        }, t4.p = Ku, t4.q = jo, t4.r = Is, t4.s = Y2, t4.t = Di, t4.u = Qi, t4.v = dt, t4.w = j3, t4.x = Ui, t4.y = Oi, t4.z = function([t5, e6, r8]) {
          return e6 += 90, e6 *= Math.PI / 180, r8 *= Math.PI / 180, { x: t5 * Math.cos(e6) * Math.sin(r8), y: t5 * Math.sin(e6) * Math.sin(r8), z: t5 * Math.cos(r8) };
        };
      });
      define2("worker", ["./shared"], function(e5) {
        "use strict";
        class t4 {
          constructor(e6) {
            this.keyCache = {}, e6 && this.replace(e6);
          }
          replace(e6) {
            this._layerConfigs = {}, this._layers = {}, this.update(e6, []);
          }
          update(t5, o6) {
            for (const o7 of t5) {
              this._layerConfigs[o7.id] = o7;
              const t6 = this._layers[o7.id] = e5.by(o7);
              t6._featureFilter = e5.a7(t6.filter), this.keyCache[o7.id] && delete this.keyCache[o7.id];
            }
            for (const e6 of o6) delete this.keyCache[e6], delete this._layerConfigs[e6], delete this._layers[e6];
            this.familiesBySource = {};
            const i6 = e5.cp(Object.values(this._layerConfigs), this.keyCache);
            for (const e6 of i6) {
              const t6 = e6.map((e7) => this._layers[e7.id]), o7 = t6[0];
              if ("none" === o7.visibility) continue;
              const i7 = o7.source || "";
              let r8 = this.familiesBySource[i7];
              r8 || (r8 = this.familiesBySource[i7] = {});
              const s4 = o7.sourceLayer || "_geojsonTileLayer";
              let n6 = r8[s4];
              n6 || (n6 = r8[s4] = []), n6.push(t6);
            }
          }
        }
        class o5 {
          constructor(t5) {
            const o6 = {}, i6 = [];
            for (const e6 in t5) {
              const r9 = t5[e6], s5 = o6[e6] = {};
              for (const e7 in r9) {
                const t6 = r9[+e7];
                if (!t6 || 0 === t6.bitmap.width || 0 === t6.bitmap.height) continue;
                const o7 = { x: 0, y: 0, w: t6.bitmap.width + 2, h: t6.bitmap.height + 2 };
                i6.push(o7), s5[e7] = { rect: o7, metrics: t6.metrics };
              }
            }
            const { w: r8, h: s4 } = e5.p(i6), n6 = new e5.q({ width: r8 || 1, height: s4 || 1 });
            for (const i7 in t5) {
              const r9 = t5[i7];
              for (const t6 in r9) {
                const s5 = r9[+t6];
                if (!s5 || 0 === s5.bitmap.width || 0 === s5.bitmap.height) continue;
                const a4 = o6[i7][t6].rect;
                e5.q.copy(s5.bitmap, n6, { x: 0, y: 0 }, { x: a4.x + 1, y: a4.y + 1 }, s5.bitmap);
              }
            }
            this.image = n6, this.positions = o6;
          }
        }
        e5.cq("GlyphAtlas", o5);
        class i5 {
          constructor(t5) {
            this.tileID = new e5.Y(t5.tileID.overscaledZ, t5.tileID.wrap, t5.tileID.canonical.z, t5.tileID.canonical.x, t5.tileID.canonical.y), this.uid = t5.uid, this.zoom = t5.zoom, this.pixelRatio = t5.pixelRatio, this.tileSize = t5.tileSize, this.source = t5.source, this.overscaling = this.tileID.overscaleFactor(), this.showCollisionBoxes = t5.showCollisionBoxes, this.collectResourceTiming = !!t5.collectResourceTiming, this.returnDependencies = !!t5.returnDependencies, this.promoteId = t5.promoteId, this.inFlightDependencies = [];
          }
          parse(t5, i6, s4, n6, a4) {
            return e5._(this, void 0, void 0, function* () {
              this.status = "parsing", this.data = t5, this.collisionBoxArray = new e5.a5();
              const l5 = new e5.cr(Object.keys(t5.layers).sort()), c5 = new e5.cs(this.tileID, this.promoteId);
              c5.bucketLayerIDs = [];
              const u4 = {}, h4 = { featureIndex: c5, iconDependencies: {}, patternDependencies: {}, glyphDependencies: {}, availableImages: s4, subdivisionGranularity: a4 }, d4 = i6.familiesBySource[this.source];
              for (const o6 in d4) {
                const i7 = t5.layers[o6];
                if (!i7) continue;
                1 === i7.version && e5.w(`Vector tile source "${this.source}" layer "${o6}" does not use vector tile spec v2 and therefore may have some rendering errors.`);
                const n7 = l5.encode(o6), a5 = [];
                for (let e6 = 0; e6 < i7.length; e6++) {
                  const t6 = i7.feature(e6), r8 = c5.getId(t6, o6);
                  a5.push({ feature: t6, id: r8, index: e6, sourceLayerIndex: n7 });
                }
                for (const t6 of d4[o6]) {
                  const o7 = t6[0];
                  o7.source !== this.source && e5.w(`layer.source = ${o7.source} does not equal this.source = ${this.source}`), o7.minzoom && this.zoom < Math.floor(o7.minzoom) || o7.maxzoom && this.zoom >= o7.maxzoom || "none" !== o7.visibility && (r7(t6, this.zoom, s4), (u4[o7.id] = o7.createBucket({ index: c5.bucketLayerIDs.length, layers: t6, zoom: this.zoom, pixelRatio: this.pixelRatio, overscaling: this.overscaling, collisionBoxArray: this.collisionBoxArray, sourceLayerIndex: n7, sourceID: this.source })).populate(a5, h4, this.tileID.canonical), c5.bucketLayerIDs.push(t6.map((e6) => e6.id)));
                }
              }
              const f4 = e5.bD(h4.glyphDependencies, (e6) => Object.keys(e6).map(Number));
              this.inFlightDependencies.forEach((e6) => null == e6 ? void 0 : e6.abort()), this.inFlightDependencies = [];
              let g4 = Promise.resolve({});
              if (Object.keys(f4).length) {
                const e6 = new AbortController();
                this.inFlightDependencies.push(e6), g4 = n6.sendAsync({ type: "GG", data: { stacks: f4, source: this.source, tileID: this.tileID, type: "glyphs" } }, e6);
              }
              const p4 = Object.keys(h4.iconDependencies);
              let m4 = Promise.resolve({});
              if (p4.length) {
                const e6 = new AbortController();
                this.inFlightDependencies.push(e6), m4 = n6.sendAsync({ type: "GI", data: { icons: p4, source: this.source, tileID: this.tileID, type: "icons" } }, e6);
              }
              const y4 = Object.keys(h4.patternDependencies);
              let v4 = Promise.resolve({});
              if (y4.length) {
                const e6 = new AbortController();
                this.inFlightDependencies.push(e6), v4 = n6.sendAsync({ type: "GI", data: { icons: y4, source: this.source, tileID: this.tileID, type: "patterns" } }, e6);
              }
              const [w4, x4, _4] = yield Promise.all([g4, m4, v4]), b5 = new o5(w4), M5 = new e5.ct(x4, _4);
              for (const t6 in u4) {
                const o6 = u4[t6];
                o6 instanceof e5.a6 ? (r7(o6.layers, this.zoom, s4), e5.cu({ bucket: o6, glyphMap: w4, glyphPositions: b5.positions, imageMap: x4, imagePositions: M5.iconPositions, showCollisionBoxes: this.showCollisionBoxes, canonical: this.tileID.canonical, subdivisionGranularity: h4.subdivisionGranularity })) : o6.hasPattern && (o6 instanceof e5.cv || o6 instanceof e5.cw || o6 instanceof e5.cx) && (r7(o6.layers, this.zoom, s4), o6.addFeatures(h4, this.tileID.canonical, M5.patternPositions));
              }
              return this.status = "done", { buckets: Object.values(u4).filter((e6) => !e6.isEmpty()), featureIndex: c5, collisionBoxArray: this.collisionBoxArray, glyphAtlasImage: b5.image, imageAtlas: M5, glyphMap: this.returnDependencies ? w4 : null, iconMap: this.returnDependencies ? x4 : null, glyphPositions: this.returnDependencies ? b5.positions : null };
            });
          }
        }
        function r7(t5, o6, i6) {
          const r8 = new e5.C(o6);
          for (const e6 of t5) e6.recalculate(r8, i6);
        }
        class s3 {
          constructor(e6, t5, o6) {
            this.actor = e6, this.layerIndex = t5, this.availableImages = o6, this.fetching = {}, this.loading = {}, this.loaded = {};
          }
          loadVectorTile(t5, o6) {
            return e5._(this, void 0, void 0, function* () {
              const i6 = yield e5.n(t5.request, o6);
              try {
                return { vectorTile: new e5.cy.VectorTile(new e5.cz(i6.data)), rawData: i6.data, cacheControl: i6.cacheControl, expires: i6.expires };
              } catch (e6) {
                const o7 = new Uint8Array(i6.data);
                let r8 = `Unable to parse the tile at ${t5.request.url}, `;
                throw r8 += 31 === o7[0] && 139 === o7[1] ? "please make sure the data is not gzipped and that you have configured the relevant header in the server" : `got error: ${e6.message}`, new Error(r8);
              }
            });
          }
          loadTile(t5) {
            return e5._(this, void 0, void 0, function* () {
              const o6 = t5.uid, r8 = !!(t5 && t5.request && t5.request.collectResourceTiming) && new e5.cA(t5.request), s4 = new i5(t5);
              this.loading[o6] = s4;
              const n6 = new AbortController();
              s4.abort = n6;
              try {
                const i6 = yield this.loadVectorTile(t5, n6);
                if (delete this.loading[o6], !i6) return null;
                const a4 = i6.rawData, l5 = {};
                i6.expires && (l5.expires = i6.expires), i6.cacheControl && (l5.cacheControl = i6.cacheControl);
                const c5 = {};
                if (r8) {
                  const e6 = r8.finish();
                  e6 && (c5.resourceTiming = JSON.parse(JSON.stringify(e6)));
                }
                s4.vectorTile = i6.vectorTile;
                const u4 = s4.parse(i6.vectorTile, this.layerIndex, this.availableImages, this.actor, t5.subdivisionGranularity);
                this.loaded[o6] = s4, this.fetching[o6] = { rawTileData: a4, cacheControl: l5, resourceTiming: c5 };
                try {
                  const t6 = yield u4;
                  return e5.e({ rawTileData: a4.slice(0) }, t6, l5, c5);
                } finally {
                  delete this.fetching[o6];
                }
              } catch (e6) {
                throw delete this.loading[o6], s4.status = "done", this.loaded[o6] = s4, e6;
              }
            });
          }
          reloadTile(t5) {
            return e5._(this, void 0, void 0, function* () {
              const o6 = t5.uid;
              if (!this.loaded || !this.loaded[o6]) throw new Error("Should not be trying to reload a tile that was never loaded or has been removed");
              const i6 = this.loaded[o6];
              if (i6.showCollisionBoxes = t5.showCollisionBoxes, "parsing" === i6.status) {
                const r8 = yield i6.parse(i6.vectorTile, this.layerIndex, this.availableImages, this.actor, t5.subdivisionGranularity);
                let s4;
                if (this.fetching[o6]) {
                  const { rawTileData: t6, cacheControl: i7, resourceTiming: n6 } = this.fetching[o6];
                  delete this.fetching[o6], s4 = e5.e({ rawTileData: t6.slice(0) }, r8, i7, n6);
                } else s4 = r8;
                return s4;
              }
              if ("done" === i6.status && i6.vectorTile) return i6.parse(i6.vectorTile, this.layerIndex, this.availableImages, this.actor, t5.subdivisionGranularity);
            });
          }
          abortTile(t5) {
            return e5._(this, void 0, void 0, function* () {
              const e6 = this.loading, o6 = t5.uid;
              e6 && e6[o6] && e6[o6].abort && (e6[o6].abort.abort(), delete e6[o6]);
            });
          }
          removeTile(t5) {
            return e5._(this, void 0, void 0, function* () {
              this.loaded && this.loaded[t5.uid] && delete this.loaded[t5.uid];
            });
          }
        }
        class n5 {
          constructor() {
            this.loaded = {};
          }
          loadTile(t5) {
            return e5._(this, void 0, void 0, function* () {
              const { uid: o6, encoding: i6, rawImageData: r8, redFactor: s4, greenFactor: n6, blueFactor: a4, baseShift: l5 } = t5, c5 = r8.width + 2, u4 = r8.height + 2, h4 = e5.b(r8) ? new e5.R({ width: c5, height: u4 }, yield e5.cB(r8, -1, -1, c5, u4)) : r8, d4 = new e5.cC(o6, h4, i6, s4, n6, a4, l5);
              return this.loaded = this.loaded || {}, this.loaded[o6] = d4, d4;
            });
          }
          removeTile(e6) {
            const t5 = this.loaded, o6 = e6.uid;
            t5 && t5[o6] && delete t5[o6];
          }
        }
        var a3, l4, c4 = function() {
          if (l4) return a3;
          function e6(e7, o6) {
            if (0 !== e7.length) {
              t5(e7[0], o6);
              for (var i6 = 1; i6 < e7.length; i6++) t5(e7[i6], !o6);
            }
          }
          function t5(e7, t6) {
            for (var o6 = 0, i6 = 0, r8 = 0, s4 = e7.length, n6 = s4 - 1; r8 < s4; n6 = r8++) {
              var a4 = (e7[r8][0] - e7[n6][0]) * (e7[n6][1] + e7[r8][1]), l5 = o6 + a4;
              i6 += Math.abs(o6) >= Math.abs(a4) ? o6 - l5 + a4 : a4 - l5 + o6, o6 = l5;
            }
            o6 + i6 >= 0 != !!t6 && e7.reverse();
          }
          return l4 = 1, a3 = function t6(o6, i6) {
            var r8, s4 = o6 && o6.type;
            if ("FeatureCollection" === s4) for (r8 = 0; r8 < o6.features.length; r8++) t6(o6.features[r8], i6);
            else if ("GeometryCollection" === s4) for (r8 = 0; r8 < o6.geometries.length; r8++) t6(o6.geometries[r8], i6);
            else if ("Feature" === s4) t6(o6.geometry, i6);
            else if ("Polygon" === s4) e6(o6.coordinates, i6);
            else if ("MultiPolygon" === s4) for (r8 = 0; r8 < o6.coordinates.length; r8++) e6(o6.coordinates[r8], i6);
            return o6;
          };
        }(), u3 = e5.cD(c4);
        const h3 = e5.cy.VectorTileFeature.prototype.toGeoJSON;
        class d3 {
          constructor(t5) {
            this._feature = t5, this.extent = e5.Z, this.type = t5.type, this.properties = t5.tags, "id" in t5 && !isNaN(t5.id) && (this.id = parseInt(t5.id, 10));
          }
          loadGeometry() {
            if (1 === this._feature.type) {
              const t5 = [];
              for (const o6 of this._feature.geometry) t5.push([new e5.P(o6[0], o6[1])]);
              return t5;
            }
            {
              const t5 = [];
              for (const o6 of this._feature.geometry) {
                const i6 = [];
                for (const t6 of o6) i6.push(new e5.P(t6[0], t6[1]));
                t5.push(i6);
              }
              return t5;
            }
          }
          toGeoJSON(e6, t5, o6) {
            return h3.call(this, e6, t5, o6);
          }
        }
        class f3 {
          constructor(t5) {
            this.layers = { _geojsonTileLayer: this }, this.name = "_geojsonTileLayer", this.extent = e5.Z, this.length = t5.length, this._features = t5;
          }
          feature(e6) {
            return new d3(this._features[e6]);
          }
        }
        var g3, p3, m3, y3 = { exports: {} }, v3 = function() {
          if (m3) return y3.exports;
          m3 = 1;
          var t5 = e5.cG(), o6 = function() {
            if (p3) return g3;
            p3 = 1;
            var t6 = e5.cE(), o7 = e5.cF().VectorTileFeature;
            function i7(e6, t7) {
              this.options = t7 || {}, this.features = e6, this.length = e6.length;
            }
            function r9(e6, t7) {
              this.id = "number" == typeof e6.id ? e6.id : void 0, this.type = e6.type, this.rawGeometry = 1 === e6.type ? [e6.geometry] : e6.geometry, this.properties = e6.tags, this.extent = t7 || 4096;
            }
            return g3 = i7, i7.prototype.feature = function(e6) {
              return new r9(this.features[e6], this.options.extent);
            }, r9.prototype.loadGeometry = function() {
              var e6 = this.rawGeometry;
              this.geometry = [];
              for (var o8 = 0; o8 < e6.length; o8++) {
                for (var i8 = e6[o8], r10 = [], s5 = 0; s5 < i8.length; s5++) r10.push(new t6(i8[s5][0], i8[s5][1]));
                this.geometry.push(r10);
              }
              return this.geometry;
            }, r9.prototype.bbox = function() {
              this.geometry || this.loadGeometry();
              for (var e6 = this.geometry, t7 = 1 / 0, o8 = -1 / 0, i8 = 1 / 0, r10 = -1 / 0, s5 = 0; s5 < e6.length; s5++) for (var n7 = e6[s5], a5 = 0; a5 < n7.length; a5++) {
                var l6 = n7[a5];
                t7 = Math.min(t7, l6.x), o8 = Math.max(o8, l6.x), i8 = Math.min(i8, l6.y), r10 = Math.max(r10, l6.y);
              }
              return [t7, i8, o8, r10];
            }, r9.prototype.toGeoJSON = o7.prototype.toGeoJSON, g3;
          }();
          function i6(e6) {
            var o7 = new t5();
            return function(e7, t6) {
              for (var o8 in e7.layers) t6.writeMessage(3, r8, e7.layers[o8]);
            }(e6, o7), o7.finish();
          }
          function r8(e6, t6) {
            var o7;
            t6.writeVarintField(15, e6.version || 1), t6.writeStringField(1, e6.name || ""), t6.writeVarintField(5, e6.extent || 4096);
            var i7 = { keys: [], values: [], keycache: {}, valuecache: {} };
            for (o7 = 0; o7 < e6.length; o7++) i7.feature = e6.feature(o7), t6.writeMessage(2, s4, i7);
            var r9 = i7.keys;
            for (o7 = 0; o7 < r9.length; o7++) t6.writeStringField(3, r9[o7]);
            var n7 = i7.values;
            for (o7 = 0; o7 < n7.length; o7++) t6.writeMessage(4, u4, n7[o7]);
          }
          function s4(e6, t6) {
            var o7 = e6.feature;
            void 0 !== o7.id && t6.writeVarintField(1, o7.id), t6.writeMessage(2, n6, e6), t6.writeVarintField(3, o7.type), t6.writeMessage(4, c5, o7);
          }
          function n6(e6, t6) {
            var o7 = e6.feature, i7 = e6.keys, r9 = e6.values, s5 = e6.keycache, n7 = e6.valuecache;
            for (var a5 in o7.properties) {
              var l6 = o7.properties[a5], c6 = s5[a5];
              if (null !== l6) {
                void 0 === c6 && (i7.push(a5), s5[a5] = c6 = i7.length - 1), t6.writeVarint(c6);
                var u5 = typeof l6;
                "string" !== u5 && "boolean" !== u5 && "number" !== u5 && (l6 = JSON.stringify(l6));
                var h4 = u5 + ":" + l6, d4 = n7[h4];
                void 0 === d4 && (r9.push(l6), n7[h4] = d4 = r9.length - 1), t6.writeVarint(d4);
              }
            }
          }
          function a4(e6, t6) {
            return (t6 << 3) + (7 & e6);
          }
          function l5(e6) {
            return e6 << 1 ^ e6 >> 31;
          }
          function c5(e6, t6) {
            for (var o7 = e6.loadGeometry(), i7 = e6.type, r9 = 0, s5 = 0, n7 = o7.length, c6 = 0; c6 < n7; c6++) {
              var u5 = o7[c6], h4 = 1;
              1 === i7 && (h4 = u5.length), t6.writeVarint(a4(1, h4));
              for (var d4 = 3 === i7 ? u5.length - 1 : u5.length, f4 = 0; f4 < d4; f4++) {
                1 === f4 && 1 !== i7 && t6.writeVarint(a4(2, d4 - 1));
                var g4 = u5[f4].x - r9, p4 = u5[f4].y - s5;
                t6.writeVarint(l5(g4)), t6.writeVarint(l5(p4)), r9 += g4, s5 += p4;
              }
              3 === i7 && t6.writeVarint(a4(7, 1));
            }
          }
          function u4(e6, t6) {
            var o7 = typeof e6;
            "string" === o7 ? t6.writeStringField(1, e6) : "boolean" === o7 ? t6.writeBooleanField(7, e6) : "number" === o7 && (e6 % 1 != 0 ? t6.writeDoubleField(3, e6) : e6 < 0 ? t6.writeSVarintField(6, e6) : t6.writeVarintField(5, e6));
          }
          return y3.exports = i6, y3.exports.fromVectorTileJs = i6, y3.exports.fromGeojsonVt = function(e6, t6) {
            t6 = t6 || {};
            var r9 = {};
            for (var s5 in e6) r9[s5] = new o6(e6[s5].features, t6), r9[s5].name = s5, r9[s5].version = t6.version, r9[s5].extent = t6.extent;
            return i6({ layers: r9 });
          }, y3.exports.GeoJSONWrapper = o6, y3.exports;
        }(), w3 = e5.cD(v3);
        const x3 = { minZoom: 0, maxZoom: 16, minPoints: 2, radius: 40, extent: 512, nodeSize: 64, log: false, generateId: false, reduce: null, map: (e6) => e6 }, _3 = Math.fround || (b4 = new Float32Array(1), (e6) => (b4[0] = +e6, b4[0]));
        var b4;
        const M4 = 3, S4 = 5, I3 = 6;
        class P3 {
          constructor(e6) {
            this.options = Object.assign(Object.create(x3), e6), this.trees = new Array(this.options.maxZoom + 1), this.stride = this.options.reduce ? 7 : 6, this.clusterProps = [];
          }
          load(e6) {
            const { log: t5, minZoom: o6, maxZoom: i6 } = this.options;
            t5 && console.time("total time");
            const r8 = `prepare ${e6.length} points`;
            t5 && console.time(r8), this.points = e6;
            const s4 = [];
            for (let t6 = 0; t6 < e6.length; t6++) {
              const o7 = e6[t6];
              if (!o7.geometry) continue;
              const [i7, r9] = o7.geometry.coordinates, n7 = _3(D2(i7)), a4 = _3(C3(r9));
              s4.push(n7, a4, 1 / 0, t6, -1, 1), this.options.reduce && s4.push(0);
            }
            let n6 = this.trees[i6 + 1] = this._createTree(s4);
            t5 && console.timeEnd(r8);
            for (let e7 = i6; e7 >= o6; e7--) {
              const o7 = +Date.now();
              n6 = this.trees[e7] = this._createTree(this._cluster(n6, e7)), t5 && console.log("z%d: %d clusters in %dms", e7, n6.numItems, +Date.now() - o7);
            }
            return t5 && console.timeEnd("total time"), this;
          }
          getClusters(e6, t5) {
            let o6 = ((e6[0] + 180) % 360 + 360) % 360 - 180;
            const i6 = Math.max(-90, Math.min(90, e6[1]));
            let r8 = 180 === e6[2] ? 180 : ((e6[2] + 180) % 360 + 360) % 360 - 180;
            const s4 = Math.max(-90, Math.min(90, e6[3]));
            if (e6[2] - e6[0] >= 360) o6 = -180, r8 = 180;
            else if (o6 > r8) {
              const e7 = this.getClusters([o6, i6, 180, s4], t5), n7 = this.getClusters([-180, i6, r8, s4], t5);
              return e7.concat(n7);
            }
            const n6 = this.trees[this._limitZoom(t5)], a4 = n6.range(D2(o6), C3(s4), D2(r8), C3(i6)), l5 = n6.data, c5 = [];
            for (const e7 of a4) {
              const t6 = this.stride * e7;
              c5.push(l5[t6 + S4] > 1 ? k3(l5, t6, this.clusterProps) : this.points[l5[t6 + M4]]);
            }
            return c5;
          }
          getChildren(e6) {
            const t5 = this._getOriginId(e6), o6 = this._getOriginZoom(e6), i6 = "No cluster with the specified id.", r8 = this.trees[o6];
            if (!r8) throw new Error(i6);
            const s4 = r8.data;
            if (t5 * this.stride >= s4.length) throw new Error(i6);
            const n6 = this.options.radius / (this.options.extent * Math.pow(2, o6 - 1)), a4 = r8.within(s4[t5 * this.stride], s4[t5 * this.stride + 1], n6), l5 = [];
            for (const t6 of a4) {
              const o7 = t6 * this.stride;
              s4[o7 + 4] === e6 && l5.push(s4[o7 + S4] > 1 ? k3(s4, o7, this.clusterProps) : this.points[s4[o7 + M4]]);
            }
            if (0 === l5.length) throw new Error(i6);
            return l5;
          }
          getLeaves(e6, t5, o6) {
            const i6 = [];
            return this._appendLeaves(i6, e6, t5 = t5 || 10, o6 = o6 || 0, 0), i6;
          }
          getTile(e6, t5, o6) {
            const i6 = this.trees[this._limitZoom(e6)], r8 = Math.pow(2, e6), { extent: s4, radius: n6 } = this.options, a4 = n6 / s4, l5 = (o6 - a4) / r8, c5 = (o6 + 1 + a4) / r8, u4 = { features: [] };
            return this._addTileFeatures(i6.range((t5 - a4) / r8, l5, (t5 + 1 + a4) / r8, c5), i6.data, t5, o6, r8, u4), 0 === t5 && this._addTileFeatures(i6.range(1 - a4 / r8, l5, 1, c5), i6.data, r8, o6, r8, u4), t5 === r8 - 1 && this._addTileFeatures(i6.range(0, l5, a4 / r8, c5), i6.data, -1, o6, r8, u4), u4.features.length ? u4 : null;
          }
          getClusterExpansionZoom(e6) {
            let t5 = this._getOriginZoom(e6) - 1;
            for (; t5 <= this.options.maxZoom; ) {
              const o6 = this.getChildren(e6);
              if (t5++, 1 !== o6.length) break;
              e6 = o6[0].properties.cluster_id;
            }
            return t5;
          }
          _appendLeaves(e6, t5, o6, i6, r8) {
            const s4 = this.getChildren(t5);
            for (const t6 of s4) {
              const s5 = t6.properties;
              if (s5 && s5.cluster ? r8 + s5.point_count <= i6 ? r8 += s5.point_count : r8 = this._appendLeaves(e6, s5.cluster_id, o6, i6, r8) : r8 < i6 ? r8++ : e6.push(t6), e6.length === o6) break;
            }
            return r8;
          }
          _createTree(t5) {
            const o6 = new e5.aC(t5.length / this.stride | 0, this.options.nodeSize, Float32Array);
            for (let e6 = 0; e6 < t5.length; e6 += this.stride) o6.add(t5[e6], t5[e6 + 1]);
            return o6.finish(), o6.data = t5, o6;
          }
          _addTileFeatures(e6, t5, o6, i6, r8, s4) {
            for (const n6 of e6) {
              const e7 = n6 * this.stride, a4 = t5[e7 + S4] > 1;
              let l5, c5, u4;
              if (a4) l5 = T4(t5, e7, this.clusterProps), c5 = t5[e7], u4 = t5[e7 + 1];
              else {
                const o7 = this.points[t5[e7 + M4]];
                l5 = o7.properties;
                const [i7, r9] = o7.geometry.coordinates;
                c5 = D2(i7), u4 = C3(r9);
              }
              const h4 = { type: 1, geometry: [[Math.round(this.options.extent * (c5 * r8 - o6)), Math.round(this.options.extent * (u4 * r8 - i6))]], tags: l5 };
              let d4;
              d4 = a4 || this.options.generateId ? t5[e7 + M4] : this.points[t5[e7 + M4]].id, void 0 !== d4 && (h4.id = d4), s4.features.push(h4);
            }
          }
          _limitZoom(e6) {
            return Math.max(this.options.minZoom, Math.min(Math.floor(+e6), this.options.maxZoom + 1));
          }
          _cluster(e6, t5) {
            const { radius: o6, extent: i6, reduce: r8, minPoints: s4 } = this.options, n6 = o6 / (i6 * Math.pow(2, t5)), a4 = e6.data, l5 = [], c5 = this.stride;
            for (let o7 = 0; o7 < a4.length; o7 += c5) {
              if (a4[o7 + 2] <= t5) continue;
              a4[o7 + 2] = t5;
              const i7 = a4[o7], u4 = a4[o7 + 1], h4 = e6.within(a4[o7], a4[o7 + 1], n6), d4 = a4[o7 + S4];
              let f4 = d4;
              for (const e7 of h4) {
                const o8 = e7 * c5;
                a4[o8 + 2] > t5 && (f4 += a4[o8 + S4]);
              }
              if (f4 > d4 && f4 >= s4) {
                let e7, s5 = i7 * d4, n7 = u4 * d4, g4 = -1;
                const p4 = ((o7 / c5 | 0) << 5) + (t5 + 1) + this.points.length;
                for (const i8 of h4) {
                  const l6 = i8 * c5;
                  if (a4[l6 + 2] <= t5) continue;
                  a4[l6 + 2] = t5;
                  const u5 = a4[l6 + S4];
                  s5 += a4[l6] * u5, n7 += a4[l6 + 1] * u5, a4[l6 + 4] = p4, r8 && (e7 || (e7 = this._map(a4, o7, true), g4 = this.clusterProps.length, this.clusterProps.push(e7)), r8(e7, this._map(a4, l6)));
                }
                a4[o7 + 4] = p4, l5.push(s5 / f4, n7 / f4, 1 / 0, p4, -1, f4), r8 && l5.push(g4);
              } else {
                for (let e7 = 0; e7 < c5; e7++) l5.push(a4[o7 + e7]);
                if (f4 > 1) for (const e7 of h4) {
                  const o8 = e7 * c5;
                  if (!(a4[o8 + 2] <= t5)) {
                    a4[o8 + 2] = t5;
                    for (let e8 = 0; e8 < c5; e8++) l5.push(a4[o8 + e8]);
                  }
                }
              }
            }
            return l5;
          }
          _getOriginId(e6) {
            return e6 - this.points.length >> 5;
          }
          _getOriginZoom(e6) {
            return (e6 - this.points.length) % 32;
          }
          _map(e6, t5, o6) {
            if (e6[t5 + S4] > 1) {
              const i7 = this.clusterProps[e6[t5 + I3]];
              return o6 ? Object.assign({}, i7) : i7;
            }
            const i6 = this.points[e6[t5 + M4]].properties, r8 = this.options.map(i6);
            return o6 && r8 === i6 ? Object.assign({}, r8) : r8;
          }
        }
        function k3(e6, t5, o6) {
          return { type: "Feature", id: e6[t5 + M4], properties: T4(e6, t5, o6), geometry: { type: "Point", coordinates: [(i6 = e6[t5], 360 * (i6 - 0.5)), O2(e6[t5 + 1])] } };
          var i6;
        }
        function T4(e6, t5, o6) {
          const i6 = e6[t5 + S4], r8 = i6 >= 1e4 ? `${Math.round(i6 / 1e3)}k` : i6 >= 1e3 ? Math.round(i6 / 100) / 10 + "k" : i6, s4 = e6[t5 + I3], n6 = -1 === s4 ? {} : Object.assign({}, o6[s4]);
          return Object.assign(n6, { cluster: true, cluster_id: e6[t5 + M4], point_count: i6, point_count_abbreviated: r8 });
        }
        function D2(e6) {
          return e6 / 360 + 0.5;
        }
        function C3(e6) {
          const t5 = Math.sin(e6 * Math.PI / 180), o6 = 0.5 - 0.25 * Math.log((1 + t5) / (1 - t5)) / Math.PI;
          return o6 < 0 ? 0 : o6 > 1 ? 1 : o6;
        }
        function O2(e6) {
          const t5 = (180 - 360 * e6) * Math.PI / 180;
          return 360 * Math.atan(Math.exp(t5)) / Math.PI - 90;
        }
        function L3(e6, t5, o6, i6) {
          let r8 = i6;
          const s4 = t5 + (o6 - t5 >> 1);
          let n6, a4 = o6 - t5;
          const l5 = e6[t5], c5 = e6[t5 + 1], u4 = e6[o6], h4 = e6[o6 + 1];
          for (let i7 = t5 + 3; i7 < o6; i7 += 3) {
            const t6 = F2(e6[i7], e6[i7 + 1], l5, c5, u4, h4);
            if (t6 > r8) n6 = i7, r8 = t6;
            else if (t6 === r8) {
              const e7 = Math.abs(i7 - s4);
              e7 < a4 && (n6 = i7, a4 = e7);
            }
          }
          r8 > i6 && (n6 - t5 > 3 && L3(e6, t5, n6, i6), e6[n6 + 2] = r8, o6 - n6 > 3 && L3(e6, n6, o6, i6));
        }
        function F2(e6, t5, o6, i6, r8, s4) {
          let n6 = r8 - o6, a4 = s4 - i6;
          if (0 !== n6 || 0 !== a4) {
            const l5 = ((e6 - o6) * n6 + (t5 - i6) * a4) / (n6 * n6 + a4 * a4);
            l5 > 1 ? (o6 = r8, i6 = s4) : l5 > 0 && (o6 += n6 * l5, i6 += a4 * l5);
          }
          return n6 = e6 - o6, a4 = t5 - i6, n6 * n6 + a4 * a4;
        }
        function G2(e6, t5, o6, i6) {
          const r8 = { id: null == e6 ? null : e6, type: t5, geometry: o6, tags: i6, minX: 1 / 0, minY: 1 / 0, maxX: -1 / 0, maxY: -1 / 0 };
          if ("Point" === t5 || "MultiPoint" === t5 || "LineString" === t5) z3(r8, o6);
          else if ("Polygon" === t5) z3(r8, o6[0]);
          else if ("MultiLineString" === t5) for (const e7 of o6) z3(r8, e7);
          else if ("MultiPolygon" === t5) for (const e7 of o6) z3(r8, e7[0]);
          return r8;
        }
        function z3(e6, t5) {
          for (let o6 = 0; o6 < t5.length; o6 += 3) e6.minX = Math.min(e6.minX, t5[o6]), e6.minY = Math.min(e6.minY, t5[o6 + 1]), e6.maxX = Math.max(e6.maxX, t5[o6]), e6.maxY = Math.max(e6.maxY, t5[o6 + 1]);
        }
        function A4(e6, t5, o6, i6) {
          if (!t5.geometry) return;
          const r8 = t5.geometry.coordinates;
          if (r8 && 0 === r8.length) return;
          const s4 = t5.geometry.type, n6 = Math.pow(o6.tolerance / ((1 << o6.maxZoom) * o6.extent), 2);
          let a4 = [], l5 = t5.id;
          if (o6.promoteId ? l5 = t5.properties[o6.promoteId] : o6.generateId && (l5 = i6 || 0), "Point" === s4) j3(r8, a4);
          else if ("MultiPoint" === s4) for (const e7 of r8) j3(e7, a4);
          else if ("LineString" === s4) E3(r8, a4, n6, false);
          else if ("MultiLineString" === s4) {
            if (o6.lineMetrics) {
              for (const o7 of r8) a4 = [], E3(o7, a4, n6, false), e6.push(G2(l5, "LineString", a4, t5.properties));
              return;
            }
            Z2(r8, a4, n6, false);
          } else if ("Polygon" === s4) Z2(r8, a4, n6, true);
          else {
            if ("MultiPolygon" !== s4) {
              if ("GeometryCollection" === s4) {
                for (const r9 of t5.geometry.geometries) A4(e6, { id: l5, geometry: r9, properties: t5.properties }, o6, i6);
                return;
              }
              throw new Error("Input data is not a valid GeoJSON object.");
            }
            for (const e7 of r8) {
              const t6 = [];
              Z2(e7, t6, n6, true), a4.push(t6);
            }
          }
          e6.push(G2(l5, s4, a4, t5.properties));
        }
        function j3(e6, t5) {
          t5.push(N3(e6[0]), J2(e6[1]), 0);
        }
        function E3(e6, t5, o6, i6) {
          let r8, s4, n6 = 0;
          for (let o7 = 0; o7 < e6.length; o7++) {
            const a5 = N3(e6[o7][0]), l5 = J2(e6[o7][1]);
            t5.push(a5, l5, 0), o7 > 0 && (n6 += i6 ? (r8 * l5 - a5 * s4) / 2 : Math.sqrt(Math.pow(a5 - r8, 2) + Math.pow(l5 - s4, 2))), r8 = a5, s4 = l5;
          }
          const a4 = t5.length - 3;
          t5[2] = 1, L3(t5, 0, a4, o6), t5[a4 + 2] = 1, t5.size = Math.abs(n6), t5.start = 0, t5.end = t5.size;
        }
        function Z2(e6, t5, o6, i6) {
          for (let r8 = 0; r8 < e6.length; r8++) {
            const s4 = [];
            E3(e6[r8], s4, o6, i6), t5.push(s4);
          }
        }
        function N3(e6) {
          return e6 / 360 + 0.5;
        }
        function J2(e6) {
          const t5 = Math.sin(e6 * Math.PI / 180), o6 = 0.5 - 0.25 * Math.log((1 + t5) / (1 - t5)) / Math.PI;
          return o6 < 0 ? 0 : o6 > 1 ? 1 : o6;
        }
        function W(e6, t5, o6, i6, r8, s4, n6, a4) {
          if (i6 /= t5, s4 >= (o6 /= t5) && n6 < i6) return e6;
          if (n6 < o6 || s4 >= i6) return null;
          const l5 = [];
          for (const t6 of e6) {
            const e7 = t6.geometry;
            let s5 = t6.type;
            const n7 = 0 === r8 ? t6.minX : t6.minY, c5 = 0 === r8 ? t6.maxX : t6.maxY;
            if (n7 >= o6 && c5 < i6) {
              l5.push(t6);
              continue;
            }
            if (c5 < o6 || n7 >= i6) continue;
            let u4 = [];
            if ("Point" === s5 || "MultiPoint" === s5) R4(e7, u4, o6, i6, r8);
            else if ("LineString" === s5) Y2(e7, u4, o6, i6, r8, false, a4.lineMetrics);
            else if ("MultiLineString" === s5) H4(e7, u4, o6, i6, r8, false);
            else if ("Polygon" === s5) H4(e7, u4, o6, i6, r8, true);
            else if ("MultiPolygon" === s5) for (const t7 of e7) {
              const e8 = [];
              H4(t7, e8, o6, i6, r8, true), e8.length && u4.push(e8);
            }
            if (u4.length) {
              if (a4.lineMetrics && "LineString" === s5) {
                for (const e8 of u4) l5.push(G2(t6.id, s5, e8, t6.tags));
                continue;
              }
              "LineString" !== s5 && "MultiLineString" !== s5 || (1 === u4.length ? (s5 = "LineString", u4 = u4[0]) : s5 = "MultiLineString"), "Point" !== s5 && "MultiPoint" !== s5 || (s5 = 3 === u4.length ? "Point" : "MultiPoint"), l5.push(G2(t6.id, s5, u4, t6.tags));
            }
          }
          return l5.length ? l5 : null;
        }
        function R4(e6, t5, o6, i6, r8) {
          for (let s4 = 0; s4 < e6.length; s4 += 3) {
            const n6 = e6[s4 + r8];
            n6 >= o6 && n6 <= i6 && V2(t5, e6[s4], e6[s4 + 1], e6[s4 + 2]);
          }
        }
        function Y2(e6, t5, o6, i6, r8, s4, n6) {
          let a4 = q2(e6);
          const l5 = 0 === r8 ? X2 : B4;
          let c5, u4, h4 = e6.start;
          for (let d5 = 0; d5 < e6.length - 3; d5 += 3) {
            const f5 = e6[d5], g5 = e6[d5 + 1], p5 = e6[d5 + 2], m4 = e6[d5 + 3], y4 = e6[d5 + 4], v4 = 0 === r8 ? f5 : g5, w4 = 0 === r8 ? m4 : y4;
            let x4 = false;
            n6 && (c5 = Math.sqrt(Math.pow(f5 - m4, 2) + Math.pow(g5 - y4, 2))), v4 < o6 ? w4 > o6 && (u4 = l5(a4, f5, g5, m4, y4, o6), n6 && (a4.start = h4 + c5 * u4)) : v4 > i6 ? w4 < i6 && (u4 = l5(a4, f5, g5, m4, y4, i6), n6 && (a4.start = h4 + c5 * u4)) : V2(a4, f5, g5, p5), w4 < o6 && v4 >= o6 && (u4 = l5(a4, f5, g5, m4, y4, o6), x4 = true), w4 > i6 && v4 <= i6 && (u4 = l5(a4, f5, g5, m4, y4, i6), x4 = true), !s4 && x4 && (n6 && (a4.end = h4 + c5 * u4), t5.push(a4), a4 = q2(e6)), n6 && (h4 += c5);
          }
          let d4 = e6.length - 3;
          const f4 = e6[d4], g4 = e6[d4 + 1], p4 = 0 === r8 ? f4 : g4;
          p4 >= o6 && p4 <= i6 && V2(a4, f4, g4, e6[d4 + 2]), d4 = a4.length - 3, s4 && d4 >= 3 && (a4[d4] !== a4[0] || a4[d4 + 1] !== a4[1]) && V2(a4, a4[0], a4[1], a4[2]), a4.length && t5.push(a4);
        }
        function q2(e6) {
          const t5 = [];
          return t5.size = e6.size, t5.start = e6.start, t5.end = e6.end, t5;
        }
        function H4(e6, t5, o6, i6, r8, s4) {
          for (const n6 of e6) Y2(n6, t5, o6, i6, r8, s4, false);
        }
        function V2(e6, t5, o6, i6) {
          e6.push(t5, o6, i6);
        }
        function X2(e6, t5, o6, i6, r8, s4) {
          const n6 = (s4 - t5) / (i6 - t5);
          return V2(e6, s4, o6 + (r8 - o6) * n6, 1), n6;
        }
        function B4(e6, t5, o6, i6, r8, s4) {
          const n6 = (s4 - o6) / (r8 - o6);
          return V2(e6, t5 + (i6 - t5) * n6, s4, 1), n6;
        }
        function $2(e6, t5) {
          const o6 = [];
          for (let i6 = 0; i6 < e6.length; i6++) {
            const r8 = e6[i6], s4 = r8.type;
            let n6;
            if ("Point" === s4 || "MultiPoint" === s4 || "LineString" === s4) n6 = U3(r8.geometry, t5);
            else if ("MultiLineString" === s4 || "Polygon" === s4) {
              n6 = [];
              for (const e7 of r8.geometry) n6.push(U3(e7, t5));
            } else if ("MultiPolygon" === s4) {
              n6 = [];
              for (const e7 of r8.geometry) {
                const o7 = [];
                for (const i7 of e7) o7.push(U3(i7, t5));
                n6.push(o7);
              }
            }
            o6.push(G2(r8.id, s4, n6, r8.tags));
          }
          return o6;
        }
        function U3(e6, t5) {
          const o6 = [];
          o6.size = e6.size, void 0 !== e6.start && (o6.start = e6.start, o6.end = e6.end);
          for (let i6 = 0; i6 < e6.length; i6 += 3) o6.push(e6[i6] + t5, e6[i6 + 1], e6[i6 + 2]);
          return o6;
        }
        function K2(e6, t5) {
          if (e6.transformed) return e6;
          const o6 = 1 << e6.z, i6 = e6.x, r8 = e6.y;
          for (const s4 of e6.features) {
            const e7 = s4.geometry, n6 = s4.type;
            if (s4.geometry = [], 1 === n6) for (let n7 = 0; n7 < e7.length; n7 += 2) s4.geometry.push(Q2(e7[n7], e7[n7 + 1], t5, o6, i6, r8));
            else for (let n7 = 0; n7 < e7.length; n7++) {
              const a4 = [];
              for (let s5 = 0; s5 < e7[n7].length; s5 += 2) a4.push(Q2(e7[n7][s5], e7[n7][s5 + 1], t5, o6, i6, r8));
              s4.geometry.push(a4);
            }
          }
          return e6.transformed = true, e6;
        }
        function Q2(e6, t5, o6, i6, r8, s4) {
          return [Math.round(o6 * (e6 * i6 - r8)), Math.round(o6 * (t5 * i6 - s4))];
        }
        function ee(e6, t5, o6, i6, r8) {
          const s4 = t5 === r8.maxZoom ? 0 : r8.tolerance / ((1 << t5) * r8.extent), n6 = { features: [], numPoints: 0, numSimplified: 0, numFeatures: e6.length, source: null, x: o6, y: i6, z: t5, transformed: false, minX: 2, minY: 1, maxX: -1, maxY: 0 };
          for (const t6 of e6) te(n6, t6, s4, r8);
          return n6;
        }
        function te(e6, t5, o6, i6) {
          const r8 = t5.geometry, s4 = t5.type, n6 = [];
          if (e6.minX = Math.min(e6.minX, t5.minX), e6.minY = Math.min(e6.minY, t5.minY), e6.maxX = Math.max(e6.maxX, t5.maxX), e6.maxY = Math.max(e6.maxY, t5.maxY), "Point" === s4 || "MultiPoint" === s4) for (let t6 = 0; t6 < r8.length; t6 += 3) n6.push(r8[t6], r8[t6 + 1]), e6.numPoints++, e6.numSimplified++;
          else if ("LineString" === s4) oe(n6, r8, e6, o6, false, false);
          else if ("MultiLineString" === s4 || "Polygon" === s4) for (let t6 = 0; t6 < r8.length; t6++) oe(n6, r8[t6], e6, o6, "Polygon" === s4, 0 === t6);
          else if ("MultiPolygon" === s4) for (let t6 = 0; t6 < r8.length; t6++) {
            const i7 = r8[t6];
            for (let t7 = 0; t7 < i7.length; t7++) oe(n6, i7[t7], e6, o6, true, 0 === t7);
          }
          if (n6.length) {
            let o7 = t5.tags || null;
            if ("LineString" === s4 && i6.lineMetrics) {
              o7 = {};
              for (const e7 in t5.tags) o7[e7] = t5.tags[e7];
              o7.mapbox_clip_start = r8.start / r8.size, o7.mapbox_clip_end = r8.end / r8.size;
            }
            const a4 = { geometry: n6, type: "Polygon" === s4 || "MultiPolygon" === s4 ? 3 : "LineString" === s4 || "MultiLineString" === s4 ? 2 : 1, tags: o7 };
            null !== t5.id && (a4.id = t5.id), e6.features.push(a4);
          }
        }
        function oe(e6, t5, o6, i6, r8, s4) {
          const n6 = i6 * i6;
          if (i6 > 0 && t5.size < (r8 ? n6 : i6)) return void (o6.numPoints += t5.length / 3);
          const a4 = [];
          for (let e7 = 0; e7 < t5.length; e7 += 3) (0 === i6 || t5[e7 + 2] > n6) && (o6.numSimplified++, a4.push(t5[e7], t5[e7 + 1])), o6.numPoints++;
          r8 && function(e7, t6) {
            let o7 = 0;
            for (let t7 = 0, i7 = e7.length, r9 = i7 - 2; t7 < i7; r9 = t7, t7 += 2) o7 += (e7[t7] - e7[r9]) * (e7[t7 + 1] + e7[r9 + 1]);
            if (o7 > 0 === t6) for (let t7 = 0, o8 = e7.length; t7 < o8 / 2; t7 += 2) {
              const i7 = e7[t7], r9 = e7[t7 + 1];
              e7[t7] = e7[o8 - 2 - t7], e7[t7 + 1] = e7[o8 - 1 - t7], e7[o8 - 2 - t7] = i7, e7[o8 - 1 - t7] = r9;
            }
          }(a4, s4), e6.push(a4);
        }
        const ie2 = { maxZoom: 14, indexMaxZoom: 5, indexMaxPoints: 1e5, tolerance: 3, extent: 4096, buffer: 64, lineMetrics: false, promoteId: null, generateId: false, debug: 0 };
        class re2 {
          constructor(e6, t5) {
            const o6 = (t5 = this.options = function(e7, t6) {
              for (const o7 in t6) e7[o7] = t6[o7];
              return e7;
            }(Object.create(ie2), t5)).debug;
            if (o6 && console.time("preprocess data"), t5.maxZoom < 0 || t5.maxZoom > 24) throw new Error("maxZoom should be in the 0-24 range");
            if (t5.promoteId && t5.generateId) throw new Error("promoteId and generateId cannot be used together.");
            let i6 = function(e7, t6) {
              const o7 = [];
              if ("FeatureCollection" === e7.type) for (let i7 = 0; i7 < e7.features.length; i7++) A4(o7, e7.features[i7], t6, i7);
              else A4(o7, "Feature" === e7.type ? e7 : { geometry: e7 }, t6);
              return o7;
            }(e6, t5);
            this.tiles = {}, this.tileCoords = [], o6 && (console.timeEnd("preprocess data"), console.log("index: maxZoom: %d, maxPoints: %d", t5.indexMaxZoom, t5.indexMaxPoints), console.time("generate tiles"), this.stats = {}, this.total = 0), i6 = function(e7, t6) {
              const o7 = t6.buffer / t6.extent;
              let i7 = e7;
              const r8 = W(e7, 1, -1 - o7, o7, 0, -1, 2, t6), s4 = W(e7, 1, 1 - o7, 2 + o7, 0, -1, 2, t6);
              return (r8 || s4) && (i7 = W(e7, 1, -o7, 1 + o7, 0, -1, 2, t6) || [], r8 && (i7 = $2(r8, 1).concat(i7)), s4 && (i7 = i7.concat($2(s4, -1)))), i7;
            }(i6, t5), i6.length && this.splitTile(i6, 0, 0, 0), o6 && (i6.length && console.log("features: %d, points: %d", this.tiles[0].numFeatures, this.tiles[0].numPoints), console.timeEnd("generate tiles"), console.log("tiles generated:", this.total, JSON.stringify(this.stats)));
          }
          splitTile(e6, t5, o6, i6, r8, s4, n6) {
            const a4 = [e6, t5, o6, i6], l5 = this.options, c5 = l5.debug;
            for (; a4.length; ) {
              i6 = a4.pop(), o6 = a4.pop(), t5 = a4.pop(), e6 = a4.pop();
              const u4 = 1 << t5, h4 = se(t5, o6, i6);
              let d4 = this.tiles[h4];
              if (!d4 && (c5 > 1 && console.time("creation"), d4 = this.tiles[h4] = ee(e6, t5, o6, i6, l5), this.tileCoords.push({ z: t5, x: o6, y: i6 }), c5)) {
                c5 > 1 && (console.log("tile z%d-%d-%d (features: %d, points: %d, simplified: %d)", t5, o6, i6, d4.numFeatures, d4.numPoints, d4.numSimplified), console.timeEnd("creation"));
                const e7 = `z${t5}`;
                this.stats[e7] = (this.stats[e7] || 0) + 1, this.total++;
              }
              if (d4.source = e6, null == r8) {
                if (t5 === l5.indexMaxZoom || d4.numPoints <= l5.indexMaxPoints) continue;
              } else {
                if (t5 === l5.maxZoom || t5 === r8) continue;
                if (null != r8) {
                  const e7 = r8 - t5;
                  if (o6 !== s4 >> e7 || i6 !== n6 >> e7) continue;
                }
              }
              if (d4.source = null, 0 === e6.length) continue;
              c5 > 1 && console.time("clipping");
              const f4 = 0.5 * l5.buffer / l5.extent, g4 = 0.5 - f4, p4 = 0.5 + f4, m4 = 1 + f4;
              let y4 = null, v4 = null, w4 = null, x4 = null, _4 = W(e6, u4, o6 - f4, o6 + p4, 0, d4.minX, d4.maxX, l5), b5 = W(e6, u4, o6 + g4, o6 + m4, 0, d4.minX, d4.maxX, l5);
              e6 = null, _4 && (y4 = W(_4, u4, i6 - f4, i6 + p4, 1, d4.minY, d4.maxY, l5), v4 = W(_4, u4, i6 + g4, i6 + m4, 1, d4.minY, d4.maxY, l5), _4 = null), b5 && (w4 = W(b5, u4, i6 - f4, i6 + p4, 1, d4.minY, d4.maxY, l5), x4 = W(b5, u4, i6 + g4, i6 + m4, 1, d4.minY, d4.maxY, l5), b5 = null), c5 > 1 && console.timeEnd("clipping"), a4.push(y4 || [], t5 + 1, 2 * o6, 2 * i6), a4.push(v4 || [], t5 + 1, 2 * o6, 2 * i6 + 1), a4.push(w4 || [], t5 + 1, 2 * o6 + 1, 2 * i6), a4.push(x4 || [], t5 + 1, 2 * o6 + 1, 2 * i6 + 1);
            }
          }
          getTile(e6, t5, o6) {
            e6 = +e6, t5 = +t5, o6 = +o6;
            const i6 = this.options, { extent: r8, debug: s4 } = i6;
            if (e6 < 0 || e6 > 24) return null;
            const n6 = 1 << e6, a4 = se(e6, t5 = t5 + n6 & n6 - 1, o6);
            if (this.tiles[a4]) return K2(this.tiles[a4], r8);
            s4 > 1 && console.log("drilling down to z%d-%d-%d", e6, t5, o6);
            let l5, c5 = e6, u4 = t5, h4 = o6;
            for (; !l5 && c5 > 0; ) c5--, u4 >>= 1, h4 >>= 1, l5 = this.tiles[se(c5, u4, h4)];
            return l5 && l5.source ? (s4 > 1 && (console.log("found parent tile z%d-%d-%d", c5, u4, h4), console.time("drilling down")), this.splitTile(l5.source, c5, u4, h4, e6, t5, o6), s4 > 1 && console.timeEnd("drilling down"), this.tiles[a4] ? K2(this.tiles[a4], r8) : null) : null;
          }
        }
        function se(e6, t5, o6) {
          return 32 * ((1 << e6) * o6 + t5) + e6;
        }
        function ne(e6, t5) {
          return t5 ? e6.properties[t5] : e6.id;
        }
        function ae(e6, t5) {
          if (null == e6) return true;
          if ("Feature" === e6.type) return null != ne(e6, t5);
          if ("FeatureCollection" === e6.type) {
            const o6 = /* @__PURE__ */ new Set();
            for (const i6 of e6.features) {
              const e7 = ne(i6, t5);
              if (null == e7) return false;
              if (o6.has(e7)) return false;
              o6.add(e7);
            }
            return true;
          }
          return false;
        }
        function le(e6, t5) {
          const o6 = /* @__PURE__ */ new Map();
          if (null == e6) ;
          else if ("Feature" === e6.type) o6.set(ne(e6, t5), e6);
          else for (const i6 of e6.features) o6.set(ne(i6, t5), i6);
          return o6;
        }
        class ce extends s3 {
          constructor() {
            super(...arguments), this._dataUpdateable = /* @__PURE__ */ new Map();
          }
          loadVectorTile(t5, o6) {
            return e5._(this, void 0, void 0, function* () {
              const e6 = t5.tileID.canonical;
              if (!this._geoJSONIndex) throw new Error("Unable to parse the data into a cluster or geojson");
              const o7 = this._geoJSONIndex.getTile(e6.z, e6.x, e6.y);
              if (!o7) return null;
              const i6 = new f3(o7.features);
              let r8 = w3(i6);
              return 0 === r8.byteOffset && r8.byteLength === r8.buffer.byteLength || (r8 = new Uint8Array(r8)), { vectorTile: i6, rawData: r8.buffer };
            });
          }
          loadData(t5) {
            return e5._(this, void 0, void 0, function* () {
              var o6;
              null === (o6 = this._pendingRequest) || void 0 === o6 || o6.abort();
              const i6 = !!(t5 && t5.request && t5.request.collectResourceTiming) && new e5.cA(t5.request);
              this._pendingRequest = new AbortController();
              try {
                this._pendingData = this.loadAndProcessGeoJSON(t5, this._pendingRequest), this._geoJSONIndex = t5.cluster ? new P3(function({ superclusterOptions: t6, clusterProperties: o8 }) {
                  if (!o8 || !t6) return t6;
                  const i7 = {}, r9 = {}, s4 = { accumulated: null, zoom: 0 }, n6 = { properties: null }, a4 = Object.keys(o8);
                  for (const t7 of a4) {
                    const [s5, n7] = o8[t7], a5 = e5.cH(n7), l5 = e5.cH("string" == typeof s5 ? [s5, ["accumulated"], ["get", t7]] : s5);
                    i7[t7] = a5.value, r9[t7] = l5.value;
                  }
                  return t6.map = (e6) => {
                    n6.properties = e6;
                    const t7 = {};
                    for (const e7 of a4) t7[e7] = i7[e7].evaluate(s4, n6);
                    return t7;
                  }, t6.reduce = (e6, t7) => {
                    n6.properties = t7;
                    for (const t8 of a4) s4.accumulated = e6[t8], e6[t8] = r9[t8].evaluate(s4, n6);
                  }, t6;
                }(t5)).load((yield this._pendingData).features) : (r8 = yield this._pendingData, new re2(r8, t5.geojsonVtOptions)), this.loaded = {};
                const o7 = {};
                if (i6) {
                  const e6 = i6.finish();
                  e6 && (o7.resourceTiming = {}, o7.resourceTiming[t5.source] = JSON.parse(JSON.stringify(e6)));
                }
                return o7;
              } catch (t6) {
                if (delete this._pendingRequest, e5.cl(t6)) return { abandoned: true };
                throw t6;
              }
              var r8;
            });
          }
          getData() {
            return e5._(this, void 0, void 0, function* () {
              return this._pendingData;
            });
          }
          reloadTile(e6) {
            const t5 = this.loaded;
            return t5 && t5[e6.uid] ? super.reloadTile(e6) : this.loadTile(e6);
          }
          loadAndProcessGeoJSON(t5, o6) {
            return e5._(this, void 0, void 0, function* () {
              let i6 = yield this.loadGeoJSON(t5, o6);
              if (delete this._pendingRequest, "object" != typeof i6) throw new Error(`Input data given to '${t5.source}' is not a valid GeoJSON object.`);
              if (u3(i6, true), t5.filter) {
                const o7 = e5.cH(t5.filter, { type: "boolean", "property-type": "data-driven", overridable: false, transition: false });
                if ("error" === o7.result) throw new Error(o7.value.map((e6) => `${e6.key}: ${e6.message}`).join(", "));
                const r8 = i6.features.filter((e6) => o7.value.evaluate({ zoom: 0 }, e6));
                i6 = { type: "FeatureCollection", features: r8 };
              }
              return i6;
            });
          }
          loadGeoJSON(t5, o6) {
            return e5._(this, void 0, void 0, function* () {
              const { promoteId: i6 } = t5;
              if (t5.request) {
                const r8 = yield e5.j(t5.request, o6);
                return this._dataUpdateable = ae(r8.data, i6) ? le(r8.data, i6) : void 0, r8.data;
              }
              if ("string" == typeof t5.data) try {
                const e6 = JSON.parse(t5.data);
                return this._dataUpdateable = ae(e6, i6) ? le(e6, i6) : void 0, e6;
              } catch (e6) {
                throw new Error(`Input data given to '${t5.source}' is not a valid GeoJSON object.`);
              }
              if (!t5.dataDiff) throw new Error(`Input data given to '${t5.source}' is not a valid GeoJSON object.`);
              if (!this._dataUpdateable) throw new Error(`Cannot update existing geojson data in ${t5.source}`);
              return function(e6, t6, o7) {
                var i7, r8, s4, n6;
                if (t6.removeAll && e6.clear(), t6.remove) for (const o8 of t6.remove) e6.delete(o8);
                if (t6.add) for (const i8 of t6.add) {
                  const t7 = ne(i8, o7);
                  null != t7 && e6.set(t7, i8);
                }
                if (t6.update) for (const o8 of t6.update) {
                  let t7 = e6.get(o8.id);
                  if (null == t7) continue;
                  const a4 = !o8.removeAllProperties && ((null === (i7 = o8.removeProperties) || void 0 === i7 ? void 0 : i7.length) > 0 || (null === (r8 = o8.addOrUpdateProperties) || void 0 === r8 ? void 0 : r8.length) > 0);
                  if ((o8.newGeometry || o8.removeAllProperties || a4) && (t7 = Object.assign({}, t7), e6.set(o8.id, t7), a4 && (t7.properties = Object.assign({}, t7.properties))), o8.newGeometry && (t7.geometry = o8.newGeometry), o8.removeAllProperties) t7.properties = {};
                  else if ((null === (s4 = o8.removeProperties) || void 0 === s4 ? void 0 : s4.length) > 0) for (const e7 of o8.removeProperties) Object.prototype.hasOwnProperty.call(t7.properties, e7) && delete t7.properties[e7];
                  if ((null === (n6 = o8.addOrUpdateProperties) || void 0 === n6 ? void 0 : n6.length) > 0) for (const { key: e7, value: i8 } of o8.addOrUpdateProperties) t7.properties[e7] = i8;
                }
              }(this._dataUpdateable, t5.dataDiff, i6), { type: "FeatureCollection", features: Array.from(this._dataUpdateable.values()) };
            });
          }
          removeSource(t5) {
            return e5._(this, void 0, void 0, function* () {
              this._pendingRequest && this._pendingRequest.abort();
            });
          }
          getClusterExpansionZoom(e6) {
            return this._geoJSONIndex.getClusterExpansionZoom(e6.clusterId);
          }
          getClusterChildren(e6) {
            return this._geoJSONIndex.getChildren(e6.clusterId);
          }
          getClusterLeaves(e6) {
            return this._geoJSONIndex.getLeaves(e6.clusterId, e6.limit, e6.offset);
          }
        }
        class ue {
          constructor(t5) {
            this.self = t5, this.actor = new e5.H(t5), this.layerIndexes = {}, this.availableImages = {}, this.workerSources = {}, this.demWorkerSources = {}, this.externalWorkerSourceTypes = {}, this.self.registerWorkerSource = (e6, t6) => {
              if (this.externalWorkerSourceTypes[e6]) throw new Error(`Worker source with name "${e6}" already registered.`);
              this.externalWorkerSourceTypes[e6] = t6;
            }, this.self.addProtocol = e5.cn, this.self.removeProtocol = e5.co, this.self.registerRTLTextPlugin = (t6) => {
              e5.cI.setMethods(t6);
            }, this.actor.registerMessageHandler("LDT", (e6, t6) => this._getDEMWorkerSource(e6, t6.source).loadTile(t6)), this.actor.registerMessageHandler("RDT", (t6, o6) => e5._(this, void 0, void 0, function* () {
              this._getDEMWorkerSource(t6, o6.source).removeTile(o6);
            })), this.actor.registerMessageHandler("GCEZ", (t6, o6) => e5._(this, void 0, void 0, function* () {
              return this._getWorkerSource(t6, o6.type, o6.source).getClusterExpansionZoom(o6);
            })), this.actor.registerMessageHandler("GCC", (t6, o6) => e5._(this, void 0, void 0, function* () {
              return this._getWorkerSource(t6, o6.type, o6.source).getClusterChildren(o6);
            })), this.actor.registerMessageHandler("GCL", (t6, o6) => e5._(this, void 0, void 0, function* () {
              return this._getWorkerSource(t6, o6.type, o6.source).getClusterLeaves(o6);
            })), this.actor.registerMessageHandler("LD", (e6, t6) => this._getWorkerSource(e6, t6.type, t6.source).loadData(t6)), this.actor.registerMessageHandler("GD", (e6, t6) => this._getWorkerSource(e6, t6.type, t6.source).getData()), this.actor.registerMessageHandler("LT", (e6, t6) => this._getWorkerSource(e6, t6.type, t6.source).loadTile(t6)), this.actor.registerMessageHandler("RT", (e6, t6) => this._getWorkerSource(e6, t6.type, t6.source).reloadTile(t6)), this.actor.registerMessageHandler("AT", (e6, t6) => this._getWorkerSource(e6, t6.type, t6.source).abortTile(t6)), this.actor.registerMessageHandler("RMT", (e6, t6) => this._getWorkerSource(e6, t6.type, t6.source).removeTile(t6)), this.actor.registerMessageHandler("RS", (t6, o6) => e5._(this, void 0, void 0, function* () {
              if (!this.workerSources[t6] || !this.workerSources[t6][o6.type] || !this.workerSources[t6][o6.type][o6.source]) return;
              const e6 = this.workerSources[t6][o6.type][o6.source];
              delete this.workerSources[t6][o6.type][o6.source], void 0 !== e6.removeSource && e6.removeSource(o6);
            })), this.actor.registerMessageHandler("RM", (t6) => e5._(this, void 0, void 0, function* () {
              delete this.layerIndexes[t6], delete this.availableImages[t6], delete this.workerSources[t6], delete this.demWorkerSources[t6];
            })), this.actor.registerMessageHandler("SR", (t6, o6) => e5._(this, void 0, void 0, function* () {
              this.referrer = o6;
            })), this.actor.registerMessageHandler("SRPS", (e6, t6) => this._syncRTLPluginState(e6, t6)), this.actor.registerMessageHandler("IS", (t6, o6) => e5._(this, void 0, void 0, function* () {
              this.self.importScripts(o6);
            })), this.actor.registerMessageHandler("SI", (e6, t6) => this._setImages(e6, t6)), this.actor.registerMessageHandler("UL", (t6, o6) => e5._(this, void 0, void 0, function* () {
              this._getLayerIndex(t6).update(o6.layers, o6.removedIds);
            })), this.actor.registerMessageHandler("SL", (t6, o6) => e5._(this, void 0, void 0, function* () {
              this._getLayerIndex(t6).replace(o6);
            }));
          }
          _setImages(t5, o6) {
            return e5._(this, void 0, void 0, function* () {
              this.availableImages[t5] = o6;
              for (const e6 in this.workerSources[t5]) {
                const i6 = this.workerSources[t5][e6];
                for (const e7 in i6) i6[e7].availableImages = o6;
              }
            });
          }
          _syncRTLPluginState(t5, o6) {
            return e5._(this, void 0, void 0, function* () {
              return yield e5.cI.syncState(o6, this.self.importScripts);
            });
          }
          _getAvailableImages(e6) {
            let t5 = this.availableImages[e6];
            return t5 || (t5 = []), t5;
          }
          _getLayerIndex(e6) {
            let o6 = this.layerIndexes[e6];
            return o6 || (o6 = this.layerIndexes[e6] = new t4()), o6;
          }
          _getWorkerSource(e6, t5, o6) {
            if (this.workerSources[e6] || (this.workerSources[e6] = {}), this.workerSources[e6][t5] || (this.workerSources[e6][t5] = {}), !this.workerSources[e6][t5][o6]) {
              const i6 = { sendAsync: (t6, o7) => (t6.targetMapId = e6, this.actor.sendAsync(t6, o7)) };
              switch (t5) {
                case "vector":
                  this.workerSources[e6][t5][o6] = new s3(i6, this._getLayerIndex(e6), this._getAvailableImages(e6));
                  break;
                case "geojson":
                  this.workerSources[e6][t5][o6] = new ce(i6, this._getLayerIndex(e6), this._getAvailableImages(e6));
                  break;
                default:
                  this.workerSources[e6][t5][o6] = new this.externalWorkerSourceTypes[t5](i6, this._getLayerIndex(e6), this._getAvailableImages(e6));
              }
            }
            return this.workerSources[e6][t5][o6];
          }
          _getDEMWorkerSource(e6, t5) {
            return this.demWorkerSources[e6] || (this.demWorkerSources[e6] = {}), this.demWorkerSources[e6][t5] || (this.demWorkerSources[e6][t5] = new n5()), this.demWorkerSources[e6][t5];
          }
        }
        return e5.i(self) && (self.worker = new ue(self)), ue;
      });
      define2("index", ["exports", "./shared"], function(e5, t4) {
        "use strict";
        var i5 = "5.3.0";
        function r7() {
          var e6 = new t4.A(4);
          return t4.A != Float32Array && (e6[1] = 0, e6[2] = 0), e6[0] = 1, e6[3] = 1, e6;
        }
        let o5, a3;
        const s3 = { now: "undefined" != typeof performance && performance && performance.now ? performance.now.bind(performance) : Date.now.bind(Date), frame(e6, i6, r8) {
          const o6 = requestAnimationFrame((e7) => {
            a4(), i6(e7);
          }), { unsubscribe: a4 } = t4.s(e6.signal, "abort", () => {
            a4(), cancelAnimationFrame(o6), r8(t4.c());
          }, false);
        }, frameAsync(e6) {
          return new Promise((t5, i6) => {
            this.frame(e6, t5, i6);
          });
        }, getImageData(e6, t5 = 0) {
          return this.getImageCanvasContext(e6).getImageData(-t5, -t5, e6.width + 2 * t5, e6.height + 2 * t5);
        }, getImageCanvasContext(e6) {
          const t5 = window.document.createElement("canvas"), i6 = t5.getContext("2d", { willReadFrequently: true });
          if (!i6) throw new Error("failed to create canvas 2d context");
          return t5.width = e6.width, t5.height = e6.height, i6.drawImage(e6, 0, 0, e6.width, e6.height), i6;
        }, resolveURL: (e6) => (o5 || (o5 = document.createElement("a")), o5.href = e6, o5.href), hardwareConcurrency: "undefined" != typeof navigator && navigator.hardwareConcurrency || 4, get prefersReducedMotion() {
          return !!matchMedia && (null == a3 && (a3 = matchMedia("(prefers-reduced-motion: reduce)")), a3.matches);
        } };
        class n5 {
          static testProp(e6) {
            if (!n5.docStyle) return e6[0];
            for (let t5 = 0; t5 < e6.length; t5++) if (e6[t5] in n5.docStyle) return e6[t5];
            return e6[0];
          }
          static create(e6, t5, i6) {
            const r8 = window.document.createElement(e6);
            return void 0 !== t5 && (r8.className = t5), i6 && i6.appendChild(r8), r8;
          }
          static createNS(e6, t5) {
            return window.document.createElementNS(e6, t5);
          }
          static disableDrag() {
            n5.docStyle && n5.selectProp && (n5.userSelect = n5.docStyle[n5.selectProp], n5.docStyle[n5.selectProp] = "none");
          }
          static enableDrag() {
            n5.docStyle && n5.selectProp && (n5.docStyle[n5.selectProp] = n5.userSelect);
          }
          static setTransform(e6, t5) {
            e6.style[n5.transformProp] = t5;
          }
          static addEventListener(e6, t5, i6, r8 = {}) {
            e6.addEventListener(t5, i6, "passive" in r8 ? r8 : r8.capture);
          }
          static removeEventListener(e6, t5, i6, r8 = {}) {
            e6.removeEventListener(t5, i6, "passive" in r8 ? r8 : r8.capture);
          }
          static suppressClickInternal(e6) {
            e6.preventDefault(), e6.stopPropagation(), window.removeEventListener("click", n5.suppressClickInternal, true);
          }
          static suppressClick() {
            window.addEventListener("click", n5.suppressClickInternal, true), window.setTimeout(() => {
              window.removeEventListener("click", n5.suppressClickInternal, true);
            }, 0);
          }
          static getScale(e6) {
            const t5 = e6.getBoundingClientRect();
            return { x: t5.width / e6.offsetWidth || 1, y: t5.height / e6.offsetHeight || 1, boundingClientRect: t5 };
          }
          static getPoint(e6, i6, r8) {
            const o6 = i6.boundingClientRect;
            return new t4.P((r8.clientX - o6.left) / i6.x - e6.clientLeft, (r8.clientY - o6.top) / i6.y - e6.clientTop);
          }
          static mousePos(e6, t5) {
            const i6 = n5.getScale(e6);
            return n5.getPoint(e6, i6, t5);
          }
          static touchPos(e6, t5) {
            const i6 = [], r8 = n5.getScale(e6);
            for (let o6 = 0; o6 < t5.length; o6++) i6.push(n5.getPoint(e6, r8, t5[o6]));
            return i6;
          }
          static mouseButton(e6) {
            return e6.button;
          }
          static remove(e6) {
            e6.parentNode && e6.parentNode.removeChild(e6);
          }
          static sanitize(e6) {
            const t5 = new DOMParser().parseFromString(e6, "text/html").body || document.createElement("body"), i6 = t5.querySelectorAll("script");
            for (const e7 of i6) e7.remove();
            return n5.clean(t5), t5.innerHTML;
          }
          static isPossiblyDangerous(e6, t5) {
            const i6 = t5.replace(/\s+/g, "").toLowerCase();
            return !(!["src", "href", "xlink:href"].includes(e6) || !i6.includes("javascript:") && !i6.includes("data:")) || !!e6.startsWith("on") || void 0;
          }
          static clean(e6) {
            const t5 = e6.children;
            for (const e7 of t5) n5.removeAttributes(e7), n5.clean(e7);
          }
          static removeAttributes(e6) {
            for (const { name: t5, value: i6 } of e6.attributes) n5.isPossiblyDangerous(t5, i6) && e6.removeAttribute(t5);
          }
        }
        n5.docStyle = "undefined" != typeof window && window.document && window.document.documentElement.style, n5.selectProp = n5.testProp(["userSelect", "MozUserSelect", "WebkitUserSelect", "msUserSelect"]), n5.transformProp = n5.testProp(["transform", "WebkitTransform"]);
        const l4 = { supported: false, testSupport: function(e6) {
          !u3 && h3 && (d3 ? _3(e6) : c4 = e6);
        } };
        let c4, h3, u3 = false, d3 = false;
        function _3(e6) {
          const t5 = e6.createTexture();
          e6.bindTexture(e6.TEXTURE_2D, t5);
          try {
            if (e6.texImage2D(e6.TEXTURE_2D, 0, e6.RGBA, e6.RGBA, e6.UNSIGNED_BYTE, h3), e6.isContextLost()) return;
            l4.supported = true;
          } catch (e7) {
          }
          e6.deleteTexture(t5), u3 = true;
        }
        var p3;
        "undefined" != typeof document && (h3 = document.createElement("img"), h3.onload = () => {
          c4 && _3(c4), c4 = null, d3 = true;
        }, h3.onerror = () => {
          u3 = true, c4 = null;
        }, h3.src = "data:image/webp;base64,UklGRh4AAABXRUJQVlA4TBEAAAAvAQAAAAfQ//73v/+BiOh/AAA="), function(e6) {
          let i6, r8, o6, a4;
          e6.resetRequestQueue = () => {
            i6 = [], r8 = 0, o6 = 0, a4 = {};
          }, e6.addThrottleControl = (e7) => {
            const t5 = o6++;
            return a4[t5] = e7, t5;
          }, e6.removeThrottleControl = (e7) => {
            delete a4[e7], n6();
          }, e6.getImage = (e7, r9, o7 = true) => new Promise((a5, s5) => {
            l4.supported && (e7.headers || (e7.headers = {}), e7.headers.accept = "image/webp,*/*"), t4.e(e7, { type: "image" }), i6.push({ abortController: r9, requestParameters: e7, supportImageRefresh: o7, state: "queued", onError: (e8) => {
              s5(e8);
            }, onSuccess: (e8) => {
              a5(e8);
            } }), n6();
          });
          const s4 = (e7) => t4._(this, void 0, void 0, function* () {
            e7.state = "running";
            const { requestParameters: i7, supportImageRefresh: o7, onError: a5, onSuccess: s5, abortController: l5 } = e7, h4 = false === o7 && !t4.i(self) && !t4.g(i7.url) && (!i7.headers || Object.keys(i7.headers).reduce((e8, t5) => e8 && "accept" === t5, true));
            r8++;
            const u4 = h4 ? c5(i7, l5) : t4.m(i7, l5);
            try {
              const i8 = yield u4;
              delete e7.abortController, e7.state = "completed", i8.data instanceof HTMLImageElement || t4.b(i8.data) ? s5(i8) : i8.data && s5({ data: yield (d4 = i8.data, "function" == typeof createImageBitmap ? t4.f(d4) : t4.h(d4)), cacheControl: i8.cacheControl, expires: i8.expires });
            } catch (t5) {
              delete e7.abortController, a5(t5);
            } finally {
              r8--, n6();
            }
            var d4;
          }), n6 = () => {
            const e7 = (() => {
              for (const e8 of Object.keys(a4)) if (a4[e8]()) return true;
              return false;
            })() ? t4.a.MAX_PARALLEL_IMAGE_REQUESTS_PER_FRAME : t4.a.MAX_PARALLEL_IMAGE_REQUESTS;
            for (let t5 = r8; t5 < e7 && i6.length > 0; t5++) {
              const e8 = i6.shift();
              e8.abortController.signal.aborted ? t5-- : s4(e8);
            }
          }, c5 = (e7, i7) => new Promise((r9, o7) => {
            const a5 = new Image(), s5 = e7.url, n7 = e7.credentials;
            n7 && "include" === n7 ? a5.crossOrigin = "use-credentials" : (n7 && "same-origin" === n7 || !t4.d(s5)) && (a5.crossOrigin = "anonymous"), i7.signal.addEventListener("abort", () => {
              a5.src = "", o7(t4.c());
            }), a5.fetchPriority = "high", a5.onload = () => {
              a5.onerror = a5.onload = null, r9({ data: a5 });
            }, a5.onerror = () => {
              a5.onerror = a5.onload = null, i7.signal.aborted || o7(new Error("Could not load image. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported."));
            }, a5.src = s5;
          });
        }(p3 || (p3 = {})), p3.resetRequestQueue();
        class m3 {
          constructor(e6) {
            this._transformRequestFn = e6;
          }
          transformRequest(e6, t5) {
            return this._transformRequestFn && this._transformRequestFn(e6, t5) || { url: e6 };
          }
          setTransformRequest(e6) {
            this._transformRequestFn = e6;
          }
        }
        function f3(e6) {
          const t5 = [];
          if ("string" == typeof e6) t5.push({ id: "default", url: e6 });
          else if (e6 && e6.length > 0) {
            const i6 = [];
            for (const { id: r8, url: o6 } of e6) {
              const e7 = `${r8}${o6}`;
              -1 === i6.indexOf(e7) && (i6.push(e7), t5.push({ id: r8, url: o6 }));
            }
          }
          return t5;
        }
        function g3(e6, t5, i6) {
          try {
            const r8 = new URL(e6);
            return r8.pathname += `${t5}${i6}`, r8.toString();
          } catch (t6) {
            throw new Error(`Invalid sprite URL "${e6}", must be absolute. Modify style specification directly or use TransformStyleFunction to correct the issue dynamically`);
          }
        }
        class v3 {
          constructor(e6, t5, i6, r8) {
            this.context = e6, this.format = i6, this.texture = e6.gl.createTexture(), this.update(t5, r8);
          }
          update(e6, i6, r8) {
            const { width: o6, height: a4 } = e6, s4 = !(this.size && this.size[0] === o6 && this.size[1] === a4 || r8), { context: n6 } = this, { gl: l5 } = n6;
            if (this.useMipmap = Boolean(i6 && i6.useMipmap), l5.bindTexture(l5.TEXTURE_2D, this.texture), n6.pixelStoreUnpackFlipY.set(false), n6.pixelStoreUnpack.set(1), n6.pixelStoreUnpackPremultiplyAlpha.set(this.format === l5.RGBA && (!i6 || false !== i6.premultiply)), s4) this.size = [o6, a4], e6 instanceof HTMLImageElement || e6 instanceof HTMLCanvasElement || e6 instanceof HTMLVideoElement || e6 instanceof ImageData || t4.b(e6) ? l5.texImage2D(l5.TEXTURE_2D, 0, this.format, this.format, l5.UNSIGNED_BYTE, e6) : l5.texImage2D(l5.TEXTURE_2D, 0, this.format, o6, a4, 0, this.format, l5.UNSIGNED_BYTE, e6.data);
            else {
              const { x: i7, y: s5 } = r8 || { x: 0, y: 0 };
              e6 instanceof HTMLImageElement || e6 instanceof HTMLCanvasElement || e6 instanceof HTMLVideoElement || e6 instanceof ImageData || t4.b(e6) ? l5.texSubImage2D(l5.TEXTURE_2D, 0, i7, s5, l5.RGBA, l5.UNSIGNED_BYTE, e6) : l5.texSubImage2D(l5.TEXTURE_2D, 0, i7, s5, o6, a4, l5.RGBA, l5.UNSIGNED_BYTE, e6.data);
            }
            this.useMipmap && this.isSizePowerOfTwo() && l5.generateMipmap(l5.TEXTURE_2D);
          }
          bind(e6, t5, i6) {
            const { context: r8 } = this, { gl: o6 } = r8;
            o6.bindTexture(o6.TEXTURE_2D, this.texture), i6 !== o6.LINEAR_MIPMAP_NEAREST || this.isSizePowerOfTwo() || (i6 = o6.LINEAR), e6 !== this.filter && (o6.texParameteri(o6.TEXTURE_2D, o6.TEXTURE_MAG_FILTER, e6), o6.texParameteri(o6.TEXTURE_2D, o6.TEXTURE_MIN_FILTER, i6 || e6), this.filter = e6), t5 !== this.wrap && (o6.texParameteri(o6.TEXTURE_2D, o6.TEXTURE_WRAP_S, t5), o6.texParameteri(o6.TEXTURE_2D, o6.TEXTURE_WRAP_T, t5), this.wrap = t5);
          }
          isSizePowerOfTwo() {
            return this.size[0] === this.size[1] && Math.log(this.size[0]) / Math.LN2 % 1 == 0;
          }
          destroy() {
            const { gl: e6 } = this.context;
            e6.deleteTexture(this.texture), this.texture = null;
          }
        }
        function x3(e6) {
          const { userImage: t5 } = e6;
          return !!(t5 && t5.render && t5.render()) && (e6.data.replace(new Uint8Array(t5.data.buffer)), true);
        }
        class b4 extends t4.E {
          constructor() {
            super(), this.images = {}, this.updatedImages = {}, this.callbackDispatchedThisFrame = {}, this.loaded = false, this.requestors = [], this.patterns = {}, this.atlasImage = new t4.R({ width: 1, height: 1 }), this.dirty = true;
          }
          isLoaded() {
            return this.loaded;
          }
          setLoaded(e6) {
            if (this.loaded !== e6 && (this.loaded = e6, e6)) {
              for (const { ids: e7, promiseResolve: t5 } of this.requestors) t5(this._getImagesForIds(e7));
              this.requestors = [];
            }
          }
          getImage(e6) {
            const i6 = this.images[e6];
            if (i6 && !i6.data && i6.spriteData) {
              const e7 = i6.spriteData;
              i6.data = new t4.R({ width: e7.width, height: e7.height }, e7.context.getImageData(e7.x, e7.y, e7.width, e7.height).data), i6.spriteData = null;
            }
            return i6;
          }
          addImage(e6, t5) {
            if (this.images[e6]) throw new Error(`Image id ${e6} already exist, use updateImage instead`);
            this._validate(e6, t5) && (this.images[e6] = t5);
          }
          _validate(e6, i6) {
            let r8 = true;
            const o6 = i6.data || i6.spriteData;
            return this._validateStretch(i6.stretchX, o6 && o6.width) || (this.fire(new t4.k(new Error(`Image "${e6}" has invalid "stretchX" value`))), r8 = false), this._validateStretch(i6.stretchY, o6 && o6.height) || (this.fire(new t4.k(new Error(`Image "${e6}" has invalid "stretchY" value`))), r8 = false), this._validateContent(i6.content, i6) || (this.fire(new t4.k(new Error(`Image "${e6}" has invalid "content" value`))), r8 = false), r8;
          }
          _validateStretch(e6, t5) {
            if (!e6) return true;
            let i6 = 0;
            for (const r8 of e6) {
              if (r8[0] < i6 || r8[1] < r8[0] || t5 < r8[1]) return false;
              i6 = r8[1];
            }
            return true;
          }
          _validateContent(e6, t5) {
            if (!e6) return true;
            if (4 !== e6.length) return false;
            const i6 = t5.spriteData, r8 = i6 && i6.width || t5.data.width, o6 = i6 && i6.height || t5.data.height;
            return !(e6[0] < 0 || r8 < e6[0] || e6[1] < 0 || o6 < e6[1] || e6[2] < 0 || r8 < e6[2] || e6[3] < 0 || o6 < e6[3] || e6[2] < e6[0] || e6[3] < e6[1]);
          }
          updateImage(e6, t5, i6 = true) {
            const r8 = this.getImage(e6);
            if (i6 && (r8.data.width !== t5.data.width || r8.data.height !== t5.data.height)) throw new Error(`size mismatch between old image (${r8.data.width}x${r8.data.height}) and new image (${t5.data.width}x${t5.data.height}).`);
            t5.version = r8.version + 1, this.images[e6] = t5, this.updatedImages[e6] = true;
          }
          removeImage(e6) {
            const t5 = this.images[e6];
            delete this.images[e6], delete this.patterns[e6], t5.userImage && t5.userImage.onRemove && t5.userImage.onRemove();
          }
          listImages() {
            return Object.keys(this.images);
          }
          getImages(e6) {
            return new Promise((t5, i6) => {
              let r8 = true;
              if (!this.isLoaded()) for (const t6 of e6) this.images[t6] || (r8 = false);
              this.isLoaded() || r8 ? t5(this._getImagesForIds(e6)) : this.requestors.push({ ids: e6, promiseResolve: t5 });
            });
          }
          _getImagesForIds(e6) {
            const i6 = {};
            for (const r8 of e6) {
              let e7 = this.getImage(r8);
              e7 || (this.fire(new t4.l("styleimagemissing", { id: r8 })), e7 = this.getImage(r8)), e7 ? i6[r8] = { data: e7.data.clone(), pixelRatio: e7.pixelRatio, sdf: e7.sdf, version: e7.version, stretchX: e7.stretchX, stretchY: e7.stretchY, content: e7.content, textFitWidth: e7.textFitWidth, textFitHeight: e7.textFitHeight, hasRenderCallback: Boolean(e7.userImage && e7.userImage.render) } : t4.w(`Image "${r8}" could not be loaded. Please make sure you have added the image with map.addImage() or a "sprite" property in your style. You can provide missing images by listening for the "styleimagemissing" map event.`);
            }
            return i6;
          }
          getPixelSize() {
            const { width: e6, height: t5 } = this.atlasImage;
            return { width: e6, height: t5 };
          }
          getPattern(e6) {
            const i6 = this.patterns[e6], r8 = this.getImage(e6);
            if (!r8) return null;
            if (i6 && i6.position.version === r8.version) return i6.position;
            if (i6) i6.position.version = r8.version;
            else {
              const i7 = { w: r8.data.width + 2, h: r8.data.height + 2, x: 0, y: 0 }, o6 = new t4.I(i7, r8);
              this.patterns[e6] = { bin: i7, position: o6 };
            }
            return this._updatePatternAtlas(), this.patterns[e6].position;
          }
          bind(e6) {
            const t5 = e6.gl;
            this.atlasTexture ? this.dirty && (this.atlasTexture.update(this.atlasImage), this.dirty = false) : this.atlasTexture = new v3(e6, this.atlasImage, t5.RGBA), this.atlasTexture.bind(t5.LINEAR, t5.CLAMP_TO_EDGE);
          }
          _updatePatternAtlas() {
            const e6 = [];
            for (const t5 in this.patterns) e6.push(this.patterns[t5].bin);
            const { w: i6, h: r8 } = t4.p(e6), o6 = this.atlasImage;
            o6.resize({ width: i6 || 1, height: r8 || 1 });
            for (const e7 in this.patterns) {
              const { bin: i7 } = this.patterns[e7], r9 = i7.x + 1, a4 = i7.y + 1, s4 = this.getImage(e7).data, n6 = s4.width, l5 = s4.height;
              t4.R.copy(s4, o6, { x: 0, y: 0 }, { x: r9, y: a4 }, { width: n6, height: l5 }), t4.R.copy(s4, o6, { x: 0, y: l5 - 1 }, { x: r9, y: a4 - 1 }, { width: n6, height: 1 }), t4.R.copy(s4, o6, { x: 0, y: 0 }, { x: r9, y: a4 + l5 }, { width: n6, height: 1 }), t4.R.copy(s4, o6, { x: n6 - 1, y: 0 }, { x: r9 - 1, y: a4 }, { width: 1, height: l5 }), t4.R.copy(s4, o6, { x: 0, y: 0 }, { x: r9 + n6, y: a4 }, { width: 1, height: l5 });
            }
            this.dirty = true;
          }
          beginFrame() {
            this.callbackDispatchedThisFrame = {};
          }
          dispatchRenderCallbacks(e6) {
            for (const i6 of e6) {
              if (this.callbackDispatchedThisFrame[i6]) continue;
              this.callbackDispatchedThisFrame[i6] = true;
              const e7 = this.getImage(i6);
              e7 || t4.w(`Image with ID: "${i6}" was not found`), x3(e7) && this.updateImage(i6, e7);
            }
          }
        }
        const y3 = 1e20;
        function w3(e6, t5, i6, r8, o6, a4, s4, n6, l5) {
          for (let c5 = t5; c5 < t5 + r8; c5++) T4(e6, i6 * a4 + c5, a4, o6, s4, n6, l5);
          for (let c5 = i6; c5 < i6 + o6; c5++) T4(e6, c5 * a4 + t5, 1, r8, s4, n6, l5);
        }
        function T4(e6, t5, i6, r8, o6, a4, s4) {
          a4[0] = 0, s4[0] = -1e20, s4[1] = y3, o6[0] = e6[t5];
          for (let n6 = 1, l5 = 0, c5 = 0; n6 < r8; n6++) {
            o6[n6] = e6[t5 + n6 * i6];
            const r9 = n6 * n6;
            do {
              const e7 = a4[l5];
              c5 = (o6[n6] - o6[e7] + r9 - e7 * e7) / (n6 - e7) / 2;
            } while (c5 <= s4[l5] && --l5 > -1);
            l5++, a4[l5] = n6, s4[l5] = c5, s4[l5 + 1] = y3;
          }
          for (let n6 = 0, l5 = 0; n6 < r8; n6++) {
            for (; s4[l5 + 1] < n6; ) l5++;
            const r9 = a4[l5], c5 = n6 - r9;
            e6[t5 + n6 * i6] = o6[r9] + c5 * c5;
          }
        }
        class P3 {
          constructor(e6, t5) {
            this.requestManager = e6, this.localIdeographFontFamily = t5, this.entries = {};
          }
          setURL(e6) {
            this.url = e6;
          }
          getGlyphs(e6) {
            return t4._(this, void 0, void 0, function* () {
              const t5 = [];
              for (const i7 in e6) for (const r9 of e6[i7]) t5.push(this._getAndCacheGlyphsPromise(i7, r9));
              const i6 = yield Promise.all(t5), r8 = {};
              for (const { stack: e7, id: t6, glyph: o6 } of i6) r8[e7] || (r8[e7] = {}), r8[e7][t6] = o6 && { id: o6.id, bitmap: o6.bitmap.clone(), metrics: o6.metrics };
              return r8;
            });
          }
          _getAndCacheGlyphsPromise(e6, i6) {
            return t4._(this, void 0, void 0, function* () {
              let t5 = this.entries[e6];
              t5 || (t5 = this.entries[e6] = { glyphs: {}, requests: {}, ranges: {} });
              let r8 = t5.glyphs[i6];
              if (void 0 !== r8) return { stack: e6, id: i6, glyph: r8 };
              if (r8 = this._tinySDF(t5, e6, i6), r8) return t5.glyphs[i6] = r8, { stack: e6, id: i6, glyph: r8 };
              const o6 = Math.floor(i6 / 256);
              if (256 * o6 > 65535) throw new Error("glyphs > 65535 not supported");
              if (t5.ranges[o6]) return { stack: e6, id: i6, glyph: r8 };
              if (!this.url) throw new Error("glyphsUrl is not set");
              if (!t5.requests[o6]) {
                const i7 = P3.loadGlyphRange(e6, o6, this.url, this.requestManager);
                t5.requests[o6] = i7;
              }
              const a4 = yield t5.requests[o6];
              for (const e7 in a4) this._doesCharSupportLocalGlyph(+e7) || (t5.glyphs[+e7] = a4[+e7]);
              return t5.ranges[o6] = true, { stack: e6, id: i6, glyph: a4[i6] || null };
            });
          }
          _doesCharSupportLocalGlyph(e6) {
            return !!this.localIdeographFontFamily && (/\p{Ideo}|\p{sc=Hang}|\p{sc=Hira}|\p{sc=Kana}/u.test(String.fromCodePoint(e6)) || t4.u["CJK Unified Ideographs"](e6) || t4.u["Hangul Syllables"](e6) || t4.u.Hiragana(e6) || t4.u.Katakana(e6) || t4.u["CJK Symbols and Punctuation"](e6) || t4.u["Halfwidth and Fullwidth Forms"](e6));
          }
          _tinySDF(e6, i6, r8) {
            const o6 = this.localIdeographFontFamily;
            if (!o6) return;
            if (!this._doesCharSupportLocalGlyph(r8)) return;
            let a4 = e6.tinySDF;
            if (!a4) {
              let t5 = "400";
              /bold/i.test(i6) ? t5 = "900" : /medium/i.test(i6) ? t5 = "500" : /light/i.test(i6) && (t5 = "200"), a4 = e6.tinySDF = new P3.TinySDF({ fontSize: 48, buffer: 6, radius: 16, cutoff: 0.25, fontFamily: o6, fontWeight: t5 });
            }
            const s4 = a4.draw(String.fromCharCode(r8));
            return { id: r8, bitmap: new t4.q({ width: s4.width || 60, height: s4.height || 60 }, s4.data), metrics: { width: s4.glyphWidth / 2 || 24, height: s4.glyphHeight / 2 || 24, left: s4.glyphLeft / 2 + 0.5 || 0, top: s4.glyphTop / 2 - 27.5 || -8, advance: s4.glyphAdvance / 2 || 24, isDoubleResolution: true } };
          }
        }
        P3.loadGlyphRange = function(e6, i6, r8, o6) {
          return t4._(this, void 0, void 0, function* () {
            const a4 = 256 * i6, s4 = a4 + 255, n6 = o6.transformRequest(r8.replace("{fontstack}", e6).replace("{range}", `${a4}-${s4}`), "Glyphs"), l5 = yield t4.n(n6, new AbortController());
            if (!l5 || !l5.data) throw new Error(`Could not load glyph range. range: ${i6}, ${a4}-${s4}`);
            const c5 = {};
            for (const e7 of t4.o(l5.data)) c5[e7.id] = e7;
            return c5;
          });
        }, P3.TinySDF = class {
          constructor({ fontSize: e6 = 24, buffer: t5 = 3, radius: i6 = 8, cutoff: r8 = 0.25, fontFamily: o6 = "sans-serif", fontWeight: a4 = "normal", fontStyle: s4 = "normal" } = {}) {
            this.buffer = t5, this.cutoff = r8, this.radius = i6;
            const n6 = this.size = e6 + 4 * t5, l5 = this._createCanvas(n6), c5 = this.ctx = l5.getContext("2d", { willReadFrequently: true });
            c5.font = `${s4} ${a4} ${e6}px ${o6}`, c5.textBaseline = "alphabetic", c5.textAlign = "left", c5.fillStyle = "black", this.gridOuter = new Float64Array(n6 * n6), this.gridInner = new Float64Array(n6 * n6), this.f = new Float64Array(n6), this.z = new Float64Array(n6 + 1), this.v = new Uint16Array(n6);
          }
          _createCanvas(e6) {
            const t5 = document.createElement("canvas");
            return t5.width = t5.height = e6, t5;
          }
          draw(e6) {
            const { width: t5, actualBoundingBoxAscent: i6, actualBoundingBoxDescent: r8, actualBoundingBoxLeft: o6, actualBoundingBoxRight: a4 } = this.ctx.measureText(e6), s4 = Math.ceil(i6), n6 = Math.max(0, Math.min(this.size - this.buffer, Math.ceil(a4 - o6))), l5 = Math.min(this.size - this.buffer, s4 + Math.ceil(r8)), c5 = n6 + 2 * this.buffer, h4 = l5 + 2 * this.buffer, u4 = Math.max(c5 * h4, 0), d4 = new Uint8ClampedArray(u4), _4 = { data: d4, width: c5, height: h4, glyphWidth: n6, glyphHeight: l5, glyphTop: s4, glyphLeft: 0, glyphAdvance: t5 };
            if (0 === n6 || 0 === l5) return _4;
            const { ctx: p4, buffer: m4, gridInner: f4, gridOuter: g4 } = this;
            p4.clearRect(m4, m4, n6, l5), p4.fillText(e6, m4, m4 + s4);
            const v4 = p4.getImageData(m4, m4, n6, l5);
            g4.fill(y3, 0, u4), f4.fill(0, 0, u4);
            for (let e7 = 0; e7 < l5; e7++) for (let t6 = 0; t6 < n6; t6++) {
              const i7 = v4.data[4 * (e7 * n6 + t6) + 3] / 255;
              if (0 === i7) continue;
              const r9 = (e7 + m4) * c5 + t6 + m4;
              if (1 === i7) g4[r9] = 0, f4[r9] = y3;
              else {
                const e8 = 0.5 - i7;
                g4[r9] = e8 > 0 ? e8 * e8 : 0, f4[r9] = e8 < 0 ? e8 * e8 : 0;
              }
            }
            w3(g4, 0, 0, c5, h4, c5, this.f, this.v, this.z), w3(f4, m4, m4, n6, l5, c5, this.f, this.v, this.z);
            for (let e7 = 0; e7 < u4; e7++) {
              const t6 = Math.sqrt(g4[e7]) - Math.sqrt(f4[e7]);
              d4[e7] = Math.round(255 - 255 * (t6 / this.radius + this.cutoff));
            }
            return _4;
          }
        };
        class C3 {
          constructor() {
            this.specification = t4.v.light.position;
          }
          possiblyEvaluate(e6, i6) {
            return t4.z(e6.expression.evaluate(i6));
          }
          interpolate(e6, i6, r8) {
            return { x: t4.B.number(e6.x, i6.x, r8), y: t4.B.number(e6.y, i6.y, r8), z: t4.B.number(e6.z, i6.z, r8) };
          }
        }
        let I3;
        class M4 extends t4.E {
          constructor(e6) {
            super(), I3 = I3 || new t4.r({ anchor: new t4.D(t4.v.light.anchor), position: new C3(), color: new t4.D(t4.v.light.color), intensity: new t4.D(t4.v.light.intensity) }), this._transitionable = new t4.T(I3), this.setLight(e6), this._transitioning = this._transitionable.untransitioned();
          }
          getLight() {
            return this._transitionable.serialize();
          }
          setLight(e6, i6 = {}) {
            if (!this._validate(t4.t, e6, i6)) for (const t5 in e6) {
              const i7 = e6[t5];
              t5.endsWith("-transition") ? this._transitionable.setTransition(t5.slice(0, -11), i7) : this._transitionable.setValue(t5, i7);
            }
          }
          updateTransitions(e6) {
            this._transitioning = this._transitionable.transitioned(e6, this._transitioning);
          }
          hasTransition() {
            return this._transitioning.hasTransition();
          }
          recalculate(e6) {
            this.properties = this._transitioning.possiblyEvaluate(e6);
          }
          _validate(e6, i6, r8) {
            return (!r8 || false !== r8.validate) && t4.x(this, e6.call(t4.y, { value: i6, style: { glyphs: true, sprite: true }, styleSpec: t4.v }));
          }
        }
        const E3 = new t4.r({ "sky-color": new t4.D(t4.v.sky["sky-color"]), "horizon-color": new t4.D(t4.v.sky["horizon-color"]), "fog-color": new t4.D(t4.v.sky["fog-color"]), "fog-ground-blend": new t4.D(t4.v.sky["fog-ground-blend"]), "horizon-fog-blend": new t4.D(t4.v.sky["horizon-fog-blend"]), "sky-horizon-blend": new t4.D(t4.v.sky["sky-horizon-blend"]), "atmosphere-blend": new t4.D(t4.v.sky["atmosphere-blend"]) });
        class S4 extends t4.E {
          constructor(e6) {
            super(), this._transitionable = new t4.T(E3), this.setSky(e6), this._transitioning = this._transitionable.untransitioned(), this.recalculate(new t4.C(0));
          }
          setSky(e6, i6 = {}) {
            if (!this._validate(t4.F, e6, i6)) {
              e6 || (e6 = { "sky-color": "transparent", "horizon-color": "transparent", "fog-color": "transparent", "fog-ground-blend": 1, "atmosphere-blend": 0 });
              for (const t5 in e6) {
                const i7 = e6[t5];
                t5.endsWith("-transition") ? this._transitionable.setTransition(t5.slice(0, -11), i7) : this._transitionable.setValue(t5, i7);
              }
            }
          }
          getSky() {
            return this._transitionable.serialize();
          }
          updateTransitions(e6) {
            this._transitioning = this._transitionable.transitioned(e6, this._transitioning);
          }
          hasTransition() {
            return this._transitioning.hasTransition();
          }
          recalculate(e6) {
            this.properties = this._transitioning.possiblyEvaluate(e6);
          }
          _validate(e6, i6, r8 = {}) {
            return false !== (null == r8 ? void 0 : r8.validate) && t4.x(this, e6.call(t4.y, t4.e({ value: i6, style: { glyphs: true, sprite: true }, styleSpec: t4.v })));
          }
          calculateFogBlendOpacity(e6) {
            return e6 < 60 ? 0 : e6 < 70 ? (e6 - 60) / 10 : 1;
          }
        }
        class R4 {
          constructor(e6, t5) {
            this.width = e6, this.height = t5, this.nextRow = 0, this.data = new Uint8Array(this.width * this.height), this.dashEntry = {};
          }
          getDash(e6, t5) {
            const i6 = e6.join(",") + String(t5);
            return this.dashEntry[i6] || (this.dashEntry[i6] = this.addDash(e6, t5)), this.dashEntry[i6];
          }
          getDashRanges(e6, t5, i6) {
            const r8 = [];
            let o6 = e6.length % 2 == 1 ? -e6[e6.length - 1] * i6 : 0, a4 = e6[0] * i6, s4 = true;
            r8.push({ left: o6, right: a4, isDash: s4, zeroLength: 0 === e6[0] });
            let n6 = e6[0];
            for (let t6 = 1; t6 < e6.length; t6++) {
              s4 = !s4;
              const l5 = e6[t6];
              o6 = n6 * i6, n6 += l5, a4 = n6 * i6, r8.push({ left: o6, right: a4, isDash: s4, zeroLength: 0 === l5 });
            }
            return r8;
          }
          addRoundDash(e6, t5, i6) {
            const r8 = t5 / 2;
            for (let t6 = -i6; t6 <= i6; t6++) {
              const o6 = this.width * (this.nextRow + i6 + t6);
              let a4 = 0, s4 = e6[a4];
              for (let n6 = 0; n6 < this.width; n6++) {
                n6 / s4.right > 1 && (s4 = e6[++a4]);
                const l5 = Math.abs(n6 - s4.left), c5 = Math.abs(n6 - s4.right), h4 = Math.min(l5, c5);
                let u4;
                const d4 = t6 / i6 * (r8 + 1);
                if (s4.isDash) {
                  const e7 = r8 - Math.abs(d4);
                  u4 = Math.sqrt(h4 * h4 + e7 * e7);
                } else u4 = r8 - Math.sqrt(h4 * h4 + d4 * d4);
                this.data[o6 + n6] = Math.max(0, Math.min(255, u4 + 128));
              }
            }
          }
          addRegularDash(e6) {
            for (let t6 = e6.length - 1; t6 >= 0; --t6) {
              const i7 = e6[t6], r9 = e6[t6 + 1];
              i7.zeroLength ? e6.splice(t6, 1) : r9 && r9.isDash === i7.isDash && (r9.left = i7.left, e6.splice(t6, 1));
            }
            const t5 = e6[0], i6 = e6[e6.length - 1];
            t5.isDash === i6.isDash && (t5.left = i6.left - this.width, i6.right = t5.right + this.width);
            const r8 = this.width * this.nextRow;
            let o6 = 0, a4 = e6[o6];
            for (let t6 = 0; t6 < this.width; t6++) {
              t6 / a4.right > 1 && (a4 = e6[++o6]);
              const i7 = Math.abs(t6 - a4.left), s4 = Math.abs(t6 - a4.right), n6 = Math.min(i7, s4);
              this.data[r8 + t6] = Math.max(0, Math.min(255, (a4.isDash ? n6 : -n6) + 128));
            }
          }
          addDash(e6, i6) {
            const r8 = i6 ? 7 : 0, o6 = 2 * r8 + 1;
            if (this.nextRow + o6 > this.height) return t4.w("LineAtlas out of space"), null;
            let a4 = 0;
            for (let t5 = 0; t5 < e6.length; t5++) a4 += e6[t5];
            if (0 !== a4) {
              const t5 = this.width / a4, o7 = this.getDashRanges(e6, this.width, t5);
              i6 ? this.addRoundDash(o7, t5, r8) : this.addRegularDash(o7);
            }
            const s4 = { y: (this.nextRow + r8 + 0.5) / this.height, height: 2 * r8 / this.height, width: a4 };
            return this.nextRow += o6, this.dirty = true, s4;
          }
          bind(e6) {
            const t5 = e6.gl;
            this.texture ? (t5.bindTexture(t5.TEXTURE_2D, this.texture), this.dirty && (this.dirty = false, t5.texSubImage2D(t5.TEXTURE_2D, 0, 0, 0, this.width, this.height, t5.ALPHA, t5.UNSIGNED_BYTE, this.data))) : (this.texture = t5.createTexture(), t5.bindTexture(t5.TEXTURE_2D, this.texture), t5.texParameteri(t5.TEXTURE_2D, t5.TEXTURE_WRAP_S, t5.REPEAT), t5.texParameteri(t5.TEXTURE_2D, t5.TEXTURE_WRAP_T, t5.REPEAT), t5.texParameteri(t5.TEXTURE_2D, t5.TEXTURE_MIN_FILTER, t5.LINEAR), t5.texParameteri(t5.TEXTURE_2D, t5.TEXTURE_MAG_FILTER, t5.LINEAR), t5.texImage2D(t5.TEXTURE_2D, 0, t5.ALPHA, this.width, this.height, 0, t5.ALPHA, t5.UNSIGNED_BYTE, this.data));
          }
        }
        const D2 = "maplibre_preloaded_worker_pool";
        class z3 {
          constructor() {
            this.active = {};
          }
          acquire(e6) {
            if (!this.workers) for (this.workers = []; this.workers.length < z3.workerCount; ) this.workers.push(new Worker(t4.a.WORKER_URL));
            return this.active[e6] = true, this.workers.slice();
          }
          release(e6) {
            delete this.active[e6], 0 === this.numActive() && (this.workers.forEach((e7) => {
              e7.terminate();
            }), this.workers = null);
          }
          isPreloaded() {
            return !!this.active[D2];
          }
          numActive() {
            return Object.keys(this.active).length;
          }
        }
        const A4 = Math.floor(s3.hardwareConcurrency / 2);
        let L3, k3;
        function F2() {
          return L3 || (L3 = new z3()), L3;
        }
        z3.workerCount = t4.G(globalThis) ? Math.max(Math.min(A4, 3), 1) : 1;
        class B4 {
          constructor(e6, i6) {
            this.workerPool = e6, this.actors = [], this.currentActor = 0, this.id = i6;
            const r8 = this.workerPool.acquire(i6);
            for (let e7 = 0; e7 < r8.length; e7++) {
              const o6 = new t4.H(r8[e7], i6);
              o6.name = `Worker ${e7}`, this.actors.push(o6);
            }
            if (!this.actors.length) throw new Error("No actors found");
          }
          broadcast(e6, t5) {
            const i6 = [];
            for (const r8 of this.actors) i6.push(r8.sendAsync({ type: e6, data: t5 }));
            return Promise.all(i6);
          }
          getActor() {
            return this.currentActor = (this.currentActor + 1) % this.actors.length, this.actors[this.currentActor];
          }
          remove(e6 = true) {
            this.actors.forEach((e7) => {
              e7.remove();
            }), this.actors = [], e6 && this.workerPool.release(this.id);
          }
          registerMessageHandler(e6, t5) {
            for (const i6 of this.actors) i6.registerMessageHandler(e6, t5);
          }
        }
        function O2() {
          return k3 || (k3 = new B4(F2(), t4.J), k3.registerMessageHandler("GR", (e6, i6, r8) => t4.m(i6, r8))), k3;
        }
        function j3(e6, i6) {
          const r8 = t4.K();
          return t4.L(r8, r8, [1, 1, 0]), t4.M(r8, r8, [0.5 * e6.width, 0.5 * e6.height, 1]), e6.calculatePosMatrix ? t4.N(r8, r8, e6.calculatePosMatrix(i6.toUnwrapped())) : r8;
        }
        function Z2(e6, t5, i6, r8, o6, a4, s4) {
          var n6;
          const l5 = function(e7, t6, i7) {
            if (e7) for (const r9 of e7) {
              const e8 = t6[r9];
              if (e8 && e8.source === i7 && "fill-extrusion" === e8.type) return true;
            }
            else for (const e8 in t6) {
              const r9 = t6[e8];
              if (r9.source === i7 && "fill-extrusion" === r9.type) return true;
            }
            return false;
          }(null !== (n6 = null == o6 ? void 0 : o6.layers) && void 0 !== n6 ? n6 : null, t5, e6.id), c5 = a4.maxPitchScaleFactor(), h4 = e6.tilesIn(r8, c5, l5);
          h4.sort(N3);
          const u4 = [];
          for (const r9 of h4) u4.push({ wrappedTileID: r9.tileID.wrapped().key, queryResults: r9.tile.queryRenderedFeatures(t5, i6, e6._state, r9.queryGeometry, r9.cameraQueryGeometry, r9.scale, o6, a4, c5, j3(e6.transform, r9.tileID), s4 ? (e7, t6) => s4(r9.tileID, e7, t6) : void 0) });
          return function(e7, t6) {
            for (const i7 in e7) for (const r9 of e7[i7]) G2(r9, t6);
            return e7;
          }(function(e7) {
            const t6 = {}, i7 = {};
            for (const r9 of e7) {
              const e8 = r9.queryResults, o7 = r9.wrappedTileID, a5 = i7[o7] = i7[o7] || {};
              for (const i8 in e8) {
                const r10 = e8[i8], o8 = a5[i8] = a5[i8] || {}, s5 = t6[i8] = t6[i8] || [];
                for (const e9 of r10) o8[e9.featureIndex] || (o8[e9.featureIndex] = true, s5.push(e9));
              }
            }
            return t6;
          }(u4), e6);
        }
        function N3(e6, t5) {
          const i6 = e6.tileID, r8 = t5.tileID;
          return i6.overscaledZ - r8.overscaledZ || i6.canonical.y - r8.canonical.y || i6.wrap - r8.wrap || i6.canonical.x - r8.canonical.x;
        }
        function G2(e6, t5) {
          const i6 = e6.feature, r8 = t5.getFeatureState(i6.layer["source-layer"], i6.id);
          i6.source = i6.layer.source, i6.layer["source-layer"] && (i6.sourceLayer = i6.layer["source-layer"]), i6.state = r8;
        }
        function U3(e6, i6, r8) {
          return t4._(this, void 0, void 0, function* () {
            let o6 = e6;
            if (e6.url ? o6 = (yield t4.j(i6.transformRequest(e6.url, "Source"), r8)).data : yield s3.frameAsync(r8), !o6) return null;
            const a4 = t4.O(t4.e(o6, e6), ["tiles", "minzoom", "maxzoom", "attribution", "bounds", "scheme", "tileSize", "encoding"]);
            return "vector_layers" in o6 && o6.vector_layers && (a4.vectorLayerIds = o6.vector_layers.map((e7) => e7.id)), a4;
          });
        }
        class V2 {
          constructor(e6, t5) {
            e6 && (t5 ? this.setSouthWest(e6).setNorthEast(t5) : Array.isArray(e6) && (4 === e6.length ? this.setSouthWest([e6[0], e6[1]]).setNorthEast([e6[2], e6[3]]) : this.setSouthWest(e6[0]).setNorthEast(e6[1])));
          }
          setNorthEast(e6) {
            return this._ne = e6 instanceof t4.Q ? new t4.Q(e6.lng, e6.lat) : t4.Q.convert(e6), this;
          }
          setSouthWest(e6) {
            return this._sw = e6 instanceof t4.Q ? new t4.Q(e6.lng, e6.lat) : t4.Q.convert(e6), this;
          }
          extend(e6) {
            const i6 = this._sw, r8 = this._ne;
            let o6, a4;
            if (e6 instanceof t4.Q) o6 = e6, a4 = e6;
            else {
              if (!(e6 instanceof V2)) return Array.isArray(e6) ? 4 === e6.length || e6.every(Array.isArray) ? this.extend(V2.convert(e6)) : this.extend(t4.Q.convert(e6)) : e6 && ("lng" in e6 || "lon" in e6) && "lat" in e6 ? this.extend(t4.Q.convert(e6)) : this;
              if (o6 = e6._sw, a4 = e6._ne, !o6 || !a4) return this;
            }
            return i6 || r8 ? (i6.lng = Math.min(o6.lng, i6.lng), i6.lat = Math.min(o6.lat, i6.lat), r8.lng = Math.max(a4.lng, r8.lng), r8.lat = Math.max(a4.lat, r8.lat)) : (this._sw = new t4.Q(o6.lng, o6.lat), this._ne = new t4.Q(a4.lng, a4.lat)), this;
          }
          getCenter() {
            return new t4.Q((this._sw.lng + this._ne.lng) / 2, (this._sw.lat + this._ne.lat) / 2);
          }
          getSouthWest() {
            return this._sw;
          }
          getNorthEast() {
            return this._ne;
          }
          getNorthWest() {
            return new t4.Q(this.getWest(), this.getNorth());
          }
          getSouthEast() {
            return new t4.Q(this.getEast(), this.getSouth());
          }
          getWest() {
            return this._sw.lng;
          }
          getSouth() {
            return this._sw.lat;
          }
          getEast() {
            return this._ne.lng;
          }
          getNorth() {
            return this._ne.lat;
          }
          toArray() {
            return [this._sw.toArray(), this._ne.toArray()];
          }
          toString() {
            return `LngLatBounds(${this._sw.toString()}, ${this._ne.toString()})`;
          }
          isEmpty() {
            return !(this._sw && this._ne);
          }
          contains(e6) {
            const { lng: i6, lat: r8 } = t4.Q.convert(e6);
            let o6 = this._sw.lng <= i6 && i6 <= this._ne.lng;
            return this._sw.lng > this._ne.lng && (o6 = this._sw.lng >= i6 && i6 >= this._ne.lng), this._sw.lat <= r8 && r8 <= this._ne.lat && o6;
          }
          static convert(e6) {
            return e6 instanceof V2 ? e6 : e6 ? new V2(e6) : e6;
          }
          static fromLngLat(e6, i6 = 0) {
            const r8 = 360 * i6 / 40075017, o6 = r8 / Math.cos(Math.PI / 180 * e6.lat);
            return new V2(new t4.Q(e6.lng - o6, e6.lat - r8), new t4.Q(e6.lng + o6, e6.lat + r8));
          }
          adjustAntiMeridian() {
            const e6 = new t4.Q(this._sw.lng, this._sw.lat), i6 = new t4.Q(this._ne.lng, this._ne.lat);
            return new V2(e6, e6.lng > i6.lng ? new t4.Q(i6.lng + 360, i6.lat) : i6);
          }
        }
        class q2 {
          constructor(e6, t5, i6) {
            this.bounds = V2.convert(this.validateBounds(e6)), this.minzoom = t5 || 0, this.maxzoom = i6 || 24;
          }
          validateBounds(e6) {
            return Array.isArray(e6) && 4 === e6.length ? [Math.max(-180, e6[0]), Math.max(-90, e6[1]), Math.min(180, e6[2]), Math.min(90, e6[3])] : [-180, -90, 180, 90];
          }
          contains(e6) {
            const i6 = Math.pow(2, e6.z), r8 = Math.floor(t4.U(this.bounds.getWest()) * i6), o6 = Math.floor(t4.S(this.bounds.getNorth()) * i6), a4 = Math.ceil(t4.U(this.bounds.getEast()) * i6), s4 = Math.ceil(t4.S(this.bounds.getSouth()) * i6);
            return e6.x >= r8 && e6.x < a4 && e6.y >= o6 && e6.y < s4;
          }
        }
        class W extends t4.E {
          constructor(e6, i6, r8, o6) {
            if (super(), this.id = e6, this.dispatcher = r8, this.type = "vector", this.minzoom = 0, this.maxzoom = 22, this.scheme = "xyz", this.tileSize = 512, this.reparseOverscaled = true, this.isTileClipped = true, this._loaded = false, t4.e(this, t4.O(i6, ["url", "scheme", "tileSize", "promoteId"])), this._options = t4.e({ type: "vector" }, i6), this._collectResourceTiming = i6.collectResourceTiming, 512 !== this.tileSize) throw new Error("vector tile sources must have a tileSize of 512");
            this.setEventedParent(o6);
          }
          load() {
            return t4._(this, void 0, void 0, function* () {
              this._loaded = false, this.fire(new t4.l("dataloading", { dataType: "source" })), this._tileJSONRequest = new AbortController();
              try {
                const e6 = yield U3(this._options, this.map._requestManager, this._tileJSONRequest);
                this._tileJSONRequest = null, this._loaded = true, this.map.style.sourceCaches[this.id].clearTiles(), e6 && (t4.e(this, e6), e6.bounds && (this.tileBounds = new q2(e6.bounds, this.minzoom, this.maxzoom)), this.fire(new t4.l("data", { dataType: "source", sourceDataType: "metadata" })), this.fire(new t4.l("data", { dataType: "source", sourceDataType: "content" })));
              } catch (e6) {
                this._tileJSONRequest = null, this.fire(new t4.k(e6));
              }
            });
          }
          loaded() {
            return this._loaded;
          }
          hasTile(e6) {
            return !this.tileBounds || this.tileBounds.contains(e6.canonical);
          }
          onAdd(e6) {
            this.map = e6, this.load();
          }
          setSourceProperty(e6) {
            this._tileJSONRequest && this._tileJSONRequest.abort(), e6(), this.load();
          }
          setTiles(e6) {
            return this.setSourceProperty(() => {
              this._options.tiles = e6;
            }), this;
          }
          setUrl(e6) {
            return this.setSourceProperty(() => {
              this.url = e6, this._options.url = e6;
            }), this;
          }
          onRemove() {
            this._tileJSONRequest && (this._tileJSONRequest.abort(), this._tileJSONRequest = null);
          }
          serialize() {
            return t4.e({}, this._options);
          }
          loadTile(e6) {
            return t4._(this, void 0, void 0, function* () {
              const t5 = e6.tileID.canonical.url(this.tiles, this.map.getPixelRatio(), this.scheme), i6 = { request: this.map._requestManager.transformRequest(t5, "Tile"), uid: e6.uid, tileID: e6.tileID, zoom: e6.tileID.overscaledZ, tileSize: this.tileSize * e6.tileID.overscaleFactor(), type: this.type, source: this.id, pixelRatio: this.map.getPixelRatio(), showCollisionBoxes: this.map.showCollisionBoxes, promoteId: this.promoteId, subdivisionGranularity: this.map.style.projection.subdivisionGranularity };
              i6.request.collectResourceTiming = this._collectResourceTiming;
              let r8 = "RT";
              if (e6.actor && "expired" !== e6.state) {
                if ("loading" === e6.state) return new Promise((t6, i7) => {
                  e6.reloadPromise = { resolve: t6, reject: i7 };
                });
              } else e6.actor = this.dispatcher.getActor(), r8 = "LT";
              e6.abortController = new AbortController();
              try {
                const t6 = yield e6.actor.sendAsync({ type: r8, data: i6 }, e6.abortController);
                if (delete e6.abortController, e6.aborted) return;
                this._afterTileLoadWorkerResponse(e6, t6);
              } catch (t6) {
                if (delete e6.abortController, e6.aborted) return;
                if (t6 && 404 !== t6.status) throw t6;
                this._afterTileLoadWorkerResponse(e6, null);
              }
            });
          }
          _afterTileLoadWorkerResponse(e6, t5) {
            if (t5 && t5.resourceTiming && (e6.resourceTiming = t5.resourceTiming), t5 && this.map._refreshExpiredTiles && e6.setExpiryData(t5), e6.loadVectorData(t5, this.map.painter), e6.reloadPromise) {
              const t6 = e6.reloadPromise;
              e6.reloadPromise = null, this.loadTile(e6).then(t6.resolve).catch(t6.reject);
            }
          }
          abortTile(e6) {
            return t4._(this, void 0, void 0, function* () {
              e6.abortController && (e6.abortController.abort(), delete e6.abortController), e6.actor && (yield e6.actor.sendAsync({ type: "AT", data: { uid: e6.uid, type: this.type, source: this.id } }));
            });
          }
          unloadTile(e6) {
            return t4._(this, void 0, void 0, function* () {
              e6.unloadVectorData(), e6.actor && (yield e6.actor.sendAsync({ type: "RMT", data: { uid: e6.uid, type: this.type, source: this.id } }));
            });
          }
          hasTransition() {
            return false;
          }
        }
        class $2 extends t4.E {
          constructor(e6, i6, r8, o6) {
            super(), this.id = e6, this.dispatcher = r8, this.setEventedParent(o6), this.type = "raster", this.minzoom = 0, this.maxzoom = 22, this.roundZoom = true, this.scheme = "xyz", this.tileSize = 512, this._loaded = false, this._options = t4.e({ type: "raster" }, i6), t4.e(this, t4.O(i6, ["url", "scheme", "tileSize"]));
          }
          load() {
            return t4._(this, arguments, void 0, function* (e6 = false) {
              this._loaded = false, this.fire(new t4.l("dataloading", { dataType: "source" })), this._tileJSONRequest = new AbortController();
              try {
                const i6 = yield U3(this._options, this.map._requestManager, this._tileJSONRequest);
                this._tileJSONRequest = null, this._loaded = true, i6 && (t4.e(this, i6), i6.bounds && (this.tileBounds = new q2(i6.bounds, this.minzoom, this.maxzoom)), this.fire(new t4.l("data", { dataType: "source", sourceDataType: "metadata" })), this.fire(new t4.l("data", { dataType: "source", sourceDataType: "content", sourceDataChanged: e6 })));
              } catch (e7) {
                this._tileJSONRequest = null, this.fire(new t4.k(e7));
              }
            });
          }
          loaded() {
            return this._loaded;
          }
          onAdd(e6) {
            this.map = e6, this.load();
          }
          onRemove() {
            this._tileJSONRequest && (this._tileJSONRequest.abort(), this._tileJSONRequest = null);
          }
          setSourceProperty(e6) {
            this._tileJSONRequest && (this._tileJSONRequest.abort(), this._tileJSONRequest = null), e6(), this.load(true);
          }
          setTiles(e6) {
            return this.setSourceProperty(() => {
              this._options.tiles = e6;
            }), this;
          }
          setUrl(e6) {
            return this.setSourceProperty(() => {
              this.url = e6, this._options.url = e6;
            }), this;
          }
          serialize() {
            return t4.e({}, this._options);
          }
          hasTile(e6) {
            return !this.tileBounds || this.tileBounds.contains(e6.canonical);
          }
          loadTile(e6) {
            return t4._(this, void 0, void 0, function* () {
              const t5 = e6.tileID.canonical.url(this.tiles, this.map.getPixelRatio(), this.scheme);
              e6.abortController = new AbortController();
              try {
                const i6 = yield p3.getImage(this.map._requestManager.transformRequest(t5, "Tile"), e6.abortController, this.map._refreshExpiredTiles);
                if (delete e6.abortController, e6.aborted) return void (e6.state = "unloaded");
                if (i6 && i6.data) {
                  this.map._refreshExpiredTiles && i6.cacheControl && i6.expires && e6.setExpiryData({ cacheControl: i6.cacheControl, expires: i6.expires });
                  const t6 = this.map.painter.context, r8 = t6.gl, o6 = i6.data;
                  e6.texture = this.map.painter.getTileTexture(o6.width), e6.texture ? e6.texture.update(o6, { useMipmap: true }) : (e6.texture = new v3(t6, o6, r8.RGBA, { useMipmap: true }), e6.texture.bind(r8.LINEAR, r8.CLAMP_TO_EDGE, r8.LINEAR_MIPMAP_NEAREST)), e6.state = "loaded";
                }
              } catch (t6) {
                if (delete e6.abortController, e6.aborted) e6.state = "unloaded";
                else if (t6) throw e6.state = "errored", t6;
              }
            });
          }
          abortTile(e6) {
            return t4._(this, void 0, void 0, function* () {
              e6.abortController && (e6.abortController.abort(), delete e6.abortController);
            });
          }
          unloadTile(e6) {
            return t4._(this, void 0, void 0, function* () {
              e6.texture && this.map.painter.saveTileTexture(e6.texture);
            });
          }
          hasTransition() {
            return false;
          }
        }
        class H4 extends $2 {
          constructor(e6, i6, r8, o6) {
            super(e6, i6, r8, o6), this.type = "raster-dem", this.maxzoom = 22, this._options = t4.e({ type: "raster-dem" }, i6), this.encoding = i6.encoding || "mapbox", this.redFactor = i6.redFactor, this.greenFactor = i6.greenFactor, this.blueFactor = i6.blueFactor, this.baseShift = i6.baseShift;
          }
          loadTile(e6) {
            return t4._(this, void 0, void 0, function* () {
              const i6 = e6.tileID.canonical.url(this.tiles, this.map.getPixelRatio(), this.scheme), r8 = this.map._requestManager.transformRequest(i6, "Tile");
              e6.neighboringTiles = this._getNeighboringTiles(e6.tileID), e6.abortController = new AbortController();
              try {
                const i7 = yield p3.getImage(r8, e6.abortController, this.map._refreshExpiredTiles);
                if (delete e6.abortController, e6.aborted) return void (e6.state = "unloaded");
                if (i7 && i7.data) {
                  const r9 = i7.data;
                  this.map._refreshExpiredTiles && i7.cacheControl && i7.expires && e6.setExpiryData({ cacheControl: i7.cacheControl, expires: i7.expires });
                  const o6 = t4.b(r9) && t4.V() ? r9 : yield this.readImageNow(r9), a4 = { type: this.type, uid: e6.uid, source: this.id, rawImageData: o6, encoding: this.encoding, redFactor: this.redFactor, greenFactor: this.greenFactor, blueFactor: this.blueFactor, baseShift: this.baseShift };
                  if (!e6.actor || "expired" === e6.state) {
                    e6.actor = this.dispatcher.getActor();
                    const t5 = yield e6.actor.sendAsync({ type: "LDT", data: a4 });
                    e6.dem = t5, e6.needsHillshadePrepare = true, e6.needsTerrainPrepare = true, e6.state = "loaded";
                  }
                }
              } catch (t5) {
                if (delete e6.abortController, e6.aborted) e6.state = "unloaded";
                else if (t5) throw e6.state = "errored", t5;
              }
            });
          }
          readImageNow(e6) {
            return t4._(this, void 0, void 0, function* () {
              if ("undefined" != typeof VideoFrame && t4.W()) {
                const i6 = e6.width + 2, r8 = e6.height + 2;
                try {
                  return new t4.R({ width: i6, height: r8 }, yield t4.X(e6, -1, -1, i6, r8));
                } catch (e7) {
                }
              }
              return s3.getImageData(e6, 1);
            });
          }
          _getNeighboringTiles(e6) {
            const i6 = e6.canonical, r8 = Math.pow(2, i6.z), o6 = (i6.x - 1 + r8) % r8, a4 = 0 === i6.x ? e6.wrap - 1 : e6.wrap, s4 = (i6.x + 1 + r8) % r8, n6 = i6.x + 1 === r8 ? e6.wrap + 1 : e6.wrap, l5 = {};
            return l5[new t4.Y(e6.overscaledZ, a4, i6.z, o6, i6.y).key] = { backfilled: false }, l5[new t4.Y(e6.overscaledZ, n6, i6.z, s4, i6.y).key] = { backfilled: false }, i6.y > 0 && (l5[new t4.Y(e6.overscaledZ, a4, i6.z, o6, i6.y - 1).key] = { backfilled: false }, l5[new t4.Y(e6.overscaledZ, e6.wrap, i6.z, i6.x, i6.y - 1).key] = { backfilled: false }, l5[new t4.Y(e6.overscaledZ, n6, i6.z, s4, i6.y - 1).key] = { backfilled: false }), i6.y + 1 < r8 && (l5[new t4.Y(e6.overscaledZ, a4, i6.z, o6, i6.y + 1).key] = { backfilled: false }, l5[new t4.Y(e6.overscaledZ, e6.wrap, i6.z, i6.x, i6.y + 1).key] = { backfilled: false }, l5[new t4.Y(e6.overscaledZ, n6, i6.z, s4, i6.y + 1).key] = { backfilled: false }), l5;
          }
          unloadTile(e6) {
            return t4._(this, void 0, void 0, function* () {
              e6.demTexture && this.map.painter.saveTileTexture(e6.demTexture), e6.fbo && (e6.fbo.destroy(), delete e6.fbo), e6.dem && delete e6.dem, delete e6.neighboringTiles, e6.state = "unloaded", e6.actor && (yield e6.actor.sendAsync({ type: "RDT", data: { type: this.type, uid: e6.uid, source: this.id } }));
            });
          }
        }
        class K2 extends t4.E {
          constructor(e6, i6, r8, o6) {
            super(), this.id = e6, this.type = "geojson", this.minzoom = 0, this.maxzoom = 18, this.tileSize = 512, this.isTileClipped = true, this.reparseOverscaled = true, this._removed = false, this._pendingLoads = 0, this.actor = r8.getActor(), this.setEventedParent(o6), this._data = i6.data, this._options = t4.e({}, i6), this._collectResourceTiming = i6.collectResourceTiming, void 0 !== i6.maxzoom && (this.maxzoom = i6.maxzoom), i6.type && (this.type = i6.type), i6.attribution && (this.attribution = i6.attribution), this.promoteId = i6.promoteId, void 0 !== i6.clusterMaxZoom && this.maxzoom <= i6.clusterMaxZoom && t4.w(`The maxzoom value "${this.maxzoom}" is expected to be greater than the clusterMaxZoom value "${i6.clusterMaxZoom}".`), this.workerOptions = t4.e({ source: this.id, cluster: i6.cluster || false, geojsonVtOptions: { buffer: this._pixelsToTileUnits(void 0 !== i6.buffer ? i6.buffer : 128), tolerance: this._pixelsToTileUnits(void 0 !== i6.tolerance ? i6.tolerance : 0.375), extent: t4.Z, maxZoom: this.maxzoom, lineMetrics: i6.lineMetrics || false, generateId: i6.generateId || false }, superclusterOptions: { maxZoom: void 0 !== i6.clusterMaxZoom ? i6.clusterMaxZoom : this.maxzoom - 1, minPoints: Math.max(2, i6.clusterMinPoints || 2), extent: t4.Z, radius: this._pixelsToTileUnits(i6.clusterRadius || 50), log: false, generateId: i6.generateId || false }, clusterProperties: i6.clusterProperties, filter: i6.filter }, i6.workerOptions), "string" == typeof this.promoteId && (this.workerOptions.promoteId = this.promoteId);
          }
          _pixelsToTileUnits(e6) {
            return e6 * (t4.Z / this.tileSize);
          }
          load() {
            return t4._(this, void 0, void 0, function* () {
              yield this._updateWorkerData();
            });
          }
          onAdd(e6) {
            this.map = e6, this.load();
          }
          setData(e6) {
            return this._data = e6, this._updateWorkerData(), this;
          }
          updateData(e6) {
            return this._updateWorkerData(e6), this;
          }
          getData() {
            return t4._(this, void 0, void 0, function* () {
              const e6 = t4.e({ type: this.type }, this.workerOptions);
              return this.actor.sendAsync({ type: "GD", data: e6 });
            });
          }
          getCoordinatesFromGeometry(e6) {
            return "GeometryCollection" === e6.type ? e6.geometries.map((e7) => e7.coordinates).flat(1 / 0) : e6.coordinates.flat(1 / 0);
          }
          getBounds() {
            return t4._(this, void 0, void 0, function* () {
              const e6 = new V2(), t5 = yield this.getData();
              let i6;
              switch (t5.type) {
                case "FeatureCollection":
                  i6 = t5.features.map((e7) => this.getCoordinatesFromGeometry(e7.geometry)).flat(1 / 0);
                  break;
                case "Feature":
                  i6 = this.getCoordinatesFromGeometry(t5.geometry);
                  break;
                default:
                  i6 = this.getCoordinatesFromGeometry(t5);
              }
              if (0 == i6.length) return e6;
              for (let t6 = 0; t6 < i6.length - 1; t6 += 2) e6.extend([i6[t6], i6[t6 + 1]]);
              return e6;
            });
          }
          setClusterOptions(e6) {
            return this.workerOptions.cluster = e6.cluster, e6 && (void 0 !== e6.clusterRadius && (this.workerOptions.superclusterOptions.radius = this._pixelsToTileUnits(e6.clusterRadius)), void 0 !== e6.clusterMaxZoom && (this.workerOptions.superclusterOptions.maxZoom = e6.clusterMaxZoom)), this._updateWorkerData(), this;
          }
          getClusterExpansionZoom(e6) {
            return this.actor.sendAsync({ type: "GCEZ", data: { type: this.type, clusterId: e6, source: this.id } });
          }
          getClusterChildren(e6) {
            return this.actor.sendAsync({ type: "GCC", data: { type: this.type, clusterId: e6, source: this.id } });
          }
          getClusterLeaves(e6, t5, i6) {
            return this.actor.sendAsync({ type: "GCL", data: { type: this.type, source: this.id, clusterId: e6, limit: t5, offset: i6 } });
          }
          _updateWorkerData(e6) {
            return t4._(this, void 0, void 0, function* () {
              const i6 = t4.e({ type: this.type }, this.workerOptions);
              e6 ? i6.dataDiff = e6 : "string" == typeof this._data ? (i6.request = this.map._requestManager.transformRequest(s3.resolveURL(this._data), "Source"), i6.request.collectResourceTiming = this._collectResourceTiming) : i6.data = JSON.stringify(this._data), this._pendingLoads++, this.fire(new t4.l("dataloading", { dataType: "source" }));
              try {
                const e7 = yield this.actor.sendAsync({ type: "LD", data: i6 });
                if (this._pendingLoads--, this._removed || e7.abandoned) return void this.fire(new t4.l("dataabort", { dataType: "source" }));
                let r8 = null;
                e7.resourceTiming && e7.resourceTiming[this.id] && (r8 = e7.resourceTiming[this.id].slice(0));
                const o6 = { dataType: "source" };
                this._collectResourceTiming && r8 && r8.length > 0 && t4.e(o6, { resourceTiming: r8 }), this.fire(new t4.l("data", Object.assign(Object.assign({}, o6), { sourceDataType: "metadata" }))), this.fire(new t4.l("data", Object.assign(Object.assign({}, o6), { sourceDataType: "content" })));
              } catch (e7) {
                if (this._pendingLoads--, this._removed) return void this.fire(new t4.l("dataabort", { dataType: "source" }));
                this.fire(new t4.k(e7));
              }
            });
          }
          loaded() {
            return 0 === this._pendingLoads;
          }
          loadTile(e6) {
            return t4._(this, void 0, void 0, function* () {
              const t5 = e6.actor ? "RT" : "LT";
              e6.actor = this.actor;
              const i6 = { type: this.type, uid: e6.uid, tileID: e6.tileID, zoom: e6.tileID.overscaledZ, maxZoom: this.maxzoom, tileSize: this.tileSize, source: this.id, pixelRatio: this.map.getPixelRatio(), showCollisionBoxes: this.map.showCollisionBoxes, promoteId: this.promoteId, subdivisionGranularity: this.map.style.projection.subdivisionGranularity };
              e6.abortController = new AbortController();
              const r8 = yield this.actor.sendAsync({ type: t5, data: i6 }, e6.abortController);
              delete e6.abortController, e6.unloadVectorData(), e6.aborted || e6.loadVectorData(r8, this.map.painter, "RT" === t5);
            });
          }
          abortTile(e6) {
            return t4._(this, void 0, void 0, function* () {
              e6.abortController && (e6.abortController.abort(), delete e6.abortController), e6.aborted = true;
            });
          }
          unloadTile(e6) {
            return t4._(this, void 0, void 0, function* () {
              e6.unloadVectorData(), yield this.actor.sendAsync({ type: "RMT", data: { uid: e6.uid, type: this.type, source: this.id } });
            });
          }
          onRemove() {
            this._removed = true, this.actor.sendAsync({ type: "RS", data: { type: this.type, source: this.id } });
          }
          serialize() {
            return t4.e({}, this._options, { type: this.type, data: this._data });
          }
          hasTransition() {
            return false;
          }
        }
        class X2 extends t4.E {
          constructor(e6, t5, i6, r8) {
            super(), this.flippedWindingOrder = false, this.id = e6, this.dispatcher = i6, this.coordinates = t5.coordinates, this.type = "image", this.minzoom = 0, this.maxzoom = 22, this.tileSize = 512, this.tiles = {}, this._loaded = false, this.setEventedParent(r8), this.options = t5;
          }
          load(e6) {
            return t4._(this, void 0, void 0, function* () {
              this._loaded = false, this.fire(new t4.l("dataloading", { dataType: "source" })), this.url = this.options.url, this._request = new AbortController();
              try {
                const t5 = yield p3.getImage(this.map._requestManager.transformRequest(this.url, "Image"), this._request);
                this._request = null, this._loaded = true, t5 && t5.data && (this.image = t5.data, e6 && (this.coordinates = e6), this._finishLoading());
              } catch (e7) {
                this._request = null, this._loaded = true, this.fire(new t4.k(e7));
              }
            });
          }
          loaded() {
            return this._loaded;
          }
          updateImage(e6) {
            return e6.url ? (this._request && (this._request.abort(), this._request = null), this.options.url = e6.url, this.load(e6.coordinates).finally(() => {
              this.texture = null;
            }), this) : this;
          }
          _finishLoading() {
            this.map && (this.setCoordinates(this.coordinates), this.fire(new t4.l("data", { dataType: "source", sourceDataType: "metadata" })));
          }
          onAdd(e6) {
            this.map = e6, this.load();
          }
          onRemove() {
            this._request && (this._request.abort(), this._request = null);
          }
          setCoordinates(e6) {
            this.coordinates = e6;
            const i6 = e6.map(t4.$.fromLngLat);
            var r8;
            return this.tileID = function(e7) {
              let i7 = 1 / 0, r9 = 1 / 0, o6 = -1 / 0, a4 = -1 / 0;
              for (const t5 of e7) i7 = Math.min(i7, t5.x), r9 = Math.min(r9, t5.y), o6 = Math.max(o6, t5.x), a4 = Math.max(a4, t5.y);
              const s4 = Math.max(o6 - i7, a4 - r9), n6 = Math.max(0, Math.floor(-Math.log(s4) / Math.LN2)), l5 = Math.pow(2, n6);
              return new t4.a1(n6, Math.floor((i7 + o6) / 2 * l5), Math.floor((r9 + a4) / 2 * l5));
            }(i6), this.terrainTileRanges = this._getOverlappingTileRanges(i6), this.minzoom = this.maxzoom = this.tileID.z, this.tileCoords = i6.map((e7) => this.tileID.getTilePoint(e7)._round()), this.flippedWindingOrder = ((r8 = this.tileCoords)[1].x - r8[0].x) * (r8[2].y - r8[0].y) - (r8[1].y - r8[0].y) * (r8[2].x - r8[0].x) < 0, this.fire(new t4.l("data", { dataType: "source", sourceDataType: "content" })), this;
          }
          prepare() {
            if (0 === Object.keys(this.tiles).length || !this.image) return;
            const e6 = this.map.painter.context, i6 = e6.gl;
            this.texture || (this.texture = new v3(e6, this.image, i6.RGBA), this.texture.bind(i6.LINEAR, i6.CLAMP_TO_EDGE));
            let r8 = false;
            for (const e7 in this.tiles) {
              const t5 = this.tiles[e7];
              "loaded" !== t5.state && (t5.state = "loaded", t5.texture = this.texture, r8 = true);
            }
            r8 && this.fire(new t4.l("data", { dataType: "source", sourceDataType: "idle", sourceId: this.id }));
          }
          loadTile(e6) {
            return t4._(this, void 0, void 0, function* () {
              this.tileID && this.tileID.equals(e6.tileID.canonical) ? (this.tiles[String(e6.tileID.wrap)] = e6, e6.buckets = {}) : e6.state = "errored";
            });
          }
          serialize() {
            return { type: "image", url: this.options.url, coordinates: this.coordinates };
          }
          hasTransition() {
            return false;
          }
          _getOverlappingTileRanges(e6) {
            let i6 = 1 / 0, r8 = 1 / 0, o6 = -1 / 0, a4 = -1 / 0;
            for (const t5 of e6) i6 = Math.min(i6, t5.x), r8 = Math.min(r8, t5.y), o6 = Math.max(o6, t5.x), a4 = Math.max(a4, t5.y);
            const s4 = {};
            for (let e7 = 0; e7 <= t4.a0; e7++) {
              const t5 = Math.pow(2, e7), n6 = Math.floor(i6 * t5), l5 = Math.floor(r8 * t5), c5 = Math.floor(o6 * t5), h4 = Math.floor(a4 * t5);
              s4[e7] = { minTileX: n6, minTileY: l5, maxTileX: c5, maxTileY: h4 };
            }
            return s4;
          }
        }
        class Q2 extends X2 {
          constructor(e6, t5, i6, r8) {
            super(e6, t5, i6, r8), this.roundZoom = true, this.type = "video", this.options = t5;
          }
          load() {
            return t4._(this, void 0, void 0, function* () {
              this._loaded = false;
              const e6 = this.options;
              this.urls = [];
              for (const t5 of e6.urls) this.urls.push(this.map._requestManager.transformRequest(t5, "Source").url);
              try {
                const e7 = yield t4.a2(this.urls);
                if (this._loaded = true, !e7) return;
                this.video = e7, this.video.loop = true, this.video.addEventListener("playing", () => {
                  this.map.triggerRepaint();
                }), this.map && this.video.play(), this._finishLoading();
              } catch (e7) {
                this.fire(new t4.k(e7));
              }
            });
          }
          pause() {
            this.video && this.video.pause();
          }
          play() {
            this.video && this.video.play();
          }
          seek(e6) {
            if (this.video) {
              const i6 = this.video.seekable;
              e6 < i6.start(0) || e6 > i6.end(0) ? this.fire(new t4.k(new t4.a3(`sources.${this.id}`, null, `Playback for this video can be set only between the ${i6.start(0)} and ${i6.end(0)}-second mark.`))) : this.video.currentTime = e6;
            }
          }
          getVideo() {
            return this.video;
          }
          onAdd(e6) {
            this.map || (this.map = e6, this.load(), this.video && (this.video.play(), this.setCoordinates(this.coordinates)));
          }
          prepare() {
            if (0 === Object.keys(this.tiles).length || this.video.readyState < 2) return;
            const e6 = this.map.painter.context, i6 = e6.gl;
            this.texture ? this.video.paused || (this.texture.bind(i6.LINEAR, i6.CLAMP_TO_EDGE), i6.texSubImage2D(i6.TEXTURE_2D, 0, 0, 0, i6.RGBA, i6.UNSIGNED_BYTE, this.video)) : (this.texture = new v3(e6, this.video, i6.RGBA), this.texture.bind(i6.LINEAR, i6.CLAMP_TO_EDGE));
            let r8 = false;
            for (const e7 in this.tiles) {
              const t5 = this.tiles[e7];
              "loaded" !== t5.state && (t5.state = "loaded", t5.texture = this.texture, r8 = true);
            }
            r8 && this.fire(new t4.l("data", { dataType: "source", sourceDataType: "idle", sourceId: this.id }));
          }
          serialize() {
            return { type: "video", urls: this.urls, coordinates: this.coordinates };
          }
          hasTransition() {
            return this.video && !this.video.paused;
          }
        }
        class Y2 extends X2 {
          constructor(e6, i6, r8, o6) {
            super(e6, i6, r8, o6), i6.coordinates ? Array.isArray(i6.coordinates) && 4 === i6.coordinates.length && !i6.coordinates.some((e7) => !Array.isArray(e7) || 2 !== e7.length || e7.some((e8) => "number" != typeof e8)) || this.fire(new t4.k(new t4.a3(`sources.${e6}`, null, '"coordinates" property must be an array of 4 longitude/latitude array pairs'))) : this.fire(new t4.k(new t4.a3(`sources.${e6}`, null, 'missing required property "coordinates"'))), i6.animate && "boolean" != typeof i6.animate && this.fire(new t4.k(new t4.a3(`sources.${e6}`, null, 'optional "animate" property must be a boolean value'))), i6.canvas ? "string" == typeof i6.canvas || i6.canvas instanceof HTMLCanvasElement || this.fire(new t4.k(new t4.a3(`sources.${e6}`, null, '"canvas" must be either a string representing the ID of the canvas element from which to read, or an HTMLCanvasElement instance'))) : this.fire(new t4.k(new t4.a3(`sources.${e6}`, null, 'missing required property "canvas"'))), this.options = i6, this.animate = void 0 === i6.animate || i6.animate;
          }
          load() {
            return t4._(this, void 0, void 0, function* () {
              this._loaded = true, this.canvas || (this.canvas = this.options.canvas instanceof HTMLCanvasElement ? this.options.canvas : document.getElementById(this.options.canvas)), this.width = this.canvas.width, this.height = this.canvas.height, this._hasInvalidDimensions() ? this.fire(new t4.k(new Error("Canvas dimensions cannot be less than or equal to zero."))) : (this.play = function() {
                this._playing = true, this.map.triggerRepaint();
              }, this.pause = function() {
                this._playing && (this.prepare(), this._playing = false);
              }, this._finishLoading());
            });
          }
          getCanvas() {
            return this.canvas;
          }
          onAdd(e6) {
            this.map = e6, this.load(), this.canvas && this.animate && this.play();
          }
          onRemove() {
            this.pause();
          }
          prepare() {
            let e6 = false;
            if (this.canvas.width !== this.width && (this.width = this.canvas.width, e6 = true), this.canvas.height !== this.height && (this.height = this.canvas.height, e6 = true), this._hasInvalidDimensions()) return;
            if (0 === Object.keys(this.tiles).length) return;
            const i6 = this.map.painter.context, r8 = i6.gl;
            this.texture ? (e6 || this._playing) && this.texture.update(this.canvas, { premultiply: true }) : this.texture = new v3(i6, this.canvas, r8.RGBA, { premultiply: true });
            let o6 = false;
            for (const e7 in this.tiles) {
              const t5 = this.tiles[e7];
              "loaded" !== t5.state && (t5.state = "loaded", t5.texture = this.texture, o6 = true);
            }
            o6 && this.fire(new t4.l("data", { dataType: "source", sourceDataType: "idle", sourceId: this.id }));
          }
          serialize() {
            return { type: "canvas", coordinates: this.coordinates };
          }
          hasTransition() {
            return this._playing;
          }
          _hasInvalidDimensions() {
            for (const e6 of [this.canvas.width, this.canvas.height]) if (isNaN(e6) || e6 <= 0) return true;
            return false;
          }
        }
        const J2 = {}, ee = (e6) => {
          switch (e6) {
            case "geojson":
              return K2;
            case "image":
              return X2;
            case "raster":
              return $2;
            case "raster-dem":
              return H4;
            case "vector":
              return W;
            case "video":
              return Q2;
            case "canvas":
              return Y2;
          }
          return J2[e6];
        }, te = "RTLPluginLoaded";
        class ie2 extends t4.E {
          constructor() {
            super(...arguments), this.status = "unavailable", this.url = null, this.dispatcher = O2();
          }
          _syncState(e6) {
            return this.status = e6, this.dispatcher.broadcast("SRPS", { pluginStatus: e6, pluginURL: this.url }).catch((e7) => {
              throw this.status = "error", e7;
            });
          }
          getRTLTextPluginStatus() {
            return this.status;
          }
          clearRTLTextPlugin() {
            this.status = "unavailable", this.url = null;
          }
          setRTLTextPlugin(e6) {
            return t4._(this, arguments, void 0, function* (e7, t5 = false) {
              if (this.url) throw new Error("setRTLTextPlugin cannot be called multiple times.");
              if (this.url = s3.resolveURL(e7), !this.url) throw new Error(`requested url ${e7} is invalid`);
              if ("unavailable" === this.status) {
                if (!t5) return this._requestImport();
                this.status = "deferred", this._syncState(this.status);
              } else if ("requested" === this.status) return this._requestImport();
            });
          }
          _requestImport() {
            return t4._(this, void 0, void 0, function* () {
              yield this._syncState("loading"), this.status = "loaded", this.fire(new t4.l(te));
            });
          }
          lazyLoad() {
            "unavailable" === this.status ? this.status = "requested" : "deferred" === this.status && this._requestImport();
          }
        }
        let re2 = null;
        function oe() {
          return re2 || (re2 = new ie2()), re2;
        }
        class ae {
          constructor(e6, i6) {
            this.timeAdded = 0, this.fadeEndTime = 0, this.tileID = e6, this.uid = t4.a4(), this.uses = 0, this.tileSize = i6, this.buckets = {}, this.expirationTime = null, this.queryPadding = 0, this.hasSymbolBuckets = false, this.hasRTLText = false, this.dependencies = {}, this.rtt = [], this.rttCoords = {}, this.expiredRequestCount = 0, this.state = "loading";
          }
          registerFadeDuration(e6) {
            const t5 = e6 + this.timeAdded;
            t5 < this.fadeEndTime || (this.fadeEndTime = t5);
          }
          wasRequested() {
            return "errored" === this.state || "loaded" === this.state || "reloading" === this.state;
          }
          clearTextures(e6) {
            this.demTexture && e6.saveTileTexture(this.demTexture), this.demTexture = null;
          }
          loadVectorData(e6, i6, r8) {
            if (this.hasData() && this.unloadVectorData(), this.state = "loaded", e6) {
              e6.featureIndex && (this.latestFeatureIndex = e6.featureIndex, e6.rawTileData ? (this.latestRawTileData = e6.rawTileData, this.latestFeatureIndex.rawTileData = e6.rawTileData) : this.latestRawTileData && (this.latestFeatureIndex.rawTileData = this.latestRawTileData)), this.collisionBoxArray = e6.collisionBoxArray, this.buckets = function(e7, t5) {
                const i7 = {};
                if (!t5) return i7;
                for (const r9 of e7) {
                  const e8 = r9.layerIds.map((e9) => t5.getLayer(e9)).filter(Boolean);
                  if (0 !== e8.length) {
                    r9.layers = e8, r9.stateDependentLayerIds && (r9.stateDependentLayers = r9.stateDependentLayerIds.map((t6) => e8.filter((e9) => e9.id === t6)[0]));
                    for (const t6 of e8) i7[t6.id] = r9;
                  }
                }
                return i7;
              }(e6.buckets, null == i6 ? void 0 : i6.style), this.hasSymbolBuckets = false;
              for (const e7 in this.buckets) {
                const i7 = this.buckets[e7];
                if (i7 instanceof t4.a6) {
                  if (this.hasSymbolBuckets = true, !r8) break;
                  i7.justReloaded = true;
                }
              }
              if (this.hasRTLText = false, this.hasSymbolBuckets) for (const e7 in this.buckets) {
                const i7 = this.buckets[e7];
                if (i7 instanceof t4.a6 && i7.hasRTLText) {
                  this.hasRTLText = true, oe().lazyLoad();
                  break;
                }
              }
              this.queryPadding = 0;
              for (const e7 in this.buckets) {
                const t5 = this.buckets[e7];
                this.queryPadding = Math.max(this.queryPadding, i6.style.getLayer(e7).queryRadius(t5));
              }
              e6.imageAtlas && (this.imageAtlas = e6.imageAtlas), e6.glyphAtlasImage && (this.glyphAtlasImage = e6.glyphAtlasImage);
            } else this.collisionBoxArray = new t4.a5();
          }
          unloadVectorData() {
            for (const e6 in this.buckets) this.buckets[e6].destroy();
            this.buckets = {}, this.imageAtlasTexture && this.imageAtlasTexture.destroy(), this.imageAtlas && (this.imageAtlas = null), this.glyphAtlasTexture && this.glyphAtlasTexture.destroy(), this.latestFeatureIndex = null, this.state = "unloaded";
          }
          getBucket(e6) {
            return this.buckets[e6.id];
          }
          upload(e6) {
            for (const t6 in this.buckets) {
              const i6 = this.buckets[t6];
              i6.uploadPending() && i6.upload(e6);
            }
            const t5 = e6.gl;
            this.imageAtlas && !this.imageAtlas.uploaded && (this.imageAtlasTexture = new v3(e6, this.imageAtlas.image, t5.RGBA), this.imageAtlas.uploaded = true), this.glyphAtlasImage && (this.glyphAtlasTexture = new v3(e6, this.glyphAtlasImage, t5.ALPHA), this.glyphAtlasImage = null);
          }
          prepare(e6) {
            this.imageAtlas && this.imageAtlas.patchUpdatedImages(e6, this.imageAtlasTexture);
          }
          queryRenderedFeatures(e6, t5, i6, r8, o6, a4, s4, n6, l5, c5, h4) {
            return this.latestFeatureIndex && this.latestFeatureIndex.rawTileData ? this.latestFeatureIndex.query({ queryGeometry: r8, cameraQueryGeometry: o6, scale: a4, tileSize: this.tileSize, pixelPosMatrix: c5, transform: n6, params: s4, queryPadding: this.queryPadding * l5, getElevation: h4 }, e6, t5, i6) : {};
          }
          querySourceFeatures(e6, i6) {
            const r8 = this.latestFeatureIndex;
            if (!r8 || !r8.rawTileData) return;
            const o6 = r8.loadVTLayers(), a4 = i6 && i6.sourceLayer ? i6.sourceLayer : "", s4 = o6._geojsonTileLayer || o6[a4];
            if (!s4) return;
            const n6 = t4.a7(i6 && i6.filter), { z: l5, x: c5, y: h4 } = this.tileID.canonical, u4 = { z: l5, x: c5, y: h4 };
            for (let i7 = 0; i7 < s4.length; i7++) {
              const o7 = s4.feature(i7);
              if (n6.needGeometry) {
                const e7 = t4.a8(o7, true);
                if (!n6.filter(new t4.C(this.tileID.overscaledZ), e7, this.tileID.canonical)) continue;
              } else if (!n6.filter(new t4.C(this.tileID.overscaledZ), o7)) continue;
              const d4 = r8.getId(o7, a4), _4 = new t4.a9(o7, l5, c5, h4, d4);
              _4.tile = u4, e6.push(_4);
            }
          }
          hasData() {
            return "loaded" === this.state || "reloading" === this.state || "expired" === this.state;
          }
          patternsLoaded() {
            return this.imageAtlas && !!Object.keys(this.imageAtlas.patternPositions).length;
          }
          setExpiryData(e6) {
            const i6 = this.expirationTime;
            if (e6.cacheControl) {
              const i7 = t4.aa(e6.cacheControl);
              i7["max-age"] && (this.expirationTime = Date.now() + 1e3 * i7["max-age"]);
            } else e6.expires && (this.expirationTime = new Date(e6.expires).getTime());
            if (this.expirationTime) {
              const e7 = Date.now();
              let t5 = false;
              if (this.expirationTime > e7) t5 = false;
              else if (i6) if (this.expirationTime < i6) t5 = true;
              else {
                const r8 = this.expirationTime - i6;
                r8 ? this.expirationTime = e7 + Math.max(r8, 3e4) : t5 = true;
              }
              else t5 = true;
              t5 ? (this.expiredRequestCount++, this.state = "expired") : this.expiredRequestCount = 0;
            }
          }
          getExpiryTimeout() {
            if (this.expirationTime) return this.expiredRequestCount ? 1e3 * (1 << Math.min(this.expiredRequestCount - 1, 31)) : Math.min(this.expirationTime - (/* @__PURE__ */ new Date()).getTime(), Math.pow(2, 31) - 1);
          }
          setFeatureState(e6, t5) {
            if (!this.latestFeatureIndex || !this.latestFeatureIndex.rawTileData || 0 === Object.keys(e6).length) return;
            const i6 = this.latestFeatureIndex.loadVTLayers();
            for (const r8 in this.buckets) {
              if (!t5.style.hasLayer(r8)) continue;
              const o6 = this.buckets[r8], a4 = o6.layers[0].sourceLayer || "_geojsonTileLayer", s4 = i6[a4], n6 = e6[a4];
              if (!s4 || !n6 || 0 === Object.keys(n6).length) continue;
              o6.update(n6, s4, this.imageAtlas && this.imageAtlas.patternPositions || {});
              const l5 = t5 && t5.style && t5.style.getLayer(r8);
              l5 && (this.queryPadding = Math.max(this.queryPadding, l5.queryRadius(o6)));
            }
          }
          holdingForFade() {
            return void 0 !== this.symbolFadeHoldUntil;
          }
          symbolFadeFinished() {
            return !this.symbolFadeHoldUntil || this.symbolFadeHoldUntil < s3.now();
          }
          clearFadeHold() {
            this.symbolFadeHoldUntil = void 0;
          }
          setHoldDuration(e6) {
            this.symbolFadeHoldUntil = s3.now() + e6;
          }
          setDependencies(e6, t5) {
            const i6 = {};
            for (const e7 of t5) i6[e7] = true;
            this.dependencies[e6] = i6;
          }
          hasDependency(e6, t5) {
            for (const i6 of e6) {
              const e7 = this.dependencies[i6];
              if (e7) {
                for (const i7 of t5) if (e7[i7]) return true;
              }
            }
            return false;
          }
        }
        class se {
          constructor(e6, t5) {
            this.max = e6, this.onRemove = t5, this.reset();
          }
          reset() {
            for (const e6 in this.data) for (const t5 of this.data[e6]) t5.timeout && clearTimeout(t5.timeout), this.onRemove(t5.value);
            return this.data = {}, this.order = [], this;
          }
          add(e6, t5, i6) {
            const r8 = e6.wrapped().key;
            void 0 === this.data[r8] && (this.data[r8] = []);
            const o6 = { value: t5, timeout: void 0 };
            if (void 0 !== i6 && (o6.timeout = setTimeout(() => {
              this.remove(e6, o6);
            }, i6)), this.data[r8].push(o6), this.order.push(r8), this.order.length > this.max) {
              const e7 = this._getAndRemoveByKey(this.order[0]);
              e7 && this.onRemove(e7);
            }
            return this;
          }
          has(e6) {
            return e6.wrapped().key in this.data;
          }
          getAndRemove(e6) {
            return this.has(e6) ? this._getAndRemoveByKey(e6.wrapped().key) : null;
          }
          _getAndRemoveByKey(e6) {
            const t5 = this.data[e6].shift();
            return t5.timeout && clearTimeout(t5.timeout), 0 === this.data[e6].length && delete this.data[e6], this.order.splice(this.order.indexOf(e6), 1), t5.value;
          }
          getByKey(e6) {
            const t5 = this.data[e6];
            return t5 ? t5[0].value : null;
          }
          get(e6) {
            return this.has(e6) ? this.data[e6.wrapped().key][0].value : null;
          }
          remove(e6, t5) {
            if (!this.has(e6)) return this;
            const i6 = e6.wrapped().key, r8 = void 0 === t5 ? 0 : this.data[i6].indexOf(t5), o6 = this.data[i6][r8];
            return this.data[i6].splice(r8, 1), o6.timeout && clearTimeout(o6.timeout), 0 === this.data[i6].length && delete this.data[i6], this.onRemove(o6.value), this.order.splice(this.order.indexOf(i6), 1), this;
          }
          setMaxSize(e6) {
            for (this.max = e6; this.order.length > this.max; ) {
              const e7 = this._getAndRemoveByKey(this.order[0]);
              e7 && this.onRemove(e7);
            }
            return this;
          }
          filter(e6) {
            const t5 = [];
            for (const i6 in this.data) for (const r8 of this.data[i6]) e6(r8.value) || t5.push(r8);
            for (const e7 of t5) this.remove(e7.value.tileID, e7);
          }
        }
        class ne {
          constructor() {
            this.state = {}, this.stateChanges = {}, this.deletedStates = {};
          }
          updateState(e6, i6, r8) {
            const o6 = String(i6);
            if (this.stateChanges[e6] = this.stateChanges[e6] || {}, this.stateChanges[e6][o6] = this.stateChanges[e6][o6] || {}, t4.e(this.stateChanges[e6][o6], r8), null === this.deletedStates[e6]) {
              this.deletedStates[e6] = {};
              for (const t5 in this.state[e6]) t5 !== o6 && (this.deletedStates[e6][t5] = null);
            } else if (this.deletedStates[e6] && null === this.deletedStates[e6][o6]) {
              this.deletedStates[e6][o6] = {};
              for (const t5 in this.state[e6][o6]) r8[t5] || (this.deletedStates[e6][o6][t5] = null);
            } else for (const t5 in r8) this.deletedStates[e6] && this.deletedStates[e6][o6] && null === this.deletedStates[e6][o6][t5] && delete this.deletedStates[e6][o6][t5];
          }
          removeFeatureState(e6, t5, i6) {
            if (null === this.deletedStates[e6]) return;
            const r8 = String(t5);
            if (this.deletedStates[e6] = this.deletedStates[e6] || {}, i6 && void 0 !== t5) null !== this.deletedStates[e6][r8] && (this.deletedStates[e6][r8] = this.deletedStates[e6][r8] || {}, this.deletedStates[e6][r8][i6] = null);
            else if (void 0 !== t5) if (this.stateChanges[e6] && this.stateChanges[e6][r8]) for (i6 in this.deletedStates[e6][r8] = {}, this.stateChanges[e6][r8]) this.deletedStates[e6][r8][i6] = null;
            else this.deletedStates[e6][r8] = null;
            else this.deletedStates[e6] = null;
          }
          getState(e6, i6) {
            const r8 = String(i6), o6 = t4.e({}, (this.state[e6] || {})[r8], (this.stateChanges[e6] || {})[r8]);
            if (null === this.deletedStates[e6]) return {};
            if (this.deletedStates[e6]) {
              const t5 = this.deletedStates[e6][i6];
              if (null === t5) return {};
              for (const e7 in t5) delete o6[e7];
            }
            return o6;
          }
          initializeTileState(e6, t5) {
            e6.setFeatureState(this.state, t5);
          }
          coalesceChanges(e6, i6) {
            const r8 = {};
            for (const e7 in this.stateChanges) {
              this.state[e7] = this.state[e7] || {};
              const i7 = {};
              for (const r9 in this.stateChanges[e7]) this.state[e7][r9] || (this.state[e7][r9] = {}), t4.e(this.state[e7][r9], this.stateChanges[e7][r9]), i7[r9] = this.state[e7][r9];
              r8[e7] = i7;
            }
            for (const e7 in this.deletedStates) {
              this.state[e7] = this.state[e7] || {};
              const i7 = {};
              if (null === this.deletedStates[e7]) for (const t5 in this.state[e7]) i7[t5] = {}, this.state[e7][t5] = {};
              else for (const t5 in this.deletedStates[e7]) {
                if (null === this.deletedStates[e7][t5]) this.state[e7][t5] = {};
                else for (const i8 of Object.keys(this.deletedStates[e7][t5])) delete this.state[e7][t5][i8];
                i7[t5] = this.state[e7][t5];
              }
              r8[e7] = r8[e7] || {}, t4.e(r8[e7], i7);
            }
            if (this.stateChanges = {}, this.deletedStates = {}, 0 !== Object.keys(r8).length) for (const t5 in e6) e6[t5].setFeatureState(r8, i6);
          }
        }
        function le(e6, t5, i6) {
          const r8 = t5.intersectsFrustum(e6);
          if (!i6) return r8;
          const o6 = t5.intersectsPlane(i6);
          return 0 === r8 || 0 === o6 ? 0 : 2 === r8 && 2 === o6 ? 2 : 1;
        }
        function ce(e6, i6, r8, o6, a4) {
          let s4 = e6;
          const n6 = Math.atan(i6 / r8), l5 = Math.hypot(i6, r8);
          return s4 = e6 + t4.ab(o6 / l5 / Math.max(0.5, Math.cos(t4.ad(a4 / 2)))), s4 += 1 * t4.ab(Math.cos(n6)) / 2, s4 += t4.ae(e6 - s4, -0, 0), s4;
        }
        function he(e6, i6) {
          const r8 = (i6.roundZoom ? Math.round : Math.floor)(e6.zoom + t4.ab(e6.tileSize / i6.tileSize));
          return Math.max(0, r8);
        }
        function ue(e6, i6) {
          const r8 = e6.getCameraFrustum(), o6 = e6.getClippingPlane(), a4 = e6.screenPointToMercatorCoordinate(e6.getCameraPoint()), s4 = t4.$.fromLngLat(e6.center, e6.elevation);
          a4.z = s4.z + Math.cos(e6.pitchInRadians) * e6.cameraToCenterDistance / e6.worldSize;
          const n6 = e6.getCoveringTilesDetailsProvider(), l5 = n6.allowVariableZoom(e6, i6), c5 = he(e6, i6), h4 = i6.minzoom || 0, u4 = void 0 !== i6.maxzoom ? i6.maxzoom : e6.maxZoom, d4 = Math.min(Math.max(0, c5), u4), _4 = Math.pow(2, d4), p4 = [_4 * a4.x, _4 * a4.y, 0], m4 = [_4 * s4.x, _4 * s4.y, 0], f4 = Math.hypot(s4.x - a4.x, s4.y - a4.y), g4 = Math.abs(s4.z - a4.z), v4 = Math.hypot(f4, g4), x4 = (e7) => ({ zoom: 0, x: 0, y: 0, wrap: e7, fullyVisible: false }), b5 = [], y4 = [];
          if (e6.renderWorldCopies && n6.allowWorldCopies()) for (let e7 = 1; e7 <= 3; e7++) b5.push(x4(-e7)), b5.push(x4(e7));
          for (b5.push(x4(0)); b5.length > 0; ) {
            const _5 = b5.pop(), f5 = _5.x, x5 = _5.y;
            let w4 = _5.fullyVisible;
            const T5 = { x: f5, y: x5, z: _5.zoom }, P4 = n6.getTileAABB(T5, _5.wrap, e6.elevation, i6);
            if (!w4) {
              const e7 = le(r8, P4, o6);
              if (0 === e7) continue;
              w4 = 2 === e7;
            }
            const C4 = n6.distanceToTile2d(a4.x, a4.y, T5, P4);
            let I4 = c5;
            l5 && (I4 = (i6.calculateTileZoom || ce)(e6.zoom + t4.ab(e6.tileSize / i6.tileSize), C4, g4, v4, e6.fov)), I4 = (i6.roundZoom ? Math.round : Math.floor)(I4), I4 = Math.max(0, I4);
            const M5 = Math.min(I4, u4);
            if (_5.wrap = n6.getWrap(s4, T5, _5.wrap), _5.zoom >= M5) {
              if (_5.zoom < h4) continue;
              const e7 = d4 - _5.zoom, r9 = p4[0] - 0.5 - (f5 << e7), o7 = p4[1] - 0.5 - (x5 << e7), a5 = i6.reparseOverscaled ? Math.max(_5.zoom, I4) : _5.zoom;
              y4.push({ tileID: new t4.Y(_5.zoom === u4 ? a5 : _5.zoom, _5.wrap, _5.zoom, f5, x5), distanceSq: t4.ac([m4[0] - 0.5 - f5, m4[1] - 0.5 - x5]), tileDistanceToCamera: Math.sqrt(r9 * r9 + o7 * o7) });
            } else for (let e7 = 0; e7 < 4; e7++) b5.push({ zoom: _5.zoom + 1, x: (f5 << 1) + e7 % 2, y: (x5 << 1) + (e7 >> 1), wrap: _5.wrap, fullyVisible: w4 });
          }
          return y4.sort((e7, t5) => e7.distanceSq - t5.distanceSq).map((e7) => e7.tileID);
        }
        class de extends t4.E {
          constructor(e6, t5, i6) {
            super(), this.id = e6, this.dispatcher = i6, this.on("data", (e7) => this._dataHandler(e7)), this.on("dataloading", () => {
              this._sourceErrored = false;
            }), this.on("error", () => {
              this._sourceErrored = this._source.loaded();
            }), this._source = ((e7, t6, i7, r8) => {
              const o6 = new (ee(t6.type))(e7, t6, i7, r8);
              if (o6.id !== e7) throw new Error(`Expected Source id to be ${e7} instead of ${o6.id}`);
              return o6;
            })(e6, t5, i6, this), this._tiles = {}, this._cache = new se(0, (e7) => this._unloadTile(e7)), this._timers = {}, this._cacheTimers = {}, this._maxTileCacheSize = null, this._maxTileCacheZoomLevels = null, this._loadedParentTiles = {}, this._coveredTiles = {}, this._state = new ne(), this._didEmitContent = false, this._updated = false;
          }
          onAdd(e6) {
            this.map = e6, this._maxTileCacheSize = e6 ? e6._maxTileCacheSize : null, this._maxTileCacheZoomLevels = e6 ? e6._maxTileCacheZoomLevels : null, this._source && this._source.onAdd && this._source.onAdd(e6);
          }
          onRemove(e6) {
            this.clearTiles(), this._source && this._source.onRemove && this._source.onRemove(e6);
          }
          loaded() {
            if (this._sourceErrored) return true;
            if (!this._sourceLoaded) return false;
            if (!this._source.loaded()) return false;
            if (!(void 0 === this.used && void 0 === this.usedForTerrain || this.used || this.usedForTerrain)) return true;
            if (!this._updated) return false;
            for (const e6 in this._tiles) {
              const t5 = this._tiles[e6];
              if ("loaded" !== t5.state && "errored" !== t5.state) return false;
            }
            return true;
          }
          getSource() {
            return this._source;
          }
          pause() {
            this._paused = true;
          }
          resume() {
            if (!this._paused) return;
            const e6 = this._shouldReloadOnResume;
            this._paused = false, this._shouldReloadOnResume = false, e6 && this.reload(), this.transform && this.update(this.transform, this.terrain);
          }
          _loadTile(e6, i6, r8) {
            return t4._(this, void 0, void 0, function* () {
              try {
                yield this._source.loadTile(e6), this._tileLoaded(e6, i6, r8);
              } catch (i7) {
                e6.state = "errored", 404 !== i7.status ? this._source.fire(new t4.k(i7, { tile: e6 })) : this.update(this.transform, this.terrain);
              }
            });
          }
          _unloadTile(e6) {
            this._source.unloadTile && this._source.unloadTile(e6);
          }
          _abortTile(e6) {
            this._source.abortTile && this._source.abortTile(e6), this._source.fire(new t4.l("dataabort", { tile: e6, coord: e6.tileID, dataType: "source" }));
          }
          serialize() {
            return this._source.serialize();
          }
          prepare(e6) {
            this._source.prepare && this._source.prepare(), this._state.coalesceChanges(this._tiles, this.map ? this.map.painter : null);
            for (const t5 in this._tiles) {
              const i6 = this._tiles[t5];
              i6.upload(e6), i6.prepare(this.map.style.imageManager);
            }
          }
          getIds() {
            return Object.values(this._tiles).map((e6) => e6.tileID).sort(_e).map((e6) => e6.key);
          }
          getRenderableIds(e6) {
            const i6 = [];
            for (const t5 in this._tiles) this._isIdRenderable(t5, e6) && i6.push(this._tiles[t5]);
            return e6 ? i6.sort((e7, i7) => {
              const r8 = e7.tileID, o6 = i7.tileID, a4 = new t4.P(r8.canonical.x, r8.canonical.y)._rotate(-this.transform.bearingInRadians), s4 = new t4.P(o6.canonical.x, o6.canonical.y)._rotate(-this.transform.bearingInRadians);
              return r8.overscaledZ - o6.overscaledZ || s4.y - a4.y || s4.x - a4.x;
            }).map((e7) => e7.tileID.key) : i6.map((e7) => e7.tileID).sort(_e).map((e7) => e7.key);
          }
          hasRenderableParent(e6) {
            const t5 = this.findLoadedParent(e6, 0);
            return !!t5 && this._isIdRenderable(t5.tileID.key);
          }
          _isIdRenderable(e6, t5) {
            return this._tiles[e6] && this._tiles[e6].hasData() && !this._coveredTiles[e6] && (t5 || !this._tiles[e6].holdingForFade());
          }
          reload(e6) {
            if (this._paused) this._shouldReloadOnResume = true;
            else {
              this._cache.reset();
              for (const t5 in this._tiles) (e6 || "errored" !== this._tiles[t5].state) && this._reloadTile(t5, "reloading");
            }
          }
          _reloadTile(e6, i6) {
            return t4._(this, void 0, void 0, function* () {
              const t5 = this._tiles[e6];
              t5 && ("loading" !== t5.state && (t5.state = i6), yield this._loadTile(t5, e6, i6));
            });
          }
          _tileLoaded(e6, i6, r8) {
            e6.timeAdded = s3.now(), "expired" === r8 && (e6.refreshedUponExpiration = true), this._setTileReloadTimer(i6, e6), "raster-dem" === this.getSource().type && e6.dem && this._backfillDEM(e6), this._state.initializeTileState(e6, this.map ? this.map.painter : null), e6.aborted || this._source.fire(new t4.l("data", { dataType: "source", tile: e6, coord: e6.tileID }));
          }
          _backfillDEM(e6) {
            const t5 = this.getRenderableIds();
            for (let r8 = 0; r8 < t5.length; r8++) {
              const o6 = t5[r8];
              if (e6.neighboringTiles && e6.neighboringTiles[o6]) {
                const t6 = this.getTileByID(o6);
                i6(e6, t6), i6(t6, e6);
              }
            }
            function i6(e7, t6) {
              e7.needsHillshadePrepare = true, e7.needsTerrainPrepare = true;
              let i7 = t6.tileID.canonical.x - e7.tileID.canonical.x;
              const r8 = t6.tileID.canonical.y - e7.tileID.canonical.y, o6 = Math.pow(2, e7.tileID.canonical.z), a4 = t6.tileID.key;
              0 === i7 && 0 === r8 || Math.abs(r8) > 1 || (Math.abs(i7) > 1 && (1 === Math.abs(i7 + o6) ? i7 += o6 : 1 === Math.abs(i7 - o6) && (i7 -= o6)), t6.dem && e7.dem && (e7.dem.backfillBorder(t6.dem, i7, r8), e7.neighboringTiles && e7.neighboringTiles[a4] && (e7.neighboringTiles[a4].backfilled = true)));
            }
          }
          getTile(e6) {
            return this.getTileByID(e6.key);
          }
          getTileByID(e6) {
            return this._tiles[e6];
          }
          _retainLoadedChildren(e6, t5, i6, r8) {
            for (const o6 in this._tiles) {
              let a4 = this._tiles[o6];
              if (r8[o6] || !a4.hasData() || a4.tileID.overscaledZ <= t5 || a4.tileID.overscaledZ > i6) continue;
              let s4 = a4.tileID;
              for (; a4 && a4.tileID.overscaledZ > t5 + 1; ) {
                const e7 = a4.tileID.scaledTo(a4.tileID.overscaledZ - 1);
                a4 = this._tiles[e7.key], a4 && a4.hasData() && (s4 = e7);
              }
              let n6 = s4;
              for (; n6.overscaledZ > t5; ) if (n6 = n6.scaledTo(n6.overscaledZ - 1), e6[n6.key] || e6[n6.canonical.key]) {
                r8[s4.key] = s4;
                break;
              }
            }
          }
          findLoadedParent(e6, t5) {
            if (e6.key in this._loadedParentTiles) {
              const i6 = this._loadedParentTiles[e6.key];
              return i6 && i6.tileID.overscaledZ >= t5 ? i6 : null;
            }
            for (let i6 = e6.overscaledZ - 1; i6 >= t5; i6--) {
              const t6 = e6.scaledTo(i6), r8 = this._getLoadedTile(t6);
              if (r8) return r8;
            }
          }
          findLoadedSibling(e6) {
            return this._getLoadedTile(e6);
          }
          _getLoadedTile(e6) {
            const t5 = this._tiles[e6.key];
            return t5 && t5.hasData() ? t5 : this._cache.getByKey(e6.wrapped().key);
          }
          updateCacheSize(e6) {
            const i6 = Math.ceil(e6.width / this._source.tileSize) + 1, r8 = Math.ceil(e6.height / this._source.tileSize) + 1, o6 = Math.floor(i6 * r8 * (null === this._maxTileCacheZoomLevels ? t4.a.MAX_TILE_CACHE_ZOOM_LEVELS : this._maxTileCacheZoomLevels)), a4 = "number" == typeof this._maxTileCacheSize ? Math.min(this._maxTileCacheSize, o6) : o6;
            this._cache.setMaxSize(a4);
          }
          handleWrapJump(e6) {
            const t5 = Math.round((e6 - (void 0 === this._prevLng ? e6 : this._prevLng)) / 360);
            if (this._prevLng = e6, t5) {
              const e7 = {};
              for (const i6 in this._tiles) {
                const r8 = this._tiles[i6];
                r8.tileID = r8.tileID.unwrapTo(r8.tileID.wrap + t5), e7[r8.tileID.key] = r8;
              }
              this._tiles = e7;
              for (const e8 in this._timers) clearTimeout(this._timers[e8]), delete this._timers[e8];
              for (const e8 in this._tiles) this._setTileReloadTimer(e8, this._tiles[e8]);
            }
          }
          _updateCoveredAndRetainedTiles(e6, t5, i6, r8, o6, a4) {
            const n6 = {}, l5 = {}, c5 = Object.keys(e6), h4 = s3.now();
            for (const i7 of c5) {
              const r9 = e6[i7], o7 = this._tiles[i7];
              if (!o7 || 0 !== o7.fadeEndTime && o7.fadeEndTime <= h4) continue;
              const a5 = this.findLoadedParent(r9, t5), s4 = this.findLoadedSibling(r9), c6 = a5 || s4 || null;
              c6 && (this._addTile(c6.tileID), n6[c6.tileID.key] = c6.tileID), l5[i7] = r9;
            }
            this._retainLoadedChildren(l5, r8, i6, e6);
            for (const t6 in n6) e6[t6] || (this._coveredTiles[t6] = true, e6[t6] = n6[t6]);
            if (a4) {
              const t6 = {}, i7 = {};
              for (const e7 of o6) this._tiles[e7.key].hasData() ? t6[e7.key] = e7 : i7[e7.key] = e7;
              for (const r9 in i7) {
                const o7 = i7[r9].children(this._source.maxzoom);
                this._tiles[o7[0].key] && this._tiles[o7[1].key] && this._tiles[o7[2].key] && this._tiles[o7[3].key] && (t6[o7[0].key] = e6[o7[0].key] = o7[0], t6[o7[1].key] = e6[o7[1].key] = o7[1], t6[o7[2].key] = e6[o7[2].key] = o7[2], t6[o7[3].key] = e6[o7[3].key] = o7[3], delete i7[r9]);
              }
              for (const r9 in i7) {
                const o7 = i7[r9], a5 = this.findLoadedParent(o7, this._source.minzoom), s4 = this.findLoadedSibling(o7), n7 = a5 || s4 || null;
                if (n7) {
                  t6[n7.tileID.key] = e6[n7.tileID.key] = n7.tileID;
                  for (const e7 in t6) t6[e7].isChildOf(n7.tileID) && delete t6[e7];
                }
              }
              for (const e7 in this._tiles) t6[e7] || (this._coveredTiles[e7] = true);
            }
          }
          update(e6, i6) {
            if (!this._sourceLoaded || this._paused) return;
            let r8;
            this.transform = e6, this.terrain = i6, this.updateCacheSize(e6), this.handleWrapJump(this.transform.center.lng), this._coveredTiles = {}, this.used || this.usedForTerrain ? this._source.tileID ? r8 = e6.getVisibleUnwrappedCoordinates(this._source.tileID).map((e7) => new t4.Y(e7.canonical.z, e7.wrap, e7.canonical.z, e7.canonical.x, e7.canonical.y)) : (r8 = ue(e6, { tileSize: this.usedForTerrain ? this.tileSize : this._source.tileSize, minzoom: this._source.minzoom, maxzoom: this._source.maxzoom, roundZoom: !this.usedForTerrain && this._source.roundZoom, reparseOverscaled: this._source.reparseOverscaled, terrain: i6, calculateTileZoom: this._source.calculateTileZoom }), this._source.hasTile && (r8 = r8.filter((e7) => this._source.hasTile(e7)))) : r8 = [];
            const o6 = he(e6, this._source), a4 = Math.max(o6 - de.maxOverzooming, this._source.minzoom), s4 = Math.max(o6 + de.maxUnderzooming, this._source.minzoom);
            if (this.usedForTerrain) {
              const e7 = {};
              for (const t5 of r8) if (t5.canonical.z > this._source.minzoom) {
                const i7 = t5.scaledTo(t5.canonical.z - 1);
                e7[i7.key] = i7;
                const r9 = t5.scaledTo(Math.max(this._source.minzoom, Math.min(t5.canonical.z, 5)));
                e7[r9.key] = r9;
              }
              r8 = r8.concat(Object.values(e7));
            }
            const n6 = 0 === r8.length && !this._updated && this._didEmitContent;
            this._updated = true, n6 && this.fire(new t4.l("data", { sourceDataType: "idle", dataType: "source", sourceId: this.id }));
            const l5 = this._updateRetainedTiles(r8, o6);
            pe(this._source.type) && this._updateCoveredAndRetainedTiles(l5, a4, s4, o6, r8, i6);
            for (const e7 in l5) this._tiles[e7].clearFadeHold();
            const c5 = t4.af(this._tiles, l5);
            for (const e7 of c5) {
              const t5 = this._tiles[e7];
              t5.hasSymbolBuckets && !t5.holdingForFade() ? t5.setHoldDuration(this.map._fadeDuration) : t5.hasSymbolBuckets && !t5.symbolFadeFinished() || this._removeTile(e7);
            }
            this._updateLoadedParentTileCache(), this._updateLoadedSiblingTileCache();
          }
          releaseSymbolFadeTiles() {
            for (const e6 in this._tiles) this._tiles[e6].holdingForFade() && this._removeTile(e6);
          }
          _updateRetainedTiles(e6, t5) {
            var i6;
            const r8 = {}, o6 = {}, a4 = Math.max(t5 - de.maxOverzooming, this._source.minzoom), s4 = Math.max(t5 + de.maxUnderzooming, this._source.minzoom), n6 = {};
            for (const i7 of e6) {
              const e7 = this._addTile(i7);
              r8[i7.key] = i7, e7.hasData() || t5 < this._source.maxzoom && (n6[i7.key] = i7);
            }
            this._retainLoadedChildren(n6, t5, s4, r8);
            for (const s5 of e6) {
              let e7 = this._tiles[s5.key];
              if (e7.hasData()) continue;
              if (t5 + 1 > this._source.maxzoom) {
                const e8 = s5.children(this._source.maxzoom)[0], t6 = this.getTile(e8);
                if (t6 && t6.hasData()) {
                  r8[e8.key] = e8;
                  continue;
                }
              } else {
                const e8 = s5.children(this._source.maxzoom);
                if (r8[e8[0].key] && r8[e8[1].key] && r8[e8[2].key] && r8[e8[3].key]) continue;
              }
              let n7 = e7.wasRequested();
              for (let t6 = s5.overscaledZ - 1; t6 >= a4; --t6) {
                const a5 = s5.scaledTo(t6);
                if (o6[a5.key]) break;
                if (o6[a5.key] = true, e7 = this.getTile(a5), !e7 && n7 && (e7 = this._addTile(a5)), e7) {
                  const t7 = e7.hasData();
                  if ((t7 || !(null === (i6 = this.map) || void 0 === i6 ? void 0 : i6.cancelPendingTileRequestsWhileZooming) || n7) && (r8[a5.key] = a5), n7 = e7.wasRequested(), t7) break;
                }
              }
            }
            return r8;
          }
          _updateLoadedParentTileCache() {
            this._loadedParentTiles = {};
            for (const e6 in this._tiles) {
              const t5 = [];
              let i6, r8 = this._tiles[e6].tileID;
              for (; r8.overscaledZ > 0; ) {
                if (r8.key in this._loadedParentTiles) {
                  i6 = this._loadedParentTiles[r8.key];
                  break;
                }
                t5.push(r8.key);
                const e7 = r8.scaledTo(r8.overscaledZ - 1);
                if (i6 = this._getLoadedTile(e7), i6) break;
                r8 = e7;
              }
              for (const e7 of t5) this._loadedParentTiles[e7] = i6;
            }
          }
          _updateLoadedSiblingTileCache() {
            this._loadedSiblingTiles = {};
            for (const e6 in this._tiles) {
              const t5 = this._tiles[e6].tileID, i6 = this._getLoadedTile(t5);
              this._loadedSiblingTiles[t5.key] = i6;
            }
          }
          _addTile(e6) {
            let i6 = this._tiles[e6.key];
            if (i6) return i6;
            i6 = this._cache.getAndRemove(e6), i6 && (this._setTileReloadTimer(e6.key, i6), i6.tileID = e6, this._state.initializeTileState(i6, this.map ? this.map.painter : null), this._cacheTimers[e6.key] && (clearTimeout(this._cacheTimers[e6.key]), delete this._cacheTimers[e6.key], this._setTileReloadTimer(e6.key, i6)));
            const r8 = i6;
            return i6 || (i6 = new ae(e6, this._source.tileSize * e6.overscaleFactor()), this._loadTile(i6, e6.key, i6.state)), i6.uses++, this._tiles[e6.key] = i6, r8 || this._source.fire(new t4.l("dataloading", { tile: i6, coord: i6.tileID, dataType: "source" })), i6;
          }
          _setTileReloadTimer(e6, t5) {
            e6 in this._timers && (clearTimeout(this._timers[e6]), delete this._timers[e6]);
            const i6 = t5.getExpiryTimeout();
            i6 && (this._timers[e6] = setTimeout(() => {
              this._reloadTile(e6, "expired"), delete this._timers[e6];
            }, i6));
          }
          _removeTile(e6) {
            const t5 = this._tiles[e6];
            t5 && (t5.uses--, delete this._tiles[e6], this._timers[e6] && (clearTimeout(this._timers[e6]), delete this._timers[e6]), t5.uses > 0 || (t5.hasData() && "reloading" !== t5.state ? this._cache.add(t5.tileID, t5, t5.getExpiryTimeout()) : (t5.aborted = true, this._abortTile(t5), this._unloadTile(t5))));
          }
          _dataHandler(e6) {
            const t5 = e6.sourceDataType;
            "source" === e6.dataType && "metadata" === t5 && (this._sourceLoaded = true), this._sourceLoaded && !this._paused && "source" === e6.dataType && "content" === t5 && (this.reload(e6.sourceDataChanged), this.transform && this.update(this.transform, this.terrain), this._didEmitContent = true);
          }
          clearTiles() {
            this._shouldReloadOnResume = false, this._paused = false;
            for (const e6 in this._tiles) this._removeTile(e6);
            this._cache.reset();
          }
          tilesIn(e6, i6, r8) {
            const o6 = [], a4 = this.transform;
            if (!a4) return o6;
            const s4 = r8 ? a4.getCameraQueryGeometry(e6) : e6, n6 = e6.map((e7) => a4.screenPointToMercatorCoordinate(e7, this.terrain)), l5 = s4.map((e7) => a4.screenPointToMercatorCoordinate(e7, this.terrain)), c5 = this.getIds();
            let h4 = 1 / 0, u4 = 1 / 0, d4 = -1 / 0, _4 = -1 / 0;
            for (const e7 of l5) h4 = Math.min(h4, e7.x), u4 = Math.min(u4, e7.y), d4 = Math.max(d4, e7.x), _4 = Math.max(_4, e7.y);
            for (let e7 = 0; e7 < c5.length; e7++) {
              const r9 = this._tiles[c5[e7]];
              if (r9.holdingForFade()) continue;
              const s5 = r9.tileID, p4 = Math.pow(2, a4.zoom - r9.tileID.overscaledZ), m4 = i6 * r9.queryPadding * t4.Z / r9.tileSize / p4, f4 = [s5.getTilePoint(new t4.$(h4, u4)), s5.getTilePoint(new t4.$(d4, _4))];
              if (f4[0].x - m4 < t4.Z && f4[0].y - m4 < t4.Z && f4[1].x + m4 >= 0 && f4[1].y + m4 >= 0) {
                const e8 = n6.map((e9) => s5.getTilePoint(e9)), t5 = l5.map((e9) => s5.getTilePoint(e9));
                o6.push({ tile: r9, tileID: s5, queryGeometry: e8, cameraQueryGeometry: t5, scale: p4 });
              }
            }
            return o6;
          }
          getVisibleCoordinates(e6) {
            const t5 = this.getRenderableIds(e6).map((e7) => this._tiles[e7].tileID);
            return this.transform && this.transform.populateCache(t5), t5;
          }
          hasTransition() {
            if (this._source.hasTransition()) return true;
            if (pe(this._source.type)) {
              const e6 = s3.now();
              for (const t5 in this._tiles) if (this._tiles[t5].fadeEndTime >= e6) return true;
            }
            return false;
          }
          setFeatureState(e6, t5, i6) {
            this._state.updateState(e6 = e6 || "_geojsonTileLayer", t5, i6);
          }
          removeFeatureState(e6, t5, i6) {
            this._state.removeFeatureState(e6 = e6 || "_geojsonTileLayer", t5, i6);
          }
          getFeatureState(e6, t5) {
            return this._state.getState(e6 = e6 || "_geojsonTileLayer", t5);
          }
          setDependencies(e6, t5, i6) {
            const r8 = this._tiles[e6];
            r8 && r8.setDependencies(t5, i6);
          }
          reloadTilesForDependencies(e6, t5) {
            for (const i6 in this._tiles) this._tiles[i6].hasDependency(e6, t5) && this._reloadTile(i6, "reloading");
            this._cache.filter((i6) => !i6.hasDependency(e6, t5));
          }
        }
        function _e(e6, t5) {
          const i6 = Math.abs(2 * e6.wrap) - +(e6.wrap < 0), r8 = Math.abs(2 * t5.wrap) - +(t5.wrap < 0);
          return e6.overscaledZ - t5.overscaledZ || r8 - i6 || t5.canonical.y - e6.canonical.y || t5.canonical.x - e6.canonical.x;
        }
        function pe(e6) {
          return "raster" === e6 || "image" === e6 || "video" === e6;
        }
        de.maxOverzooming = 10, de.maxUnderzooming = 3;
        class me {
          constructor(e6, t5) {
            this.reset(e6, t5);
          }
          reset(e6, t5) {
            this.points = e6 || [], this._distances = [0];
            for (let e7 = 1; e7 < this.points.length; e7++) this._distances[e7] = this._distances[e7 - 1] + this.points[e7].dist(this.points[e7 - 1]);
            this.length = this._distances[this._distances.length - 1], this.padding = Math.min(t5 || 0, 0.5 * this.length), this.paddedLength = this.length - 2 * this.padding;
          }
          lerp(e6) {
            if (1 === this.points.length) return this.points[0];
            e6 = t4.ae(e6, 0, 1);
            let i6 = 1, r8 = this._distances[i6];
            const o6 = e6 * this.paddedLength + this.padding;
            for (; r8 < o6 && i6 < this._distances.length; ) r8 = this._distances[++i6];
            const a4 = i6 - 1, s4 = this._distances[a4], n6 = r8 - s4, l5 = n6 > 0 ? (o6 - s4) / n6 : 0;
            return this.points[a4].mult(1 - l5).add(this.points[i6].mult(l5));
          }
        }
        function fe(e6, t5) {
          let i6 = true;
          return "always" === e6 || "never" !== e6 && "never" !== t5 || (i6 = false), i6;
        }
        class ge {
          constructor(e6, t5, i6) {
            const r8 = this.boxCells = [], o6 = this.circleCells = [];
            this.xCellCount = Math.ceil(e6 / i6), this.yCellCount = Math.ceil(t5 / i6);
            for (let e7 = 0; e7 < this.xCellCount * this.yCellCount; e7++) r8.push([]), o6.push([]);
            this.circleKeys = [], this.boxKeys = [], this.bboxes = [], this.circles = [], this.width = e6, this.height = t5, this.xScale = this.xCellCount / e6, this.yScale = this.yCellCount / t5, this.boxUid = 0, this.circleUid = 0;
          }
          keysLength() {
            return this.boxKeys.length + this.circleKeys.length;
          }
          insert(e6, t5, i6, r8, o6) {
            this._forEachCell(t5, i6, r8, o6, this._insertBoxCell, this.boxUid++), this.boxKeys.push(e6), this.bboxes.push(t5), this.bboxes.push(i6), this.bboxes.push(r8), this.bboxes.push(o6);
          }
          insertCircle(e6, t5, i6, r8) {
            this._forEachCell(t5 - r8, i6 - r8, t5 + r8, i6 + r8, this._insertCircleCell, this.circleUid++), this.circleKeys.push(e6), this.circles.push(t5), this.circles.push(i6), this.circles.push(r8);
          }
          _insertBoxCell(e6, t5, i6, r8, o6, a4) {
            this.boxCells[o6].push(a4);
          }
          _insertCircleCell(e6, t5, i6, r8, o6, a4) {
            this.circleCells[o6].push(a4);
          }
          _query(e6, t5, i6, r8, o6, a4, s4) {
            if (i6 < 0 || e6 > this.width || r8 < 0 || t5 > this.height) return [];
            const n6 = [];
            if (e6 <= 0 && t5 <= 0 && this.width <= i6 && this.height <= r8) {
              if (o6) return [{ key: null, x1: e6, y1: t5, x2: i6, y2: r8 }];
              for (let e7 = 0; e7 < this.boxKeys.length; e7++) n6.push({ key: this.boxKeys[e7], x1: this.bboxes[4 * e7], y1: this.bboxes[4 * e7 + 1], x2: this.bboxes[4 * e7 + 2], y2: this.bboxes[4 * e7 + 3] });
              for (let e7 = 0; e7 < this.circleKeys.length; e7++) {
                const t6 = this.circles[3 * e7], i7 = this.circles[3 * e7 + 1], r9 = this.circles[3 * e7 + 2];
                n6.push({ key: this.circleKeys[e7], x1: t6 - r9, y1: i7 - r9, x2: t6 + r9, y2: i7 + r9 });
              }
            } else this._forEachCell(e6, t5, i6, r8, this._queryCell, n6, { hitTest: o6, overlapMode: a4, seenUids: { box: {}, circle: {} } }, s4);
            return n6;
          }
          query(e6, t5, i6, r8) {
            return this._query(e6, t5, i6, r8, false, null);
          }
          hitTest(e6, t5, i6, r8, o6, a4) {
            return this._query(e6, t5, i6, r8, true, o6, a4).length > 0;
          }
          hitTestCircle(e6, t5, i6, r8, o6) {
            const a4 = e6 - i6, s4 = e6 + i6, n6 = t5 - i6, l5 = t5 + i6;
            if (s4 < 0 || a4 > this.width || l5 < 0 || n6 > this.height) return false;
            const c5 = [];
            return this._forEachCell(a4, n6, s4, l5, this._queryCellCircle, c5, { hitTest: true, overlapMode: r8, circle: { x: e6, y: t5, radius: i6 }, seenUids: { box: {}, circle: {} } }, o6), c5.length > 0;
          }
          _queryCell(e6, t5, i6, r8, o6, a4, s4, n6) {
            const { seenUids: l5, hitTest: c5, overlapMode: h4 } = s4, u4 = this.boxCells[o6];
            if (null !== u4) {
              const o7 = this.bboxes;
              for (const s5 of u4) if (!l5.box[s5]) {
                l5.box[s5] = true;
                const u5 = 4 * s5, d5 = this.boxKeys[s5];
                if (e6 <= o7[u5 + 2] && t5 <= o7[u5 + 3] && i6 >= o7[u5 + 0] && r8 >= o7[u5 + 1] && (!n6 || n6(d5)) && (!c5 || !fe(h4, d5.overlapMode)) && (a4.push({ key: d5, x1: o7[u5], y1: o7[u5 + 1], x2: o7[u5 + 2], y2: o7[u5 + 3] }), c5)) return true;
              }
            }
            const d4 = this.circleCells[o6];
            if (null !== d4) {
              const o7 = this.circles;
              for (const s5 of d4) if (!l5.circle[s5]) {
                l5.circle[s5] = true;
                const u5 = 3 * s5, d5 = this.circleKeys[s5];
                if (this._circleAndRectCollide(o7[u5], o7[u5 + 1], o7[u5 + 2], e6, t5, i6, r8) && (!n6 || n6(d5)) && (!c5 || !fe(h4, d5.overlapMode))) {
                  const e7 = o7[u5], t6 = o7[u5 + 1], i7 = o7[u5 + 2];
                  if (a4.push({ key: d5, x1: e7 - i7, y1: t6 - i7, x2: e7 + i7, y2: t6 + i7 }), c5) return true;
                }
              }
            }
            return false;
          }
          _queryCellCircle(e6, t5, i6, r8, o6, a4, s4, n6) {
            const { circle: l5, seenUids: c5, overlapMode: h4 } = s4, u4 = this.boxCells[o6];
            if (null !== u4) {
              const e7 = this.bboxes;
              for (const t6 of u4) if (!c5.box[t6]) {
                c5.box[t6] = true;
                const i7 = 4 * t6, r9 = this.boxKeys[t6];
                if (this._circleAndRectCollide(l5.x, l5.y, l5.radius, e7[i7 + 0], e7[i7 + 1], e7[i7 + 2], e7[i7 + 3]) && (!n6 || n6(r9)) && !fe(h4, r9.overlapMode)) return a4.push(true), true;
              }
            }
            const d4 = this.circleCells[o6];
            if (null !== d4) {
              const e7 = this.circles;
              for (const t6 of d4) if (!c5.circle[t6]) {
                c5.circle[t6] = true;
                const i7 = 3 * t6, r9 = this.circleKeys[t6];
                if (this._circlesCollide(e7[i7], e7[i7 + 1], e7[i7 + 2], l5.x, l5.y, l5.radius) && (!n6 || n6(r9)) && !fe(h4, r9.overlapMode)) return a4.push(true), true;
              }
            }
          }
          _forEachCell(e6, t5, i6, r8, o6, a4, s4, n6) {
            const l5 = this._convertToXCellCoord(e6), c5 = this._convertToYCellCoord(t5), h4 = this._convertToXCellCoord(i6), u4 = this._convertToYCellCoord(r8);
            for (let d4 = l5; d4 <= h4; d4++) for (let l6 = c5; l6 <= u4; l6++) if (o6.call(this, e6, t5, i6, r8, this.xCellCount * l6 + d4, a4, s4, n6)) return;
          }
          _convertToXCellCoord(e6) {
            return Math.max(0, Math.min(this.xCellCount - 1, Math.floor(e6 * this.xScale)));
          }
          _convertToYCellCoord(e6) {
            return Math.max(0, Math.min(this.yCellCount - 1, Math.floor(e6 * this.yScale)));
          }
          _circlesCollide(e6, t5, i6, r8, o6, a4) {
            const s4 = r8 - e6, n6 = o6 - t5, l5 = i6 + a4;
            return l5 * l5 > s4 * s4 + n6 * n6;
          }
          _circleAndRectCollide(e6, t5, i6, r8, o6, a4, s4) {
            const n6 = (a4 - r8) / 2, l5 = Math.abs(e6 - (r8 + n6));
            if (l5 > n6 + i6) return false;
            const c5 = (s4 - o6) / 2, h4 = Math.abs(t5 - (o6 + c5));
            if (h4 > c5 + i6) return false;
            if (l5 <= n6 || h4 <= c5) return true;
            const u4 = l5 - n6, d4 = h4 - c5;
            return u4 * u4 + d4 * d4 <= i6 * i6;
          }
        }
        function ve(e6, i6, o6) {
          const a4 = t4.K();
          if (!e6) {
            const { vecSouth: e7, vecEast: t5 } = be(i6), o7 = r7();
            o7[0] = t5[0], o7[1] = t5[1], o7[2] = e7[0], o7[3] = e7[1], s4 = o7, (d4 = (l5 = (n6 = o7)[0]) * (u4 = n6[3]) - (h4 = n6[2]) * (c5 = n6[1])) && (s4[0] = u4 * (d4 = 1 / d4), s4[1] = -c5 * d4, s4[2] = -h4 * d4, s4[3] = l5 * d4), a4[0] = o7[0], a4[1] = o7[1], a4[4] = o7[2], a4[5] = o7[3];
          }
          var s4, n6, l5, c5, h4, u4, d4;
          return t4.M(a4, a4, [1 / o6, 1 / o6, 1]), a4;
        }
        function xe(e6, i6, r8, o6) {
          if (e6) {
            const e7 = t4.K();
            if (!i6) {
              const { vecSouth: t5, vecEast: i7 } = be(r8);
              e7[0] = i7[0], e7[1] = i7[1], e7[4] = t5[0], e7[5] = t5[1];
            }
            return t4.M(e7, e7, [o6, o6, 1]), e7;
          }
          return r8.pixelsToClipSpaceMatrix;
        }
        function be(e6) {
          const i6 = Math.cos(e6.rollInRadians), r8 = Math.sin(e6.rollInRadians), o6 = Math.cos(e6.pitchInRadians), a4 = Math.cos(e6.bearingInRadians), s4 = Math.sin(e6.bearingInRadians), n6 = t4.ak();
          n6[0] = -a4 * o6 * r8 - s4 * i6, n6[1] = -s4 * o6 * r8 + a4 * i6;
          const l5 = t4.al(n6);
          l5 < 1e-9 ? t4.am(n6) : t4.an(n6, n6, 1 / l5);
          const c5 = t4.ak();
          c5[0] = a4 * o6 * i6 - s4 * r8, c5[1] = s4 * o6 * i6 + a4 * r8;
          const h4 = t4.al(c5);
          return h4 < 1e-9 ? t4.am(c5) : t4.an(c5, c5, 1 / h4), { vecEast: c5, vecSouth: n6 };
        }
        function ye(e6, i6, r8, o6) {
          let a4;
          o6 ? (a4 = [e6, i6, o6(e6, i6), 1], t4.ap(a4, a4, r8)) : (a4 = [e6, i6, 0, 1], Oe(a4, a4, r8));
          const s4 = a4[3];
          return { point: new t4.P(a4[0] / s4, a4[1] / s4), signedDistanceFromCamera: s4, isOccluded: false };
        }
        function we(e6, t5) {
          return 0.5 + e6 / t5 * 0.5;
        }
        function Te(e6, t5) {
          return e6.x >= -t5[0] && e6.x <= t5[0] && e6.y >= -t5[1] && e6.y <= t5[1];
        }
        function Pe(e6, i6, r8, o6, a4, s4, n6, l5, c5, h4, u4, d4, _4) {
          const p4 = r8 ? e6.textSizeData : e6.iconSizeData, m4 = t4.ag(p4, i6.transform.zoom), f4 = [256 / i6.width * 2 + 1, 256 / i6.height * 2 + 1], g4 = r8 ? e6.text.dynamicLayoutVertexArray : e6.icon.dynamicLayoutVertexArray;
          g4.clear();
          const v4 = e6.lineVertexArray, x4 = r8 ? e6.text.placedSymbolArray : e6.icon.placedSymbolArray, b5 = i6.transform.width / i6.transform.height;
          let y4 = false;
          for (let r9 = 0; r9 < x4.length; r9++) {
            const w4 = x4.get(r9);
            if (w4.hidden || w4.writingMode === t4.ah.vertical && !y4) {
              Be(w4.numGlyphs, g4);
              continue;
            }
            y4 = false;
            const T5 = new t4.P(w4.anchorX, w4.anchorY), P4 = { getElevation: _4, pitchedLabelPlaneMatrix: o6, lineVertexArray: v4, pitchWithMap: s4, projectionCache: { projections: {}, offsets: {}, cachedAnchorPoint: void 0, anyProjectionOccluded: false }, transform: i6.transform, tileAnchorPoint: T5, unwrappedTileID: c5, width: h4, height: u4, translation: d4 }, C4 = ze(w4.anchorX, w4.anchorY, P4);
            if (!Te(C4.point, f4)) {
              Be(w4.numGlyphs, g4);
              continue;
            }
            const I4 = we(i6.transform.cameraToCenterDistance, C4.signedDistanceFromCamera), M5 = t4.ai(p4, m4, w4), E4 = s4 ? M5 * i6.transform.getPitchedTextCorrection(w4.anchorX, w4.anchorY, c5) / I4 : M5 * I4, S5 = Me({ projectionContext: P4, pitchedLabelPlaneMatrixInverse: a4, symbol: w4, fontSize: E4, flip: false, keepUpright: n6, glyphOffsetArray: e6.glyphOffsetArray, dynamicLayoutVertexArray: g4, aspectRatio: b5, rotateToLine: l5 });
            y4 = S5.useVertical, (S5.notEnoughRoom || y4 || S5.needsFlipping && Me({ projectionContext: P4, pitchedLabelPlaneMatrixInverse: a4, symbol: w4, fontSize: E4, flip: true, keepUpright: n6, glyphOffsetArray: e6.glyphOffsetArray, dynamicLayoutVertexArray: g4, aspectRatio: b5, rotateToLine: l5 }).notEnoughRoom) && Be(w4.numGlyphs, g4);
          }
          r8 ? e6.text.dynamicLayoutVertexBuffer.updateData(g4) : e6.icon.dynamicLayoutVertexBuffer.updateData(g4);
        }
        function Ce(e6, t5, i6, r8, o6, a4, s4, n6) {
          const l5 = a4.glyphStartIndex + a4.numGlyphs, c5 = a4.lineStartIndex, h4 = a4.lineStartIndex + a4.lineLength, u4 = t5.getoffsetX(a4.glyphStartIndex), d4 = t5.getoffsetX(l5 - 1), _4 = ke(e6 * u4, i6, r8, o6, a4.segment, c5, h4, n6, s4);
          if (!_4) return null;
          const p4 = ke(e6 * d4, i6, r8, o6, a4.segment, c5, h4, n6, s4);
          return p4 ? n6.projectionCache.anyProjectionOccluded ? null : { first: _4, last: p4 } : null;
        }
        function Ie(e6, i6, r8, o6) {
          return e6 === t4.ah.horizontal && Math.abs(r8.y - i6.y) > Math.abs(r8.x - i6.x) * o6 ? { useVertical: true } : (e6 === t4.ah.vertical ? i6.y < r8.y : i6.x > r8.x) ? { needsFlipping: true } : null;
        }
        function Me(e6) {
          const { projectionContext: i6, pitchedLabelPlaneMatrixInverse: r8, symbol: o6, fontSize: a4, flip: s4, keepUpright: n6, glyphOffsetArray: l5, dynamicLayoutVertexArray: c5, aspectRatio: h4, rotateToLine: u4 } = e6, d4 = a4 / 24, _4 = o6.lineOffsetX * d4, p4 = o6.lineOffsetY * d4;
          let m4;
          if (o6.numGlyphs > 1) {
            const e7 = o6.glyphStartIndex + o6.numGlyphs, t5 = o6.lineStartIndex, a5 = o6.lineStartIndex + o6.lineLength, c6 = Ce(d4, l5, _4, p4, s4, o6, u4, i6);
            if (!c6) return { notEnoughRoom: true };
            const f4 = De(c6.first.point.x, c6.first.point.y, i6, r8), g4 = De(c6.last.point.x, c6.last.point.y, i6, r8);
            if (n6 && !s4) {
              const e8 = Ie(o6.writingMode, f4, g4, h4);
              if (e8) return e8;
            }
            m4 = [c6.first];
            for (let r9 = o6.glyphStartIndex + 1; r9 < e7 - 1; r9++) m4.push(ke(d4 * l5.getoffsetX(r9), _4, p4, s4, o6.segment, t5, a5, i6, u4));
            m4.push(c6.last);
          } else {
            if (n6 && !s4) {
              const e8 = Re(i6.tileAnchorPoint.x, i6.tileAnchorPoint.y, i6).point, a5 = o6.lineStartIndex + o6.segment + 1, s5 = new t4.P(i6.lineVertexArray.getx(a5), i6.lineVertexArray.gety(a5)), n7 = Re(s5.x, s5.y, i6), l6 = n7.signedDistanceFromCamera > 0 ? n7.point : Ee(i6.tileAnchorPoint, s5, e8, 1, i6), c6 = De(e8.x, e8.y, i6, r8), u5 = De(l6.x, l6.y, i6, r8), d5 = Ie(o6.writingMode, c6, u5, h4);
              if (d5) return d5;
            }
            const e7 = ke(d4 * l5.getoffsetX(o6.glyphStartIndex), _4, p4, s4, o6.segment, o6.lineStartIndex, o6.lineStartIndex + o6.lineLength, i6, u4);
            if (!e7 || i6.projectionCache.anyProjectionOccluded) return { notEnoughRoom: true };
            m4 = [e7];
          }
          for (const e7 of m4) t4.ao(c5, e7.point, e7.angle);
          return {};
        }
        function Ee(e6, t5, i6, r8, o6) {
          const a4 = e6.add(e6.sub(t5)._unit()), s4 = Re(a4.x, a4.y, o6).point, n6 = i6.sub(s4);
          return i6.add(n6._mult(r8 / n6.mag()));
        }
        function Se(e6, i6, r8) {
          const o6 = i6.projectionCache;
          if (o6.projections[e6]) return o6.projections[e6];
          const a4 = new t4.P(i6.lineVertexArray.getx(e6), i6.lineVertexArray.gety(e6)), s4 = Re(a4.x, a4.y, i6);
          if (s4.signedDistanceFromCamera > 0) return o6.projections[e6] = s4.point, o6.anyProjectionOccluded = o6.anyProjectionOccluded || s4.isOccluded, s4.point;
          const n6 = e6 - r8.direction;
          return Ee(0 === r8.distanceFromAnchor ? i6.tileAnchorPoint : new t4.P(i6.lineVertexArray.getx(n6), i6.lineVertexArray.gety(n6)), a4, r8.previousVertex, r8.absOffsetX - r8.distanceFromAnchor + 1, i6);
        }
        function Re(e6, t5, i6) {
          const r8 = e6 + i6.translation[0], o6 = t5 + i6.translation[1];
          let a4;
          return i6.pitchWithMap ? (a4 = ye(r8, o6, i6.pitchedLabelPlaneMatrix, i6.getElevation), a4.isOccluded = false) : (a4 = i6.transform.projectTileCoordinates(r8, o6, i6.unwrappedTileID, i6.getElevation), a4.point.x = (0.5 * a4.point.x + 0.5) * i6.width, a4.point.y = (0.5 * -a4.point.y + 0.5) * i6.height), a4;
        }
        function De(e6, i6, r8, o6) {
          if (r8.pitchWithMap) {
            const a4 = [e6, i6, 0, 1];
            return t4.ap(a4, a4, o6), r8.transform.projectTileCoordinates(a4[0] / a4[3], a4[1] / a4[3], r8.unwrappedTileID, r8.getElevation).point;
          }
          return { x: e6 / r8.width * 2 - 1, y: i6 / r8.height * 2 - 1 };
        }
        function ze(e6, t5, i6) {
          return i6.transform.projectTileCoordinates(e6, t5, i6.unwrappedTileID, i6.getElevation);
        }
        function Ae(e6, t5, i6) {
          return e6._unit()._perp()._mult(t5 * i6);
        }
        function Le(e6, i6, r8, o6, a4, s4, n6, l5, c5) {
          if (l5.projectionCache.offsets[e6]) return l5.projectionCache.offsets[e6];
          const h4 = r8.add(i6);
          if (e6 + c5.direction < o6 || e6 + c5.direction >= a4) return l5.projectionCache.offsets[e6] = h4, h4;
          const u4 = Se(e6 + c5.direction, l5, c5), d4 = Ae(u4.sub(r8), n6, c5.direction), _4 = r8.add(d4), p4 = u4.add(d4);
          return l5.projectionCache.offsets[e6] = t4.aq(s4, h4, _4, p4) || h4, l5.projectionCache.offsets[e6];
        }
        function ke(e6, t5, i6, r8, o6, a4, s4, n6, l5) {
          const c5 = r8 ? e6 - t5 : e6 + t5;
          let h4 = c5 > 0 ? 1 : -1, u4 = 0;
          r8 && (h4 *= -1, u4 = Math.PI), h4 < 0 && (u4 += Math.PI);
          let d4, _4 = h4 > 0 ? a4 + o6 : a4 + o6 + 1;
          n6.projectionCache.cachedAnchorPoint ? d4 = n6.projectionCache.cachedAnchorPoint : (d4 = Re(n6.tileAnchorPoint.x, n6.tileAnchorPoint.y, n6).point, n6.projectionCache.cachedAnchorPoint = d4);
          let p4, m4, f4 = d4, g4 = d4, v4 = 0, x4 = 0;
          const b5 = Math.abs(c5), y4 = [];
          let w4;
          for (; v4 + x4 <= b5; ) {
            if (_4 += h4, _4 < a4 || _4 >= s4) return null;
            v4 += x4, g4 = f4, m4 = p4;
            const e7 = { absOffsetX: b5, direction: h4, distanceFromAnchor: v4, previousVertex: g4 };
            if (f4 = Se(_4, n6, e7), 0 === i6) y4.push(g4), w4 = f4.sub(g4);
            else {
              let t6;
              const r9 = f4.sub(g4);
              t6 = 0 === r9.mag() ? Ae(Se(_4 + h4, n6, e7).sub(f4), i6, h4) : Ae(r9, i6, h4), m4 || (m4 = g4.add(t6)), p4 = Le(_4, t6, f4, a4, s4, m4, i6, n6, e7), y4.push(m4), w4 = p4.sub(m4);
            }
            x4 = w4.mag();
          }
          const T5 = w4._mult((b5 - v4) / x4)._add(m4 || g4), P4 = u4 + Math.atan2(f4.y - g4.y, f4.x - g4.x);
          return y4.push(T5), { point: T5, angle: l5 ? P4 : 0, path: y4 };
        }
        const Fe = new Float32Array([-1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0]);
        function Be(e6, t5) {
          for (let i6 = 0; i6 < e6; i6++) {
            const e7 = t5.length;
            t5.resize(e7 + 4), t5.float32.set(Fe, 3 * e7);
          }
        }
        function Oe(e6, t5, i6) {
          const r8 = t5[0], o6 = t5[1];
          return e6[0] = i6[0] * r8 + i6[4] * o6 + i6[12], e6[1] = i6[1] * r8 + i6[5] * o6 + i6[13], e6[3] = i6[3] * r8 + i6[7] * o6 + i6[15], e6;
        }
        const je = 100;
        class Ze {
          constructor(e6, t5 = new ge(e6.width + 200, e6.height + 200, 25), i6 = new ge(e6.width + 200, e6.height + 200, 25)) {
            this.transform = e6, this.grid = t5, this.ignoredGrid = i6, this.pitchFactor = Math.cos(e6.pitch * Math.PI / 180) * e6.cameraToCenterDistance, this.screenRightBoundary = e6.width + je, this.screenBottomBoundary = e6.height + je, this.gridRightBoundary = e6.width + 200, this.gridBottomBoundary = e6.height + 200, this.perspectiveRatioCutoff = 0.6;
          }
          placeCollisionBox(e6, t5, i6, r8, o6, a4, s4, n6, l5, c5, h4, u4) {
            const d4 = this.projectAndGetPerspectiveRatio(e6.anchorPointX + n6[0], e6.anchorPointY + n6[1], o6, c5, u4), _4 = i6 * d4.perspectiveRatio;
            let p4;
            if (a4 || s4) p4 = this._projectCollisionBox(e6, _4, r8, o6, a4, s4, n6, d4, c5, h4, u4);
            else {
              const t6 = d4.x + (h4 ? h4.x * _4 : 0), i7 = d4.y + (h4 ? h4.y * _4 : 0);
              p4 = { allPointsOccluded: false, box: [t6 + e6.x1 * _4, i7 + e6.y1 * _4, t6 + e6.x2 * _4, i7 + e6.y2 * _4] };
            }
            const [m4, f4, g4, v4] = p4.box, x4 = a4 ? p4.allPointsOccluded : d4.isOccluded;
            let b5 = x4;
            return b5 || (b5 = d4.perspectiveRatio < this.perspectiveRatioCutoff), b5 || (b5 = !this.isInsideGrid(m4, f4, g4, v4)), b5 || "always" !== t5 && this.grid.hitTest(m4, f4, g4, v4, t5, l5) ? { box: [m4, f4, g4, v4], placeable: false, offscreen: false, occluded: x4 } : { box: [m4, f4, g4, v4], placeable: true, offscreen: this.isOffscreen(m4, f4, g4, v4), occluded: x4 };
          }
          placeCollisionCircles(e6, i6, r8, o6, a4, s4, n6, l5, c5, h4, u4, d4, _4, p4) {
            const m4 = [], f4 = new t4.P(i6.anchorX, i6.anchorY), g4 = this.getPerspectiveRatio(f4.x, f4.y, s4, p4), v4 = (c5 ? a4 * this.transform.getPitchedTextCorrection(i6.anchorX, i6.anchorY, s4) / g4 : a4 * g4) / t4.av, x4 = { getElevation: p4, pitchedLabelPlaneMatrix: n6, lineVertexArray: r8, pitchWithMap: c5, projectionCache: { projections: {}, offsets: {}, cachedAnchorPoint: void 0, anyProjectionOccluded: false }, transform: this.transform, tileAnchorPoint: f4, unwrappedTileID: s4, width: this.transform.width, height: this.transform.height, translation: _4 }, b5 = Ce(v4, o6, i6.lineOffsetX * v4, i6.lineOffsetY * v4, false, i6, false, x4);
            let y4 = false, w4 = false, T5 = true;
            if (b5) {
              const i7 = 0.5 * u4 * g4 + d4, r9 = new t4.P(-100, -100), o7 = new t4.P(this.screenRightBoundary, this.screenBottomBoundary), a5 = new me(), s5 = b5.first, n7 = b5.last;
              let _5 = [];
              for (let e7 = s5.path.length - 1; e7 >= 1; e7--) _5.push(s5.path[e7]);
              for (let e7 = 1; e7 < n7.path.length; e7++) _5.push(n7.path[e7]);
              const p5 = 2.5 * i7;
              if (c5) {
                const e7 = this.projectPathToScreenSpace(_5, x4);
                _5 = e7.some((e8) => e8.signedDistanceFromCamera <= 0) ? [] : e7.map((e8) => e8.point);
              }
              let f5 = [];
              if (_5.length > 0) {
                const e7 = _5[0].clone(), i8 = _5[0].clone();
                for (let t5 = 1; t5 < _5.length; t5++) e7.x = Math.min(e7.x, _5[t5].x), e7.y = Math.min(e7.y, _5[t5].y), i8.x = Math.max(i8.x, _5[t5].x), i8.y = Math.max(i8.y, _5[t5].y);
                f5 = e7.x >= r9.x && i8.x <= o7.x && e7.y >= r9.y && i8.y <= o7.y ? [_5] : i8.x < r9.x || e7.x > o7.x || i8.y < r9.y || e7.y > o7.y ? [] : t4.ar([_5], r9.x, r9.y, o7.x, o7.y);
              }
              for (const t5 of f5) {
                a5.reset(t5, 0.25 * i7);
                let r10 = 0;
                r10 = a5.length <= 0.5 * i7 ? 1 : Math.ceil(a5.paddedLength / p5) + 1;
                for (let t6 = 0; t6 < r10; t6++) {
                  const o8 = t6 / Math.max(r10 - 1, 1), s6 = a5.lerp(o8), n8 = s6.x + je, c6 = s6.y + je;
                  m4.push(n8, c6, i7, 0);
                  const u5 = n8 - i7, d5 = c6 - i7, _6 = n8 + i7, p6 = c6 + i7;
                  if (T5 = T5 && this.isOffscreen(u5, d5, _6, p6), w4 = w4 || this.isInsideGrid(u5, d5, _6, p6), "always" !== e6 && this.grid.hitTestCircle(n8, c6, i7, e6, h4) && (y4 = true, !l5)) return { circles: [], offscreen: false, collisionDetected: y4 };
                }
              }
            }
            return { circles: !l5 && y4 || !w4 || g4 < this.perspectiveRatioCutoff ? [] : m4, offscreen: T5, collisionDetected: y4 };
          }
          projectPathToScreenSpace(e6, i6) {
            const r8 = function(e7, i7) {
              const r9 = t4.K();
              return t4.aj(r9, i7.pitchedLabelPlaneMatrix), e7.map((e8) => {
                const t5 = ye(e8.x, e8.y, r9, i7.getElevation), o6 = i7.transform.projectTileCoordinates(t5.point.x, t5.point.y, i7.unwrappedTileID, i7.getElevation);
                return o6.point.x = (0.5 * o6.point.x + 0.5) * i7.width, o6.point.y = (0.5 * -o6.point.y + 0.5) * i7.height, o6;
              });
            }(e6, i6);
            return function(e7) {
              let t5 = 0, i7 = 0, r9 = 0, o6 = 0;
              for (let a4 = 0; a4 < e7.length; a4++) e7[a4].isOccluded ? (r9 = a4 + 1, o6 = 0) : (o6++, o6 > i7 && (i7 = o6, t5 = r9));
              return e7.slice(t5, t5 + i7);
            }(r8);
          }
          queryRenderedSymbols(e6) {
            if (0 === e6.length || 0 === this.grid.keysLength() && 0 === this.ignoredGrid.keysLength()) return {};
            const i6 = [];
            let r8 = 1 / 0, o6 = 1 / 0, a4 = -1 / 0, s4 = -1 / 0;
            for (const n7 of e6) {
              const e7 = new t4.P(n7.x + je, n7.y + je);
              r8 = Math.min(r8, e7.x), o6 = Math.min(o6, e7.y), a4 = Math.max(a4, e7.x), s4 = Math.max(s4, e7.y), i6.push(e7);
            }
            const n6 = this.grid.query(r8, o6, a4, s4).concat(this.ignoredGrid.query(r8, o6, a4, s4)), l5 = {}, c5 = {};
            for (const e7 of n6) {
              const r9 = e7.key;
              if (void 0 === l5[r9.bucketInstanceId] && (l5[r9.bucketInstanceId] = {}), l5[r9.bucketInstanceId][r9.featureIndex]) continue;
              const o7 = [new t4.P(e7.x1, e7.y1), new t4.P(e7.x2, e7.y1), new t4.P(e7.x2, e7.y2), new t4.P(e7.x1, e7.y2)];
              t4.as(i6, o7) && (l5[r9.bucketInstanceId][r9.featureIndex] = true, void 0 === c5[r9.bucketInstanceId] && (c5[r9.bucketInstanceId] = []), c5[r9.bucketInstanceId].push(r9.featureIndex));
            }
            return c5;
          }
          insertCollisionBox(e6, t5, i6, r8, o6, a4) {
            (i6 ? this.ignoredGrid : this.grid).insert({ bucketInstanceId: r8, featureIndex: o6, collisionGroupID: a4, overlapMode: t5 }, e6[0], e6[1], e6[2], e6[3]);
          }
          insertCollisionCircles(e6, t5, i6, r8, o6, a4) {
            const s4 = i6 ? this.ignoredGrid : this.grid, n6 = { bucketInstanceId: r8, featureIndex: o6, collisionGroupID: a4, overlapMode: t5 };
            for (let t6 = 0; t6 < e6.length; t6 += 4) s4.insertCircle(n6, e6[t6], e6[t6 + 1], e6[t6 + 2]);
          }
          projectAndGetPerspectiveRatio(e6, i6, r8, o6, a4) {
            if (a4) {
              let r9;
              o6 ? (r9 = [e6, i6, o6(e6, i6), 1], t4.ap(r9, r9, a4)) : (r9 = [e6, i6, 0, 1], Oe(r9, r9, a4));
              const s4 = r9[3];
              return { x: (r9[0] / s4 + 1) / 2 * this.transform.width + je, y: (-r9[1] / s4 + 1) / 2 * this.transform.height + je, perspectiveRatio: 0.5 + this.transform.cameraToCenterDistance / s4 * 0.5, isOccluded: false, signedDistanceFromCamera: s4 };
            }
            {
              const t5 = this.transform.projectTileCoordinates(e6, i6, r8, o6);
              return { x: (t5.point.x + 1) / 2 * this.transform.width + je, y: (1 - t5.point.y) / 2 * this.transform.height + je, perspectiveRatio: 0.5 + this.transform.cameraToCenterDistance / t5.signedDistanceFromCamera * 0.5, isOccluded: t5.isOccluded, signedDistanceFromCamera: t5.signedDistanceFromCamera };
            }
          }
          getPerspectiveRatio(e6, t5, i6, r8) {
            const o6 = this.transform.projectTileCoordinates(e6, t5, i6, r8);
            return 0.5 + this.transform.cameraToCenterDistance / o6.signedDistanceFromCamera * 0.5;
          }
          isOffscreen(e6, t5, i6, r8) {
            return i6 < je || e6 >= this.screenRightBoundary || r8 < je || t5 > this.screenBottomBoundary;
          }
          isInsideGrid(e6, t5, i6, r8) {
            return i6 >= 0 && e6 < this.gridRightBoundary && r8 >= 0 && t5 < this.gridBottomBoundary;
          }
          getViewportMatrix() {
            const e6 = t4.at([]);
            return t4.L(e6, e6, [-100, -100, 0]), e6;
          }
          _projectCollisionBox(e6, i6, r8, o6, a4, s4, n6, l5, c5, h4, u4) {
            let d4 = 1, _4 = 0, p4 = 0, m4 = 1;
            const f4 = e6.anchorPointX + n6[0], g4 = e6.anchorPointY + n6[1];
            if (s4 && !a4) {
              const e7 = this.projectAndGetPerspectiveRatio(f4 + 1, g4, o6, c5, u4), t5 = e7.x - l5.x, i7 = Math.atan((e7.y - l5.y) / t5) + (t5 < 0 ? Math.PI : 0), r9 = Math.sin(i7), a5 = Math.cos(i7);
              d4 = a5, _4 = r9, p4 = -r9, m4 = a5;
            } else if (!s4 && a4) {
              const e7 = be(this.transform);
              d4 = e7.vecEast[0], _4 = e7.vecEast[1], p4 = e7.vecSouth[0], m4 = e7.vecSouth[1];
            }
            let v4 = l5.x, x4 = l5.y, b5 = i6;
            a4 && (v4 = f4, x4 = g4, b5 = Math.pow(2, -(this.transform.zoom - r8.overscaledZ)), b5 *= this.transform.getPitchedTextCorrection(f4, g4, o6), h4 || (b5 *= t4.ae(0.5 + l5.signedDistanceFromCamera / this.transform.cameraToCenterDistance * 0.5, 0, 4))), h4 && (v4 += d4 * h4.x * b5 + p4 * h4.y * b5, x4 += _4 * h4.x * b5 + m4 * h4.y * b5);
            const y4 = e6.x1 * b5, w4 = e6.x2 * b5, T5 = (y4 + w4) / 2, P4 = e6.y1 * b5, C4 = e6.y2 * b5, I4 = (P4 + C4) / 2, M5 = [{ offsetX: y4, offsetY: P4 }, { offsetX: T5, offsetY: P4 }, { offsetX: w4, offsetY: P4 }, { offsetX: w4, offsetY: I4 }, { offsetX: w4, offsetY: C4 }, { offsetX: T5, offsetY: C4 }, { offsetX: y4, offsetY: C4 }, { offsetX: y4, offsetY: I4 }];
            let E4 = [];
            for (const { offsetX: e7, offsetY: i7 } of M5) E4.push(new t4.P(v4 + d4 * e7 + p4 * i7, x4 + _4 * e7 + m4 * i7));
            let S5 = false;
            if (a4) {
              const e7 = E4.map((e8) => this.projectAndGetPerspectiveRatio(e8.x, e8.y, o6, c5, u4));
              S5 = e7.some((e8) => !e8.isOccluded), E4 = e7.map((e8) => new t4.P(e8.x, e8.y));
            } else S5 = true;
            return { box: t4.au(E4), allPointsOccluded: !S5 };
          }
        }
        class Ne {
          constructor(e6, t5, i6, r8) {
            this.opacity = e6 ? Math.max(0, Math.min(1, e6.opacity + (e6.placed ? t5 : -t5))) : r8 && i6 ? 1 : 0, this.placed = i6;
          }
          isHidden() {
            return 0 === this.opacity && !this.placed;
          }
        }
        class Ge {
          constructor(e6, t5, i6, r8, o6) {
            this.text = new Ne(e6 ? e6.text : null, t5, i6, o6), this.icon = new Ne(e6 ? e6.icon : null, t5, r8, o6);
          }
          isHidden() {
            return this.text.isHidden() && this.icon.isHidden();
          }
        }
        class Ue {
          constructor(e6, t5, i6) {
            this.text = e6, this.icon = t5, this.skipFade = i6;
          }
        }
        class Ve {
          constructor(e6, t5, i6, r8, o6) {
            this.bucketInstanceId = e6, this.featureIndex = t5, this.sourceLayerIndex = i6, this.bucketIndex = r8, this.tileID = o6;
          }
        }
        class qe {
          constructor(e6) {
            this.crossSourceCollisions = e6, this.maxGroupID = 0, this.collisionGroups = {};
          }
          get(e6) {
            if (this.crossSourceCollisions) return { ID: 0, predicate: null };
            if (!this.collisionGroups[e6]) {
              const t5 = ++this.maxGroupID;
              this.collisionGroups[e6] = { ID: t5, predicate: (e7) => e7.collisionGroupID === t5 };
            }
            return this.collisionGroups[e6];
          }
        }
        function We(e6, i6, r8, o6, a4) {
          const { horizontalAlign: s4, verticalAlign: n6 } = t4.aB(e6);
          return new t4.P(-(s4 - 0.5) * i6 + o6[0] * a4, -(n6 - 0.5) * r8 + o6[1] * a4);
        }
        class $e {
          constructor(e6, t5, i6, r8, o6) {
            this.transform = e6.clone(), this.terrain = t5, this.collisionIndex = new Ze(this.transform), this.placements = {}, this.opacities = {}, this.variableOffsets = {}, this.stale = false, this.commitTime = 0, this.fadeDuration = i6, this.retainedQueryData = {}, this.collisionGroups = new qe(r8), this.collisionCircleArrays = {}, this.collisionBoxArrays = /* @__PURE__ */ new Map(), this.prevPlacement = o6, o6 && (o6.prevPlacement = void 0), this.placedOrientations = {};
          }
          _getTerrainElevationFunc(e6) {
            const t5 = this.terrain;
            return t5 ? (i6, r8) => t5.getElevation(e6, i6, r8) : null;
          }
          getBucketParts(e6, i6, r8, o6) {
            const a4 = r8.getBucket(i6), s4 = r8.latestFeatureIndex;
            if (!a4 || !s4 || i6.id !== a4.layerIds[0]) return;
            const n6 = r8.collisionBoxArray, l5 = a4.layers[0].layout, c5 = a4.layers[0].paint, h4 = Math.pow(2, this.transform.zoom - r8.tileID.overscaledZ), u4 = r8.tileSize / t4.Z, d4 = r8.tileID.toUnwrapped(), _4 = "map" === l5.get("text-rotation-alignment"), p4 = t4.aw(r8, 1, this.transform.zoom), m4 = t4.ax(this.collisionIndex.transform, r8, c5.get("text-translate"), c5.get("text-translate-anchor")), f4 = t4.ax(this.collisionIndex.transform, r8, c5.get("icon-translate"), c5.get("icon-translate-anchor")), g4 = ve(_4, this.transform, p4);
            this.retainedQueryData[a4.bucketInstanceId] = new Ve(a4.bucketInstanceId, s4, a4.sourceLayerIndex, a4.index, r8.tileID);
            const v4 = { bucket: a4, layout: l5, translationText: m4, translationIcon: f4, unwrappedTileID: d4, pitchedLabelPlaneMatrix: g4, scale: h4, textPixelRatio: u4, holdingForFade: r8.holdingForFade(), collisionBoxArray: n6, partiallyEvaluatedTextSize: t4.ag(a4.textSizeData, this.transform.zoom), collisionGroup: this.collisionGroups.get(a4.sourceID) };
            if (o6) for (const t5 of a4.sortKeyRanges) {
              const { sortKey: i7, symbolInstanceStart: r9, symbolInstanceEnd: o7 } = t5;
              e6.push({ sortKey: i7, symbolInstanceStart: r9, symbolInstanceEnd: o7, parameters: v4 });
            }
            else e6.push({ symbolInstanceStart: 0, symbolInstanceEnd: a4.symbolInstances.length, parameters: v4 });
          }
          attemptAnchorPlacement(e6, i6, r8, o6, a4, s4, n6, l5, c5, h4, u4, d4, _4, p4, m4, f4, g4, v4, x4, b5) {
            const y4 = t4.ay[e6.textAnchor], w4 = [e6.textOffset0, e6.textOffset1], T5 = We(y4, r8, o6, w4, a4), P4 = this.collisionIndex.placeCollisionBox(i6, d4, l5, c5, h4, n6, s4, f4, u4.predicate, x4, T5, b5);
            if ((!v4 || this.collisionIndex.placeCollisionBox(v4, d4, l5, c5, h4, n6, s4, g4, u4.predicate, x4, T5, b5).placeable) && P4.placeable) {
              let e7;
              if (this.prevPlacement && this.prevPlacement.variableOffsets[_4.crossTileID] && this.prevPlacement.placements[_4.crossTileID] && this.prevPlacement.placements[_4.crossTileID].text && (e7 = this.prevPlacement.variableOffsets[_4.crossTileID].anchor), 0 === _4.crossTileID) throw new Error("symbolInstance.crossTileID can't be 0");
              return this.variableOffsets[_4.crossTileID] = { textOffset: w4, width: r8, height: o6, anchor: y4, textBoxScale: a4, prevAnchor: e7 }, this.markUsedJustification(p4, y4, _4, m4), p4.allowVerticalPlacement && (this.markUsedOrientation(p4, m4, _4), this.placedOrientations[_4.crossTileID] = m4), { shift: T5, placedGlyphBoxes: P4 };
            }
          }
          placeLayerBucketPart(e6, i6, r8) {
            const { bucket: o6, layout: a4, translationText: s4, translationIcon: n6, unwrappedTileID: l5, pitchedLabelPlaneMatrix: c5, textPixelRatio: h4, holdingForFade: u4, collisionBoxArray: d4, partiallyEvaluatedTextSize: _4, collisionGroup: p4 } = e6.parameters, m4 = a4.get("text-optional"), f4 = a4.get("icon-optional"), g4 = t4.az(a4, "text-overlap", "text-allow-overlap"), v4 = "always" === g4, x4 = t4.az(a4, "icon-overlap", "icon-allow-overlap"), b5 = "always" === x4, y4 = "map" === a4.get("text-rotation-alignment"), w4 = "map" === a4.get("text-pitch-alignment"), T5 = "none" !== a4.get("icon-text-fit"), P4 = "viewport-y" === a4.get("symbol-z-order"), C4 = v4 && (b5 || !o6.hasIconData() || f4), I4 = b5 && (v4 || !o6.hasTextData() || m4);
            !o6.collisionArrays && d4 && o6.deserializeCollisionBoxes(d4);
            const M5 = this.retainedQueryData[o6.bucketInstanceId].tileID, E4 = this._getTerrainElevationFunc(M5), S5 = this.transform.getFastPathSimpleProjectionMatrix(M5), R5 = (e7, d5, b6) => {
              var P5, R6;
              if (i6[e7.crossTileID]) return;
              if (u4) return void (this.placements[e7.crossTileID] = new Ue(false, false, false));
              let D3 = false, z4 = false, A5 = true, L4 = null, k4 = { box: null, placeable: false, offscreen: null, occluded: false }, F3 = { placeable: false }, B5 = null, O3 = null, j4 = null, Z3 = 0, N4 = 0, G3 = 0;
              d5.textFeatureIndex ? Z3 = d5.textFeatureIndex : e7.useRuntimeCollisionCircles && (Z3 = e7.featureIndex), d5.verticalTextFeatureIndex && (N4 = d5.verticalTextFeatureIndex);
              const U4 = d5.textBox;
              if (U4) {
                const i7 = (i8) => {
                  let r9 = t4.ah.horizontal;
                  if (o6.allowVerticalPlacement && !i8 && this.prevPlacement) {
                    const t5 = this.prevPlacement.placedOrientations[e7.crossTileID];
                    t5 && (this.placedOrientations[e7.crossTileID] = t5, r9 = t5, this.markUsedOrientation(o6, r9, e7));
                  }
                  return r9;
                }, a5 = (i8, r9) => {
                  if (o6.allowVerticalPlacement && e7.numVerticalGlyphVertices > 0 && d5.verticalTextBox) {
                    for (const e8 of o6.writingModes) if (e8 === t4.ah.vertical ? (k4 = r9(), F3 = k4) : k4 = i8(), k4 && k4.placeable) break;
                  } else k4 = i8();
                }, c6 = e7.textAnchorOffsetStartIndex, u5 = e7.textAnchorOffsetEndIndex;
                if (u5 === c6) {
                  const r9 = (t5, i8) => {
                    const r10 = this.collisionIndex.placeCollisionBox(t5, g4, h4, M5, l5, w4, y4, s4, p4.predicate, E4, void 0, S5);
                    return r10 && r10.placeable && (this.markUsedOrientation(o6, i8, e7), this.placedOrientations[e7.crossTileID] = i8), r10;
                  };
                  a5(() => r9(U4, t4.ah.horizontal), () => {
                    const i8 = d5.verticalTextBox;
                    return o6.allowVerticalPlacement && e7.numVerticalGlyphVertices > 0 && i8 ? r9(i8, t4.ah.vertical) : { box: null, offscreen: null };
                  }), i7(k4 && k4.placeable);
                } else {
                  let _5 = t4.ay[null === (R6 = null === (P5 = this.prevPlacement) || void 0 === P5 ? void 0 : P5.variableOffsets[e7.crossTileID]) || void 0 === R6 ? void 0 : R6.anchor];
                  const m5 = (t5, i8, a6) => {
                    const d6 = t5.x2 - t5.x1, m6 = t5.y2 - t5.y1, f6 = e7.textBoxScale, v5 = T5 && "never" === x4 ? i8 : null;
                    let b7 = null, P6 = "never" === g4 ? 1 : 2, C5 = "never";
                    _5 && P6++;
                    for (let i9 = 0; i9 < P6; i9++) {
                      for (let i10 = c6; i10 < u5; i10++) {
                        const r9 = o6.textAnchorOffsets.get(i10);
                        if (_5 && r9.textAnchor !== _5) continue;
                        const c7 = this.attemptAnchorPlacement(r9, t5, d6, m6, f6, y4, w4, h4, M5, l5, p4, C5, e7, o6, a6, s4, n6, v5, E4);
                        if (c7 && (b7 = c7.placedGlyphBoxes, b7 && b7.placeable)) return D3 = true, L4 = c7.shift, b7;
                      }
                      _5 ? _5 = null : C5 = g4;
                    }
                    return r8 && !b7 && (b7 = { box: this.collisionIndex.placeCollisionBox(U4, "always", h4, M5, l5, w4, y4, s4, p4.predicate, E4, void 0, S5).box, offscreen: false, placeable: false, occluded: false }), b7;
                  };
                  a5(() => m5(U4, d5.iconBox, t4.ah.horizontal), () => {
                    const i8 = d5.verticalTextBox;
                    return o6.allowVerticalPlacement && (!k4 || !k4.placeable) && e7.numVerticalGlyphVertices > 0 && i8 ? m5(i8, d5.verticalIconBox, t4.ah.vertical) : { box: null, occluded: true, offscreen: null };
                  }), k4 && (D3 = k4.placeable, A5 = k4.offscreen);
                  const f5 = i7(k4 && k4.placeable);
                  if (!D3 && this.prevPlacement) {
                    const t5 = this.prevPlacement.variableOffsets[e7.crossTileID];
                    t5 && (this.variableOffsets[e7.crossTileID] = t5, this.markUsedJustification(o6, t5.anchor, e7, f5));
                  }
                }
              }
              if (B5 = k4, D3 = B5 && B5.placeable, A5 = B5 && B5.offscreen, e7.useRuntimeCollisionCircles) {
                const i7 = o6.text.placedSymbolArray.get(e7.centerJustifiedTextSymbolIndex), n7 = t4.ai(o6.textSizeData, _4, i7), h5 = a4.get("text-padding");
                O3 = this.collisionIndex.placeCollisionCircles(g4, i7, o6.lineVertexArray, o6.glyphOffsetArray, n7, l5, c5, r8, w4, p4.predicate, e7.collisionCircleDiameter, h5, s4, E4), O3.circles.length && O3.collisionDetected && !r8 && t4.w("Collisions detected, but collision boxes are not shown"), D3 = v4 || O3.circles.length > 0 && !O3.collisionDetected, A5 = A5 && O3.offscreen;
              }
              if (d5.iconFeatureIndex && (G3 = d5.iconFeatureIndex), d5.iconBox) {
                const e8 = (e9) => this.collisionIndex.placeCollisionBox(e9, x4, h4, M5, l5, w4, y4, n6, p4.predicate, E4, T5 && L4 ? L4 : void 0, S5);
                F3 && F3.placeable && d5.verticalIconBox ? (j4 = e8(d5.verticalIconBox), z4 = j4.placeable) : (j4 = e8(d5.iconBox), z4 = j4.placeable), A5 = A5 && j4.offscreen;
              }
              const V3 = m4 || 0 === e7.numHorizontalGlyphVertices && 0 === e7.numVerticalGlyphVertices, q3 = f4 || 0 === e7.numIconVertices;
              V3 || q3 ? q3 ? V3 || (z4 = z4 && D3) : D3 = z4 && D3 : z4 = D3 = z4 && D3;
              const W2 = z4 && j4.placeable;
              if (D3 && B5.placeable && this.collisionIndex.insertCollisionBox(B5.box, g4, a4.get("text-ignore-placement"), o6.bucketInstanceId, F3 && F3.placeable && N4 ? N4 : Z3, p4.ID), W2 && this.collisionIndex.insertCollisionBox(j4.box, x4, a4.get("icon-ignore-placement"), o6.bucketInstanceId, G3, p4.ID), O3 && D3 && this.collisionIndex.insertCollisionCircles(O3.circles, g4, a4.get("text-ignore-placement"), o6.bucketInstanceId, Z3, p4.ID), r8 && this.storeCollisionData(o6.bucketInstanceId, b6, d5, B5, j4, O3), 0 === e7.crossTileID) throw new Error("symbolInstance.crossTileID can't be 0");
              if (0 === o6.bucketInstanceId) throw new Error("bucket.bucketInstanceId can't be 0");
              this.placements[e7.crossTileID] = new Ue((D3 || C4) && !(null == B5 ? void 0 : B5.occluded), (z4 || I4) && !(null == j4 ? void 0 : j4.occluded), A5 || o6.justReloaded), i6[e7.crossTileID] = true;
            };
            if (P4) {
              if (0 !== e6.symbolInstanceStart) throw new Error("bucket.bucketInstanceId should be 0");
              const t5 = o6.getSortedSymbolIndexes(-this.transform.bearingInRadians);
              for (let e7 = t5.length - 1; e7 >= 0; --e7) {
                const i7 = t5[e7];
                R5(o6.symbolInstances.get(i7), o6.collisionArrays[i7], i7);
              }
            } else for (let t5 = e6.symbolInstanceStart; t5 < e6.symbolInstanceEnd; t5++) R5(o6.symbolInstances.get(t5), o6.collisionArrays[t5], t5);
            o6.justReloaded = false;
          }
          storeCollisionData(e6, t5, i6, r8, o6, a4) {
            if (i6.textBox || i6.iconBox) {
              let a5, s4;
              this.collisionBoxArrays.has(e6) ? a5 = this.collisionBoxArrays.get(e6) : (a5 = /* @__PURE__ */ new Map(), this.collisionBoxArrays.set(e6, a5)), a5.has(t5) ? s4 = a5.get(t5) : (s4 = { text: null, icon: null }, a5.set(t5, s4)), i6.textBox && (s4.text = r8.box), i6.iconBox && (s4.icon = o6.box);
            }
            if (a4) {
              let t6 = this.collisionCircleArrays[e6];
              void 0 === t6 && (t6 = this.collisionCircleArrays[e6] = []);
              for (let e7 = 0; e7 < a4.circles.length; e7 += 4) t6.push(a4.circles[e7 + 0] - je), t6.push(a4.circles[e7 + 1] - je), t6.push(a4.circles[e7 + 2]), t6.push(a4.collisionDetected ? 1 : 0);
            }
          }
          markUsedJustification(e6, i6, r8, o6) {
            let a4;
            a4 = o6 === t4.ah.vertical ? r8.verticalPlacedTextSymbolIndex : { left: r8.leftJustifiedTextSymbolIndex, center: r8.centerJustifiedTextSymbolIndex, right: r8.rightJustifiedTextSymbolIndex }[t4.aA(i6)];
            const s4 = [r8.leftJustifiedTextSymbolIndex, r8.centerJustifiedTextSymbolIndex, r8.rightJustifiedTextSymbolIndex, r8.verticalPlacedTextSymbolIndex];
            for (const t5 of s4) t5 >= 0 && (e6.text.placedSymbolArray.get(t5).crossTileID = a4 >= 0 && t5 !== a4 ? 0 : r8.crossTileID);
          }
          markUsedOrientation(e6, i6, r8) {
            const o6 = i6 === t4.ah.horizontal || i6 === t4.ah.horizontalOnly ? i6 : 0, a4 = i6 === t4.ah.vertical ? i6 : 0, s4 = [r8.leftJustifiedTextSymbolIndex, r8.centerJustifiedTextSymbolIndex, r8.rightJustifiedTextSymbolIndex];
            for (const t5 of s4) e6.text.placedSymbolArray.get(t5).placedOrientation = o6;
            r8.verticalPlacedTextSymbolIndex && (e6.text.placedSymbolArray.get(r8.verticalPlacedTextSymbolIndex).placedOrientation = a4);
          }
          commit(e6) {
            this.commitTime = e6, this.zoomAtLastRecencyCheck = this.transform.zoom;
            const t5 = this.prevPlacement;
            let i6 = false;
            this.prevZoomAdjustment = t5 ? t5.zoomAdjustment(this.transform.zoom) : 0;
            const r8 = t5 ? t5.symbolFadeChange(e6) : 1, o6 = t5 ? t5.opacities : {}, a4 = t5 ? t5.variableOffsets : {}, s4 = t5 ? t5.placedOrientations : {};
            for (const e7 in this.placements) {
              const t6 = this.placements[e7], a5 = o6[e7];
              a5 ? (this.opacities[e7] = new Ge(a5, r8, t6.text, t6.icon), i6 = i6 || t6.text !== a5.text.placed || t6.icon !== a5.icon.placed) : (this.opacities[e7] = new Ge(null, r8, t6.text, t6.icon, t6.skipFade), i6 = i6 || t6.text || t6.icon);
            }
            for (const e7 in o6) {
              const t6 = o6[e7];
              if (!this.opacities[e7]) {
                const o7 = new Ge(t6, r8, false, false);
                o7.isHidden() || (this.opacities[e7] = o7, i6 = i6 || t6.text.placed || t6.icon.placed);
              }
            }
            for (const e7 in a4) this.variableOffsets[e7] || !this.opacities[e7] || this.opacities[e7].isHidden() || (this.variableOffsets[e7] = a4[e7]);
            for (const e7 in s4) this.placedOrientations[e7] || !this.opacities[e7] || this.opacities[e7].isHidden() || (this.placedOrientations[e7] = s4[e7]);
            if (t5 && void 0 === t5.lastPlacementChangeTime) throw new Error("Last placement time for previous placement is not defined");
            i6 ? this.lastPlacementChangeTime = e6 : "number" != typeof this.lastPlacementChangeTime && (this.lastPlacementChangeTime = t5 ? t5.lastPlacementChangeTime : e6);
          }
          updateLayerOpacities(e6, t5) {
            const i6 = {};
            for (const r8 of t5) {
              const t6 = r8.getBucket(e6);
              t6 && r8.latestFeatureIndex && e6.id === t6.layerIds[0] && this.updateBucketOpacities(t6, r8.tileID, i6, r8.collisionBoxArray);
            }
          }
          updateBucketOpacities(e6, i6, r8, o6) {
            e6.hasTextData() && (e6.text.opacityVertexArray.clear(), e6.text.hasVisibleVertices = false), e6.hasIconData() && (e6.icon.opacityVertexArray.clear(), e6.icon.hasVisibleVertices = false), e6.hasIconCollisionBoxData() && e6.iconCollisionBox.collisionVertexArray.clear(), e6.hasTextCollisionBoxData() && e6.textCollisionBox.collisionVertexArray.clear();
            const a4 = e6.layers[0], s4 = a4.layout, n6 = new Ge(null, 0, false, false, true), l5 = s4.get("text-allow-overlap"), c5 = s4.get("icon-allow-overlap"), h4 = a4._unevaluatedLayout.hasValue("text-variable-anchor") || a4._unevaluatedLayout.hasValue("text-variable-anchor-offset"), u4 = "map" === s4.get("text-rotation-alignment"), d4 = "map" === s4.get("text-pitch-alignment"), _4 = "none" !== s4.get("icon-text-fit"), p4 = new Ge(null, 0, l5 && (c5 || !e6.hasIconData() || s4.get("icon-optional")), c5 && (l5 || !e6.hasTextData() || s4.get("text-optional")), true);
            !e6.collisionArrays && o6 && (e6.hasIconCollisionBoxData() || e6.hasTextCollisionBoxData()) && e6.deserializeCollisionBoxes(o6);
            const m4 = (e7, t5, i7) => {
              for (let r9 = 0; r9 < t5 / 4; r9++) e7.opacityVertexArray.emplaceBack(i7);
              e7.hasVisibleVertices = e7.hasVisibleVertices || i7 !== rt;
            }, f4 = this.collisionBoxArrays.get(e6.bucketInstanceId);
            for (let i7 = 0; i7 < e6.symbolInstances.length; i7++) {
              const o7 = e6.symbolInstances.get(i7), { numHorizontalGlyphVertices: a5, numVerticalGlyphVertices: s5, crossTileID: l6 } = o7;
              let c6 = this.opacities[l6];
              r8[l6] ? c6 = n6 : c6 || (c6 = p4, this.opacities[l6] = c6), r8[l6] = true;
              const g4 = o7.numIconVertices > 0, v4 = this.placedOrientations[o7.crossTileID], x4 = v4 === t4.ah.vertical, b5 = v4 === t4.ah.horizontal || v4 === t4.ah.horizontalOnly;
              if (a5 > 0 || s5 > 0) {
                const t5 = it(c6.text);
                m4(e6.text, a5, x4 ? rt : t5), m4(e6.text, s5, b5 ? rt : t5);
                const i8 = c6.text.isHidden();
                [o7.rightJustifiedTextSymbolIndex, o7.centerJustifiedTextSymbolIndex, o7.leftJustifiedTextSymbolIndex].forEach((t6) => {
                  t6 >= 0 && (e6.text.placedSymbolArray.get(t6).hidden = i8 || x4 ? 1 : 0);
                }), o7.verticalPlacedTextSymbolIndex >= 0 && (e6.text.placedSymbolArray.get(o7.verticalPlacedTextSymbolIndex).hidden = i8 || b5 ? 1 : 0);
                const r9 = this.variableOffsets[o7.crossTileID];
                r9 && this.markUsedJustification(e6, r9.anchor, o7, v4);
                const n7 = this.placedOrientations[o7.crossTileID];
                n7 && (this.markUsedJustification(e6, "left", o7, n7), this.markUsedOrientation(e6, n7, o7));
              }
              if (g4) {
                const t5 = it(c6.icon), i8 = !(_4 && o7.verticalPlacedIconSymbolIndex && x4);
                o7.placedIconSymbolIndex >= 0 && (m4(e6.icon, o7.numIconVertices, i8 ? t5 : rt), e6.icon.placedSymbolArray.get(o7.placedIconSymbolIndex).hidden = c6.icon.isHidden()), o7.verticalPlacedIconSymbolIndex >= 0 && (m4(e6.icon, o7.numVerticalIconVertices, i8 ? rt : t5), e6.icon.placedSymbolArray.get(o7.verticalPlacedIconSymbolIndex).hidden = c6.icon.isHidden());
              }
              const y4 = f4 && f4.has(i7) ? f4.get(i7) : { text: null, icon: null };
              if (e6.hasIconCollisionBoxData() || e6.hasTextCollisionBoxData()) {
                const r9 = e6.collisionArrays[i7];
                if (r9) {
                  let i8 = new t4.P(0, 0);
                  if (r9.textBox || r9.verticalTextBox) {
                    let t5 = true;
                    if (h4) {
                      const e7 = this.variableOffsets[l6];
                      e7 ? (i8 = We(e7.anchor, e7.width, e7.height, e7.textOffset, e7.textBoxScale), u4 && i8._rotate(d4 ? -this.transform.bearingInRadians : this.transform.bearingInRadians)) : t5 = false;
                    }
                    if (r9.textBox || r9.verticalTextBox) {
                      let o8;
                      r9.textBox && (o8 = x4), r9.verticalTextBox && (o8 = b5), He(e6.textCollisionBox.collisionVertexArray, c6.text.placed, !t5 || o8, y4.text, i8.x, i8.y);
                    }
                  }
                  if (r9.iconBox || r9.verticalIconBox) {
                    const t5 = Boolean(!b5 && r9.verticalIconBox);
                    let o8;
                    r9.iconBox && (o8 = t5), r9.verticalIconBox && (o8 = !t5), He(e6.iconCollisionBox.collisionVertexArray, c6.icon.placed, o8, y4.icon, _4 ? i8.x : 0, _4 ? i8.y : 0);
                  }
                }
              }
            }
            if (e6.sortFeatures(-this.transform.bearingInRadians), this.retainedQueryData[e6.bucketInstanceId] && (this.retainedQueryData[e6.bucketInstanceId].featureSortOrder = e6.featureSortOrder), e6.hasTextData() && e6.text.opacityVertexBuffer && e6.text.opacityVertexBuffer.updateData(e6.text.opacityVertexArray), e6.hasIconData() && e6.icon.opacityVertexBuffer && e6.icon.opacityVertexBuffer.updateData(e6.icon.opacityVertexArray), e6.hasIconCollisionBoxData() && e6.iconCollisionBox.collisionVertexBuffer && e6.iconCollisionBox.collisionVertexBuffer.updateData(e6.iconCollisionBox.collisionVertexArray), e6.hasTextCollisionBoxData() && e6.textCollisionBox.collisionVertexBuffer && e6.textCollisionBox.collisionVertexBuffer.updateData(e6.textCollisionBox.collisionVertexArray), e6.text.opacityVertexArray.length !== e6.text.layoutVertexArray.length / 4) throw new Error(`bucket.text.opacityVertexArray.length (= ${e6.text.opacityVertexArray.length}) !== bucket.text.layoutVertexArray.length (= ${e6.text.layoutVertexArray.length}) / 4`);
            if (e6.icon.opacityVertexArray.length !== e6.icon.layoutVertexArray.length / 4) throw new Error(`bucket.icon.opacityVertexArray.length (= ${e6.icon.opacityVertexArray.length}) !== bucket.icon.layoutVertexArray.length (= ${e6.icon.layoutVertexArray.length}) / 4`);
            e6.bucketInstanceId in this.collisionCircleArrays && (e6.collisionCircleArray = this.collisionCircleArrays[e6.bucketInstanceId], delete this.collisionCircleArrays[e6.bucketInstanceId]);
          }
          symbolFadeChange(e6) {
            return 0 === this.fadeDuration ? 1 : (e6 - this.commitTime) / this.fadeDuration + this.prevZoomAdjustment;
          }
          zoomAdjustment(e6) {
            return Math.max(0, (this.transform.zoom - e6) / 1.5);
          }
          hasTransitions(e6) {
            return this.stale || e6 - this.lastPlacementChangeTime < this.fadeDuration;
          }
          stillRecent(e6, t5) {
            const i6 = this.zoomAtLastRecencyCheck === t5 ? 1 - this.zoomAdjustment(t5) : 1;
            return this.zoomAtLastRecencyCheck = t5, this.commitTime + this.fadeDuration * i6 > e6;
          }
          setStale() {
            this.stale = true;
          }
        }
        function He(e6, t5, i6, r8, o6, a4) {
          r8 && 0 !== r8.length || (r8 = [0, 0, 0, 0]);
          const s4 = r8[0] - je, n6 = r8[1] - je, l5 = r8[2] - je, c5 = r8[3] - je;
          e6.emplaceBack(t5 ? 1 : 0, i6 ? 1 : 0, o6 || 0, a4 || 0, s4, n6), e6.emplaceBack(t5 ? 1 : 0, i6 ? 1 : 0, o6 || 0, a4 || 0, l5, n6), e6.emplaceBack(t5 ? 1 : 0, i6 ? 1 : 0, o6 || 0, a4 || 0, l5, c5), e6.emplaceBack(t5 ? 1 : 0, i6 ? 1 : 0, o6 || 0, a4 || 0, s4, c5);
        }
        const Ke = Math.pow(2, 25), Xe = Math.pow(2, 24), Qe = Math.pow(2, 17), Ye = Math.pow(2, 16), Je = Math.pow(2, 9), et2 = Math.pow(2, 8), tt = Math.pow(2, 1);
        function it(e6) {
          if (0 === e6.opacity && !e6.placed) return 0;
          if (1 === e6.opacity && e6.placed) return 4294967295;
          const t5 = e6.placed ? 1 : 0, i6 = Math.floor(127 * e6.opacity);
          return i6 * Ke + t5 * Xe + i6 * Qe + t5 * Ye + i6 * Je + t5 * et2 + i6 * tt + t5;
        }
        const rt = 0;
        class ot {
          constructor(e6) {
            this._sortAcrossTiles = "viewport-y" !== e6.layout.get("symbol-z-order") && !e6.layout.get("symbol-sort-key").isConstant(), this._currentTileIndex = 0, this._currentPartIndex = 0, this._seenCrossTileIDs = {}, this._bucketParts = [];
          }
          continuePlacement(e6, t5, i6, r8, o6) {
            const a4 = this._bucketParts;
            for (; this._currentTileIndex < e6.length; ) if (t5.getBucketParts(a4, r8, e6[this._currentTileIndex], this._sortAcrossTiles), this._currentTileIndex++, o6()) return true;
            for (this._sortAcrossTiles && (this._sortAcrossTiles = false, a4.sort((e7, t6) => e7.sortKey - t6.sortKey)); this._currentPartIndex < a4.length; ) if (t5.placeLayerBucketPart(a4[this._currentPartIndex], this._seenCrossTileIDs, i6), this._currentPartIndex++, o6()) return true;
            return false;
          }
        }
        class at {
          constructor(e6, t5, i6, r8, o6, a4, s4, n6) {
            this.placement = new $e(e6, t5, a4, s4, n6), this._currentPlacementIndex = i6.length - 1, this._forceFullPlacement = r8, this._showCollisionBoxes = o6, this._done = false;
          }
          isDone() {
            return this._done;
          }
          continuePlacement(e6, t5, i6) {
            const r8 = s3.now(), o6 = () => !this._forceFullPlacement && s3.now() - r8 > 2;
            for (; this._currentPlacementIndex >= 0; ) {
              const r9 = t5[e6[this._currentPlacementIndex]], a4 = this.placement.collisionIndex.transform.zoom;
              if ("symbol" === r9.type && (!r9.minzoom || r9.minzoom <= a4) && (!r9.maxzoom || r9.maxzoom > a4)) {
                if (this._inProgressLayer || (this._inProgressLayer = new ot(r9)), this._inProgressLayer.continuePlacement(i6[r9.source], this.placement, this._showCollisionBoxes, r9, o6)) return;
                delete this._inProgressLayer;
              }
              this._currentPlacementIndex--;
            }
            this._done = true;
          }
          commit(e6) {
            return this.placement.commit(e6), this.placement;
          }
        }
        const st = 512 / t4.Z / 2;
        class nt {
          constructor(e6, i6, r8) {
            this.tileID = e6, this.bucketInstanceId = r8, this._symbolsByKey = {};
            const o6 = /* @__PURE__ */ new Map();
            for (let e7 = 0; e7 < i6.length; e7++) {
              const t5 = i6.get(e7), r9 = t5.key, a4 = o6.get(r9);
              a4 ? a4.push(t5) : o6.set(r9, [t5]);
            }
            for (const [e7, i7] of o6) {
              const r9 = { positions: i7.map((e8) => ({ x: Math.floor(e8.anchorX * st), y: Math.floor(e8.anchorY * st) })), crossTileIDs: i7.map((e8) => e8.crossTileID) };
              if (r9.positions.length > 128) {
                const e8 = new t4.aC(r9.positions.length, 16, Uint16Array);
                for (const { x: t5, y: i8 } of r9.positions) e8.add(t5, i8);
                e8.finish(), delete r9.positions, r9.index = e8;
              }
              this._symbolsByKey[e7] = r9;
            }
          }
          getScaledCoordinates(e6, i6) {
            const { x: r8, y: o6, z: a4 } = this.tileID.canonical, { x: s4, y: n6, z: l5 } = i6.canonical, c5 = st / Math.pow(2, l5 - a4), h4 = (n6 * t4.Z + e6.anchorY) * c5, u4 = o6 * t4.Z * st;
            return { x: Math.floor((s4 * t4.Z + e6.anchorX) * c5 - r8 * t4.Z * st), y: Math.floor(h4 - u4) };
          }
          findMatches(e6, t5, i6) {
            const r8 = this.tileID.canonical.z < t5.canonical.z ? 1 : Math.pow(2, this.tileID.canonical.z - t5.canonical.z);
            for (let o6 = 0; o6 < e6.length; o6++) {
              const a4 = e6.get(o6);
              if (a4.crossTileID) continue;
              const s4 = this._symbolsByKey[a4.key];
              if (!s4) continue;
              const n6 = this.getScaledCoordinates(a4, t5);
              if (s4.index) {
                const e7 = s4.index.range(n6.x - r8, n6.y - r8, n6.x + r8, n6.y + r8).sort();
                for (const t6 of e7) {
                  const e8 = s4.crossTileIDs[t6];
                  if (!i6[e8]) {
                    i6[e8] = true, a4.crossTileID = e8;
                    break;
                  }
                }
              } else if (s4.positions) for (let e7 = 0; e7 < s4.positions.length; e7++) {
                const t6 = s4.positions[e7], o7 = s4.crossTileIDs[e7];
                if (Math.abs(t6.x - n6.x) <= r8 && Math.abs(t6.y - n6.y) <= r8 && !i6[o7]) {
                  i6[o7] = true, a4.crossTileID = o7;
                  break;
                }
              }
            }
          }
          getCrossTileIDsLists() {
            return Object.values(this._symbolsByKey).map(({ crossTileIDs: e6 }) => e6);
          }
        }
        class lt {
          constructor() {
            this.maxCrossTileID = 0;
          }
          generate() {
            return ++this.maxCrossTileID;
          }
        }
        class ct {
          constructor() {
            this.indexes = {}, this.usedCrossTileIDs = {}, this.lng = 0;
          }
          handleWrapJump(e6) {
            const t5 = Math.round((e6 - this.lng) / 360);
            if (0 !== t5) for (const e7 in this.indexes) {
              const i6 = this.indexes[e7], r8 = {};
              for (const e8 in i6) {
                const o6 = i6[e8];
                o6.tileID = o6.tileID.unwrapTo(o6.tileID.wrap + t5), r8[o6.tileID.key] = o6;
              }
              this.indexes[e7] = r8;
            }
            this.lng = e6;
          }
          addBucket(e6, t5, i6) {
            if (this.indexes[e6.overscaledZ] && this.indexes[e6.overscaledZ][e6.key]) {
              if (this.indexes[e6.overscaledZ][e6.key].bucketInstanceId === t5.bucketInstanceId) return false;
              this.removeBucketCrossTileIDs(e6.overscaledZ, this.indexes[e6.overscaledZ][e6.key]);
            }
            for (let e7 = 0; e7 < t5.symbolInstances.length; e7++) t5.symbolInstances.get(e7).crossTileID = 0;
            this.usedCrossTileIDs[e6.overscaledZ] || (this.usedCrossTileIDs[e6.overscaledZ] = {});
            const r8 = this.usedCrossTileIDs[e6.overscaledZ];
            for (const i7 in this.indexes) {
              const o6 = this.indexes[i7];
              if (Number(i7) > e6.overscaledZ) for (const i8 in o6) {
                const a4 = o6[i8];
                a4.tileID.isChildOf(e6) && a4.findMatches(t5.symbolInstances, e6, r8);
              }
              else {
                const a4 = o6[e6.scaledTo(Number(i7)).key];
                a4 && a4.findMatches(t5.symbolInstances, e6, r8);
              }
            }
            for (let e7 = 0; e7 < t5.symbolInstances.length; e7++) {
              const o6 = t5.symbolInstances.get(e7);
              o6.crossTileID || (o6.crossTileID = i6.generate(), r8[o6.crossTileID] = true);
            }
            return void 0 === this.indexes[e6.overscaledZ] && (this.indexes[e6.overscaledZ] = {}), this.indexes[e6.overscaledZ][e6.key] = new nt(e6, t5.symbolInstances, t5.bucketInstanceId), true;
          }
          removeBucketCrossTileIDs(e6, t5) {
            for (const i6 of t5.getCrossTileIDsLists()) for (const t6 of i6) delete this.usedCrossTileIDs[e6][t6];
          }
          removeStaleBuckets(e6) {
            let t5 = false;
            for (const i6 in this.indexes) {
              const r8 = this.indexes[i6];
              for (const o6 in r8) e6[r8[o6].bucketInstanceId] || (this.removeBucketCrossTileIDs(i6, r8[o6]), delete r8[o6], t5 = true);
            }
            return t5;
          }
        }
        class ht {
          constructor() {
            this.layerIndexes = {}, this.crossTileIDs = new lt(), this.maxBucketInstanceId = 0, this.bucketsInCurrentPlacement = {};
          }
          addLayer(e6, t5, i6) {
            let r8 = this.layerIndexes[e6.id];
            void 0 === r8 && (r8 = this.layerIndexes[e6.id] = new ct());
            let o6 = false;
            const a4 = {};
            r8.handleWrapJump(i6);
            for (const i7 of t5) {
              const t6 = i7.getBucket(e6);
              t6 && e6.id === t6.layerIds[0] && (t6.bucketInstanceId || (t6.bucketInstanceId = ++this.maxBucketInstanceId), r8.addBucket(i7.tileID, t6, this.crossTileIDs) && (o6 = true), a4[t6.bucketInstanceId] = true);
            }
            return r8.removeStaleBuckets(a4) && (o6 = true), o6;
          }
          pruneUnusedLayers(e6) {
            const t5 = {};
            e6.forEach((e7) => {
              t5[e7] = true;
            });
            for (const e7 in this.layerIndexes) t5[e7] || delete this.layerIndexes[e7];
          }
        }
        var ut = "void main() {fragColor=vec4(1.0);}";
        const dt = { prelude: _t("#ifdef GL_ES\nprecision mediump float;\n#else\n#if !defined(lowp)\n#define lowp\n#endif\n#if !defined(mediump)\n#define mediump\n#endif\n#if !defined(highp)\n#define highp\n#endif\n#endif\nout highp vec4 fragColor;", "#ifdef GL_ES\nprecision highp float;\n#else\n#if !defined(lowp)\n#define lowp\n#endif\n#if !defined(mediump)\n#define mediump\n#endif\n#if !defined(highp)\n#define highp\n#endif\n#endif\nvec2 unpack_float(const float packedValue) {int packedIntValue=int(packedValue);int v0=packedIntValue/256;return vec2(v0,packedIntValue-v0*256);}vec2 unpack_opacity(const float packedOpacity) {int intOpacity=int(packedOpacity)/2;return vec2(float(intOpacity)/127.0,mod(packedOpacity,2.0));}vec4 decode_color(const vec2 encodedColor) {return vec4(unpack_float(encodedColor[0])/255.0,unpack_float(encodedColor[1])/255.0\n);}float unpack_mix_vec2(const vec2 packedValue,const float t) {return mix(packedValue[0],packedValue[1],t);}vec4 unpack_mix_color(const vec4 packedColors,const float t) {vec4 minColor=decode_color(vec2(packedColors[0],packedColors[1]));vec4 maxColor=decode_color(vec2(packedColors[2],packedColors[3]));return mix(minColor,maxColor,t);}vec2 get_pattern_pos(const vec2 pixel_coord_upper,const vec2 pixel_coord_lower,const vec2 pattern_size,const float tile_units_to_pixels,const vec2 pos) {vec2 offset=mod(mod(mod(pixel_coord_upper,pattern_size)*256.0,pattern_size)*256.0+pixel_coord_lower,pattern_size);return (tile_units_to_pixels*pos+offset)/pattern_size;}mat3 rotationMatrixFromAxisAngle(vec3 u,float angle) {float c=cos(angle);float s=sin(angle);float c2=1.0-c;return mat3(u.x*u.x*c2+      c,u.x*u.y*c2-u.z*s,u.x*u.z*c2+u.y*s,u.y*u.x*c2+u.z*s,u.y*u.y*c2+    c,u.y*u.z*c2-u.x*s,u.z*u.x*c2-u.y*s,u.z*u.y*c2+u.x*s,u.z*u.z*c2+    c\n);}\n#ifdef TERRAIN3D\nuniform sampler2D u_terrain;uniform float u_terrain_dim;uniform mat4 u_terrain_matrix;uniform vec4 u_terrain_unpack;uniform float u_terrain_exaggeration;uniform highp sampler2D u_depth;\n#endif\nconst highp vec4 bitSh=vec4(256.*256.*256.,256.*256.,256.,1.);const highp vec4 bitShifts=vec4(1.)/bitSh;highp float unpack(highp vec4 color) {return dot(color,bitShifts);}highp float depthOpacity(vec3 frag) {\n#ifdef TERRAIN3D\nhighp float d=unpack(texture(u_depth,frag.xy*0.5+0.5))+0.0001-frag.z;return 1.0-max(0.0,min(1.0,-d*500.0));\n#else\nreturn 1.0;\n#endif\n}float calculate_visibility(vec4 pos) {\n#ifdef TERRAIN3D\nvec3 frag=pos.xyz/pos.w;highp float d=depthOpacity(frag);if (d > 0.95) return 1.0;return (d+depthOpacity(frag+vec3(0.0,0.01,0.0)))/2.0;\n#else\nreturn 1.0;\n#endif\n}float ele(vec2 pos) {\n#ifdef TERRAIN3D\nvec4 rgb=(texture(u_terrain,pos)*255.0)*u_terrain_unpack;return rgb.r+rgb.g+rgb.b-u_terrain_unpack.a;\n#else\nreturn 0.0;\n#endif\n}float get_elevation(vec2 pos) {\n#ifdef TERRAIN3D\n#ifdef GLOBE\nif ((pos.y <-32767.5) || (pos.y > 32766.5)) {return 0.0;}\n#endif\nvec2 coord=(u_terrain_matrix*vec4(pos,0.0,1.0)).xy*u_terrain_dim+1.0;vec2 f=fract(coord);vec2 c=(floor(coord)+0.5)/(u_terrain_dim+2.0);float d=1.0/(u_terrain_dim+2.0);float tl=ele(c);float tr=ele(c+vec2(d,0.0));float bl=ele(c+vec2(0.0,d));float br=ele(c+vec2(d,d));float elevation=mix(mix(tl,tr,f.x),mix(bl,br,f.x),f.y);return elevation*u_terrain_exaggeration;\n#else\nreturn 0.0;\n#endif\n}const float PI=3.141592653589793;uniform mat4 u_projection_matrix;"), projectionMercator: _t("", "float projectLineThickness(float tileY) {return 1.0;}float projectCircleRadius(float tileY) {return 1.0;}vec4 projectTile(vec2 p) {vec4 result=u_projection_matrix*vec4(p,0.0,1.0);return result;}vec4 projectTile(vec2 p,vec2 rawPos) {vec4 result=u_projection_matrix*vec4(p,0.0,1.0);if (rawPos.y <-32767.5 || rawPos.y > 32766.5) {result.z=-10000000.0;}return result;}vec4 projectTileWithElevation(vec2 posInTile,float elevation) {return u_projection_matrix*vec4(posInTile,elevation,1.0);}vec4 projectTileFor3D(vec2 posInTile,float elevation) {return projectTileWithElevation(posInTile,elevation);}"), projectionGlobe: _t("", "#define GLOBE_RADIUS 6371008.8\nuniform highp vec4 u_projection_tile_mercator_coords;uniform highp vec4 u_projection_clipping_plane;uniform highp float u_projection_transition;uniform mat4 u_projection_fallback_matrix;vec3 globeRotateVector(vec3 vec,vec2 angles) {vec3 axisRight=vec3(vec.z,0.0,-vec.x);vec3 axisUp=cross(axisRight,vec);axisRight=normalize(axisRight);axisUp=normalize(axisUp);vec2 t=tan(angles);return normalize(vec+axisRight*t.x+axisUp*t.y);}mat3 globeGetRotationMatrix(vec3 spherePos) {vec3 axisRight=vec3(spherePos.z,0.0,-spherePos.x);vec3 axisDown=cross(axisRight,spherePos);axisRight=normalize(axisRight);axisDown=normalize(axisDown);return mat3(axisRight,axisDown,spherePos\n);}float circumferenceRatioAtTileY(float tileY) {float mercator_pos_y=u_projection_tile_mercator_coords.y+u_projection_tile_mercator_coords.w*tileY;float spherical_y=2.0*atan(exp(PI-(mercator_pos_y*PI*2.0)))-PI*0.5;return cos(spherical_y);}float projectLineThickness(float tileY) {float thickness=1.0/circumferenceRatioAtTileY(tileY); \nif (u_projection_transition < 0.999) {return mix(1.0,thickness,u_projection_transition);} else {return thickness;}}vec3 projectToSphere(vec2 translatedPos,vec2 rawPos) {vec2 mercator_pos=u_projection_tile_mercator_coords.xy+u_projection_tile_mercator_coords.zw*translatedPos;vec2 spherical;spherical.x=mercator_pos.x*PI*2.0+PI;spherical.y=2.0*atan(exp(PI-(mercator_pos.y*PI*2.0)))-PI*0.5;float len=cos(spherical.y);vec3 pos=vec3(sin(spherical.x)*len,sin(spherical.y),cos(spherical.x)*len\n);if (rawPos.y <-32767.5) {pos=vec3(0.0,1.0,0.0);}if (rawPos.y > 32766.5) {pos=vec3(0.0,-1.0,0.0);}return pos;}vec3 projectToSphere(vec2 posInTile) {return projectToSphere(posInTile,vec2(0.0,0.0));}float globeComputeClippingZ(vec3 spherePos) {return (1.0-(dot(spherePos,u_projection_clipping_plane.xyz)+u_projection_clipping_plane.w));}vec4 interpolateProjection(vec2 posInTile,vec3 spherePos,float elevation) {vec3 elevatedPos=spherePos*(1.0+elevation/GLOBE_RADIUS);vec4 globePosition=u_projection_matrix*vec4(elevatedPos,1.0);globePosition.z=globeComputeClippingZ(elevatedPos)*globePosition.w;if (u_projection_transition > 0.999) {return globePosition;}vec4 flatPosition=u_projection_fallback_matrix*vec4(posInTile,elevation,1.0);const float z_globeness_threshold=0.2;vec4 result=globePosition;result.z=mix(0.0,globePosition.z,clamp((u_projection_transition-z_globeness_threshold)/(1.0-z_globeness_threshold),0.0,1.0));result.xyw=mix(flatPosition.xyw,globePosition.xyw,u_projection_transition);if ((posInTile.y <-32767.5) || (posInTile.y > 32766.5)) {result=globePosition;const float poles_hidden_anim_percentage=0.02;result.z=mix(globePosition.z,100.0,pow(max((1.0-u_projection_transition)/poles_hidden_anim_percentage,0.0),8.0));}return result;}vec4 interpolateProjectionFor3D(vec2 posInTile,vec3 spherePos,float elevation) {vec3 elevatedPos=spherePos*(1.0+elevation/GLOBE_RADIUS);vec4 globePosition=u_projection_matrix*vec4(elevatedPos,1.0);if (u_projection_transition > 0.999) {return globePosition;}vec4 fallbackPosition=u_projection_fallback_matrix*vec4(posInTile,elevation,1.0);return mix(fallbackPosition,globePosition,u_projection_transition);}vec4 projectTile(vec2 posInTile) {return interpolateProjection(posInTile,projectToSphere(posInTile),0.0);}vec4 projectTile(vec2 posInTile,vec2 rawPos) {return interpolateProjection(posInTile,projectToSphere(posInTile,rawPos),0.0);}vec4 projectTileWithElevation(vec2 posInTile,float elevation) {return interpolateProjection(posInTile,projectToSphere(posInTile),elevation);}vec4 projectTileFor3D(vec2 posInTile,float elevation) {vec3 spherePos=projectToSphere(posInTile,posInTile);return interpolateProjectionFor3D(posInTile,spherePos,elevation);}"), background: _t("uniform vec4 u_color;uniform float u_opacity;void main() {fragColor=u_color*u_opacity;\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(1.0);\n#endif\n}", "in vec2 a_pos;void main() {gl_Position=projectTile(a_pos);}"), backgroundPattern: _t("uniform vec2 u_pattern_tl_a;uniform vec2 u_pattern_br_a;uniform vec2 u_pattern_tl_b;uniform vec2 u_pattern_br_b;uniform vec2 u_texsize;uniform float u_mix;uniform float u_opacity;uniform sampler2D u_image;in vec2 v_pos_a;in vec2 v_pos_b;void main() {vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(u_pattern_tl_a/u_texsize,u_pattern_br_a/u_texsize,imagecoord);vec4 color1=texture(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(u_pattern_tl_b/u_texsize,u_pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture(u_image,pos2);fragColor=mix(color1,color2,u_mix)*u_opacity;\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(1.0);\n#endif\n}", "uniform vec2 u_pattern_size_a;uniform vec2 u_pattern_size_b;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_scale_a;uniform float u_scale_b;uniform float u_tile_units_to_pixels;in vec2 a_pos;out vec2 v_pos_a;out vec2 v_pos_b;void main() {gl_Position=projectTile(a_pos);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,u_scale_a*u_pattern_size_a,u_tile_units_to_pixels,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,u_scale_b*u_pattern_size_b,u_tile_units_to_pixels,a_pos);}"), circle: _t("in vec3 v_data;in float v_visibility;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define mediump float radius\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define highp vec4 stroke_color\n#pragma mapbox: define mediump float stroke_width\n#pragma mapbox: define lowp float stroke_opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize mediump float radius\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize highp vec4 stroke_color\n#pragma mapbox: initialize mediump float stroke_width\n#pragma mapbox: initialize lowp float stroke_opacity\nvec2 extrude=v_data.xy;float extrude_length=length(extrude);float antialiased_blur=v_data.z;float opacity_t=smoothstep(0.0,antialiased_blur,extrude_length-1.0);float color_t=stroke_width < 0.01 ? 0.0 : smoothstep(antialiased_blur,0.0,extrude_length-radius/(radius+stroke_width));fragColor=v_visibility*opacity_t*mix(color*opacity,stroke_color*stroke_opacity,color_t);const float epsilon=0.5/255.0;if (fragColor.r < epsilon && fragColor.g < epsilon && fragColor.b < epsilon && fragColor.a < epsilon) {discard;}\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(1.0);\n#endif\n}", "uniform bool u_scale_with_map;uniform bool u_pitch_with_map;uniform vec2 u_extrude_scale;uniform highp float u_globe_extrude_scale;uniform lowp float u_device_pixel_ratio;uniform highp float u_camera_to_center_distance;uniform vec2 u_translate;in vec2 a_pos;out vec3 v_data;out float v_visibility;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define mediump float radius\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define highp vec4 stroke_color\n#pragma mapbox: define mediump float stroke_width\n#pragma mapbox: define lowp float stroke_opacity\nvoid main(void) {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize mediump float radius\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize highp vec4 stroke_color\n#pragma mapbox: initialize mediump float stroke_width\n#pragma mapbox: initialize lowp float stroke_opacity\nvec2 pos_raw=a_pos+32768.0;vec2 extrude=vec2(mod(pos_raw,8.0)/7.0*2.0-1.0);vec2 circle_center=floor(pos_raw/8.0)+u_translate;float ele=get_elevation(circle_center);v_visibility=calculate_visibility(projectTileWithElevation(circle_center,ele));if (u_pitch_with_map) {\n#ifdef GLOBE\nvec3 center_vector=projectToSphere(circle_center);\n#endif\nfloat angle_scale=u_globe_extrude_scale;vec2 corner_position=circle_center;if (u_scale_with_map) {angle_scale*=(radius+stroke_width);corner_position+=extrude*u_extrude_scale*(radius+stroke_width);} else {\n#ifdef GLOBE\nvec4 projected_center=interpolateProjection(circle_center,center_vector,ele);\n#else\nvec4 projected_center=projectTileWithElevation(circle_center,ele);\n#endif\ncorner_position+=extrude*u_extrude_scale*(radius+stroke_width)*(projected_center.w/u_camera_to_center_distance);angle_scale*=(radius+stroke_width)*(projected_center.w/u_camera_to_center_distance);}\n#ifdef GLOBE\nvec2 angles=extrude*angle_scale;vec3 corner_vector=globeRotateVector(center_vector,angles);gl_Position=interpolateProjection(corner_position,corner_vector,ele);\n#else\ngl_Position=projectTileWithElevation(corner_position,ele);\n#endif\n} else {gl_Position=projectTileWithElevation(circle_center,ele);if (gl_Position.z/gl_Position.w > 1.0) {gl_Position.xy=vec2(10000.0);}if (u_scale_with_map) {gl_Position.xy+=extrude*(radius+stroke_width)*u_extrude_scale*u_camera_to_center_distance;} else {gl_Position.xy+=extrude*(radius+stroke_width)*u_extrude_scale*gl_Position.w;}}float antialiasblur=-max(1.0/u_device_pixel_ratio/(radius+stroke_width),blur);v_data=vec3(extrude.x,extrude.y,antialiasblur);}"), clippingMask: _t(ut, "in vec2 a_pos;void main() {gl_Position=projectTile(a_pos);}"), heatmap: _t("uniform highp float u_intensity;in vec2 v_extrude;\n#pragma mapbox: define highp float weight\n#define GAUSS_COEF 0.3989422804014327\nvoid main() {\n#pragma mapbox: initialize highp float weight\nfloat d=-0.5*3.0*3.0*dot(v_extrude,v_extrude);float val=weight*u_intensity*GAUSS_COEF*exp(d);fragColor=vec4(val,1.0,1.0,1.0);\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(1.0);\n#endif\n}", "uniform float u_extrude_scale;uniform float u_opacity;uniform float u_intensity;uniform highp float u_globe_extrude_scale;in vec2 a_pos;out vec2 v_extrude;\n#pragma mapbox: define highp float weight\n#pragma mapbox: define mediump float radius\nconst highp float ZERO=1.0/255.0/16.0;\n#define GAUSS_COEF 0.3989422804014327\nvoid main(void) {\n#pragma mapbox: initialize highp float weight\n#pragma mapbox: initialize mediump float radius\nvec2 pos_raw=a_pos+32768.0;vec2 unscaled_extrude=vec2(mod(pos_raw,8.0)/7.0*2.0-1.0);float S=sqrt(-2.0*log(ZERO/weight/u_intensity/GAUSS_COEF))/3.0;v_extrude=S*unscaled_extrude;vec2 extrude=v_extrude*radius*u_extrude_scale;vec2 circle_center=floor(pos_raw/8.0);\n#ifdef GLOBE\nvec2 angles=v_extrude*radius*u_globe_extrude_scale;vec3 center_vector=projectToSphere(circle_center);vec3 corner_vector=globeRotateVector(center_vector,angles);gl_Position=interpolateProjection(circle_center+extrude,corner_vector,0.0);\n#else\ngl_Position=projectTileFor3D(circle_center+extrude,get_elevation(circle_center));\n#endif\n}"), heatmapTexture: _t("uniform sampler2D u_image;uniform sampler2D u_color_ramp;uniform float u_opacity;in vec2 v_pos;void main() {float t=texture(u_image,v_pos).r;vec4 color=texture(u_color_ramp,vec2(t,0.5));fragColor=color*u_opacity;\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(0.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec2 u_world;in vec2 a_pos;out vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos*u_world,0,1);v_pos.x=a_pos.x;v_pos.y=1.0-a_pos.y;}"), collisionBox: _t("in float v_placed;in float v_notUsed;void main() {float alpha=0.5;fragColor=vec4(1.0,0.0,0.0,1.0)*alpha;if (v_placed > 0.5) {fragColor=vec4(0.0,0.0,1.0,0.5)*alpha;}if (v_notUsed > 0.5) {fragColor*=.1;}}", "in vec2 a_anchor_pos;in vec2 a_placed;in vec2 a_box_real;uniform vec2 u_pixel_extrude_scale;out float v_placed;out float v_notUsed;void main() {gl_Position=projectTileWithElevation(a_anchor_pos,get_elevation(a_anchor_pos));gl_Position.xy=((a_box_real+0.5)*u_pixel_extrude_scale*2.0-1.0)*vec2(1.0,-1.0)*gl_Position.w;if (gl_Position.z/gl_Position.w < 1.1) {gl_Position.z=0.5;}v_placed=a_placed.x;v_notUsed=a_placed.y;}"), collisionCircle: _t("in float v_radius;in vec2 v_extrude;in float v_collision;void main() {float alpha=0.5;float stroke_radius=0.9;float distance_to_center=length(v_extrude);float distance_to_edge=abs(distance_to_center-v_radius);float opacity_t=smoothstep(-stroke_radius,0.0,-distance_to_edge);vec4 color=mix(vec4(0.0,0.0,1.0,0.5),vec4(1.0,0.0,0.0,1.0),v_collision);fragColor=color*alpha*opacity_t;}", "in vec2 a_pos;in float a_radius;in vec2 a_flags;uniform vec2 u_viewport_size;out float v_radius;out vec2 v_extrude;out float v_collision;void main() {float radius=a_radius;float collision=a_flags.x;float vertexIdx=a_flags.y;vec2 quadVertexOffset=vec2(mix(-1.0,1.0,float(vertexIdx >=2.0)),mix(-1.0,1.0,float(vertexIdx >=1.0 && vertexIdx <=2.0)));vec2 quadVertexExtent=quadVertexOffset*radius;float padding_factor=1.2;v_radius=radius;v_extrude=quadVertexExtent*padding_factor;v_collision=collision;gl_Position=vec4((a_pos/u_viewport_size*2.0-1.0)*vec2(1.0,-1.0),0.0,1.0)+vec4(quadVertexExtent*padding_factor/u_viewport_size*2.0,0.0,0.0);}"), debug: _t("uniform highp vec4 u_color;uniform sampler2D u_overlay;in vec2 v_uv;void main() {vec4 overlay_color=texture(u_overlay,v_uv);fragColor=mix(u_color,overlay_color,overlay_color.a);}", "in vec2 a_pos;out vec2 v_uv;uniform float u_overlay_scale;void main() {v_uv=a_pos/8192.0;gl_Position=projectTileWithElevation(a_pos*u_overlay_scale,get_elevation(a_pos));}"), depth: _t(ut, "in vec2 a_pos;void main() {\n#ifdef GLOBE\ngl_Position=projectTileFor3D(a_pos,0.0);\n#else\ngl_Position=u_projection_matrix*vec4(a_pos,0.0,1.0);\n#endif\n}"), fill: _t("#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float opacity\nfragColor=color*opacity;\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(1.0);\n#endif\n}", "uniform vec2 u_fill_translate;in vec2 a_pos;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float opacity\ngl_Position=projectTile(a_pos+u_fill_translate,a_pos);}"), fillOutline: _t("in vec2 v_pos;\n#ifdef GLOBE\nin float v_depth;\n#endif\n#pragma mapbox: define highp vec4 outline_color\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 outline_color\n#pragma mapbox: initialize lowp float opacity\nfloat dist=length(v_pos-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);fragColor=outline_color*(alpha*opacity);\n#ifdef GLOBE\nif (v_depth > 1.0) {discard;}\n#endif\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(1.0);\n#endif\n}", "uniform vec2 u_world;uniform vec2 u_fill_translate;in vec2 a_pos;out vec2 v_pos;\n#ifdef GLOBE\nout float v_depth;\n#endif\n#pragma mapbox: define highp vec4 outline_color\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 outline_color\n#pragma mapbox: initialize lowp float opacity\ngl_Position=projectTile(a_pos+u_fill_translate,a_pos);v_pos=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;\n#ifdef GLOBE\nv_depth=gl_Position.z/gl_Position.w;\n#endif\n}"), fillOutlinePattern: _t("uniform vec2 u_texsize;uniform sampler2D u_image;uniform float u_fade;in vec2 v_pos_a;in vec2 v_pos_b;in vec2 v_pos;\n#ifdef GLOBE\nin float v_depth;\n#endif\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture(u_image,pos2);float dist=length(v_pos-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);fragColor=mix(color1,color2,u_fade)*alpha*opacity;\n#ifdef GLOBE\nif (v_depth > 1.0) {discard;}\n#endif\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(1.0);\n#endif\n}", "uniform vec2 u_world;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform vec3 u_scale;uniform vec2 u_fill_translate;in vec2 a_pos;out vec2 v_pos_a;out vec2 v_pos_b;out vec2 v_pos;\n#ifdef GLOBE\nout float v_depth;\n#endif\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\n#pragma mapbox: define lowp float pixel_ratio_from\n#pragma mapbox: define lowp float pixel_ratio_to\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\n#pragma mapbox: initialize lowp float pixel_ratio_from\n#pragma mapbox: initialize lowp float pixel_ratio_to\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;gl_Position=projectTile(a_pos+u_fill_translate,a_pos);vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileRatio,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileRatio,a_pos);v_pos=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;\n#ifdef GLOBE\nv_depth=gl_Position.z/gl_Position.w;\n#endif\n}"), fillPattern: _t("#ifdef GL_ES\nprecision highp float;\n#endif\nuniform vec2 u_texsize;uniform float u_fade;uniform sampler2D u_image;in vec2 v_pos_a;in vec2 v_pos_b;\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture(u_image,pos2);fragColor=mix(color1,color2,u_fade)*opacity;\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(1.0);\n#endif\n}", "uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform vec3 u_scale;uniform vec2 u_fill_translate;in vec2 a_pos;out vec2 v_pos_a;out vec2 v_pos_b;\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\n#pragma mapbox: define lowp float pixel_ratio_from\n#pragma mapbox: define lowp float pixel_ratio_to\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\n#pragma mapbox: initialize lowp float pixel_ratio_from\n#pragma mapbox: initialize lowp float pixel_ratio_to\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileZoomRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;gl_Position=projectTile(a_pos+u_fill_translate,a_pos);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileZoomRatio,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileZoomRatio,a_pos);}"), fillExtrusion: _t("in vec4 v_color;void main() {fragColor=v_color;\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(1.0);\n#endif\n}", "uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp vec3 u_lightpos_globe;uniform lowp float u_lightintensity;uniform float u_vertical_gradient;uniform lowp float u_opacity;uniform vec2 u_fill_translate;in vec2 a_pos;in vec4 a_normal_ed;\n#ifdef TERRAIN3D\nin vec2 a_centroid;\n#endif\nout vec4 v_color;\n#pragma mapbox: define highp float base\n#pragma mapbox: define highp float height\n#pragma mapbox: define highp vec4 color\nvoid main() {\n#pragma mapbox: initialize highp float base\n#pragma mapbox: initialize highp float height\n#pragma mapbox: initialize highp vec4 color\nvec3 normal=a_normal_ed.xyz;\n#ifdef TERRAIN3D\nfloat height_terrain3d_offset=get_elevation(a_centroid);float base_terrain3d_offset=height_terrain3d_offset-(base > 0.0 ? 0.0 : 10.0);\n#else\nfloat height_terrain3d_offset=0.0;float base_terrain3d_offset=0.0;\n#endif\nbase=max(0.0,base)+base_terrain3d_offset;height=max(0.0,height)+height_terrain3d_offset;float t=mod(normal.x,2.0);float elevation=t > 0.0 ? height : base;vec2 posInTile=a_pos+u_fill_translate;\n#ifdef GLOBE\nvec3 spherePos=projectToSphere(posInTile,a_pos);gl_Position=interpolateProjectionFor3D(posInTile,spherePos,elevation);\n#else\ngl_Position=u_projection_matrix*vec4(posInTile,elevation,1.0);\n#endif\nfloat colorvalue=color.r*0.2126+color.g*0.7152+color.b*0.0722;v_color=vec4(0.0,0.0,0.0,1.0);vec4 ambientlight=vec4(0.03,0.03,0.03,1.0);color+=ambientlight;vec3 normalForLighting=normal/16384.0;float directional=clamp(dot(normalForLighting,u_lightpos),0.0,1.0);\n#ifdef GLOBE\nmat3 rotMatrix=globeGetRotationMatrix(spherePos);normalForLighting=rotMatrix*normalForLighting;directional=mix(directional,clamp(dot(normalForLighting,u_lightpos_globe),0.0,1.0),u_projection_transition);\n#endif\ndirectional=mix((1.0-u_lightintensity),max((1.0-colorvalue+u_lightintensity),1.0),directional);if (normal.y !=0.0) {directional*=((1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),mix(0.7,0.98,1.0-u_lightintensity),1.0)));}v_color.r+=clamp(color.r*directional*u_lightcolor.r,mix(0.0,0.3,1.0-u_lightcolor.r),1.0);v_color.g+=clamp(color.g*directional*u_lightcolor.g,mix(0.0,0.3,1.0-u_lightcolor.g),1.0);v_color.b+=clamp(color.b*directional*u_lightcolor.b,mix(0.0,0.3,1.0-u_lightcolor.b),1.0);v_color*=u_opacity;}"), fillExtrusionPattern: _t("uniform vec2 u_texsize;uniform float u_fade;uniform sampler2D u_image;in vec2 v_pos_a;in vec2 v_pos_b;in vec4 v_lighting;\n#pragma mapbox: define lowp float base\n#pragma mapbox: define lowp float height\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\n#pragma mapbox: define lowp float pixel_ratio_from\n#pragma mapbox: define lowp float pixel_ratio_to\nvoid main() {\n#pragma mapbox: initialize lowp float base\n#pragma mapbox: initialize lowp float height\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\n#pragma mapbox: initialize lowp float pixel_ratio_from\n#pragma mapbox: initialize lowp float pixel_ratio_to\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture(u_image,pos2);vec4 mixedColor=mix(color1,color2,u_fade);fragColor=mixedColor*v_lighting;\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(1.0);\n#endif\n}", "uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_height_factor;uniform vec3 u_scale;uniform float u_vertical_gradient;uniform lowp float u_opacity;uniform vec2 u_fill_translate;uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp vec3 u_lightpos_globe;uniform lowp float u_lightintensity;in vec2 a_pos;in vec4 a_normal_ed;\n#ifdef TERRAIN3D\nin vec2 a_centroid;\n#endif\n#ifdef GLOBE\nout vec3 v_sphere_pos;\n#endif\nout vec2 v_pos_a;out vec2 v_pos_b;out vec4 v_lighting;\n#pragma mapbox: define lowp float base\n#pragma mapbox: define lowp float height\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\n#pragma mapbox: define lowp float pixel_ratio_from\n#pragma mapbox: define lowp float pixel_ratio_to\nvoid main() {\n#pragma mapbox: initialize lowp float base\n#pragma mapbox: initialize lowp float height\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\n#pragma mapbox: initialize lowp float pixel_ratio_from\n#pragma mapbox: initialize lowp float pixel_ratio_to\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec3 normal=a_normal_ed.xyz;float edgedistance=a_normal_ed.w;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;\n#ifdef TERRAIN3D\nfloat height_terrain3d_offset=get_elevation(a_centroid);float base_terrain3d_offset=height_terrain3d_offset-(base > 0.0 ? 0.0 : 10.0);\n#else\nfloat height_terrain3d_offset=0.0;float base_terrain3d_offset=0.0;\n#endif\nbase=max(0.0,base)+base_terrain3d_offset;height=max(0.0,height)+height_terrain3d_offset;float t=mod(normal.x,2.0);float elevation=t > 0.0 ? height : base;vec2 posInTile=a_pos+u_fill_translate;\n#ifdef GLOBE\nvec3 spherePos=projectToSphere(posInTile,a_pos);vec3 elevatedPos=spherePos*(1.0+elevation/GLOBE_RADIUS);v_sphere_pos=elevatedPos;gl_Position=interpolateProjectionFor3D(posInTile,spherePos,elevation);\n#else\ngl_Position=u_projection_matrix*vec4(posInTile,elevation,1.0);\n#endif\nvec2 pos=normal.x==1.0 && normal.y==0.0 && normal.z==16384.0\n? a_pos\n: vec2(edgedistance,elevation*u_height_factor);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileRatio,pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileRatio,pos);v_lighting=vec4(0.0,0.0,0.0,1.0);float directional=clamp(dot(normal/16383.0,u_lightpos),0.0,1.0);directional=mix((1.0-u_lightintensity),max((0.5+u_lightintensity),1.0),directional);if (normal.y !=0.0) {directional*=((1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),mix(0.7,0.98,1.0-u_lightintensity),1.0)));}v_lighting.rgb+=clamp(directional*u_lightcolor,mix(vec3(0.0),vec3(0.3),1.0-u_lightcolor),vec3(1.0));v_lighting*=u_opacity;}"), hillshadePrepare: _t("#ifdef GL_ES\nprecision highp float;\n#endif\nuniform sampler2D u_image;in vec2 v_pos;uniform vec2 u_dimension;uniform float u_zoom;uniform vec4 u_unpack;float getElevation(vec2 coord,float bias) {vec4 data=texture(u_image,coord)*255.0;data.a=-1.0;return dot(data,u_unpack)/4.0;}void main() {vec2 epsilon=1.0/u_dimension;float a=getElevation(v_pos+vec2(-epsilon.x,-epsilon.y),0.0);float b=getElevation(v_pos+vec2(0,-epsilon.y),0.0);float c=getElevation(v_pos+vec2(epsilon.x,-epsilon.y),0.0);float d=getElevation(v_pos+vec2(-epsilon.x,0),0.0);float e=getElevation(v_pos,0.0);float f=getElevation(v_pos+vec2(epsilon.x,0),0.0);float g=getElevation(v_pos+vec2(-epsilon.x,epsilon.y),0.0);float h=getElevation(v_pos+vec2(0,epsilon.y),0.0);float i=getElevation(v_pos+vec2(epsilon.x,epsilon.y),0.0);float exaggerationFactor=u_zoom < 2.0 ? 0.4 : u_zoom < 4.5 ? 0.35 : 0.3;float exaggeration=u_zoom < 15.0 ? (u_zoom-15.0)*exaggerationFactor : 0.0;vec2 deriv=vec2((c+f+f+i)-(a+d+d+g),(g+h+h+i)-(a+b+b+c))/pow(2.0,exaggeration+(19.2562-u_zoom));fragColor=clamp(vec4(deriv.x/2.0+0.5,deriv.y/2.0+0.5,1.0,1.0),0.0,1.0);\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec2 u_dimension;in vec2 a_pos;in vec2 a_texture_pos;out vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);highp vec2 epsilon=1.0/u_dimension;float scale=(u_dimension.x-2.0)/u_dimension.x;v_pos=(a_texture_pos/8192.0)*scale+epsilon;}"), hillshade: _t("uniform sampler2D u_image;in vec2 v_pos;uniform vec2 u_latrange;uniform vec2 u_light;uniform vec4 u_shadow;uniform vec4 u_highlight;uniform vec4 u_accent;\n#define PI 3.141592653589793\nvoid main() {vec4 pixel=texture(u_image,v_pos);vec2 deriv=((pixel.rg*2.0)-1.0);float scaleFactor=cos(radians((u_latrange[0]-u_latrange[1])*(1.0-v_pos.y)+u_latrange[1]));float slope=atan(1.25*length(deriv)/scaleFactor);float aspect=deriv.x !=0.0 ? atan(deriv.y,-deriv.x) : PI/2.0*(deriv.y > 0.0 ? 1.0 :-1.0);float intensity=u_light.x;float azimuth=u_light.y+PI;float base=1.875-intensity*1.75;float maxValue=0.5*PI;float scaledSlope=intensity !=0.5 ? ((pow(base,slope)-1.0)/(pow(base,maxValue)-1.0))*maxValue : slope;float accent=cos(scaledSlope);vec4 accent_color=(1.0-accent)*u_accent*clamp(intensity*2.0,0.0,1.0);float shade=abs(mod((aspect+azimuth)/PI+0.5,2.0)-1.0);vec4 shade_color=mix(u_shadow,u_highlight,shade)*sin(scaledSlope)*clamp(intensity*2.0,0.0,1.0);fragColor=accent_color*(1.0-shade_color.a)+shade_color;\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;in vec2 a_pos;out vec2 v_pos;void main() {gl_Position=projectTile(a_pos,a_pos);v_pos=a_pos/8192.0;if (a_pos.y <-32767.5) {v_pos.y=0.0;}if (a_pos.y > 32766.5) {v_pos.y=1.0;}}"), line: _t("uniform lowp float u_device_pixel_ratio;in vec2 v_width2;in vec2 v_normal;in float v_gamma_scale;\n#ifdef GLOBE\nin float v_depth;\n#endif\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\nfloat dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);fragColor=color*(alpha*opacity);\n#ifdef GLOBE\nif (v_depth > 1.0) {discard;}\n#endif\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(1.0);\n#endif\n}", "\n#define scale 0.015873016\nin vec2 a_pos_normal;in vec4 a_data;uniform vec2 u_translation;uniform mediump float u_ratio;uniform vec2 u_units_to_pixels;uniform lowp float u_device_pixel_ratio;out vec2 v_normal;out vec2 v_width2;out float v_gamma_scale;out highp float v_linesofar;\n#ifdef GLOBE\nout float v_depth;\n#endif\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define mediump float gapwidth\n#pragma mapbox: define lowp float offset\n#pragma mapbox: define mediump float width\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump float gapwidth\n#pragma mapbox: initialize lowp float offset\n#pragma mapbox: initialize mediump float width\nfloat ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;v_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*2.0;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);float adjustedThickness=projectLineThickness(pos.y);vec4 projected_no_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation);vec4 projected_with_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation+dist/u_ratio*adjustedThickness);gl_Position=projected_with_extrude;\n#ifdef GLOBE\nv_depth=gl_Position.z/gl_Position.w;\n#endif\n#ifdef TERRAIN3D\nv_gamma_scale=1.0;\n#else\nfloat extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length((projected_with_extrude.xy-projected_no_extrude.xy)/projected_with_extrude.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;\n#endif\nv_width2=vec2(outset,inset);}"), lineGradient: _t("uniform lowp float u_device_pixel_ratio;uniform sampler2D u_image;in vec2 v_width2;in vec2 v_normal;in float v_gamma_scale;in highp vec2 v_uv;\n#ifdef GLOBE\nin float v_depth;\n#endif\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\nfloat dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);vec4 color=texture(u_image,v_uv);fragColor=color*(alpha*opacity);\n#ifdef GLOBE\nif (v_depth > 1.0) {discard;}\n#endif\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(1.0);\n#endif\n}", "\n#define scale 0.015873016\nin vec2 a_pos_normal;in vec4 a_data;in float a_uv_x;in float a_split_index;uniform vec2 u_translation;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;uniform vec2 u_units_to_pixels;uniform float u_image_height;out vec2 v_normal;out vec2 v_width2;out float v_gamma_scale;out highp vec2 v_uv;\n#ifdef GLOBE\nout float v_depth;\n#endif\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define mediump float gapwidth\n#pragma mapbox: define lowp float offset\n#pragma mapbox: define mediump float width\nvoid main() {\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump float gapwidth\n#pragma mapbox: initialize lowp float offset\n#pragma mapbox: initialize mediump float width\nfloat ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;highp float texel_height=1.0/u_image_height;highp float half_texel_height=0.5*texel_height;v_uv=vec2(a_uv_x,a_split_index*texel_height-half_texel_height);vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);float adjustedThickness=projectLineThickness(pos.y);vec4 projected_no_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation);vec4 projected_with_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation+dist/u_ratio*adjustedThickness);gl_Position=projected_with_extrude;\n#ifdef GLOBE\nv_depth=gl_Position.z/gl_Position.w;\n#endif\n#ifdef TERRAIN3D\nv_gamma_scale=1.0;\n#else\nfloat extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length((projected_with_extrude.xy-projected_no_extrude.xy)/projected_with_extrude.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;\n#endif\nv_width2=vec2(outset,inset);}"), linePattern: _t("#ifdef GL_ES\nprecision highp float;\n#endif\nuniform lowp float u_device_pixel_ratio;uniform vec2 u_texsize;uniform float u_fade;uniform mediump vec3 u_scale;uniform sampler2D u_image;in vec2 v_normal;in vec2 v_width2;in float v_linesofar;in float v_gamma_scale;in float v_width;\n#ifdef GLOBE\nin float v_depth;\n#endif\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\n#pragma mapbox: define lowp float pixel_ratio_from\n#pragma mapbox: define lowp float pixel_ratio_to\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\n#pragma mapbox: initialize lowp float pixel_ratio_from\n#pragma mapbox: initialize lowp float pixel_ratio_to\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileZoomRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;vec2 pattern_size_a=vec2(display_size_a.x*fromScale/tileZoomRatio,display_size_a.y);vec2 pattern_size_b=vec2(display_size_b.x*toScale/tileZoomRatio,display_size_b.y);float aspect_a=display_size_a.y/v_width;float aspect_b=display_size_b.y/v_width;float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);float x_a=mod(v_linesofar/pattern_size_a.x*aspect_a,1.0);float x_b=mod(v_linesofar/pattern_size_b.x*aspect_b,1.0);float y=0.5*v_normal.y+0.5;vec2 texel_size=1.0/u_texsize;vec2 pos_a=mix(pattern_tl_a*texel_size-texel_size,pattern_br_a*texel_size+texel_size,vec2(x_a,y));vec2 pos_b=mix(pattern_tl_b*texel_size-texel_size,pattern_br_b*texel_size+texel_size,vec2(x_b,y));vec4 color=mix(texture(u_image,pos_a),texture(u_image,pos_b),u_fade);fragColor=color*alpha*opacity;\n#ifdef GLOBE\nif (v_depth > 1.0) {discard;}\n#endif\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(1.0);\n#endif\n}", "\n#define scale 0.015873016\n#define LINE_DISTANCE_SCALE 2.0\nin vec2 a_pos_normal;in vec4 a_data;uniform vec2 u_translation;uniform vec2 u_units_to_pixels;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;out vec2 v_normal;out vec2 v_width2;out float v_linesofar;out float v_gamma_scale;out float v_width;\n#ifdef GLOBE\nout float v_depth;\n#endif\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float offset\n#pragma mapbox: define mediump float gapwidth\n#pragma mapbox: define mediump float width\n#pragma mapbox: define lowp float floorwidth\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\n#pragma mapbox: define lowp float pixel_ratio_from\n#pragma mapbox: define lowp float pixel_ratio_to\nvoid main() {\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float offset\n#pragma mapbox: initialize mediump float gapwidth\n#pragma mapbox: initialize mediump float width\n#pragma mapbox: initialize lowp float floorwidth\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\n#pragma mapbox: initialize lowp float pixel_ratio_from\n#pragma mapbox: initialize lowp float pixel_ratio_to\nfloat ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;float a_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*LINE_DISTANCE_SCALE;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);float adjustedThickness=projectLineThickness(pos.y);vec4 projected_no_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation);vec4 projected_with_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation+dist/u_ratio*adjustedThickness);gl_Position=projected_with_extrude;\n#ifdef GLOBE\nv_depth=gl_Position.z/gl_Position.w;\n#endif\n#ifdef TERRAIN3D\nv_gamma_scale=1.0;\n#else\nfloat extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length((projected_with_extrude.xy-projected_no_extrude.xy)/projected_with_extrude.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;\n#endif\nv_linesofar=a_linesofar;v_width2=vec2(outset,inset);v_width=floorwidth;}"), lineSDF: _t("uniform lowp float u_device_pixel_ratio;uniform sampler2D u_image;uniform float u_sdfgamma;uniform float u_mix;in vec2 v_normal;in vec2 v_width2;in vec2 v_tex_a;in vec2 v_tex_b;in float v_gamma_scale;\n#ifdef GLOBE\nin float v_depth;\n#endif\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define mediump float width\n#pragma mapbox: define lowp float floorwidth\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump float width\n#pragma mapbox: initialize lowp float floorwidth\nfloat dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);float sdfdist_a=texture(u_image,v_tex_a).a;float sdfdist_b=texture(u_image,v_tex_b).a;float sdfdist=mix(sdfdist_a,sdfdist_b,u_mix);alpha*=smoothstep(0.5-u_sdfgamma/floorwidth,0.5+u_sdfgamma/floorwidth,sdfdist);fragColor=color*(alpha*opacity);\n#ifdef GLOBE\nif (v_depth > 1.0) {discard;}\n#endif\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(1.0);\n#endif\n}", "\n#define scale 0.015873016\n#define LINE_DISTANCE_SCALE 2.0\nin vec2 a_pos_normal;in vec4 a_data;uniform vec2 u_translation;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;uniform vec2 u_patternscale_a;uniform float u_tex_y_a;uniform vec2 u_patternscale_b;uniform float u_tex_y_b;uniform vec2 u_units_to_pixels;out vec2 v_normal;out vec2 v_width2;out vec2 v_tex_a;out vec2 v_tex_b;out float v_gamma_scale;\n#ifdef GLOBE\nout float v_depth;\n#endif\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define mediump float gapwidth\n#pragma mapbox: define lowp float offset\n#pragma mapbox: define mediump float width\n#pragma mapbox: define lowp float floorwidth\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump float gapwidth\n#pragma mapbox: initialize lowp float offset\n#pragma mapbox: initialize mediump float width\n#pragma mapbox: initialize lowp float floorwidth\nfloat ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;float a_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*LINE_DISTANCE_SCALE;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);float adjustedThickness=projectLineThickness(pos.y);vec4 projected_no_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation);vec4 projected_with_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation+dist/u_ratio*adjustedThickness);gl_Position=projected_with_extrude;\n#ifdef GLOBE\nv_depth=gl_Position.z/gl_Position.w;\n#endif\n#ifdef TERRAIN3D\nv_gamma_scale=1.0;\n#else\nfloat extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length((projected_with_extrude.xy-projected_no_extrude.xy)/projected_with_extrude.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;\n#endif\nv_tex_a=vec2(a_linesofar*u_patternscale_a.x/floorwidth,normal.y*u_patternscale_a.y+u_tex_y_a);v_tex_b=vec2(a_linesofar*u_patternscale_b.x/floorwidth,normal.y*u_patternscale_b.y+u_tex_y_b);v_width2=vec2(outset,inset);}"), raster: _t("uniform float u_fade_t;uniform float u_opacity;uniform sampler2D u_image0;uniform sampler2D u_image1;in vec2 v_pos0;in vec2 v_pos1;uniform float u_brightness_low;uniform float u_brightness_high;uniform float u_saturation_factor;uniform float u_contrast_factor;uniform vec3 u_spin_weights;void main() {vec4 color0=texture(u_image0,v_pos0);vec4 color1=texture(u_image1,v_pos1);if (color0.a > 0.0) {color0.rgb=color0.rgb/color0.a;}if (color1.a > 0.0) {color1.rgb=color1.rgb/color1.a;}vec4 color=mix(color0,color1,u_fade_t);color.a*=u_opacity;vec3 rgb=color.rgb;rgb=vec3(dot(rgb,u_spin_weights.xyz),dot(rgb,u_spin_weights.zxy),dot(rgb,u_spin_weights.yzx));float average=(color.r+color.g+color.b)/3.0;rgb+=(average-rgb)*u_saturation_factor;rgb=(rgb-0.5)*u_contrast_factor+0.5;vec3 u_high_vec=vec3(u_brightness_low,u_brightness_low,u_brightness_low);vec3 u_low_vec=vec3(u_brightness_high,u_brightness_high,u_brightness_high);fragColor=vec4(mix(u_high_vec,u_low_vec,rgb)*color.a,color.a);\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(1.0);\n#endif\n}", "uniform vec2 u_tl_parent;uniform float u_scale_parent;uniform float u_buffer_scale;uniform vec4 u_coords_top;uniform vec4 u_coords_bottom;in vec2 a_pos;out vec2 v_pos0;out vec2 v_pos1;void main() {vec2 fractionalPos=a_pos/8192.0;vec2 position=mix(mix(u_coords_top.xy,u_coords_top.zw,fractionalPos.x),mix(u_coords_bottom.xy,u_coords_bottom.zw,fractionalPos.x),fractionalPos.y);gl_Position=projectTile(position,position);v_pos0=((fractionalPos-0.5)/u_buffer_scale)+0.5;\n#ifdef GLOBE\nif (a_pos.y <-32767.5) {v_pos0.y=0.0;}if (a_pos.y > 32766.5) {v_pos0.y=1.0;}\n#endif\nv_pos1=(v_pos0*u_scale_parent)+u_tl_parent;}"), symbolIcon: _t("uniform sampler2D u_texture;in vec2 v_tex;in float v_fade_opacity;\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\nlowp float alpha=opacity*v_fade_opacity;fragColor=texture(u_texture,v_tex)*alpha;\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(1.0);\n#endif\n}", "in vec4 a_pos_offset;in vec4 a_data;in vec4 a_pixeloffset;in vec3 a_projected_pos;in float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform highp float u_camera_to_center_distance;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform float u_fade_change;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform vec2 u_texsize;uniform bool u_is_along_line;uniform bool u_is_variable_anchor;uniform vec2 u_translation;uniform float u_pitched_scale;out vec2 v_tex;out float v_fade_opacity;\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\nvec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);vec2 a_pxoffset=a_pixeloffset.xy;vec2 a_minFontScale=a_pixeloffset.zw/256.0;float ele=get_elevation(a_pos);highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 translated_a_pos=a_pos+u_translation;vec4 projectedPoint=projectTileWithElevation(translated_a_pos,ele);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?\ncamera_to_anchor_distance/u_camera_to_center_distance :\nu_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=projectTileWithElevation(translated_a_pos+vec2(1,0),ele);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos;if (u_is_along_line || u_is_variable_anchor) {projected_pos=vec4(a_projected_pos.xy,ele,1.0);} else if (u_pitch_with_map) {projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy+u_translation,ele,1.0);} else {projected_pos=u_label_plane_matrix*projectTileWithElevation(a_projected_pos.xy+u_translation,ele);}float z=float(u_pitch_with_map)*projected_pos.z/projected_pos.w;float projectionScaling=1.0;\n#ifdef GLOBE\nif(u_pitch_with_map) {float anchor_pos_tile_y=(u_coord_matrix*vec4(projected_pos.xy/projected_pos.w,z,1.0)).y;projectionScaling=mix(projectionScaling,1.0/circumferenceRatioAtTileY(anchor_pos_tile_y)*u_pitched_scale,u_projection_transition);}\n#endif\nvec4 finalPos=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*max(a_minFontScale,fontScale)+a_pxoffset/16.0)*projectionScaling,z,1.0);if(u_pitch_with_map) {finalPos=projectTileWithElevation(finalPos.xy,finalPos.z);}gl_Position=finalPos;v_tex=a_tex/u_texsize;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float visibility=calculate_visibility(projectedPoint);v_fade_opacity=max(0.0,min(visibility,fade_opacity[0]+fade_change));}"), symbolSDF: _t("#define SDF_PX 8.0\nuniform bool u_is_halo;uniform sampler2D u_texture;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;uniform bool u_is_text;in vec2 v_data0;in vec3 v_data1;\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\nvoid main() {\n#pragma mapbox: initialize highp vec4 fill_color\n#pragma mapbox: initialize highp vec4 halo_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float halo_width\n#pragma mapbox: initialize lowp float halo_blur\nfloat EDGE_GAMMA=0.105/u_device_pixel_ratio;vec2 tex=v_data0.xy;float gamma_scale=v_data1.x;float size=v_data1.y;float fade_opacity=v_data1[2];float fontScale=u_is_text ? size/24.0 : size;lowp vec4 color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float inner_edge=(256.0-64.0)/256.0;if (u_is_halo) {color=halo_color;gamma=(halo_blur*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);inner_edge=inner_edge+gamma*gamma_scale;}lowp float dist=texture(u_texture,tex).a;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(inner_edge-gamma_scaled,inner_edge+gamma_scaled,dist);if (u_is_halo) {lowp float halo_edge=(6.0-halo_width/fontScale)/SDF_PX;alpha=min(smoothstep(halo_edge-gamma_scaled,halo_edge+gamma_scaled,dist),1.0-alpha);}fragColor=color*(alpha*opacity*fade_opacity);\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(1.0);\n#endif\n}", "in vec4 a_pos_offset;in vec4 a_data;in vec4 a_pixeloffset;in vec3 a_projected_pos;in float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform bool u_is_along_line;uniform bool u_is_variable_anchor;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;uniform vec2 u_translation;uniform float u_pitched_scale;out vec2 v_data0;out vec3 v_data1;\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\nvoid main() {\n#pragma mapbox: initialize highp vec4 fill_color\n#pragma mapbox: initialize highp vec4 halo_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float halo_width\n#pragma mapbox: initialize lowp float halo_blur\nvec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);vec2 a_pxoffset=a_pixeloffset.xy;float ele=get_elevation(a_pos);highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 translated_a_pos=a_pos+u_translation;vec4 projectedPoint=projectTileWithElevation(translated_a_pos,ele);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?\ncamera_to_anchor_distance/u_camera_to_center_distance :\nu_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=projectTileWithElevation(translated_a_pos+vec2(1,0),ele);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos;if (u_is_along_line || u_is_variable_anchor) {projected_pos=vec4(a_projected_pos.xy,ele,1.0);} else if (u_pitch_with_map) {projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy+u_translation,ele,1.0);} else {projected_pos=u_label_plane_matrix*projectTileWithElevation(a_projected_pos.xy+u_translation,ele);}float z=float(u_pitch_with_map)*projected_pos.z/projected_pos.w;float projectionScaling=1.0;\n#ifdef GLOBE\nif(u_pitch_with_map) {float anchor_pos_tile_y=(u_coord_matrix*vec4(projected_pos.xy/projected_pos.w,z,1.0)).y;projectionScaling=mix(projectionScaling,1.0/circumferenceRatioAtTileY(anchor_pos_tile_y)*u_pitched_scale,u_projection_transition);}\n#endif\nvec4 finalPos=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*fontScale+a_pxoffset)*projectionScaling,z,1.0);if(u_pitch_with_map) {finalPos=projectTileWithElevation(finalPos.xy,finalPos.z);}float gamma_scale=finalPos.w;gl_Position=finalPos;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float visibility=calculate_visibility(projectedPoint);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float interpolated_fade_opacity=max(0.0,min(visibility,fade_opacity[0]+fade_change));v_data0=a_tex/u_texsize;v_data1=vec3(gamma_scale,size,interpolated_fade_opacity);}"), symbolTextAndIcon: _t("#define SDF_PX 8.0\n#define SDF 1.0\n#define ICON 0.0\nuniform bool u_is_halo;uniform sampler2D u_texture;uniform sampler2D u_texture_icon;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;in vec4 v_data0;in vec4 v_data1;\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\nvoid main() {\n#pragma mapbox: initialize highp vec4 fill_color\n#pragma mapbox: initialize highp vec4 halo_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float halo_width\n#pragma mapbox: initialize lowp float halo_blur\nfloat fade_opacity=v_data1[2];if (v_data1.w==ICON) {vec2 tex_icon=v_data0.zw;lowp float alpha=opacity*fade_opacity;fragColor=texture(u_texture_icon,tex_icon)*alpha;\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(1.0);\n#endif\nreturn;}vec2 tex=v_data0.xy;float EDGE_GAMMA=0.105/u_device_pixel_ratio;float gamma_scale=v_data1.x;float size=v_data1.y;float fontScale=size/24.0;lowp vec4 color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float buff=(256.0-64.0)/256.0;if (u_is_halo) {color=halo_color;gamma=(halo_blur*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);buff=(6.0-halo_width/fontScale)/SDF_PX;}lowp float dist=texture(u_texture,tex).a;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(buff-gamma_scaled,buff+gamma_scaled,dist);fragColor=color*(alpha*opacity*fade_opacity);\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(1.0);\n#endif\n}", "in vec4 a_pos_offset;in vec4 a_data;in vec3 a_projected_pos;in float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;uniform vec2 u_texsize_icon;uniform bool u_is_along_line;uniform bool u_is_variable_anchor;uniform vec2 u_translation;uniform float u_pitched_scale;out vec4 v_data0;out vec4 v_data1;\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\nvoid main() {\n#pragma mapbox: initialize highp vec4 fill_color\n#pragma mapbox: initialize highp vec4 halo_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float halo_width\n#pragma mapbox: initialize lowp float halo_blur\nvec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);float is_sdf=a_size[0]-2.0*a_size_min;float ele=get_elevation(a_pos);highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 translated_a_pos=a_pos+u_translation;vec4 projectedPoint=projectTileWithElevation(translated_a_pos,ele);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?\ncamera_to_anchor_distance/u_camera_to_center_distance :\nu_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=size/24.0;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=projectTileWithElevation(translated_a_pos+vec2(1,0),ele);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos;if (u_is_along_line || u_is_variable_anchor) {projected_pos=vec4(a_projected_pos.xy,ele,1.0);} else if (u_pitch_with_map) {projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy+u_translation,ele,1.0);} else {projected_pos=u_label_plane_matrix*projectTileWithElevation(a_projected_pos.xy+u_translation,ele);}float z=float(u_pitch_with_map)*projected_pos.z/projected_pos.w;float projectionScaling=1.0;\n#ifdef GLOBE\nif(u_pitch_with_map && !u_is_along_line) {float anchor_pos_tile_y=(u_coord_matrix*vec4(projected_pos.xy/projected_pos.w,z,1.0)).y;projectionScaling=mix(projectionScaling,1.0/circumferenceRatioAtTileY(anchor_pos_tile_y)*u_pitched_scale,u_projection_transition);}\n#endif\nvec4 finalPos=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*fontScale)*projectionScaling,z,1.0);if(u_pitch_with_map) {finalPos=projectTileWithElevation(finalPos.xy,finalPos.z);}float gamma_scale=finalPos.w;gl_Position=finalPos;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float visibility=calculate_visibility(projectedPoint);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float interpolated_fade_opacity=max(0.0,min(visibility,fade_opacity[0]+fade_change));v_data0.xy=a_tex/u_texsize;v_data0.zw=a_tex/u_texsize_icon;v_data1=vec4(gamma_scale,size,interpolated_fade_opacity,is_sdf);}"), terrain: _t("uniform sampler2D u_texture;uniform vec4 u_fog_color;uniform vec4 u_horizon_color;uniform float u_fog_ground_blend;uniform float u_fog_ground_blend_opacity;uniform float u_horizon_fog_blend;uniform bool u_is_globe_mode;in vec2 v_texture_pos;in float v_fog_depth;const float gamma=2.2;vec4 gammaToLinear(vec4 color) {return pow(color,vec4(gamma));}vec4 linearToGamma(vec4 color) {return pow(color,vec4(1.0/gamma));}void main() {vec4 surface_color=texture(u_texture,vec2(v_texture_pos.x,1.0-v_texture_pos.y));if (!u_is_globe_mode && v_fog_depth > u_fog_ground_blend) {vec4 surface_color_linear=gammaToLinear(surface_color);float blend_color=smoothstep(0.0,1.0,max((v_fog_depth-u_horizon_fog_blend)/(1.0-u_horizon_fog_blend),0.0));vec4 fog_horizon_color_linear=mix(gammaToLinear(u_fog_color),gammaToLinear(u_horizon_color),blend_color);float factor_fog=max(v_fog_depth-u_fog_ground_blend,0.0)/(1.0-u_fog_ground_blend);fragColor=linearToGamma(mix(surface_color_linear,fog_horizon_color_linear,pow(factor_fog,2.0)*u_fog_ground_blend_opacity));} else {fragColor=surface_color;}}", "in vec3 a_pos3d;uniform mat4 u_fog_matrix;uniform float u_ele_delta;out vec2 v_texture_pos;out float v_fog_depth;void main() {float ele=get_elevation(a_pos3d.xy);float ele_delta=a_pos3d.z==1.0 ? u_ele_delta : 0.0;v_texture_pos=a_pos3d.xy/8192.0;gl_Position=projectTileFor3D(a_pos3d.xy,get_elevation(a_pos3d.xy)-ele_delta);vec4 pos=u_fog_matrix*vec4(a_pos3d.xy,ele,1.0);v_fog_depth=pos.z/pos.w*0.5+0.5;}"), terrainDepth: _t("in float v_depth;const highp vec4 bitSh=vec4(256.*256.*256.,256.*256.,256.,1.);const highp vec4 bitMsk=vec4(0.,vec3(1./256.0));highp vec4 pack(highp float value) {highp vec4 comp=fract(value*bitSh);comp-=comp.xxyz*bitMsk;return comp;}void main() {fragColor=pack(v_depth);}", "in vec3 a_pos3d;uniform float u_ele_delta;out float v_depth;void main() {float ele=get_elevation(a_pos3d.xy);float ele_delta=a_pos3d.z==1.0 ? u_ele_delta : 0.0;gl_Position=projectTileFor3D(a_pos3d.xy,ele-ele_delta);v_depth=gl_Position.z/gl_Position.w;}"), terrainCoords: _t("precision mediump float;uniform sampler2D u_texture;uniform float u_terrain_coords_id;in vec2 v_texture_pos;void main() {vec4 rgba=texture(u_texture,v_texture_pos);fragColor=vec4(rgba.r,rgba.g,rgba.b,u_terrain_coords_id);}", "in vec3 a_pos3d;uniform float u_ele_delta;out vec2 v_texture_pos;void main() {float ele=get_elevation(a_pos3d.xy);float ele_delta=a_pos3d.z==1.0 ? u_ele_delta : 0.0;v_texture_pos=a_pos3d.xy/8192.0;gl_Position=projectTileFor3D(a_pos3d.xy,ele-ele_delta);}"), projectionErrorMeasurement: _t("in vec4 v_output_error_encoded;void main() {fragColor=v_output_error_encoded;}", "in vec2 a_pos;uniform highp float u_input;uniform highp float u_output_expected;out vec4 v_output_error_encoded;void main() {float real_output=2.0*atan(exp(PI-(u_input*PI*2.0)))-PI*0.5;float error=real_output-u_output_expected;float abs_error=abs(error)*128.0;v_output_error_encoded.x=min(floor(abs_error*256.0),255.0)/255.0;abs_error-=v_output_error_encoded.x;v_output_error_encoded.y=min(floor(abs_error*65536.0),255.0)/255.0;abs_error-=v_output_error_encoded.x/255.0;v_output_error_encoded.z=min(floor(abs_error*16777216.0),255.0)/255.0;v_output_error_encoded.w=error >=0.0 ? 1.0 : 0.0;gl_Position=vec4(a_pos,0.0,1.0);}"), atmosphere: _t("in vec3 view_direction;uniform vec3 u_sun_pos;uniform vec3 u_globe_position;uniform float u_globe_radius;uniform float u_atmosphere_blend;/**Shader use from https:*Made some change to adapt to MapLibre Globe geometry*/const float PI=3.141592653589793;const int iSteps=5;const int jSteps=3;/*radius of the planet*/const float EARTH_RADIUS=6371e3;/*radius of the atmosphere*/const float ATMOS_RADIUS=6471e3;vec2 rsi(vec3 r0,vec3 rd,float sr) {float a=dot(rd,rd);float b=2.0*dot(rd,r0);float c=dot(r0,r0)-(sr*sr);float d=(b*b)-4.0*a*c;if (d < 0.0) return vec2(1e5,-1e5);return vec2((-b-sqrt(d))/(2.0*a),(-b+sqrt(d))/(2.0*a));}vec4 atmosphere(vec3 r,vec3 r0,vec3 pSun,float iSun,float rPlanet,float rAtmos,vec3 kRlh,float kMie,float shRlh,float shMie,float g) {pSun=normalize(pSun);r=normalize(r);vec2 p=rsi(r0,r,rAtmos);if (p.x > p.y) {return vec4(0.0,0.0,0.0,1.0);}if (p.x < 0.0) {p.x=0.0;}vec3 pos=r0+r*p.x;vec2 p2=rsi(r0,r,rPlanet);if (p2.x <=p2.y && p2.x > 0.0) {p.y=min(p.y,p2.x);}float iStepSize=(p.y-p.x)/float(iSteps);float iTime=p.x+iStepSize*0.5;vec3 totalRlh=vec3(0,0,0);vec3 totalMie=vec3(0,0,0);float iOdRlh=0.0;float iOdMie=0.0;float mu=dot(r,pSun);float mumu=mu*mu;float gg=g*g;float pRlh=3.0/(16.0*PI)*(1.0+mumu);float pMie=3.0/(8.0*PI)*((1.0-gg)*(mumu+1.0))/(pow(1.0+gg-2.0*mu*g,1.5)*(2.0+gg));for (int i=0; i < iSteps; i++) {vec3 iPos=r0+r*iTime;float iHeight=length(iPos)-rPlanet;float odStepRlh=exp(-iHeight/shRlh)*iStepSize;float odStepMie=exp(-iHeight/shMie)*iStepSize;iOdRlh+=odStepRlh;iOdMie+=odStepMie;float jStepSize=rsi(iPos,pSun,rAtmos).y/float(jSteps);float jTime=jStepSize*0.5;float jOdRlh=0.0;float jOdMie=0.0;for (int j=0; j < jSteps; j++) {vec3 jPos=iPos+pSun*jTime;float jHeight=length(jPos)-rPlanet;jOdRlh+=exp(-jHeight/shRlh)*jStepSize;jOdMie+=exp(-jHeight/shMie)*jStepSize;jTime+=jStepSize;}vec3 attn=exp(-(kMie*(iOdMie+jOdMie)+kRlh*(iOdRlh+jOdRlh)));totalRlh+=odStepRlh*attn;totalMie+=odStepMie*attn;iTime+=iStepSize;}float opacity=exp(-(length(kRlh)*length(totalRlh)+kMie*length(totalMie)));vec3 color=iSun*(pRlh*kRlh*totalRlh+pMie*kMie*totalMie);return vec4(color,opacity);}void main() {vec3 scale_camera_pos=-u_globe_position*EARTH_RADIUS/u_globe_radius;vec4 color=atmosphere(normalize(view_direction),scale_camera_pos,u_sun_pos,22.0,EARTH_RADIUS,ATMOS_RADIUS,vec3(5.5e-6,13.0e-6,22.4e-6),21e-6,8e3,1.2e3,0.758\n);color.rgb=1.0-exp(-1.0*color.rgb);color=pow(color,vec4(1.0/2.2));fragColor=vec4(color.rgb,1.0-color.a)*u_atmosphere_blend;}", "in vec2 a_pos;uniform mat4 u_inv_proj_matrix;out vec3 view_direction;void main() {view_direction=(u_inv_proj_matrix*vec4(a_pos,0.0,1.0)).xyz;gl_Position=vec4(a_pos,0.0,1.0);}"), sky: _t("uniform vec4 u_sky_color;uniform vec4 u_horizon_color;uniform vec2 u_horizon;uniform vec2 u_horizon_normal;uniform float u_sky_horizon_blend;uniform float u_sky_blend;void main() {float x=gl_FragCoord.x;float y=gl_FragCoord.y;float blend=(y-u_horizon.y)*u_horizon_normal.y+(x-u_horizon.x)*u_horizon_normal.x;if (blend > 0.0) {if (blend < u_sky_horizon_blend) {fragColor=mix(u_sky_color,u_horizon_color,pow(1.0-blend/u_sky_horizon_blend,2.0));} else {fragColor=u_sky_color;}}fragColor=mix(fragColor,vec4(vec3(0.0),0.0),u_sky_blend);}", "in vec2 a_pos;void main() {gl_Position=vec4(a_pos,1.0,1.0);}") };
        function _t(e6, t5) {
          const i6 = /#pragma mapbox: ([\w]+) ([\w]+) ([\w]+) ([\w]+)/g, r8 = t5.match(/in ([\w]+) ([\w]+)/g), o6 = e6.match(/uniform ([\w]+) ([\w]+)([\s]*)([\w]*)/g), a4 = t5.match(/uniform ([\w]+) ([\w]+)([\s]*)([\w]*)/g), s4 = a4 ? a4.concat(o6) : o6, n6 = {};
          return { fragmentSource: e6 = e6.replace(i6, (e7, t6, i7, r9, o7) => (n6[o7] = true, "define" === t6 ? `
#ifndef HAS_UNIFORM_u_${o7}
in ${i7} ${r9} ${o7};
#else
uniform ${i7} ${r9} u_${o7};
#endif
` : `
#ifdef HAS_UNIFORM_u_${o7}
    ${i7} ${r9} ${o7} = u_${o7};
#endif
`)), vertexSource: t5 = t5.replace(i6, (e7, t6, i7, r9, o7) => {
            const a5 = "float" === r9 ? "vec2" : "vec4", s5 = o7.match(/color/) ? "color" : a5;
            return n6[o7] ? "define" === t6 ? `
#ifndef HAS_UNIFORM_u_${o7}
uniform lowp float u_${o7}_t;
in ${i7} ${a5} a_${o7};
out ${i7} ${r9} ${o7};
#else
uniform ${i7} ${r9} u_${o7};
#endif
` : "vec4" === s5 ? `
#ifndef HAS_UNIFORM_u_${o7}
    ${o7} = a_${o7};
#else
    ${i7} ${r9} ${o7} = u_${o7};
#endif
` : `
#ifndef HAS_UNIFORM_u_${o7}
    ${o7} = unpack_mix_${s5}(a_${o7}, u_${o7}_t);
#else
    ${i7} ${r9} ${o7} = u_${o7};
#endif
` : "define" === t6 ? `
#ifndef HAS_UNIFORM_u_${o7}
uniform lowp float u_${o7}_t;
in ${i7} ${a5} a_${o7};
#else
uniform ${i7} ${r9} u_${o7};
#endif
` : "vec4" === s5 ? `
#ifndef HAS_UNIFORM_u_${o7}
    ${i7} ${r9} ${o7} = a_${o7};
#else
    ${i7} ${r9} ${o7} = u_${o7};
#endif
` : `
#ifndef HAS_UNIFORM_u_${o7}
    ${i7} ${r9} ${o7} = unpack_mix_${s5}(a_${o7}, u_${o7}_t);
#else
    ${i7} ${r9} ${o7} = u_${o7};
#endif
`;
          }), staticAttributes: r8, staticUniforms: s4 };
        }
        class pt {
          constructor(e6, t5, i6) {
            this.vertexBuffer = e6, this.indexBuffer = t5, this.segments = i6;
          }
          destroy() {
            this.vertexBuffer.destroy(), this.indexBuffer.destroy(), this.segments.destroy(), this.vertexBuffer = null, this.indexBuffer = null, this.segments = null;
          }
        }
        var mt = t4.aD([{ name: "a_pos", type: "Int16", components: 2 }]);
        const ft = "#define PROJECTION_MERCATOR", gt = "mercator";
        class vt {
          constructor() {
            this._cachedMesh = null;
          }
          get name() {
            return "mercator";
          }
          get useSubdivision() {
            return false;
          }
          get shaderVariantName() {
            return gt;
          }
          get shaderDefine() {
            return ft;
          }
          get shaderPreludeCode() {
            return dt.projectionMercator;
          }
          get vertexShaderPreludeCode() {
            return dt.projectionMercator.vertexSource;
          }
          get subdivisionGranularity() {
            return t4.aE.noSubdivision;
          }
          get useGlobeControls() {
            return false;
          }
          get transitionState() {
            return 0;
          }
          get latitudeErrorCorrectionRadians() {
            return 0;
          }
          destroy() {
          }
          updateGPUdependent(e6) {
          }
          getMeshFromTileID(e6, i6, r8, o6, a4) {
            if (this._cachedMesh) return this._cachedMesh;
            const s4 = new t4.aF();
            s4.emplaceBack(0, 0), s4.emplaceBack(t4.Z, 0), s4.emplaceBack(0, t4.Z), s4.emplaceBack(t4.Z, t4.Z);
            const n6 = e6.createVertexBuffer(s4, mt.members), l5 = t4.aG.simpleSegment(0, 0, 4, 2), c5 = new t4.aH();
            c5.emplaceBack(1, 0, 2), c5.emplaceBack(1, 2, 3);
            const h4 = e6.createIndexBuffer(c5);
            return this._cachedMesh = new pt(n6, h4, l5), this._cachedMesh;
          }
          recalculate() {
          }
          hasTransition() {
            return false;
          }
          setErrorQueryLatitudeDegrees(e6) {
          }
        }
        function xt(e6, i6) {
          const r8 = t4.ae(i6.lat, -85.051129, t4.aJ);
          return new t4.P(t4.U(i6.lng) * e6, t4.S(r8) * e6);
        }
        function bt(e6, i6) {
          return new t4.$(i6.x / e6, i6.y / e6).toLngLat();
        }
        function yt(e6) {
          return e6.cameraToCenterDistance * Math.min(0.85 * Math.tan(t4.ad(90 - e6.pitch)), Math.tan(t4.ad(89.25 - e6.pitch)));
        }
        function wt(e6, i6) {
          const r8 = e6.canonical, o6 = i6 / t4.aI(r8.z), a4 = r8.x + Math.pow(2, r8.z) * e6.wrap, s4 = t4.at(new Float64Array(16));
          return t4.L(s4, s4, [a4 * o6, r8.y * o6, 0]), t4.M(s4, s4, [o6 / t4.Z, o6 / t4.Z, 1]), s4;
        }
        function Tt(e6, i6, r8, o6, a4) {
          const s4 = t4.$.fromLngLat(e6, i6), n6 = a4 * t4.aK(1, e6.lat), l5 = n6 * Math.cos(t4.ad(r8)), c5 = Math.sqrt(n6 * n6 - l5 * l5), h4 = c5 * Math.sin(t4.ad(-o6)), u4 = c5 * Math.cos(t4.ad(-o6));
          return new t4.$(s4.x + h4, s4.y + u4, s4.z + l5);
        }
        class Pt {
          constructor(e6 = 0, t5 = 0, i6 = 0, r8 = 0) {
            if (isNaN(e6) || e6 < 0 || isNaN(t5) || t5 < 0 || isNaN(i6) || i6 < 0 || isNaN(r8) || r8 < 0) throw new Error("Invalid value for edge-insets, top, bottom, left and right must all be numbers");
            this.top = e6, this.bottom = t5, this.left = i6, this.right = r8;
          }
          interpolate(e6, i6, r8) {
            return null != i6.top && null != e6.top && (this.top = t4.B.number(e6.top, i6.top, r8)), null != i6.bottom && null != e6.bottom && (this.bottom = t4.B.number(e6.bottom, i6.bottom, r8)), null != i6.left && null != e6.left && (this.left = t4.B.number(e6.left, i6.left, r8)), null != i6.right && null != e6.right && (this.right = t4.B.number(e6.right, i6.right, r8)), this;
          }
          getCenter(e6, i6) {
            const r8 = t4.ae((this.left + e6 - this.right) / 2, 0, e6), o6 = t4.ae((this.top + i6 - this.bottom) / 2, 0, i6);
            return new t4.P(r8, o6);
          }
          equals(e6) {
            return this.top === e6.top && this.bottom === e6.bottom && this.left === e6.left && this.right === e6.right;
          }
          clone() {
            return new Pt(this.top, this.bottom, this.left, this.right);
          }
          toJSON() {
            return { top: this.top, bottom: this.bottom, left: this.left, right: this.right };
          }
        }
        function Ct(e6, t5) {
          if (!e6.renderWorldCopies || e6.lngRange) return;
          const i6 = t5.lng - e6.center.lng;
          t5.lng += i6 > 180 ? -360 : i6 < -180 ? 360 : 0;
        }
        function It(e6) {
          return Math.max(0, Math.floor(e6));
        }
        class Mt {
          constructor(e6, i6, r8, o6, a4, s4) {
            this._callbacks = e6, this._tileSize = 512, this._renderWorldCopies = void 0 === s4 || !!s4, this._minZoom = i6 || 0, this._maxZoom = r8 || 22, this._minPitch = null == o6 ? 0 : o6, this._maxPitch = null == a4 ? 60 : a4, this.setMaxBounds(), this._width = 0, this._height = 0, this._center = new t4.Q(0, 0), this._elevation = 0, this._zoom = 0, this._tileZoom = It(this._zoom), this._scale = t4.aI(this._zoom), this._bearingInRadians = 0, this._fovInRadians = 0.6435011087932844, this._pitchInRadians = 0, this._rollInRadians = 0, this._unmodified = true, this._edgeInsets = new Pt(), this._minElevationForCurrentTile = 0, this._autoCalculateNearFarZ = true;
          }
          apply(e6, i6, r8) {
            this._latRange = e6.latRange, this._lngRange = e6.lngRange, this._width = e6.width, this._height = e6.height, this._center = e6.center, this._elevation = e6.elevation, this._minElevationForCurrentTile = e6.minElevationForCurrentTile, this._zoom = e6.zoom, this._tileZoom = It(this._zoom), this._scale = t4.aI(this._zoom), this._bearingInRadians = e6.bearingInRadians, this._fovInRadians = e6.fovInRadians, this._pitchInRadians = e6.pitchInRadians, this._rollInRadians = e6.rollInRadians, this._unmodified = e6.unmodified, this._edgeInsets = new Pt(e6.padding.top, e6.padding.bottom, e6.padding.left, e6.padding.right), this._minZoom = e6.minZoom, this._maxZoom = e6.maxZoom, this._minPitch = e6.minPitch, this._maxPitch = e6.maxPitch, this._renderWorldCopies = e6.renderWorldCopies, this._cameraToCenterDistance = e6.cameraToCenterDistance, this._nearZ = e6.nearZ, this._farZ = e6.farZ, this._autoCalculateNearFarZ = !r8 && e6.autoCalculateNearFarZ, i6 && this._constrain(), this._calcMatrices();
          }
          get pixelsToClipSpaceMatrix() {
            return this._pixelsToClipSpaceMatrix;
          }
          get clipSpaceToPixelsMatrix() {
            return this._clipSpaceToPixelsMatrix;
          }
          get minElevationForCurrentTile() {
            return this._minElevationForCurrentTile;
          }
          setMinElevationForCurrentTile(e6) {
            this._minElevationForCurrentTile = e6;
          }
          get tileSize() {
            return this._tileSize;
          }
          get tileZoom() {
            return this._tileZoom;
          }
          get scale() {
            return this._scale;
          }
          get width() {
            return this._width;
          }
          get height() {
            return this._height;
          }
          get bearingInRadians() {
            return this._bearingInRadians;
          }
          get lngRange() {
            return this._lngRange;
          }
          get latRange() {
            return this._latRange;
          }
          get pixelsToGLUnits() {
            return this._pixelsToGLUnits;
          }
          get minZoom() {
            return this._minZoom;
          }
          setMinZoom(e6) {
            this._minZoom !== e6 && (this._minZoom = e6, this.setZoom(this.getConstrained(this._center, this.zoom).zoom));
          }
          get maxZoom() {
            return this._maxZoom;
          }
          setMaxZoom(e6) {
            this._maxZoom !== e6 && (this._maxZoom = e6, this.setZoom(this.getConstrained(this._center, this.zoom).zoom));
          }
          get minPitch() {
            return this._minPitch;
          }
          setMinPitch(e6) {
            this._minPitch !== e6 && (this._minPitch = e6, this.setPitch(Math.max(this.pitch, e6)));
          }
          get maxPitch() {
            return this._maxPitch;
          }
          setMaxPitch(e6) {
            this._maxPitch !== e6 && (this._maxPitch = e6, this.setPitch(Math.min(this.pitch, e6)));
          }
          get renderWorldCopies() {
            return this._renderWorldCopies;
          }
          setRenderWorldCopies(e6) {
            void 0 === e6 ? e6 = true : null === e6 && (e6 = false), this._renderWorldCopies = e6;
          }
          get worldSize() {
            return this._tileSize * this._scale;
          }
          get centerOffset() {
            return this.centerPoint._sub(this.size._div(2));
          }
          get size() {
            return new t4.P(this._width, this._height);
          }
          get bearing() {
            return this._bearingInRadians / Math.PI * 180;
          }
          setBearing(e6) {
            const i6 = t4.aL(e6, -180, 180) * Math.PI / 180;
            var o6, a4, s4, n6, l5, c5, h4, u4, d4;
            this._bearingInRadians !== i6 && (this._unmodified = false, this._bearingInRadians = i6, this._calcMatrices(), this._rotationMatrix = r7(), o6 = this._rotationMatrix, s4 = -this._bearingInRadians, n6 = (a4 = this._rotationMatrix)[0], l5 = a4[1], c5 = a4[2], h4 = a4[3], u4 = Math.sin(s4), d4 = Math.cos(s4), o6[0] = n6 * d4 + c5 * u4, o6[1] = l5 * d4 + h4 * u4, o6[2] = n6 * -u4 + c5 * d4, o6[3] = l5 * -u4 + h4 * d4);
          }
          get rotationMatrix() {
            return this._rotationMatrix;
          }
          get pitchInRadians() {
            return this._pitchInRadians;
          }
          get pitch() {
            return this._pitchInRadians / Math.PI * 180;
          }
          setPitch(e6) {
            const i6 = t4.ae(e6, this.minPitch, this.maxPitch) / 180 * Math.PI;
            this._pitchInRadians !== i6 && (this._unmodified = false, this._pitchInRadians = i6, this._calcMatrices());
          }
          get rollInRadians() {
            return this._rollInRadians;
          }
          get roll() {
            return this._rollInRadians / Math.PI * 180;
          }
          setRoll(e6) {
            const t5 = e6 / 180 * Math.PI;
            this._rollInRadians !== t5 && (this._unmodified = false, this._rollInRadians = t5, this._calcMatrices());
          }
          get fovInRadians() {
            return this._fovInRadians;
          }
          get fov() {
            return t4.aM(this._fovInRadians);
          }
          setFov(e6) {
            e6 = t4.ae(e6, 0.1, 150), this.fov !== e6 && (this._unmodified = false, this._fovInRadians = t4.ad(e6), this._calcMatrices());
          }
          get zoom() {
            return this._zoom;
          }
          setZoom(e6) {
            const i6 = this.getConstrained(this._center, e6).zoom;
            this._zoom !== i6 && (this._unmodified = false, this._zoom = i6, this._tileZoom = Math.max(0, Math.floor(i6)), this._scale = t4.aI(i6), this._constrain(), this._calcMatrices());
          }
          get center() {
            return this._center;
          }
          setCenter(e6) {
            e6.lat === this._center.lat && e6.lng === this._center.lng || (this._unmodified = false, this._center = e6, this._constrain(), this._calcMatrices());
          }
          get elevation() {
            return this._elevation;
          }
          setElevation(e6) {
            e6 !== this._elevation && (this._elevation = e6, this._constrain(), this._calcMatrices());
          }
          get padding() {
            return this._edgeInsets.toJSON();
          }
          setPadding(e6) {
            this._edgeInsets.equals(e6) || (this._unmodified = false, this._edgeInsets.interpolate(this._edgeInsets, e6, 1), this._calcMatrices());
          }
          get centerPoint() {
            return this._edgeInsets.getCenter(this._width, this._height);
          }
          get pixelsPerMeter() {
            return this._pixelPerMeter;
          }
          get unmodified() {
            return this._unmodified;
          }
          get cameraToCenterDistance() {
            return this._cameraToCenterDistance;
          }
          get nearZ() {
            return this._nearZ;
          }
          get farZ() {
            return this._farZ;
          }
          get autoCalculateNearFarZ() {
            return this._autoCalculateNearFarZ;
          }
          overrideNearFarZ(e6, t5) {
            this._autoCalculateNearFarZ = false, this._nearZ = e6, this._farZ = t5, this._calcMatrices();
          }
          clearNearFarZOverride() {
            this._autoCalculateNearFarZ = true, this._calcMatrices();
          }
          isPaddingEqual(e6) {
            return this._edgeInsets.equals(e6);
          }
          interpolatePadding(e6, t5, i6) {
            this._unmodified = false, this._edgeInsets.interpolate(e6, t5, i6), this._constrain(), this._calcMatrices();
          }
          resize(e6, t5, i6 = true) {
            this._width = e6, this._height = t5, i6 && this._constrain(), this._calcMatrices();
          }
          getMaxBounds() {
            return this._latRange && 2 === this._latRange.length && this._lngRange && 2 === this._lngRange.length ? new V2([this._lngRange[0], this._latRange[0]], [this._lngRange[1], this._latRange[1]]) : null;
          }
          setMaxBounds(e6) {
            e6 ? (this._lngRange = [e6.getWest(), e6.getEast()], this._latRange = [e6.getSouth(), e6.getNorth()], this._constrain()) : (this._lngRange = null, this._latRange = [-85.051129, t4.aJ]);
          }
          getConstrained(e6, t5) {
            return this._callbacks.getConstrained(e6, t5);
          }
          getCameraQueryGeometry(e6, i6) {
            if (1 === i6.length) return [i6[0], e6];
            {
              let r8 = e6.x, o6 = e6.y, a4 = e6.x, s4 = e6.y;
              for (const e7 of i6) r8 = Math.min(r8, e7.x), o6 = Math.min(o6, e7.y), a4 = Math.max(a4, e7.x), s4 = Math.max(s4, e7.y);
              return [new t4.P(r8, o6), new t4.P(a4, o6), new t4.P(a4, s4), new t4.P(r8, s4), new t4.P(r8, o6)];
            }
          }
          _constrain() {
            if (!this.center || !this._width || !this._height || this._constraining) return;
            this._constraining = true;
            const e6 = this._unmodified, { center: t5, zoom: i6 } = this.getConstrained(this.center, this.zoom);
            this.setCenter(t5), this.setZoom(i6), this._unmodified = e6, this._constraining = false;
          }
          _calcMatrices() {
            if (this._width && this._height) {
              this._pixelsToGLUnits = [2 / this._width, -2 / this._height];
              let e6 = t4.at(new Float64Array(16));
              t4.M(e6, e6, [this._width / 2, -this._height / 2, 1]), t4.L(e6, e6, [1, -1, 0]), this._clipSpaceToPixelsMatrix = e6, e6 = t4.at(new Float64Array(16)), t4.M(e6, e6, [1, -1, 1]), t4.L(e6, e6, [-1, -1, 0]), t4.M(e6, e6, [2 / this._width, 2 / this._height, 1]), this._pixelsToClipSpaceMatrix = e6, this._cameraToCenterDistance = 0.5 / Math.tan(this.fovInRadians / 2) * this._height;
            }
            this._callbacks.calcMatrices();
          }
          calculateCenterFromCameraLngLatAlt(e6, i6, r8, o6) {
            const a4 = void 0 !== r8 ? r8 : this.bearing, s4 = o6 = void 0 !== o6 ? o6 : this.pitch, n6 = t4.$.fromLngLat(e6, i6), l5 = -Math.cos(t4.ad(s4)), c5 = Math.sin(t4.ad(s4)), h4 = c5 * Math.sin(t4.ad(a4)), u4 = -c5 * Math.cos(t4.ad(a4));
            let d4 = this.elevation;
            const _4 = i6 - d4;
            let p4;
            l5 * _4 >= 0 || Math.abs(l5) < 0.1 ? (p4 = 1e4, d4 = i6 + p4 * l5) : p4 = -_4 / l5;
            let m4, f4, g4 = t4.aN(1, n6.y), v4 = 0;
            do {
              if (v4 += 1, v4 > 10) break;
              f4 = p4 / g4, m4 = new t4.$(n6.x + h4 * f4, n6.y + u4 * f4), g4 = 1 / m4.meterInMercatorCoordinateUnits();
            } while (Math.abs(p4 - f4 * g4) > 1e-12);
            return { center: m4.toLngLat(), elevation: d4, zoom: t4.ab(this.height / 2 / Math.tan(this.fovInRadians / 2) / f4 / this.tileSize) };
          }
          recalculateZoomAndCenter(e6) {
            if (this.elevation - e6 == 0) return;
            const i6 = t4.aK(1, this.center.lat) * this.worldSize, r8 = this.cameraToCenterDistance / i6, o6 = t4.$.fromLngLat(this.center, this.elevation), a4 = Tt(this.center, this.elevation, this.pitch, this.bearing, r8);
            this._elevation = e6;
            const s4 = this.calculateCenterFromCameraLngLatAlt(a4.toLngLat(), t4.aN(a4.z, o6.y), this.bearing, this.pitch);
            this._elevation = s4.elevation, this._center = s4.center, this.setZoom(s4.zoom);
          }
          getCameraPoint() {
            const e6 = Math.tan(this.pitchInRadians) * (this.cameraToCenterDistance || 1);
            return this.centerPoint.add(new t4.P(e6 * Math.sin(this.rollInRadians), e6 * Math.cos(this.rollInRadians)));
          }
          getCameraAltitude() {
            return Math.cos(this.pitchInRadians) * this._cameraToCenterDistance / this._pixelPerMeter + this.elevation;
          }
          getCameraLngLat() {
            const e6 = t4.aK(1, this.center.lat) * this.worldSize;
            return Tt(this.center, this.elevation, this.pitch, this.bearing, this.cameraToCenterDistance / e6).toLngLat();
          }
          getMercatorTileCoordinates(e6) {
            if (!e6) return [0, 0, 1, 1];
            const i6 = e6.canonical.z >= 0 ? 1 << e6.canonical.z : Math.pow(2, e6.canonical.z);
            return [e6.canonical.x / i6, e6.canonical.y / i6, 1 / i6 / t4.Z, 1 / i6 / t4.Z];
          }
        }
        class Et {
          constructor(e6, i6) {
            this.min = e6, this.max = i6, this.center = t4.aO([], t4.aP([], this.min, this.max), 0.5);
          }
          quadrant(e6) {
            const i6 = [e6 % 2 == 0, e6 < 2], r8 = t4.aQ(this.min), o6 = t4.aQ(this.max);
            for (let e7 = 0; e7 < i6.length; e7++) r8[e7] = i6[e7] ? this.min[e7] : this.center[e7], o6[e7] = i6[e7] ? this.center[e7] : this.max[e7];
            return o6[2] = this.max[2], new Et(r8, o6);
          }
          distanceX(e6) {
            return Math.max(Math.min(this.max[0], e6[0]), this.min[0]) - e6[0];
          }
          distanceY(e6) {
            return Math.max(Math.min(this.max[1], e6[1]), this.min[1]) - e6[1];
          }
          intersectsFrustum(e6) {
            let t5 = true;
            for (let i6 = 0; i6 < e6.planes.length; i6++) {
              const r8 = this.intersectsPlane(e6.planes[i6]);
              if (0 === r8) return 0;
              1 === r8 && (t5 = false);
            }
            return t5 ? 2 : e6.aabb.min[0] > this.max[0] || e6.aabb.min[1] > this.max[1] || e6.aabb.min[2] > this.max[2] || e6.aabb.max[0] < this.min[0] || e6.aabb.max[1] < this.min[1] || e6.aabb.max[2] < this.min[2] ? 0 : 1;
          }
          intersectsPlane(e6) {
            let t5 = e6[3], i6 = e6[3];
            for (let r8 = 0; r8 < 3; r8++) e6[r8] > 0 ? (t5 += e6[r8] * this.min[r8], i6 += e6[r8] * this.max[r8]) : (i6 += e6[r8] * this.min[r8], t5 += e6[r8] * this.max[r8]);
            return t5 >= 0 ? 2 : i6 < 0 ? 0 : 1;
          }
        }
        class St {
          distanceToTile2d(e6, t5, i6, r8) {
            const o6 = r8.distanceX([e6, t5]), a4 = r8.distanceY([e6, t5]);
            return Math.hypot(o6, a4);
          }
          getWrap(e6, t5, i6) {
            return i6;
          }
          getTileAABB(e6, i6, r8, o6) {
            var a4, s4;
            let n6 = r8, l5 = r8;
            if (o6.terrain) {
              const c6 = new t4.Y(e6.z, i6, e6.z, e6.x, e6.y), h4 = o6.terrain.getMinMaxElevation(c6);
              n6 = null !== (a4 = h4.minElevation) && void 0 !== a4 ? a4 : r8, l5 = null !== (s4 = h4.maxElevation) && void 0 !== s4 ? s4 : r8;
            }
            const c5 = 1 << e6.z;
            return new Et([i6 + e6.x / c5, e6.y / c5, n6], [i6 + (e6.x + 1) / c5, (e6.y + 1) / c5, l5]);
          }
          allowVariableZoom(e6, i6) {
            const r8 = e6.fov * (Math.abs(Math.cos(e6.rollInRadians)) * e6.height + Math.abs(Math.sin(e6.rollInRadians)) * e6.width) / e6.height, o6 = t4.ae(78.5 - r8 / 2, 0, 60);
            return !!i6.terrain || e6.pitch > o6;
          }
          allowWorldCopies() {
            return true;
          }
          recalculateCache() {
          }
        }
        class Rt {
          constructor(e6, t5, i6) {
            this.points = e6, this.planes = t5, this.aabb = i6;
          }
          static fromInvProjectionMatrix(e6, i6 = 1, r8 = 0) {
            const o6 = Math.pow(2, r8), a4 = [[-1, 1, -1, 1], [1, 1, -1, 1], [1, -1, -1, 1], [-1, -1, -1, 1], [-1, 1, 1, 1], [1, 1, 1, 1], [1, -1, 1, 1], [-1, -1, 1, 1]].map((r9) => {
              const a5 = 1 / (r9 = t4.ap([], r9, e6))[3] / i6 * o6;
              return t4.aR(r9, r9, [a5, a5, 1 / r9[3], a5]);
            }), s4 = [[0, 1, 2], [6, 5, 4], [0, 3, 7], [2, 1, 5], [3, 2, 6], [0, 4, 5]].map((e7) => {
              const i7 = t4.aS([], a4[e7[0]], a4[e7[1]]), r9 = t4.aS([], a4[e7[2]], a4[e7[1]]), o7 = t4.aT([], t4.aU([], i7, r9)), s5 = -t4.aV(o7, a4[e7[1]]);
              return o7.concat(s5);
            }), n6 = [Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY], l5 = [Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY];
            for (const e7 of a4) for (let t5 = 0; t5 < 3; t5++) n6[t5] = Math.min(n6[t5], e7[t5]), l5[t5] = Math.max(l5[t5], e7[t5]);
            return new Rt(a4, s4, new Et(n6, l5));
          }
        }
        class Dt {
          get pixelsToClipSpaceMatrix() {
            return this._helper.pixelsToClipSpaceMatrix;
          }
          get clipSpaceToPixelsMatrix() {
            return this._helper.clipSpaceToPixelsMatrix;
          }
          get pixelsToGLUnits() {
            return this._helper.pixelsToGLUnits;
          }
          get centerOffset() {
            return this._helper.centerOffset;
          }
          get size() {
            return this._helper.size;
          }
          get rotationMatrix() {
            return this._helper.rotationMatrix;
          }
          get centerPoint() {
            return this._helper.centerPoint;
          }
          get pixelsPerMeter() {
            return this._helper.pixelsPerMeter;
          }
          setMinZoom(e6) {
            this._helper.setMinZoom(e6);
          }
          setMaxZoom(e6) {
            this._helper.setMaxZoom(e6);
          }
          setMinPitch(e6) {
            this._helper.setMinPitch(e6);
          }
          setMaxPitch(e6) {
            this._helper.setMaxPitch(e6);
          }
          setRenderWorldCopies(e6) {
            this._helper.setRenderWorldCopies(e6);
          }
          setBearing(e6) {
            this._helper.setBearing(e6);
          }
          setPitch(e6) {
            this._helper.setPitch(e6);
          }
          setRoll(e6) {
            this._helper.setRoll(e6);
          }
          setFov(e6) {
            this._helper.setFov(e6);
          }
          setZoom(e6) {
            this._helper.setZoom(e6);
          }
          setCenter(e6) {
            this._helper.setCenter(e6);
          }
          setElevation(e6) {
            this._helper.setElevation(e6);
          }
          setMinElevationForCurrentTile(e6) {
            this._helper.setMinElevationForCurrentTile(e6);
          }
          setPadding(e6) {
            this._helper.setPadding(e6);
          }
          interpolatePadding(e6, t5, i6) {
            return this._helper.interpolatePadding(e6, t5, i6);
          }
          isPaddingEqual(e6) {
            return this._helper.isPaddingEqual(e6);
          }
          resize(e6, t5, i6 = true) {
            this._helper.resize(e6, t5, i6);
          }
          getMaxBounds() {
            return this._helper.getMaxBounds();
          }
          setMaxBounds(e6) {
            this._helper.setMaxBounds(e6);
          }
          overrideNearFarZ(e6, t5) {
            this._helper.overrideNearFarZ(e6, t5);
          }
          clearNearFarZOverride() {
            this._helper.clearNearFarZOverride();
          }
          getCameraQueryGeometry(e6) {
            return this._helper.getCameraQueryGeometry(this.getCameraPoint(), e6);
          }
          get tileSize() {
            return this._helper.tileSize;
          }
          get tileZoom() {
            return this._helper.tileZoom;
          }
          get scale() {
            return this._helper.scale;
          }
          get worldSize() {
            return this._helper.worldSize;
          }
          get width() {
            return this._helper.width;
          }
          get height() {
            return this._helper.height;
          }
          get lngRange() {
            return this._helper.lngRange;
          }
          get latRange() {
            return this._helper.latRange;
          }
          get minZoom() {
            return this._helper.minZoom;
          }
          get maxZoom() {
            return this._helper.maxZoom;
          }
          get zoom() {
            return this._helper.zoom;
          }
          get center() {
            return this._helper.center;
          }
          get minPitch() {
            return this._helper.minPitch;
          }
          get maxPitch() {
            return this._helper.maxPitch;
          }
          get pitch() {
            return this._helper.pitch;
          }
          get pitchInRadians() {
            return this._helper.pitchInRadians;
          }
          get roll() {
            return this._helper.roll;
          }
          get rollInRadians() {
            return this._helper.rollInRadians;
          }
          get bearing() {
            return this._helper.bearing;
          }
          get bearingInRadians() {
            return this._helper.bearingInRadians;
          }
          get fov() {
            return this._helper.fov;
          }
          get fovInRadians() {
            return this._helper.fovInRadians;
          }
          get elevation() {
            return this._helper.elevation;
          }
          get minElevationForCurrentTile() {
            return this._helper.minElevationForCurrentTile;
          }
          get padding() {
            return this._helper.padding;
          }
          get unmodified() {
            return this._helper.unmodified;
          }
          get renderWorldCopies() {
            return this._helper.renderWorldCopies;
          }
          get cameraToCenterDistance() {
            return this._helper.cameraToCenterDistance;
          }
          get nearZ() {
            return this._helper.nearZ;
          }
          get farZ() {
            return this._helper.farZ;
          }
          get autoCalculateNearFarZ() {
            return this._helper.autoCalculateNearFarZ;
          }
          setTransitionState(e6, t5) {
          }
          constructor(e6, t5, i6, r8, o6) {
            this._posMatrixCache = /* @__PURE__ */ new Map(), this._alignedPosMatrixCache = /* @__PURE__ */ new Map(), this._fogMatrixCacheF32 = /* @__PURE__ */ new Map(), this._helper = new Mt({ calcMatrices: () => {
              this._calcMatrices();
            }, getConstrained: (e7, t6) => this.getConstrained(e7, t6) }, e6, t5, i6, r8, o6), this._coveringTilesDetailsProvider = new St();
          }
          clone() {
            const e6 = new Dt();
            return e6.apply(this), e6;
          }
          apply(e6, t5, i6) {
            this._helper.apply(e6, t5, i6);
          }
          get cameraPosition() {
            return this._cameraPosition;
          }
          get projectionMatrix() {
            return this._projectionMatrix;
          }
          get modelViewProjectionMatrix() {
            return this._viewProjMatrix;
          }
          get inverseProjectionMatrix() {
            return this._invProjMatrix;
          }
          get mercatorMatrix() {
            return this._mercatorMatrix;
          }
          getVisibleUnwrappedCoordinates(e6) {
            const i6 = [new t4.aW(0, e6)];
            if (this._helper._renderWorldCopies) {
              const r8 = this.screenPointToMercatorCoordinate(new t4.P(0, 0)), o6 = this.screenPointToMercatorCoordinate(new t4.P(this._helper._width, 0)), a4 = this.screenPointToMercatorCoordinate(new t4.P(this._helper._width, this._helper._height)), s4 = this.screenPointToMercatorCoordinate(new t4.P(0, this._helper._height)), n6 = Math.floor(Math.min(r8.x, o6.x, a4.x, s4.x)), l5 = Math.floor(Math.max(r8.x, o6.x, a4.x, s4.x)), c5 = 1;
              for (let r9 = n6 - c5; r9 <= l5 + c5; r9++) 0 !== r9 && i6.push(new t4.aW(r9, e6));
            }
            return i6;
          }
          getCameraFrustum() {
            return Rt.fromInvProjectionMatrix(this._invViewProjMatrix, this.worldSize);
          }
          getClippingPlane() {
            return null;
          }
          getCoveringTilesDetailsProvider() {
            return this._coveringTilesDetailsProvider;
          }
          recalculateZoomAndCenter(e6) {
            const t5 = this.screenPointToLocation(this.centerPoint, e6), i6 = e6 ? e6.getElevationForLngLatZoom(t5, this._helper._tileZoom) : 0;
            this._helper.recalculateZoomAndCenter(i6);
          }
          setLocationAtPoint(e6, i6) {
            const r8 = t4.aK(this.elevation, this.center.lat), o6 = this.screenPointToMercatorCoordinateAtZ(i6, r8), a4 = this.screenPointToMercatorCoordinateAtZ(this.centerPoint, r8), s4 = t4.$.fromLngLat(e6), n6 = new t4.$(s4.x - (o6.x - a4.x), s4.y - (o6.y - a4.y));
            this.setCenter(null == n6 ? void 0 : n6.toLngLat()), this._helper._renderWorldCopies && this.setCenter(this.center.wrap());
          }
          locationToScreenPoint(e6, i6) {
            return i6 ? this.coordinatePoint(t4.$.fromLngLat(e6), i6.getElevationForLngLatZoom(e6, this._helper._tileZoom), this._pixelMatrix3D) : this.coordinatePoint(t4.$.fromLngLat(e6));
          }
          screenPointToLocation(e6, t5) {
            var i6;
            return null === (i6 = this.screenPointToMercatorCoordinate(e6, t5)) || void 0 === i6 ? void 0 : i6.toLngLat();
          }
          screenPointToMercatorCoordinate(e6, t5) {
            if (t5) {
              const i6 = t5.pointCoordinate(e6);
              if (null != i6) return i6;
            }
            return this.screenPointToMercatorCoordinateAtZ(e6);
          }
          screenPointToMercatorCoordinateAtZ(e6, i6) {
            const r8 = i6 || 0, o6 = [e6.x, e6.y, 0, 1], a4 = [e6.x, e6.y, 1, 1];
            t4.ap(o6, o6, this._pixelMatrixInverse), t4.ap(a4, a4, this._pixelMatrixInverse);
            const s4 = o6[3], n6 = a4[3], l5 = o6[1] / s4, c5 = a4[1] / n6, h4 = o6[2] / s4, u4 = a4[2] / n6, d4 = h4 === u4 ? 0 : (r8 - h4) / (u4 - h4);
            return new t4.$(t4.B.number(o6[0] / s4, a4[0] / n6, d4) / this.worldSize, t4.B.number(l5, c5, d4) / this.worldSize, r8);
          }
          coordinatePoint(e6, i6 = 0, r8 = this._pixelMatrix) {
            const o6 = [e6.x * this.worldSize, e6.y * this.worldSize, i6, 1];
            return t4.ap(o6, o6, r8), new t4.P(o6[0] / o6[3], o6[1] / o6[3]);
          }
          getBounds() {
            const e6 = Math.max(0, this._helper._height / 2 - yt(this));
            return new V2().extend(this.screenPointToLocation(new t4.P(0, e6))).extend(this.screenPointToLocation(new t4.P(this._helper._width, e6))).extend(this.screenPointToLocation(new t4.P(this._helper._width, this._helper._height))).extend(this.screenPointToLocation(new t4.P(0, this._helper._height)));
          }
          isPointOnMapSurface(e6, t5) {
            return t5 ? null != t5.pointCoordinate(e6) : e6.y > this.height / 2 - yt(this);
          }
          calculatePosMatrix(e6, i6 = false, r8) {
            var o6;
            const a4 = null !== (o6 = e6.key) && void 0 !== o6 ? o6 : t4.aX(e6.wrap, e6.canonical.z, e6.canonical.z, e6.canonical.x, e6.canonical.y), s4 = i6 ? this._alignedPosMatrixCache : this._posMatrixCache;
            if (s4.has(a4)) {
              const e7 = s4.get(a4);
              return r8 ? e7.f32 : e7.f64;
            }
            const n6 = wt(e6, this.worldSize);
            t4.N(n6, i6 ? this._alignedProjMatrix : this._viewProjMatrix, n6);
            const l5 = { f64: n6, f32: new Float32Array(n6) };
            return s4.set(a4, l5), r8 ? l5.f32 : l5.f64;
          }
          calculateFogMatrix(e6) {
            const i6 = e6.key, r8 = this._fogMatrixCacheF32;
            if (r8.has(i6)) return r8.get(i6);
            const o6 = wt(e6, this.worldSize);
            return t4.N(o6, this._fogMatrix, o6), r8.set(i6, new Float32Array(o6)), r8.get(i6);
          }
          getConstrained(e6, i6) {
            i6 = t4.ae(+i6, this.minZoom, this.maxZoom);
            const r8 = { center: new t4.Q(e6.lng, e6.lat), zoom: i6 };
            let o6 = this._helper._lngRange;
            this._helper._renderWorldCopies || null !== o6 || (o6 = [-179.9999999999, 180 - 1e-10]);
            const a4 = this.tileSize * t4.aI(r8.zoom);
            let s4 = 0, n6 = a4, l5 = 0, c5 = a4, h4 = 0, u4 = 0;
            const { x: d4, y: _4 } = this.size;
            if (this._helper._latRange) {
              const e7 = this._helper._latRange;
              s4 = t4.S(e7[1]) * a4, n6 = t4.S(e7[0]) * a4, n6 - s4 < _4 && (h4 = _4 / (n6 - s4));
            }
            o6 && (l5 = t4.aL(t4.U(o6[0]) * a4, 0, a4), c5 = t4.aL(t4.U(o6[1]) * a4, 0, a4), c5 < l5 && (c5 += a4), c5 - l5 < d4 && (u4 = d4 / (c5 - l5)));
            const { x: p4, y: m4 } = xt(a4, e6);
            let f4, g4;
            const v4 = Math.max(u4 || 0, h4 || 0);
            if (v4) {
              const e7 = new t4.P(u4 ? (c5 + l5) / 2 : p4, h4 ? (n6 + s4) / 2 : m4);
              return r8.center = bt(a4, e7).wrap(), r8.zoom += t4.ab(v4), r8;
            }
            if (this._helper._latRange) {
              const e7 = _4 / 2;
              m4 - e7 < s4 && (g4 = s4 + e7), m4 + e7 > n6 && (g4 = n6 - e7);
            }
            if (o6) {
              const e7 = (l5 + c5) / 2;
              let i7 = p4;
              this._helper._renderWorldCopies && (i7 = t4.aL(p4, e7 - a4 / 2, e7 + a4 / 2));
              const r9 = d4 / 2;
              i7 - r9 < l5 && (f4 = l5 + r9), i7 + r9 > c5 && (f4 = c5 - r9);
            }
            if (void 0 !== f4 || void 0 !== g4) {
              const e7 = new t4.P(null != f4 ? f4 : p4, null != g4 ? g4 : m4);
              r8.center = bt(a4, e7).wrap();
            }
            return r8;
          }
          calculateCenterFromCameraLngLatAlt(e6, t5, i6, r8) {
            return this._helper.calculateCenterFromCameraLngLatAlt(e6, t5, i6, r8);
          }
          _calculateNearFarZIfNeeded(e6, i6, r8) {
            if (!this._helper.autoCalculateNearFarZ) return;
            const o6 = Math.min(this.elevation, this.minElevationForCurrentTile, this.getCameraAltitude() - 100), a4 = e6 - o6 * this._helper._pixelPerMeter / Math.cos(i6), s4 = o6 < 0 ? a4 : e6, n6 = Math.PI / 2 + this.pitchInRadians, l5 = t4.ad(this.fov) * (Math.abs(Math.cos(t4.ad(this.roll))) * this.height + Math.abs(Math.sin(t4.ad(this.roll))) * this.width) / this.height * (0.5 + r8.y / this.height), c5 = Math.sin(l5) * s4 / Math.sin(t4.ae(Math.PI - n6 - l5, 0.01, Math.PI - 0.01)), h4 = yt(this), u4 = Math.atan(h4 / this._helper.cameraToCenterDistance), d4 = t4.ad(0.75), _4 = u4 > d4 ? 2 * u4 * (0.5 + r8.y / (2 * h4)) : d4, p4 = Math.sin(_4) * s4 / Math.sin(t4.ae(Math.PI - n6 - _4, 0.01, Math.PI - 0.01)), m4 = Math.min(c5, p4);
            this._helper._farZ = 1.01 * (Math.cos(Math.PI / 2 - i6) * m4 + s4), this._helper._nearZ = this._helper._height / 50;
          }
          _calcMatrices() {
            if (!this._helper._height) return;
            const e6 = this.centerOffset, i6 = xt(this.worldSize, this.center), r8 = i6.x, o6 = i6.y;
            this._helper._pixelPerMeter = t4.aK(1, this.center.lat) * this.worldSize;
            const a4 = t4.ad(Math.min(this.pitch, 89.25)), s4 = Math.max(this._helper.cameraToCenterDistance / 2, this._helper.cameraToCenterDistance + this._helper._elevation * this._helper._pixelPerMeter / Math.cos(a4));
            let n6;
            this._calculateNearFarZIfNeeded(s4, a4, e6), n6 = new Float64Array(16), t4.aY(n6, this.fovInRadians, this._helper._width / this._helper._height, this._helper._nearZ, this._helper._farZ), this._invProjMatrix = new Float64Array(16), t4.aj(this._invProjMatrix, n6), n6[8] = 2 * -e6.x / this._helper._width, n6[9] = 2 * e6.y / this._helper._height, this._projectionMatrix = t4.aZ(n6), t4.M(n6, n6, [1, -1, 1]), t4.L(n6, n6, [0, 0, -this._helper.cameraToCenterDistance]), t4.a_(n6, n6, -this.rollInRadians), t4.a$(n6, n6, this.pitchInRadians), t4.a_(n6, n6, -this.bearingInRadians), t4.L(n6, n6, [-r8, -o6, 0]), this._mercatorMatrix = t4.M([], n6, [this.worldSize, this.worldSize, this.worldSize]), t4.M(n6, n6, [1, 1, this._helper._pixelPerMeter]), this._pixelMatrix = t4.N(new Float64Array(16), this.clipSpaceToPixelsMatrix, n6), t4.L(n6, n6, [0, 0, -this.elevation]), this._viewProjMatrix = n6, this._invViewProjMatrix = t4.aj([], n6);
            const l5 = [0, 0, -1, 1];
            t4.ap(l5, l5, this._invViewProjMatrix), this._cameraPosition = [l5[0] / l5[3], l5[1] / l5[3], l5[2] / l5[3]], this._fogMatrix = new Float64Array(16), t4.aY(this._fogMatrix, this.fovInRadians, this.width / this.height, s4, this._helper._farZ), this._fogMatrix[8] = 2 * -e6.x / this.width, this._fogMatrix[9] = 2 * e6.y / this.height, t4.M(this._fogMatrix, this._fogMatrix, [1, -1, 1]), t4.L(this._fogMatrix, this._fogMatrix, [0, 0, -this.cameraToCenterDistance]), t4.a_(this._fogMatrix, this._fogMatrix, -this.rollInRadians), t4.a$(this._fogMatrix, this._fogMatrix, this.pitchInRadians), t4.a_(this._fogMatrix, this._fogMatrix, -this.bearingInRadians), t4.L(this._fogMatrix, this._fogMatrix, [-r8, -o6, 0]), t4.M(this._fogMatrix, this._fogMatrix, [1, 1, this._helper._pixelPerMeter]), t4.L(this._fogMatrix, this._fogMatrix, [0, 0, -this.elevation]), this._pixelMatrix3D = t4.N(new Float64Array(16), this.clipSpaceToPixelsMatrix, n6);
            const c5 = this._helper._width % 2 / 2, h4 = this._helper._height % 2 / 2, u4 = Math.cos(this.bearingInRadians), d4 = Math.sin(-this.bearingInRadians), _4 = r8 - Math.round(r8) + u4 * c5 + d4 * h4, p4 = o6 - Math.round(o6) + u4 * h4 + d4 * c5, m4 = new Float64Array(n6);
            if (t4.L(m4, m4, [_4 > 0.5 ? _4 - 1 : _4, p4 > 0.5 ? p4 - 1 : p4, 0]), this._alignedProjMatrix = m4, n6 = t4.aj(new Float64Array(16), this._pixelMatrix), !n6) throw new Error("failed to invert matrix");
            this._pixelMatrixInverse = n6, this._clearMatrixCaches();
          }
          _clearMatrixCaches() {
            this._posMatrixCache.clear(), this._alignedPosMatrixCache.clear(), this._fogMatrixCacheF32.clear();
          }
          maxPitchScaleFactor() {
            if (!this._pixelMatrixInverse) return 1;
            const e6 = this.screenPointToMercatorCoordinate(new t4.P(0, 0)), i6 = [e6.x * this.worldSize, e6.y * this.worldSize, 0, 1];
            return t4.ap(i6, i6, this._pixelMatrix)[3] / this._helper.cameraToCenterDistance;
          }
          getCameraPoint() {
            return this._helper.getCameraPoint();
          }
          getCameraAltitude() {
            return this._helper.getCameraAltitude();
          }
          getCameraLngLat() {
            const e6 = t4.aK(1, this.center.lat) * this.worldSize;
            return Tt(this.center, this.elevation, this.pitch, this.bearing, this._helper.cameraToCenterDistance / e6).toLngLat();
          }
          lngLatToCameraDepth(e6, i6) {
            const r8 = t4.$.fromLngLat(e6), o6 = [r8.x * this.worldSize, r8.y * this.worldSize, i6, 1];
            return t4.ap(o6, o6, this._viewProjMatrix), o6[2] / o6[3];
          }
          getProjectionData(e6) {
            const { overscaledTileID: i6, aligned: r8, applyTerrainMatrix: o6 } = e6, a4 = this._helper.getMercatorTileCoordinates(i6), s4 = i6 ? this.calculatePosMatrix(i6, r8, true) : null;
            let n6;
            return n6 = i6 && i6.terrainRttPosMatrix32f && o6 ? i6.terrainRttPosMatrix32f : s4 || t4.b0(), { mainMatrix: n6, tileMercatorCoords: a4, clippingPlane: [0, 0, 0, 0], projectionTransition: 0, fallbackMatrix: n6 };
          }
          isLocationOccluded(e6) {
            return false;
          }
          getPixelScale() {
            return 1;
          }
          getCircleRadiusCorrection() {
            return 1;
          }
          getPitchedTextCorrection(e6, t5, i6) {
            return 1;
          }
          transformLightDirection(e6) {
            return t4.aQ(e6);
          }
          getRayDirectionFromPixel(e6) {
            throw new Error("Not implemented.");
          }
          projectTileCoordinates(e6, i6, r8, o6) {
            const a4 = this.calculatePosMatrix(r8);
            let s4;
            o6 ? (s4 = [e6, i6, o6(e6, i6), 1], t4.ap(s4, s4, a4)) : (s4 = [e6, i6, 0, 1], Oe(s4, s4, a4));
            const n6 = s4[3];
            return { point: new t4.P(s4[0] / n6, s4[1] / n6), signedDistanceFromCamera: n6, isOccluded: false };
          }
          populateCache(e6) {
            for (const t5 of e6) this.calculatePosMatrix(t5);
          }
          getMatrixForModel(e6, i6) {
            const r8 = t4.$.fromLngLat(e6, i6), o6 = r8.meterInMercatorCoordinateUnits(), a4 = t4.b1();
            return t4.L(a4, a4, [r8.x, r8.y, r8.z]), t4.a_(a4, a4, Math.PI), t4.a$(a4, a4, Math.PI / 2), t4.M(a4, a4, [-o6, o6, o6]), a4;
          }
          getProjectionDataForCustomLayer(e6 = true) {
            const i6 = new t4.Y(0, 0, 0, 0, 0), r8 = this.getProjectionData({ overscaledTileID: i6, applyGlobeMatrix: e6 }), o6 = wt(i6, this.worldSize);
            t4.N(o6, this._viewProjMatrix, o6), r8.tileMercatorCoords = [0, 0, 1, 1];
            const a4 = [t4.Z, t4.Z, this.worldSize / this._helper.pixelsPerMeter], s4 = t4.b2();
            return t4.M(s4, o6, a4), r8.fallbackMatrix = s4, r8.mainMatrix = s4, r8;
          }
          getFastPathSimpleProjectionMatrix(e6) {
            return this.calculatePosMatrix(e6);
          }
        }
        function zt() {
          t4.w("Map cannot fit within canvas with the given bounds, padding, and/or offset.");
        }
        function At(e6) {
          if (e6.useSlerp) if (e6.k < 1) {
            const i6 = t4.b3(e6.startEulerAngles.roll, e6.startEulerAngles.pitch, e6.startEulerAngles.bearing), r8 = t4.b3(e6.endEulerAngles.roll, e6.endEulerAngles.pitch, e6.endEulerAngles.bearing), o6 = new Float64Array(4);
            t4.b4(o6, i6, r8, e6.k);
            const a4 = t4.b5(o6);
            e6.tr.setRoll(a4.roll), e6.tr.setPitch(a4.pitch), e6.tr.setBearing(a4.bearing);
          } else e6.tr.setRoll(e6.endEulerAngles.roll), e6.tr.setPitch(e6.endEulerAngles.pitch), e6.tr.setBearing(e6.endEulerAngles.bearing);
          else e6.tr.setRoll(t4.B.number(e6.startEulerAngles.roll, e6.endEulerAngles.roll, e6.k)), e6.tr.setPitch(t4.B.number(e6.startEulerAngles.pitch, e6.endEulerAngles.pitch, e6.k)), e6.tr.setBearing(t4.B.number(e6.startEulerAngles.bearing, e6.endEulerAngles.bearing, e6.k));
        }
        function Lt(e6, i6, r8, o6, a4) {
          const s4 = a4.padding, n6 = xt(a4.worldSize, r8.getNorthWest()), l5 = xt(a4.worldSize, r8.getNorthEast()), c5 = xt(a4.worldSize, r8.getSouthEast()), h4 = xt(a4.worldSize, r8.getSouthWest()), u4 = t4.ad(-o6), d4 = n6.rotate(u4), _4 = l5.rotate(u4), p4 = c5.rotate(u4), m4 = h4.rotate(u4), f4 = new t4.P(Math.max(d4.x, _4.x, m4.x, p4.x), Math.max(d4.y, _4.y, m4.y, p4.y)), g4 = new t4.P(Math.min(d4.x, _4.x, m4.x, p4.x), Math.min(d4.y, _4.y, m4.y, p4.y)), v4 = f4.sub(g4), x4 = (a4.width - (s4.left + s4.right + i6.left + i6.right)) / v4.x, b5 = (a4.height - (s4.top + s4.bottom + i6.top + i6.bottom)) / v4.y;
          if (b5 < 0 || x4 < 0) return void zt();
          const y4 = Math.min(t4.ab(a4.scale * Math.min(x4, b5)), e6.maxZoom), w4 = t4.P.convert(e6.offset), T5 = new t4.P((i6.left - i6.right) / 2, (i6.top - i6.bottom) / 2).rotate(t4.ad(o6)), P4 = w4.add(T5).mult(a4.scale / t4.aI(y4));
          return { center: bt(a4.worldSize, n6.add(c5).div(2).sub(P4)), zoom: y4, bearing: o6 };
        }
        class kt {
          get useGlobeControls() {
            return false;
          }
          handlePanInertia(e6, t5) {
            return { easingOffset: e6, easingCenter: t5.center };
          }
          handleMapControlsRollPitchBearingZoom(e6, t5) {
            e6.bearingDelta && t5.setBearing(t5.bearing + e6.bearingDelta), e6.pitchDelta && t5.setPitch(t5.pitch + e6.pitchDelta), e6.rollDelta && t5.setRoll(t5.roll + e6.rollDelta), e6.zoomDelta && t5.setZoom(t5.zoom + e6.zoomDelta);
          }
          handleMapControlsPan(e6, t5, i6) {
            e6.around.distSqr(t5.centerPoint) < 0.01 || t5.setLocationAtPoint(i6, e6.around);
          }
          cameraForBoxAndBearing(e6, t5, i6, r8, o6) {
            return Lt(e6, t5, i6, r8, o6);
          }
          handleJumpToCenterZoom(e6, i6) {
            e6.zoom !== (void 0 !== i6.zoom ? +i6.zoom : e6.zoom) && e6.setZoom(+i6.zoom), void 0 !== i6.center && e6.setCenter(t4.Q.convert(i6.center));
          }
          handleEaseTo(e6, i6) {
            const r8 = e6.zoom, o6 = e6.padding, a4 = { roll: e6.roll, pitch: e6.pitch, bearing: e6.bearing }, s4 = { roll: void 0 === i6.roll ? e6.roll : i6.roll, pitch: void 0 === i6.pitch ? e6.pitch : i6.pitch, bearing: void 0 === i6.bearing ? e6.bearing : i6.bearing }, n6 = void 0 !== i6.zoom, l5 = !e6.isPaddingEqual(i6.padding);
            let c5 = false;
            const h4 = n6 ? +i6.zoom : e6.zoom;
            let u4 = e6.centerPoint.add(i6.offsetAsPoint);
            const d4 = e6.screenPointToLocation(u4), { center: _4, zoom: p4 } = e6.getConstrained(t4.Q.convert(i6.center || d4), null != h4 ? h4 : r8);
            Ct(e6, _4);
            const m4 = xt(e6.worldSize, d4), f4 = xt(e6.worldSize, _4).sub(m4), g4 = t4.aI(p4 - r8);
            return c5 = p4 !== r8, { easeFunc: (n7) => {
              if (c5 && e6.setZoom(t4.B.number(r8, p4, n7)), t4.b6(a4, s4) || At({ startEulerAngles: a4, endEulerAngles: s4, tr: e6, k: n7, useSlerp: a4.roll != s4.roll }), l5 && (e6.interpolatePadding(o6, i6.padding, n7), u4 = e6.centerPoint.add(i6.offsetAsPoint)), i6.around) e6.setLocationAtPoint(i6.around, i6.aroundPoint);
              else {
                const i7 = t4.aI(e6.zoom - r8), o7 = p4 > r8 ? Math.min(2, g4) : Math.max(0.5, g4), a5 = Math.pow(o7, 1 - n7), s5 = bt(e6.worldSize, m4.add(f4.mult(n7 * a5)).mult(i7));
                e6.setLocationAtPoint(e6.renderWorldCopies ? s5.wrap() : s5, u4);
              }
            }, isZooming: c5, elevationCenter: _4 };
          }
          handleFlyTo(e6, i6) {
            const r8 = void 0 !== i6.zoom, o6 = e6.zoom, a4 = e6.getConstrained(t4.Q.convert(i6.center || i6.locationAtOffset), r8 ? +i6.zoom : o6), s4 = a4.center, n6 = a4.zoom;
            Ct(e6, s4);
            const l5 = xt(e6.worldSize, i6.locationAtOffset), c5 = xt(e6.worldSize, s4).sub(l5), h4 = c5.mag(), u4 = t4.aI(n6 - o6);
            let d4;
            if (void 0 !== i6.minZoom) {
              const r9 = Math.min(+i6.minZoom, o6, n6), a5 = e6.getConstrained(s4, r9).zoom;
              d4 = t4.aI(a5 - o6);
            }
            return { easeFunc: (i7, r9, a5, h5) => {
              e6.setZoom(1 === i7 ? n6 : o6 + t4.ab(r9));
              const u5 = 1 === i7 ? s4 : bt(e6.worldSize, l5.add(c5.mult(a5)).mult(r9));
              e6.setLocationAtPoint(e6.renderWorldCopies ? u5.wrap() : u5, h5);
            }, scaleOfZoom: u4, targetCenter: s4, scaleOfMinZoom: d4, pixelPathLength: h4 };
          }
        }
        class Ft {
          constructor(e6, t5, i6) {
            this.blendFunction = e6, this.blendColor = t5, this.mask = i6;
          }
        }
        Ft.Replace = [1, 0], Ft.disabled = new Ft(Ft.Replace, t4.b7.transparent, [false, false, false, false]), Ft.unblended = new Ft(Ft.Replace, t4.b7.transparent, [true, true, true, true]), Ft.alphaBlended = new Ft([1, 771], t4.b7.transparent, [true, true, true, true]);
        const Bt = 2305;
        class Ot {
          constructor(e6, t5, i6) {
            this.enable = e6, this.mode = t5, this.frontFace = i6;
          }
        }
        Ot.disabled = new Ot(false, 1029, Bt), Ot.backCCW = new Ot(true, 1029, Bt), Ot.frontCCW = new Ot(true, 1028, Bt);
        class jt {
          constructor(e6, t5, i6) {
            this.func = e6, this.mask = t5, this.range = i6;
          }
        }
        jt.ReadOnly = false, jt.ReadWrite = true, jt.disabled = new jt(519, jt.ReadOnly, [0, 1]);
        const Zt = 7680;
        class Nt {
          constructor(e6, t5, i6, r8, o6, a4) {
            this.test = e6, this.ref = t5, this.mask = i6, this.fail = r8, this.depthFail = o6, this.pass = a4;
          }
        }
        Nt.disabled = new Nt({ func: 519, mask: 0 }, 0, 0, Zt, Zt, Zt);
        const Gt = /* @__PURE__ */ new WeakMap();
        function Ut(e6) {
          var t5;
          if (Gt.has(e6)) return Gt.get(e6);
          {
            const i6 = null === (t5 = e6.getParameter(e6.VERSION)) || void 0 === t5 ? void 0 : t5.startsWith("WebGL 2.0");
            return Gt.set(e6, i6), i6;
          }
        }
        class Vt {
          get awaitingQuery() {
            return !!this._readbackQueue;
          }
          constructor(e6) {
            this._readbackWaitFrames = 4, this._measureWaitFrames = 6, this._texWidth = 1, this._texHeight = 1, this._measuredError = 0, this._updateCount = 0, this._lastReadbackFrame = -1e3, this._readbackQueue = null, this._cachedRenderContext = e6;
            const i6 = e6.context, r8 = i6.gl;
            this._texFormat = r8.RGBA, this._texType = r8.UNSIGNED_BYTE;
            const o6 = new t4.aF();
            o6.emplaceBack(-1, -1), o6.emplaceBack(2, -1), o6.emplaceBack(-1, 2);
            const a4 = new t4.aH();
            a4.emplaceBack(0, 1, 2), this._fullscreenTriangle = new pt(i6.createVertexBuffer(o6, mt.members), i6.createIndexBuffer(a4), t4.aG.simpleSegment(0, 0, o6.length, a4.length)), this._resultBuffer = new Uint8Array(4), i6.activeTexture.set(r8.TEXTURE1);
            const s4 = r8.createTexture();
            r8.bindTexture(r8.TEXTURE_2D, s4), r8.texParameteri(r8.TEXTURE_2D, r8.TEXTURE_WRAP_S, r8.CLAMP_TO_EDGE), r8.texParameteri(r8.TEXTURE_2D, r8.TEXTURE_WRAP_T, r8.CLAMP_TO_EDGE), r8.texParameteri(r8.TEXTURE_2D, r8.TEXTURE_MIN_FILTER, r8.NEAREST), r8.texParameteri(r8.TEXTURE_2D, r8.TEXTURE_MAG_FILTER, r8.NEAREST), r8.texImage2D(r8.TEXTURE_2D, 0, this._texFormat, this._texWidth, this._texHeight, 0, this._texFormat, this._texType, null), this._fbo = i6.createFramebuffer(this._texWidth, this._texHeight, false, false), this._fbo.colorAttachment.set(s4), Ut(r8) && (this._pbo = r8.createBuffer(), r8.bindBuffer(r8.PIXEL_PACK_BUFFER, this._pbo), r8.bufferData(r8.PIXEL_PACK_BUFFER, 4, r8.STREAM_READ), r8.bindBuffer(r8.PIXEL_PACK_BUFFER, null));
          }
          destroy() {
            const e6 = this._cachedRenderContext.context.gl;
            this._fullscreenTriangle.destroy(), this._fbo.destroy(), e6.deleteBuffer(this._pbo), this._fullscreenTriangle = null, this._fbo = null, this._pbo = null, this._resultBuffer = null;
          }
          updateErrorLoop(e6, t5) {
            const i6 = this._updateCount;
            return this._readbackQueue ? i6 >= this._readbackQueue.frameNumberIssued + this._readbackWaitFrames && this._tryReadback() : i6 >= this._lastReadbackFrame + this._measureWaitFrames && this._renderErrorTexture(e6, t5), this._updateCount++, this._measuredError;
          }
          _bindFramebuffer() {
            const e6 = this._cachedRenderContext.context, t5 = e6.gl;
            e6.activeTexture.set(t5.TEXTURE1), t5.bindTexture(t5.TEXTURE_2D, this._fbo.colorAttachment.get()), e6.bindFramebuffer.set(this._fbo.framebuffer);
          }
          _renderErrorTexture(e6, i6) {
            const r8 = this._cachedRenderContext.context, o6 = r8.gl;
            if (this._bindFramebuffer(), r8.viewport.set([0, 0, this._texWidth, this._texHeight]), r8.clear({ color: t4.b7.transparent }), this._cachedRenderContext.useProgram("projectionErrorMeasurement").draw(r8, o6.TRIANGLES, jt.disabled, Nt.disabled, Ft.unblended, Ot.disabled, /* @__PURE__ */ ((e7, t5) => ({ u_input: e7, u_output_expected: t5 }))(e6, i6), null, null, "$clipping", this._fullscreenTriangle.vertexBuffer, this._fullscreenTriangle.indexBuffer, this._fullscreenTriangle.segments), this._pbo && Ut(o6)) {
              o6.bindBuffer(o6.PIXEL_PACK_BUFFER, this._pbo), o6.readBuffer(o6.COLOR_ATTACHMENT0), o6.readPixels(0, 0, this._texWidth, this._texHeight, this._texFormat, this._texType, 0), o6.bindBuffer(o6.PIXEL_PACK_BUFFER, null);
              const e7 = o6.fenceSync(o6.SYNC_GPU_COMMANDS_COMPLETE, 0);
              o6.flush(), this._readbackQueue = { frameNumberIssued: this._updateCount, sync: e7 };
            } else this._readbackQueue = { frameNumberIssued: this._updateCount, sync: null };
          }
          _tryReadback() {
            const e6 = this._cachedRenderContext.context.gl;
            if (this._pbo && this._readbackQueue && Ut(e6)) {
              const i6 = e6.clientWaitSync(this._readbackQueue.sync, 0, 0);
              if (i6 === e6.WAIT_FAILED) return t4.w("WebGL2 clientWaitSync failed."), this._readbackQueue = null, void (this._lastReadbackFrame = this._updateCount);
              if (i6 === e6.TIMEOUT_EXPIRED) return;
              e6.bindBuffer(e6.PIXEL_PACK_BUFFER, this._pbo), e6.getBufferSubData(e6.PIXEL_PACK_BUFFER, 0, this._resultBuffer, 0, 4), e6.bindBuffer(e6.PIXEL_PACK_BUFFER, null);
            } else this._bindFramebuffer(), e6.readPixels(0, 0, this._texWidth, this._texHeight, this._texFormat, this._texType, this._resultBuffer);
            this._readbackQueue = null, this._measuredError = Vt._parseRGBA8float(this._resultBuffer), this._lastReadbackFrame = this._updateCount;
          }
          static _parseRGBA8float(e6) {
            let t5 = 0;
            return t5 += e6[0] / 256, t5 += e6[1] / 65536, t5 += e6[2] / 16777216, e6[3] < 127 && (t5 = -t5), t5 / 128;
          }
        }
        const qt = t4.Z / 128;
        function Wt(e6, i6) {
          const r8 = void 0 !== e6.granularity ? Math.max(e6.granularity, 1) : 1, o6 = r8 + (e6.generateBorders ? 2 : 0), a4 = r8 + (e6.extendToNorthPole || e6.generateBorders ? 1 : 0) + (e6.extendToSouthPole || e6.generateBorders ? 1 : 0), s4 = o6 + 1, n6 = a4 + 1, l5 = e6.generateBorders ? -1 : 0, c5 = e6.generateBorders || e6.extendToNorthPole ? -1 : 0, h4 = r8 + (e6.generateBorders ? 1 : 0), u4 = r8 + (e6.generateBorders || e6.extendToSouthPole ? 1 : 0), d4 = s4 * n6, _4 = o6 * a4 * 6, p4 = s4 * n6 > 65536;
          if (p4 && "16bit" === i6) throw new Error("Granularity is too large and meshes would not fit inside 16 bit vertex indices.");
          const m4 = p4 || "32bit" === i6, f4 = new Int16Array(2 * d4);
          let g4 = 0;
          for (let i7 = c5; i7 <= u4; i7++) for (let o7 = l5; o7 <= h4; o7++) {
            let a5 = o7 / r8 * t4.Z;
            -1 === o7 && (a5 = -64), o7 === r8 + 1 && (a5 = t4.Z + qt);
            let s5 = i7 / r8 * t4.Z;
            -1 === i7 && (s5 = e6.extendToNorthPole ? t4.b9 : -64), i7 === r8 + 1 && (s5 = e6.extendToSouthPole ? t4.ba : t4.Z + qt), f4[g4++] = a5, f4[g4++] = s5;
          }
          const v4 = m4 ? new Uint32Array(_4) : new Uint16Array(_4);
          let x4 = 0;
          for (let e7 = 0; e7 < a4; e7++) for (let t5 = 0; t5 < o6; t5++) {
            const i7 = t5 + 1 + e7 * s4, r9 = t5 + (e7 + 1) * s4, o7 = t5 + 1 + (e7 + 1) * s4;
            v4[x4++] = t5 + e7 * s4, v4[x4++] = r9, v4[x4++] = i7, v4[x4++] = i7, v4[x4++] = r9, v4[x4++] = o7;
          }
          return { vertices: f4.buffer.slice(0), indices: v4.buffer.slice(0), uses32bitIndices: m4 };
        }
        const $t = new t4.aE({ fill: new t4.bb(128, 2), line: new t4.bb(512, 0), tile: new t4.bb(128, 32), stencil: new t4.bb(128, 1), circle: 3 });
        class Ht {
          constructor() {
            this._tileMeshCache = {}, this._errorCorrectionUsable = 0, this._errorMeasurementLastValue = 0, this._errorCorrectionPreviousValue = 0, this._errorMeasurementLastChangeTime = -1e3;
          }
          get name() {
            return "vertical-perspective";
          }
          get transitionState() {
            return 1;
          }
          get useSubdivision() {
            return true;
          }
          get shaderVariantName() {
            return "globe";
          }
          get shaderDefine() {
            return "#define GLOBE";
          }
          get shaderPreludeCode() {
            return dt.projectionGlobe;
          }
          get vertexShaderPreludeCode() {
            return dt.projectionMercator.vertexSource;
          }
          get subdivisionGranularity() {
            return $t;
          }
          get useGlobeControls() {
            return true;
          }
          get latitudeErrorCorrectionRadians() {
            return this._errorCorrectionUsable;
          }
          destroy() {
            this._errorMeasurement && this._errorMeasurement.destroy();
          }
          updateGPUdependent(e6) {
            this._errorMeasurement || (this._errorMeasurement = new Vt(e6));
            const i6 = t4.S(this._errorQueryLatitudeDegrees), r8 = 2 * Math.atan(Math.exp(Math.PI - i6 * Math.PI * 2)) - 0.5 * Math.PI, o6 = this._errorMeasurement.updateErrorLoop(i6, r8), a4 = s3.now();
            o6 !== this._errorMeasurementLastValue && (this._errorCorrectionPreviousValue = this._errorCorrectionUsable, this._errorMeasurementLastValue = o6, this._errorMeasurementLastChangeTime = a4);
            const n6 = Math.min(Math.max((a4 - this._errorMeasurementLastChangeTime) / 1e3 / 0.5, 0), 1);
            this._errorCorrectionUsable = t4.bc(this._errorCorrectionPreviousValue, -this._errorMeasurementLastValue, t4.bd(n6));
          }
          _getMeshKey(e6) {
            return `${e6.granularity.toString(36)}_${e6.generateBorders ? "b" : ""}${e6.extendToNorthPole ? "n" : ""}${e6.extendToSouthPole ? "s" : ""}`;
          }
          getMeshFromTileID(e6, t5, i6, r8, o6) {
            const a4 = ("stencil" === o6 ? $t.stencil : $t.tile).getGranularityForZoomLevel(t5.z);
            return this._getMesh(e6, { granularity: a4, generateBorders: i6, extendToNorthPole: 0 === t5.y && r8, extendToSouthPole: t5.y === (1 << t5.z) - 1 && r8 });
          }
          _getMesh(e6, i6) {
            const r8 = this._getMeshKey(i6);
            if (r8 in this._tileMeshCache) return this._tileMeshCache[r8];
            const o6 = function(e7, i7) {
              const r9 = Wt(i7, "16bit"), o7 = t4.aF.deserialize({ arrayBuffer: r9.vertices, length: r9.vertices.byteLength / 2 / 2 }), a4 = t4.aH.deserialize({ arrayBuffer: r9.indices, length: r9.indices.byteLength / 2 / 3 });
              return new pt(e7.createVertexBuffer(o7, mt.members), e7.createIndexBuffer(a4), t4.aG.simpleSegment(0, 0, o7.length, a4.length));
            }(e6, i6);
            return this._tileMeshCache[r8] = o6, o6;
          }
          recalculate(e6) {
          }
          hasTransition() {
            const e6 = s3.now();
            let t5 = false;
            return t5 = t5 || (e6 - this._errorMeasurementLastChangeTime) / 1e3 < 0.7, t5 = t5 || this._errorMeasurement && this._errorMeasurement.awaitingQuery, t5;
          }
          setErrorQueryLatitudeDegrees(e6) {
            this._errorQueryLatitudeDegrees = e6;
          }
        }
        const Kt = new t4.r({ type: new t4.D(t4.v.projection.type) });
        class Xt extends t4.E {
          constructor(e6) {
            super(), this._transitionable = new t4.T(Kt), this.setProjection(e6), this._transitioning = this._transitionable.untransitioned(), this.recalculate(new t4.C(0)), this._mercatorProjection = new vt(), this._verticalPerspectiveProjection = new Ht();
          }
          get transitionState() {
            const e6 = this.properties.get("type");
            if ("string" == typeof e6 && "mercator" === e6) return 0;
            if ("string" == typeof e6 && "vertical-perspective" === e6) return 1;
            if (e6 instanceof t4.be) {
              if ("vertical-perspective" === e6.from && "mercator" === e6.to) return 1 - e6.transition;
              if ("mercator" === e6.from && "vertical-perspective" === e6.to) return e6.transition;
            }
            return 1;
          }
          get useGlobeRendering() {
            return this.transitionState > 0;
          }
          get latitudeErrorCorrectionRadians() {
            return this._verticalPerspectiveProjection.latitudeErrorCorrectionRadians;
          }
          get currentProjection() {
            return this.useGlobeRendering ? this._verticalPerspectiveProjection : this._mercatorProjection;
          }
          get name() {
            return "globe";
          }
          get useSubdivision() {
            return this.currentProjection.useSubdivision;
          }
          get shaderVariantName() {
            return this.currentProjection.shaderVariantName;
          }
          get shaderDefine() {
            return this.currentProjection.shaderDefine;
          }
          get shaderPreludeCode() {
            return this.currentProjection.shaderPreludeCode;
          }
          get vertexShaderPreludeCode() {
            return this.currentProjection.vertexShaderPreludeCode;
          }
          get subdivisionGranularity() {
            return this.currentProjection.subdivisionGranularity;
          }
          get useGlobeControls() {
            return this.transitionState > 0;
          }
          destroy() {
            this._mercatorProjection.destroy(), this._verticalPerspectiveProjection.destroy();
          }
          updateGPUdependent(e6) {
            this._mercatorProjection.updateGPUdependent(e6), this._verticalPerspectiveProjection.updateGPUdependent(e6);
          }
          getMeshFromTileID(e6, t5, i6, r8, o6) {
            return this.currentProjection.getMeshFromTileID(e6, t5, i6, r8, o6);
          }
          setProjection(e6) {
            this._transitionable.setValue("type", (null == e6 ? void 0 : e6.type) || "mercator");
          }
          updateTransitions(e6) {
            this._transitioning = this._transitionable.transitioned(e6, this._transitioning);
          }
          hasTransition() {
            return this._transitioning.hasTransition() || this.currentProjection.hasTransition();
          }
          recalculate(e6) {
            this.properties = this._transitioning.possiblyEvaluate(e6);
          }
          setErrorQueryLatitudeDegrees(e6) {
            this._verticalPerspectiveProjection.setErrorQueryLatitudeDegrees(e6), this._mercatorProjection.setErrorQueryLatitudeDegrees(e6);
          }
        }
        function Qt(e6) {
          const t5 = ei(e6.worldSize, e6.center.lat);
          return 2 * Math.PI * t5;
        }
        function Yt(e6, i6, r8, o6, a4) {
          const s4 = 1 / (1 << a4), n6 = i6 / t4.Z * s4 + o6 * s4, l5 = t4.bg((e6 / t4.Z * s4 + r8 * s4) * Math.PI * 2 + Math.PI, 2 * Math.PI), c5 = 2 * Math.atan(Math.exp(Math.PI - n6 * Math.PI * 2)) - 0.5 * Math.PI, h4 = Math.cos(c5), u4 = new Float64Array(3);
          return u4[0] = Math.sin(l5) * h4, u4[1] = Math.sin(c5), u4[2] = Math.cos(l5) * h4, u4;
        }
        function Jt(e6) {
          return function(e7, t5) {
            const i6 = Math.cos(t5), r8 = new Float64Array(3);
            return r8[0] = Math.sin(e7) * i6, r8[1] = Math.sin(t5), r8[2] = Math.cos(e7) * i6, r8;
          }(e6.lng * Math.PI / 180, e6.lat * Math.PI / 180);
        }
        function ei(e6, t5) {
          return e6 / (2 * Math.PI) / Math.cos(t5 * Math.PI / 180);
        }
        function ti(e6) {
          const i6 = Math.asin(e6[1]) / Math.PI * 180, r8 = Math.sqrt(e6[0] * e6[0] + e6[2] * e6[2]);
          if (r8 > 1e-6) {
            const o6 = e6[0] / r8, a4 = Math.acos(e6[2] / r8), s4 = (o6 > 0 ? a4 : -a4) / Math.PI * 180;
            return new t4.Q(t4.aL(s4, -180, 180), i6);
          }
          return new t4.Q(0, i6);
        }
        function ii(e6) {
          return Math.cos(e6 * Math.PI / 180);
        }
        function ri(e6, i6) {
          const r8 = ii(e6), o6 = ii(i6);
          return t4.ab(o6 / r8);
        }
        function oi(e6, i6) {
          const r8 = e6.rotate(i6.bearingInRadians), o6 = i6.zoom + ri(i6.center.lat, 0), a4 = t4.bc(1 / ii(i6.center.lat), 1 / ii(Math.min(Math.abs(i6.center.lat), 60)), t4.bf(o6, 7, 3, 0, 1)), s4 = 360 / Qt({ worldSize: i6.worldSize, center: { lat: i6.center.lat } });
          return new t4.Q(i6.center.lng - r8.x * s4 * a4, t4.ae(i6.center.lat + r8.y * s4, -85.051129, t4.aJ));
        }
        function ai(e6) {
          const t5 = 0.5 * e6, i6 = Math.sin(t5), r8 = Math.cos(t5);
          return Math.log(i6 + r8) - Math.log(r8 - i6);
        }
        function si(e6, i6, r8, o6) {
          const a4 = e6.lat + r8 * o6;
          if (Math.abs(r8) > 1) {
            const s4 = (Math.sign(e6.lat + r8) !== Math.sign(e6.lat) ? -Math.abs(e6.lat) : Math.abs(e6.lat)) * Math.PI / 180, n6 = Math.abs(e6.lat + r8) * Math.PI / 180, l5 = ai(s4 + o6 * (n6 - s4)), c5 = ai(s4), h4 = ai(n6);
            return new t4.Q(e6.lng + i6 * ((l5 - c5) / (h4 - c5)), a4);
          }
          return new t4.Q(e6.lng + i6 * o6, a4);
        }
        class ni {
          constructor(e6) {
            this._cachePrevious = /* @__PURE__ */ new Map(), this._cache = /* @__PURE__ */ new Map(), this._hadAnyChanges = false, this._aabbFactory = e6;
          }
          recalculateCache() {
            if (!this._hadAnyChanges) return;
            const e6 = this._cachePrevious;
            this._cachePrevious = this._cache, this._cache = e6, this._cache.clear(), this._hadAnyChanges = false;
          }
          getTileAABB(e6, t5, i6, r8) {
            const o6 = `${e6.z}_${e6.x}_${e6.y}`, a4 = this._cache.get(o6);
            if (a4) return a4;
            const s4 = this._cachePrevious.get(o6);
            if (s4) return this._cache.set(o6, s4), s4;
            const n6 = this._aabbFactory(e6, t5, i6, r8);
            return this._cache.set(o6, n6), this._hadAnyChanges = true, n6;
          }
        }
        function li(e6, t5, i6) {
          const r8 = e6 - t5;
          return r8 < 0 ? -r8 : Math.max(0, r8 - i6);
        }
        function ci(e6, t5, i6, r8, o6) {
          const a4 = e6 - i6;
          let s4;
          return s4 = a4 < 0 ? Math.min(-a4, 1 + a4 - o6) : a4 > 1 ? Math.min(Math.max(a4 - o6, 0), 1 - a4) : 0, Math.max(s4, li(t5, r8, o6));
        }
        class hi {
          constructor() {
            this._aabbCache = new ni(this._computeTileAABB);
          }
          recalculateCache() {
            this._aabbCache.recalculateCache();
          }
          distanceToTile2d(e6, t5, i6, r8) {
            const o6 = 1 << i6.z, a4 = 1 / o6, s4 = i6.x / o6, n6 = i6.y / o6;
            let l5 = 2;
            return l5 = Math.min(l5, ci(e6, t5, s4, n6, a4)), l5 = Math.min(l5, ci(e6, t5, s4 + 0.5, -n6 - a4, a4)), l5 = Math.min(l5, ci(e6, t5, s4 + 0.5, 2 - n6 - a4, a4)), l5;
          }
          getWrap(e6, t5, i6) {
            const r8 = 1 << t5.z, o6 = 1 / r8, a4 = t5.x / r8, s4 = li(e6.x, a4, o6), n6 = li(e6.x, a4 - 1, o6), l5 = li(e6.x, a4 + 1, o6), c5 = Math.min(s4, n6, l5);
            return c5 === l5 ? 1 : c5 === n6 ? -1 : 0;
          }
          allowVariableZoom(e6, t5) {
            return he(e6, t5) > 4;
          }
          allowWorldCopies() {
            return false;
          }
          getTileAABB(e6, t5, i6, r8) {
            return this._aabbCache.getTileAABB(e6, t5, i6, r8);
          }
          _computeTileAABB(e6, i6, r8, o6) {
            if (e6.z <= 0) return new Et([-1, -1, -1], [1, 1, 1]);
            if (1 === e6.z) return new Et([0 === e6.x ? -1 : 0, 0 === e6.y ? 0 : -1, -1], [0 === e6.x ? 0 : 1, 0 === e6.y ? 1 : 0, 1]);
            {
              const i7 = [Yt(0, 0, e6.x, e6.y, e6.z), Yt(t4.Z, 0, e6.x, e6.y, e6.z), Yt(t4.Z, t4.Z, e6.x, e6.y, e6.z), Yt(0, t4.Z, e6.x, e6.y, e6.z)], r9 = [1, 1, 1], o7 = [-1, -1, -1];
              for (const e7 of i7) for (let t5 = 0; t5 < 3; t5++) r9[t5] = Math.min(r9[t5], e7[t5]), o7[t5] = Math.max(o7[t5], e7[t5]);
              if (0 === e6.y || e6.y === (1 << e6.z) - 1) {
                const t5 = [0, 0 === e6.y ? 1 : -1, 0];
                for (let e7 = 0; e7 < 3; e7++) r9[e7] = Math.min(r9[e7], t5[e7]), o7[e7] = Math.max(o7[e7], t5[e7]);
              }
              return new Et(r9, o7);
            }
          }
        }
        class ui {
          get pixelsToClipSpaceMatrix() {
            return this._helper.pixelsToClipSpaceMatrix;
          }
          get clipSpaceToPixelsMatrix() {
            return this._helper.clipSpaceToPixelsMatrix;
          }
          get pixelsToGLUnits() {
            return this._helper.pixelsToGLUnits;
          }
          get centerOffset() {
            return this._helper.centerOffset;
          }
          get size() {
            return this._helper.size;
          }
          get rotationMatrix() {
            return this._helper.rotationMatrix;
          }
          get centerPoint() {
            return this._helper.centerPoint;
          }
          get pixelsPerMeter() {
            return this._helper.pixelsPerMeter;
          }
          setMinZoom(e6) {
            this._helper.setMinZoom(e6);
          }
          setMaxZoom(e6) {
            this._helper.setMaxZoom(e6);
          }
          setMinPitch(e6) {
            this._helper.setMinPitch(e6);
          }
          setMaxPitch(e6) {
            this._helper.setMaxPitch(e6);
          }
          setRenderWorldCopies(e6) {
            this._helper.setRenderWorldCopies(e6);
          }
          setBearing(e6) {
            this._helper.setBearing(e6);
          }
          setPitch(e6) {
            this._helper.setPitch(e6);
          }
          setRoll(e6) {
            this._helper.setRoll(e6);
          }
          setFov(e6) {
            this._helper.setFov(e6);
          }
          setZoom(e6) {
            this._helper.setZoom(e6);
          }
          setCenter(e6) {
            this._helper.setCenter(e6);
          }
          setElevation(e6) {
            this._helper.setElevation(e6);
          }
          setMinElevationForCurrentTile(e6) {
            this._helper.setMinElevationForCurrentTile(e6);
          }
          setPadding(e6) {
            this._helper.setPadding(e6);
          }
          interpolatePadding(e6, t5, i6) {
            return this._helper.interpolatePadding(e6, t5, i6);
          }
          isPaddingEqual(e6) {
            return this._helper.isPaddingEqual(e6);
          }
          resize(e6, t5) {
            this._helper.resize(e6, t5);
          }
          getMaxBounds() {
            return this._helper.getMaxBounds();
          }
          setMaxBounds(e6) {
            this._helper.setMaxBounds(e6);
          }
          overrideNearFarZ(e6, t5) {
            this._helper.overrideNearFarZ(e6, t5);
          }
          clearNearFarZOverride() {
            this._helper.clearNearFarZOverride();
          }
          getCameraQueryGeometry(e6) {
            return this._helper.getCameraQueryGeometry(this.getCameraPoint(), e6);
          }
          get tileSize() {
            return this._helper.tileSize;
          }
          get tileZoom() {
            return this._helper.tileZoom;
          }
          get scale() {
            return this._helper.scale;
          }
          get worldSize() {
            return this._helper.worldSize;
          }
          get width() {
            return this._helper.width;
          }
          get height() {
            return this._helper.height;
          }
          get lngRange() {
            return this._helper.lngRange;
          }
          get latRange() {
            return this._helper.latRange;
          }
          get minZoom() {
            return this._helper.minZoom;
          }
          get maxZoom() {
            return this._helper.maxZoom;
          }
          get zoom() {
            return this._helper.zoom;
          }
          get center() {
            return this._helper.center;
          }
          get minPitch() {
            return this._helper.minPitch;
          }
          get maxPitch() {
            return this._helper.maxPitch;
          }
          get pitch() {
            return this._helper.pitch;
          }
          get pitchInRadians() {
            return this._helper.pitchInRadians;
          }
          get roll() {
            return this._helper.roll;
          }
          get rollInRadians() {
            return this._helper.rollInRadians;
          }
          get bearing() {
            return this._helper.bearing;
          }
          get bearingInRadians() {
            return this._helper.bearingInRadians;
          }
          get fov() {
            return this._helper.fov;
          }
          get fovInRadians() {
            return this._helper.fovInRadians;
          }
          get elevation() {
            return this._helper.elevation;
          }
          get minElevationForCurrentTile() {
            return this._helper.minElevationForCurrentTile;
          }
          get padding() {
            return this._helper.padding;
          }
          get unmodified() {
            return this._helper.unmodified;
          }
          get renderWorldCopies() {
            return this._helper.renderWorldCopies;
          }
          get nearZ() {
            return this._helper.nearZ;
          }
          get farZ() {
            return this._helper.farZ;
          }
          get autoCalculateNearFarZ() {
            return this._helper.autoCalculateNearFarZ;
          }
          setTransitionState(e6) {
          }
          constructor() {
            this._cachedClippingPlane = t4.bh(), this._projectionMatrix = t4.b1(), this._globeViewProjMatrix32f = t4.b0(), this._globeViewProjMatrixNoCorrection = t4.b1(), this._globeViewProjMatrixNoCorrectionInverted = t4.b1(), this._globeProjMatrixInverted = t4.b1(), this._cameraPosition = t4.bi(), this._globeLatitudeErrorCorrectionRadians = 0, this._helper = new Mt({ calcMatrices: () => {
              this._calcMatrices();
            }, getConstrained: (e6, t5) => this.getConstrained(e6, t5) }), this._coveringTilesDetailsProvider = new hi();
          }
          clone() {
            const e6 = new ui();
            return e6.apply(this), e6;
          }
          apply(e6, t5) {
            this._globeLatitudeErrorCorrectionRadians = t5 || 0, this._helper.apply(e6);
          }
          get projectionMatrix() {
            return this._projectionMatrix;
          }
          get modelViewProjectionMatrix() {
            return this._globeViewProjMatrixNoCorrection;
          }
          get inverseProjectionMatrix() {
            return this._globeProjMatrixInverted;
          }
          get cameraPosition() {
            const e6 = t4.bi();
            return e6[0] = this._cameraPosition[0], e6[1] = this._cameraPosition[1], e6[2] = this._cameraPosition[2], e6;
          }
          get cameraToCenterDistance() {
            return this._helper.cameraToCenterDistance;
          }
          getProjectionData(e6) {
            const { overscaledTileID: t5, applyGlobeMatrix: i6 } = e6, r8 = this._helper.getMercatorTileCoordinates(t5);
            return { mainMatrix: this._globeViewProjMatrix32f, tileMercatorCoords: r8, clippingPlane: this._cachedClippingPlane, projectionTransition: i6 ? 1 : 0, fallbackMatrix: this._globeViewProjMatrix32f };
          }
          _computeClippingPlane(e6) {
            const i6 = this.pitchInRadians, r8 = this.cameraToCenterDistance / e6, o6 = Math.sin(i6) * r8, a4 = Math.cos(i6) * r8 + 1, s4 = 1 / Math.sqrt(o6 * o6 + a4 * a4) * 1;
            let n6 = -o6, l5 = a4;
            const c5 = Math.sqrt(n6 * n6 + l5 * l5);
            n6 /= c5, l5 /= c5;
            const h4 = [0, n6, l5];
            return t4.bj(h4, h4, [0, 0, 0], -this.bearingInRadians), t4.bk(h4, h4, [0, 0, 0], -1 * this.center.lat * Math.PI / 180), t4.bl(h4, h4, [0, 0, 0], this.center.lng * Math.PI / 180), t4.aO(h4, h4, 0.25), [...h4, 0.25 * -s4];
          }
          isLocationOccluded(e6) {
            return !this.isSurfacePointVisible(Jt(e6));
          }
          transformLightDirection(e6) {
            const i6 = this._helper._center.lng * Math.PI / 180, r8 = this._helper._center.lat * Math.PI / 180, o6 = Math.cos(r8), a4 = [Math.sin(i6) * o6, Math.sin(r8), Math.cos(i6) * o6], s4 = [a4[2], 0, -a4[0]], n6 = [0, 0, 0];
            t4.aU(n6, s4, a4), t4.aT(s4, s4), t4.aT(n6, n6);
            const l5 = [0, 0, 0];
            return t4.aT(l5, [s4[0] * e6[0] + n6[0] * e6[1] + a4[0] * e6[2], s4[1] * e6[0] + n6[1] * e6[1] + a4[1] * e6[2], s4[2] * e6[0] + n6[2] * e6[1] + a4[2] * e6[2]]), l5;
          }
          getPixelScale() {
            return 1 / Math.cos(this._helper._center.lat * Math.PI / 180);
          }
          getCircleRadiusCorrection() {
            return Math.cos(this._helper._center.lat * Math.PI / 180);
          }
          getPitchedTextCorrection(e6, i6, r8) {
            const o6 = function(e7, i7, r9) {
              const o7 = 1 / (1 << r9.z);
              return new t4.$(e7 / t4.Z * o7 + r9.x * o7, i7 / t4.Z * o7 + r9.y * o7);
            }(e6, i6, r8.canonical), a4 = (s4 = o6.y, [t4.bg(o6.x * Math.PI * 2 + Math.PI, 2 * Math.PI), 2 * Math.atan(Math.exp(Math.PI - s4 * Math.PI * 2)) - 0.5 * Math.PI]);
            var s4;
            return this.getCircleRadiusCorrection() / Math.cos(a4[1]);
          }
          projectTileCoordinates(e6, i6, r8, o6) {
            const a4 = r8.canonical, s4 = Yt(e6, i6, a4.x, a4.y, a4.z), n6 = 1 + (o6 ? o6(e6, i6) : 0) / t4.br, l5 = [s4[0] * n6, s4[1] * n6, s4[2] * n6, 1];
            t4.ap(l5, l5, this._globeViewProjMatrixNoCorrection);
            const c5 = this._cachedClippingPlane, h4 = c5[0] * s4[0] + c5[1] * s4[1] + c5[2] * s4[2] + c5[3] < 0;
            return { point: new t4.P(l5[0] / l5[3], l5[1] / l5[3]), signedDistanceFromCamera: l5[3], isOccluded: h4 };
          }
          _calcMatrices() {
            if (!this._helper._width || !this._helper._height) return;
            const e6 = ei(this.worldSize, this.center.lat), i6 = t4.b2(), r8 = t4.b2();
            this._helper.autoCalculateNearFarZ && (this._helper._nearZ = 0.5, this._helper._farZ = this.cameraToCenterDistance + 2 * e6), t4.aY(i6, this.fovInRadians, this.width / this.height, this._helper._nearZ, this._helper._farZ);
            const o6 = this.centerOffset;
            i6[8] = 2 * -o6.x / this._helper._width, i6[9] = 2 * o6.y / this._helper._height, this._projectionMatrix = t4.aZ(i6), this._globeProjMatrixInverted = t4.b2(), t4.aj(this._globeProjMatrixInverted, i6), t4.L(i6, i6, [0, 0, -this.cameraToCenterDistance]), t4.a_(i6, i6, this.rollInRadians), t4.a$(i6, i6, -this.pitchInRadians), t4.a_(i6, i6, this.bearingInRadians), t4.L(i6, i6, [0, 0, -e6]);
            const a4 = t4.bi();
            a4[0] = e6, a4[1] = e6, a4[2] = e6, t4.a$(r8, i6, this.center.lat * Math.PI / 180), t4.bm(r8, r8, -this.center.lng * Math.PI / 180), t4.M(r8, r8, a4), this._globeViewProjMatrixNoCorrection = r8, t4.a$(i6, i6, this.center.lat * Math.PI / 180 - this._globeLatitudeErrorCorrectionRadians), t4.bm(i6, i6, -this.center.lng * Math.PI / 180), t4.M(i6, i6, a4), this._globeViewProjMatrix32f = new Float32Array(i6), this._globeViewProjMatrixNoCorrectionInverted = t4.b2(), t4.aj(this._globeViewProjMatrixNoCorrectionInverted, r8);
            const s4 = t4.bi();
            this._cameraPosition = t4.bi(), this._cameraPosition[2] = this.cameraToCenterDistance / e6, t4.bj(this._cameraPosition, this._cameraPosition, s4, -this.rollInRadians), t4.bk(this._cameraPosition, this._cameraPosition, s4, this.pitchInRadians), t4.bj(this._cameraPosition, this._cameraPosition, s4, -this.bearingInRadians), t4.aP(this._cameraPosition, this._cameraPosition, [0, 0, 1]), t4.bk(this._cameraPosition, this._cameraPosition, s4, -this.center.lat * Math.PI / 180), t4.bl(this._cameraPosition, this._cameraPosition, s4, this.center.lng * Math.PI / 180), this._cachedClippingPlane = this._computeClippingPlane(e6);
            const n6 = t4.aZ(this._globeViewProjMatrixNoCorrectionInverted);
            t4.M(n6, n6, [1, 1, -1]), this._cachedFrustum = Rt.fromInvProjectionMatrix(n6);
          }
          calculateFogMatrix(e6) {
            t4.w("calculateFogMatrix is not supported on globe projection.");
            const i6 = t4.b2();
            return t4.at(i6), i6;
          }
          getVisibleUnwrappedCoordinates(e6) {
            return [new t4.aW(0, e6)];
          }
          getCameraFrustum() {
            return this._cachedFrustum;
          }
          getClippingPlane() {
            return this._cachedClippingPlane;
          }
          getCoveringTilesDetailsProvider() {
            return this._coveringTilesDetailsProvider;
          }
          recalculateZoomAndCenter(e6) {
            e6 && t4.w("terrain is not fully supported on vertical perspective projection."), this._helper.recalculateZoomAndCenter(0);
          }
          maxPitchScaleFactor() {
            return 1;
          }
          getCameraPoint() {
            return this._helper.getCameraPoint();
          }
          getCameraAltitude() {
            return this._helper.getCameraAltitude();
          }
          getCameraLngLat() {
            return this._helper.getCameraLngLat();
          }
          lngLatToCameraDepth(e6, i6) {
            if (!this._globeViewProjMatrixNoCorrection) return 1;
            const r8 = Jt(e6);
            t4.aO(r8, r8, 1 + i6 / t4.br);
            const o6 = t4.bh();
            return t4.ap(o6, [r8[0], r8[1], r8[2], 1], this._globeViewProjMatrixNoCorrection), o6[2] / o6[3];
          }
          populateCache(e6) {
          }
          getBounds() {
            const e6 = 0.5 * this.width, i6 = 0.5 * this.height, r8 = [new t4.P(0, 0), new t4.P(e6, 0), new t4.P(this.width, 0), new t4.P(this.width, i6), new t4.P(this.width, this.height), new t4.P(e6, this.height), new t4.P(0, this.height), new t4.P(0, i6)], o6 = [];
            for (const e7 of r8) o6.push(this.unprojectScreenPoint(e7));
            let a4 = 0, s4 = 0, n6 = 0, l5 = 0;
            const c5 = this.center;
            for (const e7 of o6) {
              const i7 = t4.bn(c5.lng, e7.lng), r9 = t4.bn(c5.lat, e7.lat);
              i7 < s4 && (s4 = i7), i7 > a4 && (a4 = i7), r9 < l5 && (l5 = r9), r9 > n6 && (n6 = r9);
            }
            const h4 = [c5.lng + s4, c5.lat + l5, c5.lng + a4, c5.lat + n6];
            return this.isSurfacePointOnScreen([0, 1, 0]) && (h4[3] = 90, h4[0] = -180, h4[2] = 180), this.isSurfacePointOnScreen([0, -1, 0]) && (h4[1] = -90, h4[0] = -180, h4[2] = 180), new V2(h4);
          }
          getConstrained(e6, i6) {
            const r8 = t4.ae(e6.lat, -85.051129, t4.aJ), o6 = t4.ae(+i6, this.minZoom + ri(0, r8), this.maxZoom);
            return { center: new t4.Q(e6.lng, r8), zoom: o6 };
          }
          calculateCenterFromCameraLngLatAlt(e6, t5, i6, r8) {
            return this._helper.calculateCenterFromCameraLngLatAlt(e6, t5, i6, r8);
          }
          setLocationAtPoint(e6, i6) {
            const r8 = Jt(this.unprojectScreenPoint(i6)), o6 = Jt(e6), a4 = t4.bi();
            t4.bo(a4);
            const s4 = t4.bi();
            t4.bl(s4, r8, a4, -this.center.lng * Math.PI / 180), t4.bk(s4, s4, a4, this.center.lat * Math.PI / 180);
            const n6 = o6[0] * o6[0] + o6[2] * o6[2], l5 = s4[0] * s4[0];
            if (n6 < l5) return;
            const c5 = Math.sqrt(n6 - l5), h4 = -c5, u4 = t4.bp(o6[0], o6[2], s4[0], c5), d4 = t4.bp(o6[0], o6[2], s4[0], h4), _4 = t4.bi();
            t4.bl(_4, o6, a4, -u4);
            const p4 = t4.bp(_4[1], _4[2], s4[1], s4[2]), m4 = t4.bi();
            t4.bl(m4, o6, a4, -d4);
            const f4 = t4.bp(m4[1], m4[2], s4[1], s4[2]), g4 = 0.5 * Math.PI, v4 = p4 >= -g4 && p4 <= g4, x4 = f4 >= -g4 && f4 <= g4;
            let b5, y4;
            if (v4 && x4) {
              const e7 = this.center.lng * Math.PI / 180, i7 = this.center.lat * Math.PI / 180;
              t4.bs(u4, e7) + t4.bs(p4, i7) < t4.bs(d4, e7) + t4.bs(f4, i7) ? (b5 = u4, y4 = p4) : (b5 = d4, y4 = f4);
            } else if (v4) b5 = u4, y4 = p4;
            else {
              if (!x4) return;
              b5 = d4, y4 = f4;
            }
            const w4 = b5 / Math.PI * 180, T5 = y4 / Math.PI * 180, P4 = this.center.lat;
            this.setCenter(new t4.Q(w4, t4.ae(T5, -90, 90))), this.setZoom(this.zoom + ri(P4, this.center.lat));
          }
          locationToScreenPoint(e6, i6) {
            const r8 = Jt(e6);
            if (i6) {
              const o6 = i6.getElevationForLngLatZoom(e6, this._helper._tileZoom);
              t4.aO(r8, r8, 1 + o6 / t4.br);
            }
            return this._projectSurfacePointToScreen(r8);
          }
          _projectSurfacePointToScreen(e6) {
            const i6 = t4.bh();
            return t4.ap(i6, [...e6, 1], this._globeViewProjMatrixNoCorrection), i6[0] /= i6[3], i6[1] /= i6[3], new t4.P((0.5 * i6[0] + 0.5) * this.width, (0.5 * -i6[1] + 0.5) * this.height);
          }
          screenPointToMercatorCoordinate(e6, i6) {
            if (i6) {
              const t5 = i6.pointCoordinate(e6);
              if (t5) return t5;
            }
            return t4.$.fromLngLat(this.unprojectScreenPoint(e6));
          }
          screenPointToLocation(e6, t5) {
            var i6;
            return null === (i6 = this.screenPointToMercatorCoordinate(e6, t5)) || void 0 === i6 ? void 0 : i6.toLngLat();
          }
          isPointOnMapSurface(e6, t5) {
            const i6 = this._cameraPosition, r8 = this.getRayDirectionFromPixel(e6);
            return !!this.rayPlanetIntersection(i6, r8);
          }
          getRayDirectionFromPixel(e6) {
            const i6 = t4.bh();
            i6[0] = e6.x / this.width * 2 - 1, i6[1] = -1 * (e6.y / this.height * 2 - 1), i6[2] = 1, i6[3] = 1, t4.ap(i6, i6, this._globeViewProjMatrixNoCorrectionInverted), i6[0] /= i6[3], i6[1] /= i6[3], i6[2] /= i6[3];
            const r8 = t4.bi();
            r8[0] = i6[0] - this._cameraPosition[0], r8[1] = i6[1] - this._cameraPosition[1], r8[2] = i6[2] - this._cameraPosition[2];
            const o6 = t4.bi();
            return t4.aT(o6, r8), o6;
          }
          isSurfacePointVisible(e6) {
            const t5 = this._cachedClippingPlane;
            return t5[0] * e6[0] + t5[1] * e6[1] + t5[2] * e6[2] + t5[3] >= 0;
          }
          isSurfacePointOnScreen(e6) {
            if (!this.isSurfacePointVisible(e6)) return false;
            const i6 = t4.bh();
            return t4.ap(i6, [...e6, 1], this._globeViewProjMatrixNoCorrection), i6[0] /= i6[3], i6[1] /= i6[3], i6[2] /= i6[3], i6[0] > -1 && i6[0] < 1 && i6[1] > -1 && i6[1] < 1 && i6[2] > -1 && i6[2] < 1;
          }
          rayPlanetIntersection(e6, i6) {
            const r8 = t4.aV(e6, i6), o6 = t4.bi(), a4 = t4.bi();
            t4.aO(a4, i6, r8), t4.aS(o6, e6, a4);
            const s4 = 1 - t4.aV(o6, o6);
            if (s4 < 0) return null;
            const n6 = t4.aV(e6, e6) - 1, l5 = -r8 + (r8 < 0 ? 1 : -1) * Math.sqrt(s4), c5 = n6 / l5, h4 = l5;
            return { tMin: Math.min(c5, h4), tMax: Math.max(c5, h4) };
          }
          unprojectScreenPoint(e6) {
            const i6 = this._cameraPosition, r8 = this.getRayDirectionFromPixel(e6), o6 = this.rayPlanetIntersection(i6, r8);
            if (o6) {
              const e7 = t4.bi();
              t4.aP(e7, i6, [r8[0] * o6.tMin, r8[1] * o6.tMin, r8[2] * o6.tMin]);
              const a5 = t4.bi();
              return t4.aT(a5, e7), ti(a5);
            }
            const a4 = this._cachedClippingPlane[0] * r8[0] + this._cachedClippingPlane[1] * r8[1] + this._cachedClippingPlane[2] * r8[2], s4 = -t4.bq(this._cachedClippingPlane, i6) / a4, n6 = t4.bi();
            if (s4 > 0) t4.aP(n6, i6, [r8[0] * s4, r8[1] * s4, r8[2] * s4]);
            else {
              const e7 = t4.bi();
              t4.aP(e7, i6, [2 * r8[0], 2 * r8[1], 2 * r8[2]]);
              const o7 = t4.bq(this._cachedClippingPlane, e7);
              t4.aS(n6, e7, [this._cachedClippingPlane[0] * o7, this._cachedClippingPlane[1] * o7, this._cachedClippingPlane[2] * o7]);
            }
            const l5 = t4.bi();
            return t4.aT(l5, n6), ti(l5);
          }
          getMatrixForModel(e6, i6) {
            const r8 = t4.Q.convert(e6), o6 = 1 / t4.br, a4 = t4.b1();
            return t4.bm(a4, a4, r8.lng / 180 * Math.PI), t4.a$(a4, a4, -r8.lat / 180 * Math.PI), t4.L(a4, a4, [0, 0, 1 + i6 / t4.br]), t4.a$(a4, a4, 0.5 * Math.PI), t4.M(a4, a4, [o6, o6, o6]), a4;
          }
          getProjectionDataForCustomLayer(e6 = true) {
            const i6 = this.getProjectionData({ overscaledTileID: new t4.Y(0, 0, 0, 0, 0), applyGlobeMatrix: e6 });
            return i6.tileMercatorCoords = [0, 0, 1, 1], i6;
          }
          getFastPathSimpleProjectionMatrix(e6) {
          }
        }
        class di {
          get pixelsToClipSpaceMatrix() {
            return this._helper.pixelsToClipSpaceMatrix;
          }
          get clipSpaceToPixelsMatrix() {
            return this._helper.clipSpaceToPixelsMatrix;
          }
          get pixelsToGLUnits() {
            return this._helper.pixelsToGLUnits;
          }
          get centerOffset() {
            return this._helper.centerOffset;
          }
          get size() {
            return this._helper.size;
          }
          get rotationMatrix() {
            return this._helper.rotationMatrix;
          }
          get centerPoint() {
            return this._helper.centerPoint;
          }
          get pixelsPerMeter() {
            return this._helper.pixelsPerMeter;
          }
          setMinZoom(e6) {
            this._helper.setMinZoom(e6);
          }
          setMaxZoom(e6) {
            this._helper.setMaxZoom(e6);
          }
          setMinPitch(e6) {
            this._helper.setMinPitch(e6);
          }
          setMaxPitch(e6) {
            this._helper.setMaxPitch(e6);
          }
          setRenderWorldCopies(e6) {
            this._helper.setRenderWorldCopies(e6);
          }
          setBearing(e6) {
            this._helper.setBearing(e6);
          }
          setPitch(e6) {
            this._helper.setPitch(e6);
          }
          setRoll(e6) {
            this._helper.setRoll(e6);
          }
          setFov(e6) {
            this._helper.setFov(e6);
          }
          setZoom(e6) {
            this._helper.setZoom(e6);
          }
          setCenter(e6) {
            this._helper.setCenter(e6);
          }
          setElevation(e6) {
            this._helper.setElevation(e6);
          }
          setMinElevationForCurrentTile(e6) {
            this._helper.setMinElevationForCurrentTile(e6);
          }
          setPadding(e6) {
            this._helper.setPadding(e6);
          }
          interpolatePadding(e6, t5, i6) {
            return this._helper.interpolatePadding(e6, t5, i6);
          }
          isPaddingEqual(e6) {
            return this._helper.isPaddingEqual(e6);
          }
          resize(e6, t5, i6 = true) {
            this._helper.resize(e6, t5, i6);
          }
          getMaxBounds() {
            return this._helper.getMaxBounds();
          }
          setMaxBounds(e6) {
            this._helper.setMaxBounds(e6);
          }
          overrideNearFarZ(e6, t5) {
            this._helper.overrideNearFarZ(e6, t5);
          }
          clearNearFarZOverride() {
            this._helper.clearNearFarZOverride();
          }
          getCameraQueryGeometry(e6) {
            return this._helper.getCameraQueryGeometry(this.getCameraPoint(), e6);
          }
          get tileSize() {
            return this._helper.tileSize;
          }
          get tileZoom() {
            return this._helper.tileZoom;
          }
          get scale() {
            return this._helper.scale;
          }
          get worldSize() {
            return this._helper.worldSize;
          }
          get width() {
            return this._helper.width;
          }
          get height() {
            return this._helper.height;
          }
          get lngRange() {
            return this._helper.lngRange;
          }
          get latRange() {
            return this._helper.latRange;
          }
          get minZoom() {
            return this._helper.minZoom;
          }
          get maxZoom() {
            return this._helper.maxZoom;
          }
          get zoom() {
            return this._helper.zoom;
          }
          get center() {
            return this._helper.center;
          }
          get minPitch() {
            return this._helper.minPitch;
          }
          get maxPitch() {
            return this._helper.maxPitch;
          }
          get pitch() {
            return this._helper.pitch;
          }
          get pitchInRadians() {
            return this._helper.pitchInRadians;
          }
          get roll() {
            return this._helper.roll;
          }
          get rollInRadians() {
            return this._helper.rollInRadians;
          }
          get bearing() {
            return this._helper.bearing;
          }
          get bearingInRadians() {
            return this._helper.bearingInRadians;
          }
          get fov() {
            return this._helper.fov;
          }
          get fovInRadians() {
            return this._helper.fovInRadians;
          }
          get elevation() {
            return this._helper.elevation;
          }
          get minElevationForCurrentTile() {
            return this._helper.minElevationForCurrentTile;
          }
          get padding() {
            return this._helper.padding;
          }
          get unmodified() {
            return this._helper.unmodified;
          }
          get renderWorldCopies() {
            return this._helper.renderWorldCopies;
          }
          get cameraToCenterDistance() {
            return this._helper.cameraToCenterDistance;
          }
          get nearZ() {
            return this._helper.nearZ;
          }
          get farZ() {
            return this._helper.farZ;
          }
          get autoCalculateNearFarZ() {
            return this._helper.autoCalculateNearFarZ;
          }
          get isGlobeRendering() {
            return this._globeness > 0;
          }
          setTransitionState(e6, t5) {
            this._globeness = e6, this._globeLatitudeErrorCorrectionRadians = t5, this._calcMatrices(), this._verticalPerspectiveTransform.getCoveringTilesDetailsProvider().recalculateCache(), this._mercatorTransform.getCoveringTilesDetailsProvider().recalculateCache();
          }
          get currentTransform() {
            return this.isGlobeRendering ? this._verticalPerspectiveTransform : this._mercatorTransform;
          }
          constructor() {
            this._globeLatitudeErrorCorrectionRadians = 0, this._globeness = 1, this._helper = new Mt({ calcMatrices: () => {
              this._calcMatrices();
            }, getConstrained: (e6, t5) => this.getConstrained(e6, t5) }), this._globeness = 1, this._mercatorTransform = new Dt(), this._verticalPerspectiveTransform = new ui();
          }
          clone() {
            const e6 = new di();
            return e6._globeness = this._globeness, e6._globeLatitudeErrorCorrectionRadians = this._globeLatitudeErrorCorrectionRadians, e6.apply(this), e6;
          }
          apply(e6) {
            this._helper.apply(e6), this._mercatorTransform.apply(this), this._verticalPerspectiveTransform.apply(this, this._globeLatitudeErrorCorrectionRadians);
          }
          get projectionMatrix() {
            return this.currentTransform.projectionMatrix;
          }
          get modelViewProjectionMatrix() {
            return this.currentTransform.modelViewProjectionMatrix;
          }
          get inverseProjectionMatrix() {
            return this.currentTransform.inverseProjectionMatrix;
          }
          get cameraPosition() {
            return this.currentTransform.cameraPosition;
          }
          getProjectionData(e6) {
            const t5 = this._mercatorTransform.getProjectionData(e6), i6 = this._verticalPerspectiveTransform.getProjectionData(e6);
            return { mainMatrix: this.isGlobeRendering ? i6.mainMatrix : t5.mainMatrix, clippingPlane: i6.clippingPlane, tileMercatorCoords: i6.tileMercatorCoords, projectionTransition: e6.applyGlobeMatrix ? this._globeness : 0, fallbackMatrix: t5.fallbackMatrix };
          }
          isLocationOccluded(e6) {
            return this.currentTransform.isLocationOccluded(e6);
          }
          transformLightDirection(e6) {
            return this.currentTransform.transformLightDirection(e6);
          }
          getPixelScale() {
            return t4.bc(this._mercatorTransform.getPixelScale(), this._verticalPerspectiveTransform.getPixelScale(), this._globeness);
          }
          getCircleRadiusCorrection() {
            return t4.bc(this._mercatorTransform.getCircleRadiusCorrection(), this._verticalPerspectiveTransform.getCircleRadiusCorrection(), this._globeness);
          }
          getPitchedTextCorrection(e6, i6, r8) {
            const o6 = this._mercatorTransform.getPitchedTextCorrection(e6, i6, r8), a4 = this._verticalPerspectiveTransform.getPitchedTextCorrection(e6, i6, r8);
            return t4.bc(o6, a4, this._globeness);
          }
          projectTileCoordinates(e6, t5, i6, r8) {
            return this.currentTransform.projectTileCoordinates(e6, t5, i6, r8);
          }
          _calcMatrices() {
            this._helper._width && this._helper._height && (this._verticalPerspectiveTransform.apply(this, this._globeLatitudeErrorCorrectionRadians), this._helper._nearZ = this._verticalPerspectiveTransform.nearZ, this._helper._farZ = this._verticalPerspectiveTransform.farZ, this._mercatorTransform.apply(this, true, this.isGlobeRendering), this._helper._nearZ = this._mercatorTransform.nearZ, this._helper._farZ = this._mercatorTransform.farZ);
          }
          calculateFogMatrix(e6) {
            return this.currentTransform.calculateFogMatrix(e6);
          }
          getVisibleUnwrappedCoordinates(e6) {
            return this.currentTransform.getVisibleUnwrappedCoordinates(e6);
          }
          getCameraFrustum() {
            return this.currentTransform.getCameraFrustum();
          }
          getClippingPlane() {
            return this.currentTransform.getClippingPlane();
          }
          getCoveringTilesDetailsProvider() {
            return this.currentTransform.getCoveringTilesDetailsProvider();
          }
          recalculateZoomAndCenter(e6) {
            this._mercatorTransform.recalculateZoomAndCenter(e6), this._verticalPerspectiveTransform.recalculateZoomAndCenter(e6);
          }
          maxPitchScaleFactor() {
            return this._mercatorTransform.maxPitchScaleFactor();
          }
          getCameraPoint() {
            return this._helper.getCameraPoint();
          }
          getCameraAltitude() {
            return this._helper.getCameraAltitude();
          }
          getCameraLngLat() {
            return this._helper.getCameraLngLat();
          }
          lngLatToCameraDepth(e6, t5) {
            return this.currentTransform.lngLatToCameraDepth(e6, t5);
          }
          populateCache(e6) {
            this._mercatorTransform.populateCache(e6), this._verticalPerspectiveTransform.populateCache(e6);
          }
          getBounds() {
            return this.currentTransform.getBounds();
          }
          getConstrained(e6, t5) {
            return this.currentTransform.getConstrained(e6, t5);
          }
          calculateCenterFromCameraLngLatAlt(e6, t5, i6, r8) {
            return this._helper.calculateCenterFromCameraLngLatAlt(e6, t5, i6, r8);
          }
          setLocationAtPoint(e6, t5) {
            if (!this.isGlobeRendering) return this._mercatorTransform.setLocationAtPoint(e6, t5), void this.apply(this._mercatorTransform);
            this._verticalPerspectiveTransform.setLocationAtPoint(e6, t5), this.apply(this._verticalPerspectiveTransform);
          }
          locationToScreenPoint(e6, t5) {
            return this.currentTransform.locationToScreenPoint(e6, t5);
          }
          screenPointToMercatorCoordinate(e6, t5) {
            return this.currentTransform.screenPointToMercatorCoordinate(e6, t5);
          }
          screenPointToLocation(e6, t5) {
            return this.currentTransform.screenPointToLocation(e6, t5);
          }
          isPointOnMapSurface(e6, t5) {
            return this.currentTransform.isPointOnMapSurface(e6, t5);
          }
          getRayDirectionFromPixel(e6) {
            return this._verticalPerspectiveTransform.getRayDirectionFromPixel(e6);
          }
          getMatrixForModel(e6, t5) {
            return this.currentTransform.getMatrixForModel(e6, t5);
          }
          getProjectionDataForCustomLayer(e6 = true) {
            const t5 = this._mercatorTransform.getProjectionDataForCustomLayer(e6);
            if (!this.isGlobeRendering) return t5;
            const i6 = this._verticalPerspectiveTransform.getProjectionDataForCustomLayer(e6);
            return i6.fallbackMatrix = t5.mainMatrix, i6;
          }
          getFastPathSimpleProjectionMatrix(e6) {
            return this.currentTransform.getFastPathSimpleProjectionMatrix(e6);
          }
        }
        class _i {
          get useGlobeControls() {
            return true;
          }
          handlePanInertia(e6, i6) {
            const r8 = oi(e6, i6);
            return Math.abs(r8.lng - i6.center.lng) > 180 && (r8.lng = i6.center.lng + 179.5 * Math.sign(r8.lng - i6.center.lng)), { easingCenter: r8, easingOffset: new t4.P(0, 0) };
          }
          handleMapControlsRollPitchBearingZoom(e6, i6) {
            const r8 = e6.around, o6 = i6.screenPointToLocation(r8);
            e6.bearingDelta && i6.setBearing(i6.bearing + e6.bearingDelta), e6.pitchDelta && i6.setPitch(i6.pitch + e6.pitchDelta), e6.rollDelta && i6.setRoll(i6.roll + e6.rollDelta);
            const a4 = i6.zoom;
            e6.zoomDelta && i6.setZoom(i6.zoom + e6.zoomDelta);
            const s4 = i6.zoom - a4;
            if (0 === s4) return;
            const n6 = t4.bn(i6.center.lng, o6.lng), l5 = n6 / (Math.abs(n6 / 180) + 1), c5 = t4.bn(i6.center.lat, o6.lat), h4 = i6.getRayDirectionFromPixel(r8), u4 = i6.cameraPosition, d4 = -1 * t4.aV(u4, h4), _4 = t4.bi();
            t4.aP(_4, u4, [h4[0] * d4, h4[1] * d4, h4[2] * d4]);
            const p4 = t4.bt(_4) - 1, m4 = Math.exp(0.5 * -Math.max(p4 - 0.3, 0)), f4 = ei(i6.worldSize, i6.center.lat) / Math.min(i6.width, i6.height), g4 = t4.bf(f4, 0.9, 0.5, 1, 0.25), v4 = (1 - t4.aI(-s4)) * Math.min(m4, g4), x4 = i6.center.lat, b5 = i6.zoom, y4 = new t4.Q(i6.center.lng + l5 * v4, t4.ae(i6.center.lat + c5 * v4, -85.051129, t4.aJ));
            i6.setLocationAtPoint(o6, r8);
            const w4 = i6.center, T5 = t4.bf(Math.abs(n6), 45, 85, 0, 1), P4 = t4.bf(f4, 0.75, 0.35, 0, 1), C4 = Math.pow(Math.max(T5, P4), 0.25), I4 = t4.bn(w4.lng, y4.lng), M5 = t4.bn(w4.lat, y4.lat);
            i6.setCenter(new t4.Q(w4.lng + I4 * C4, w4.lat + M5 * C4).wrap()), i6.setZoom(b5 + ri(x4, i6.center.lat));
          }
          handleMapControlsPan(e6, t5, i6) {
            if (!e6.panDelta) return;
            const r8 = t5.center.lat, o6 = t5.zoom;
            t5.setCenter(oi(e6.panDelta, t5).wrap()), t5.setZoom(o6 + ri(r8, t5.center.lat));
          }
          cameraForBoxAndBearing(e6, i6, r8, o6, a4) {
            const s4 = Lt(e6, i6, r8, o6, a4), n6 = i6.left / a4.width * 2 - 1, l5 = (a4.width - i6.right) / a4.width * 2 - 1, c5 = i6.top / a4.height * -2 + 1, h4 = (a4.height - i6.bottom) / a4.height * -2 + 1, u4 = t4.bn(r8.getWest(), r8.getEast()) < 0, d4 = u4 ? r8.getEast() : r8.getWest(), _4 = u4 ? r8.getWest() : r8.getEast(), p4 = Math.max(r8.getNorth(), r8.getSouth()), m4 = Math.min(r8.getNorth(), r8.getSouth()), f4 = d4 + 0.5 * t4.bn(d4, _4), g4 = p4 + 0.5 * t4.bn(p4, m4), v4 = a4.clone();
            v4.setCenter(s4.center), v4.setBearing(s4.bearing), v4.setPitch(0), v4.setRoll(0), v4.setZoom(s4.zoom);
            const x4 = v4.modelViewProjectionMatrix, b5 = [Jt(r8.getNorthWest()), Jt(r8.getNorthEast()), Jt(r8.getSouthWest()), Jt(r8.getSouthEast()), Jt(new t4.Q(_4, g4)), Jt(new t4.Q(d4, g4)), Jt(new t4.Q(f4, p4)), Jt(new t4.Q(f4, m4))], y4 = Jt(s4.center);
            let w4 = Number.POSITIVE_INFINITY;
            for (const e7 of b5) n6 < 0 && (w4 = _i.getLesserNonNegativeNonNull(w4, _i.solveVectorScale(e7, y4, x4, "x", n6))), l5 > 0 && (w4 = _i.getLesserNonNegativeNonNull(w4, _i.solveVectorScale(e7, y4, x4, "x", l5))), c5 > 0 && (w4 = _i.getLesserNonNegativeNonNull(w4, _i.solveVectorScale(e7, y4, x4, "y", c5))), h4 < 0 && (w4 = _i.getLesserNonNegativeNonNull(w4, _i.solveVectorScale(e7, y4, x4, "y", h4)));
            if (Number.isFinite(w4) && 0 !== w4) return s4.zoom = v4.zoom + t4.ab(w4), s4;
            zt();
          }
          handleJumpToCenterZoom(e6, i6) {
            const r8 = e6.center.lat, o6 = e6.getConstrained(i6.center ? t4.Q.convert(i6.center) : e6.center, e6.zoom).center;
            e6.setCenter(o6.wrap());
            const a4 = void 0 !== i6.zoom ? +i6.zoom : e6.zoom + ri(r8, o6.lat);
            e6.zoom !== a4 && e6.setZoom(a4);
          }
          handleEaseTo(e6, i6) {
            const r8 = e6.zoom, o6 = e6.center, a4 = e6.padding, s4 = { roll: e6.roll, pitch: e6.pitch, bearing: e6.bearing }, n6 = { roll: void 0 === i6.roll ? e6.roll : i6.roll, pitch: void 0 === i6.pitch ? e6.pitch : i6.pitch, bearing: void 0 === i6.bearing ? e6.bearing : i6.bearing }, l5 = void 0 !== i6.zoom, c5 = !e6.isPaddingEqual(i6.padding);
            let h4 = false;
            const u4 = i6.center ? t4.Q.convert(i6.center) : o6, d4 = e6.getConstrained(u4, r8).center;
            Ct(e6, d4);
            const _4 = e6.clone();
            _4.setCenter(d4), _4.setZoom(l5 ? +i6.zoom : r8 + ri(o6.lat, u4.lat)), _4.setBearing(i6.bearing);
            const p4 = new t4.P(t4.ae(e6.centerPoint.x + i6.offsetAsPoint.x, 0, e6.width), t4.ae(e6.centerPoint.y + i6.offsetAsPoint.y, 0, e6.height));
            _4.setLocationAtPoint(d4, p4);
            const m4 = (i6.offset && i6.offsetAsPoint.mag()) > 0 ? _4.center : d4, f4 = l5 ? +i6.zoom : r8 + ri(o6.lat, m4.lat), g4 = r8 + ri(o6.lat, 0), v4 = f4 + ri(m4.lat, 0), x4 = t4.bn(o6.lng, m4.lng), b5 = t4.bn(o6.lat, m4.lat), y4 = t4.aI(v4 - g4);
            return h4 = f4 !== r8, { easeFunc: (r9) => {
              if (t4.b6(s4, n6) || At({ startEulerAngles: s4, endEulerAngles: n6, tr: e6, k: r9, useSlerp: s4.roll != n6.roll }), c5 && e6.interpolatePadding(a4, i6.padding, r9), i6.around) t4.w("Easing around a point is not supported under globe projection."), e6.setLocationAtPoint(i6.around, i6.aroundPoint);
              else {
                const t5 = v4 > g4 ? Math.min(2, y4) : Math.max(0.5, y4), i7 = Math.pow(t5, 1 - r9), a5 = si(o6, x4, b5, r9 * i7);
                e6.setCenter(a5.wrap());
              }
              if (h4) {
                const i7 = t4.B.number(g4, v4, r9) + ri(0, e6.center.lat);
                e6.setZoom(i7);
              }
            }, isZooming: h4, elevationCenter: m4 };
          }
          handleFlyTo(e6, i6) {
            const r8 = void 0 !== i6.zoom, o6 = e6.center, a4 = e6.zoom, s4 = e6.padding, n6 = !e6.isPaddingEqual(i6.padding), l5 = e6.getConstrained(t4.Q.convert(i6.center || i6.locationAtOffset), a4).center, c5 = r8 ? +i6.zoom : e6.zoom + ri(e6.center.lat, l5.lat), h4 = e6.clone();
            h4.setCenter(l5), h4.setZoom(c5), h4.setBearing(i6.bearing);
            const u4 = new t4.P(t4.ae(e6.centerPoint.x + i6.offsetAsPoint.x, 0, e6.width), t4.ae(e6.centerPoint.y + i6.offsetAsPoint.y, 0, e6.height));
            h4.setLocationAtPoint(l5, u4);
            const d4 = h4.center;
            Ct(e6, d4);
            const _4 = function(e7, i7, r9) {
              const o7 = Jt(i7), a5 = Jt(r9), s5 = t4.aV(o7, a5), n7 = Math.acos(s5), l6 = Qt(e7);
              return n7 / (2 * Math.PI) * l6;
            }(e6, o6, d4), p4 = a4 + ri(o6.lat, 0), m4 = c5 + ri(d4.lat, 0), f4 = t4.aI(m4 - p4);
            let g4;
            if ("number" == typeof i6.minZoom) {
              const r9 = +i6.minZoom + ri(d4.lat, 0), o7 = Math.min(r9, p4, m4) + ri(0, d4.lat), a5 = e6.getConstrained(d4, o7).zoom + ri(d4.lat, 0);
              g4 = t4.aI(a5 - p4);
            }
            const v4 = t4.bn(o6.lng, d4.lng), x4 = t4.bn(o6.lat, d4.lat);
            return { easeFunc: (r9, a5, l6, h5) => {
              const u5 = si(o6, v4, x4, l6);
              n6 && e6.interpolatePadding(s4, i6.padding, r9);
              const _5 = 1 === r9 ? d4 : u5;
              e6.setCenter(_5.wrap());
              const m5 = p4 + t4.ab(a5);
              e6.setZoom(1 === r9 ? c5 : m5 + ri(0, _5.lat));
            }, scaleOfZoom: f4, targetCenter: d4, scaleOfMinZoom: g4, pixelPathLength: _4 };
          }
          static solveVectorScale(e6, t5, i6, r8, o6) {
            const a4 = "x" === r8 ? [i6[0], i6[4], i6[8], i6[12]] : [i6[1], i6[5], i6[9], i6[13]], s4 = [i6[3], i6[7], i6[11], i6[15]], n6 = e6[0] * a4[0] + e6[1] * a4[1] + e6[2] * a4[2], l5 = e6[0] * s4[0] + e6[1] * s4[1] + e6[2] * s4[2], c5 = t5[0] * a4[0] + t5[1] * a4[1] + t5[2] * a4[2], h4 = t5[0] * s4[0] + t5[1] * s4[1] + t5[2] * s4[2];
            return c5 + o6 * l5 === n6 + o6 * h4 || s4[3] * (n6 - c5) + a4[3] * (h4 - l5) + n6 * h4 == c5 * l5 ? null : (c5 + a4[3] - o6 * h4 - o6 * s4[3]) / (c5 - n6 - o6 * h4 + o6 * l5);
          }
          static getLesserNonNegativeNonNull(e6, t5) {
            return null !== t5 && t5 >= 0 && t5 < e6 ? t5 : e6;
          }
        }
        class pi {
          constructor(e6) {
            this._globe = e6, this._mercatorCameraHelper = new kt(), this._verticalPerspectiveCameraHelper = new _i();
          }
          get useGlobeControls() {
            return this._globe.useGlobeRendering;
          }
          get currentHelper() {
            return this.useGlobeControls ? this._verticalPerspectiveCameraHelper : this._mercatorCameraHelper;
          }
          handlePanInertia(e6, t5) {
            return this.currentHelper.handlePanInertia(e6, t5);
          }
          handleMapControlsRollPitchBearingZoom(e6, t5) {
            return this.currentHelper.handleMapControlsRollPitchBearingZoom(e6, t5);
          }
          handleMapControlsPan(e6, t5, i6) {
            this.currentHelper.handleMapControlsPan(e6, t5, i6);
          }
          cameraForBoxAndBearing(e6, t5, i6, r8, o6) {
            return this.currentHelper.cameraForBoxAndBearing(e6, t5, i6, r8, o6);
          }
          handleJumpToCenterZoom(e6, t5) {
            this.currentHelper.handleJumpToCenterZoom(e6, t5);
          }
          handleEaseTo(e6, t5) {
            return this.currentHelper.handleEaseTo(e6, t5);
          }
          handleFlyTo(e6, t5) {
            return this.currentHelper.handleFlyTo(e6, t5);
          }
        }
        const mi = (e6, i6) => t4.x(e6, i6 && i6.filter((e7) => "source.canvas" !== e7.identifier)), fi = t4.bu();
        class gi extends t4.E {
          constructor(e6, i6 = {}) {
            super(), this._rtlPluginLoaded = () => {
              for (const e7 in this.sourceCaches) {
                const t5 = this.sourceCaches[e7].getSource().type;
                "vector" !== t5 && "geojson" !== t5 || this.sourceCaches[e7].reload();
              }
            }, this.map = e6, this.dispatcher = new B4(F2(), e6._getMapId()), this.dispatcher.registerMessageHandler("GG", (e7, t5) => this.getGlyphs(e7, t5)), this.dispatcher.registerMessageHandler("GI", (e7, t5) => this.getImages(e7, t5)), this.imageManager = new b4(), this.imageManager.setEventedParent(this), this.glyphManager = new P3(e6._requestManager, i6.localIdeographFontFamily), this.lineAtlas = new R4(256, 512), this.crossTileSymbolIndex = new ht(), this._spritesImagesIds = {}, this._layers = {}, this._order = [], this.sourceCaches = {}, this.zoomHistory = new t4.bv(), this._loaded = false, this._availableImages = [], this._resetUpdates(), this.dispatcher.broadcast("SR", t4.bw()), oe().on(te, this._rtlPluginLoaded), this.on("data", (e7) => {
              if ("source" !== e7.dataType || "metadata" !== e7.sourceDataType) return;
              const t5 = this.sourceCaches[e7.sourceId];
              if (!t5) return;
              const i7 = t5.getSource();
              if (i7 && i7.vectorLayerIds) for (const e8 in this._layers) {
                const t6 = this._layers[e8];
                t6.source === i7.id && this._validateLayer(t6);
              }
            });
          }
          loadURL(e6, i6 = {}, r8) {
            this.fire(new t4.l("dataloading", { dataType: "style" })), i6.validate = "boolean" != typeof i6.validate || i6.validate;
            const o6 = this.map._requestManager.transformRequest(e6, "Style");
            this._loadStyleRequest = new AbortController();
            const a4 = this._loadStyleRequest;
            t4.j(o6, this._loadStyleRequest).then((e7) => {
              this._loadStyleRequest = null, this._load(e7.data, i6, r8);
            }).catch((e7) => {
              this._loadStyleRequest = null, e7 && !a4.signal.aborted && this.fire(new t4.k(e7));
            });
          }
          loadJSON(e6, i6 = {}, r8) {
            this.fire(new t4.l("dataloading", { dataType: "style" })), this._frameRequest = new AbortController(), s3.frameAsync(this._frameRequest).then(() => {
              this._frameRequest = null, i6.validate = false !== i6.validate, this._load(e6, i6, r8);
            }).catch(() => {
            });
          }
          loadEmpty() {
            this.fire(new t4.l("dataloading", { dataType: "style" })), this._load(fi, { validate: false });
          }
          _load(e6, i6, r8) {
            var o6, a4;
            const s4 = i6.transformStyle ? i6.transformStyle(r8, e6) : e6;
            if (!i6.validate || !mi(this, t4.y(s4))) {
              this._loaded = true, this.stylesheet = s4;
              for (const e7 in s4.sources) this.addSource(e7, s4.sources[e7], { validate: false });
              s4.sprite ? this._loadSprite(s4.sprite) : this.imageManager.setLoaded(true), this.glyphManager.setURL(s4.glyphs), this._createLayers(), this.light = new M4(this.stylesheet.light), this._setProjectionInternal((null === (o6 = this.stylesheet.projection) || void 0 === o6 ? void 0 : o6.type) || "mercator"), this.sky = new S4(this.stylesheet.sky), this.map.setTerrain(null !== (a4 = this.stylesheet.terrain) && void 0 !== a4 ? a4 : null), this.fire(new t4.l("data", { dataType: "style" })), this.fire(new t4.l("style.load"));
            }
          }
          _createLayers() {
            const e6 = t4.bx(this.stylesheet.layers);
            this.dispatcher.broadcast("SL", e6), this._order = e6.map((e7) => e7.id), this._layers = {}, this._serializedLayers = null;
            for (const i6 of e6) {
              const e7 = t4.by(i6);
              e7.setEventedParent(this, { layer: { id: i6.id } }), this._layers[i6.id] = e7;
            }
          }
          _loadSprite(e6, i6 = false, r8 = void 0) {
            let o6;
            this.imageManager.setLoaded(false), this._spriteRequest = new AbortController(), function(e7, i7, r9, o7) {
              return t4._(this, void 0, void 0, function* () {
                const a4 = f3(e7), n6 = r9 > 1 ? "@2x" : "", l5 = {}, c5 = {};
                for (const { id: e8, url: r10 } of a4) {
                  const a5 = i7.transformRequest(g3(r10, n6, ".json"), "SpriteJSON");
                  l5[e8] = t4.j(a5, o7);
                  const s4 = i7.transformRequest(g3(r10, n6, ".png"), "SpriteImage");
                  c5[e8] = p3.getImage(s4, o7);
                }
                return yield Promise.all([...Object.values(l5), ...Object.values(c5)]), function(e8, i8) {
                  return t4._(this, void 0, void 0, function* () {
                    const t5 = {};
                    for (const r10 in e8) {
                      t5[r10] = {};
                      const o8 = s3.getImageCanvasContext((yield i8[r10]).data), a5 = (yield e8[r10]).data;
                      for (const e9 in a5) {
                        const { width: i9, height: s4, x: n7, y: l6, sdf: c6, pixelRatio: h4, stretchX: u4, stretchY: d4, content: _4, textFitWidth: p4, textFitHeight: m4 } = a5[e9];
                        t5[r10][e9] = { data: null, pixelRatio: h4, sdf: c6, stretchX: u4, stretchY: d4, content: _4, textFitWidth: p4, textFitHeight: m4, spriteData: { width: i9, height: s4, x: n7, y: l6, context: o8 } };
                      }
                    }
                    return t5;
                  });
                }(l5, c5);
              });
            }(e6, this.map._requestManager, this.map.getPixelRatio(), this._spriteRequest).then((e7) => {
              if (this._spriteRequest = null, e7) for (const t5 in e7) {
                this._spritesImagesIds[t5] = [];
                const r9 = this._spritesImagesIds[t5] ? this._spritesImagesIds[t5].filter((t6) => !(t6 in e7)) : [];
                for (const e8 of r9) this.imageManager.removeImage(e8), this._changedImages[e8] = true;
                for (const r10 in e7[t5]) {
                  const o7 = "default" === t5 ? r10 : `${t5}:${r10}`;
                  this._spritesImagesIds[t5].push(o7), o7 in this.imageManager.images ? this.imageManager.updateImage(o7, e7[t5][r10], false) : this.imageManager.addImage(o7, e7[t5][r10]), i6 && (this._changedImages[o7] = true);
                }
              }
            }).catch((e7) => {
              this._spriteRequest = null, o6 = e7, this.fire(new t4.k(o6));
            }).finally(() => {
              this.imageManager.setLoaded(true), this._availableImages = this.imageManager.listImages(), i6 && (this._changed = true), this.dispatcher.broadcast("SI", this._availableImages), this.fire(new t4.l("data", { dataType: "style" })), r8 && r8(o6);
            });
          }
          _unloadSprite() {
            for (const e6 of Object.values(this._spritesImagesIds).flat()) this.imageManager.removeImage(e6), this._changedImages[e6] = true;
            this._spritesImagesIds = {}, this._availableImages = this.imageManager.listImages(), this._changed = true, this.dispatcher.broadcast("SI", this._availableImages), this.fire(new t4.l("data", { dataType: "style" }));
          }
          _validateLayer(e6) {
            const i6 = this.sourceCaches[e6.source];
            if (!i6) return;
            const r8 = e6.sourceLayer;
            if (!r8) return;
            const o6 = i6.getSource();
            ("geojson" === o6.type || o6.vectorLayerIds && -1 === o6.vectorLayerIds.indexOf(r8)) && this.fire(new t4.k(new Error(`Source layer "${r8}" does not exist on source "${o6.id}" as specified by style layer "${e6.id}".`)));
          }
          loaded() {
            if (!this._loaded) return false;
            if (Object.keys(this._updatedSources).length) return false;
            for (const e6 in this.sourceCaches) if (!this.sourceCaches[e6].loaded()) return false;
            return !!this.imageManager.isLoaded();
          }
          _serializeByIds(e6, i6 = false) {
            const r8 = this._serializedAllLayers();
            if (!e6 || 0 === e6.length) return Object.values(i6 ? t4.bz(r8) : r8);
            const o6 = [];
            for (const a4 of e6) if (r8[a4]) {
              const e7 = i6 ? t4.bz(r8[a4]) : r8[a4];
              o6.push(e7);
            }
            return o6;
          }
          _serializedAllLayers() {
            let e6 = this._serializedLayers;
            if (e6) return e6;
            e6 = this._serializedLayers = {};
            const t5 = Object.keys(this._layers);
            for (const i6 of t5) {
              const t6 = this._layers[i6];
              "custom" !== t6.type && (e6[i6] = t6.serialize());
            }
            return e6;
          }
          hasTransitions() {
            var e6, t5, i6;
            if (null === (e6 = this.light) || void 0 === e6 ? void 0 : e6.hasTransition()) return true;
            if (null === (t5 = this.sky) || void 0 === t5 ? void 0 : t5.hasTransition()) return true;
            if (null === (i6 = this.projection) || void 0 === i6 ? void 0 : i6.hasTransition()) return true;
            for (const e7 in this.sourceCaches) if (this.sourceCaches[e7].hasTransition()) return true;
            for (const e7 in this._layers) if (this._layers[e7].hasTransition()) return true;
            return false;
          }
          _checkLoaded() {
            if (!this._loaded) throw new Error("Style is not done loading.");
          }
          update(e6) {
            if (!this._loaded) return;
            const i6 = this._changed;
            if (i6) {
              const t5 = Object.keys(this._updatedLayers), i7 = Object.keys(this._removedLayers);
              (t5.length || i7.length) && this._updateWorkerLayers(t5, i7);
              for (const e7 in this._updatedSources) {
                const t6 = this._updatedSources[e7];
                if ("reload" === t6) this._reloadSource(e7);
                else {
                  if ("clear" !== t6) throw new Error(`Invalid action ${t6}`);
                  this._clearSource(e7);
                }
              }
              this._updateTilesForChangedImages(), this._updateTilesForChangedGlyphs();
              for (const t6 in this._updatedPaintProps) this._layers[t6].updateTransitions(e6);
              this.light.updateTransitions(e6), this.sky.updateTransitions(e6), this._resetUpdates();
            }
            const r8 = {};
            for (const e7 in this.sourceCaches) {
              const t5 = this.sourceCaches[e7];
              r8[e7] = t5.used, t5.used = false;
            }
            for (const t5 of this._order) {
              const i7 = this._layers[t5];
              i7.recalculate(e6, this._availableImages), !i7.isHidden(e6.zoom) && i7.source && (this.sourceCaches[i7.source].used = true);
            }
            for (const e7 in r8) {
              const i7 = this.sourceCaches[e7];
              !!r8[e7] != !!i7.used && i7.fire(new t4.l("data", { sourceDataType: "visibility", dataType: "source", sourceId: e7 }));
            }
            this.light.recalculate(e6), this.sky.recalculate(e6), this.projection.recalculate(e6), this.z = e6.zoom, i6 && this.fire(new t4.l("data", { dataType: "style" }));
          }
          _updateTilesForChangedImages() {
            const e6 = Object.keys(this._changedImages);
            if (e6.length) {
              for (const t5 in this.sourceCaches) this.sourceCaches[t5].reloadTilesForDependencies(["icons", "patterns"], e6);
              this._changedImages = {};
            }
          }
          _updateTilesForChangedGlyphs() {
            if (this._glyphsDidChange) {
              for (const e6 in this.sourceCaches) this.sourceCaches[e6].reloadTilesForDependencies(["glyphs"], [""]);
              this._glyphsDidChange = false;
            }
          }
          _updateWorkerLayers(e6, t5) {
            this.dispatcher.broadcast("UL", { layers: this._serializeByIds(e6, false), removedIds: t5 });
          }
          _resetUpdates() {
            this._changed = false, this._updatedLayers = {}, this._removedLayers = {}, this._updatedSources = {}, this._updatedPaintProps = {}, this._changedImages = {}, this._glyphsDidChange = false;
          }
          setState(e6, i6 = {}) {
            var r8;
            this._checkLoaded();
            const o6 = this.serialize();
            if (e6 = i6.transformStyle ? i6.transformStyle(o6, e6) : e6, (null === (r8 = i6.validate) || void 0 === r8 || r8) && mi(this, t4.y(e6))) return false;
            (e6 = t4.bz(e6)).layers = t4.bx(e6.layers);
            const a4 = t4.bA(o6, e6), s4 = this._getOperationsToPerform(a4);
            if (s4.unimplemented.length > 0) throw new Error(`Unimplemented: ${s4.unimplemented.join(", ")}.`);
            if (0 === s4.operations.length) return false;
            for (const e7 of s4.operations) e7();
            return this.stylesheet = e6, this._serializedLayers = null, true;
          }
          _getOperationsToPerform(e6) {
            const t5 = [], i6 = [];
            for (const r8 of e6) switch (r8.command) {
              case "setCenter":
              case "setZoom":
              case "setBearing":
              case "setPitch":
              case "setRoll":
                continue;
              case "addLayer":
                t5.push(() => this.addLayer.apply(this, r8.args));
                break;
              case "removeLayer":
                t5.push(() => this.removeLayer.apply(this, r8.args));
                break;
              case "setPaintProperty":
                t5.push(() => this.setPaintProperty.apply(this, r8.args));
                break;
              case "setLayoutProperty":
                t5.push(() => this.setLayoutProperty.apply(this, r8.args));
                break;
              case "setFilter":
                t5.push(() => this.setFilter.apply(this, r8.args));
                break;
              case "addSource":
                t5.push(() => this.addSource.apply(this, r8.args));
                break;
              case "removeSource":
                t5.push(() => this.removeSource.apply(this, r8.args));
                break;
              case "setLayerZoomRange":
                t5.push(() => this.setLayerZoomRange.apply(this, r8.args));
                break;
              case "setLight":
                t5.push(() => this.setLight.apply(this, r8.args));
                break;
              case "setGeoJSONSourceData":
                t5.push(() => this.setGeoJSONSourceData.apply(this, r8.args));
                break;
              case "setGlyphs":
                t5.push(() => this.setGlyphs.apply(this, r8.args));
                break;
              case "setSprite":
                t5.push(() => this.setSprite.apply(this, r8.args));
                break;
              case "setTerrain":
                t5.push(() => this.map.setTerrain.apply(this, r8.args));
                break;
              case "setSky":
                t5.push(() => this.setSky.apply(this, r8.args));
                break;
              case "setProjection":
                this.setProjection.apply(this, r8.args);
                break;
              case "setTransition":
                t5.push(() => {
                });
                break;
              default:
                i6.push(r8.command);
            }
            return { operations: t5, unimplemented: i6 };
          }
          addImage(e6, i6) {
            if (this.getImage(e6)) return this.fire(new t4.k(new Error(`An image named "${e6}" already exists.`)));
            this.imageManager.addImage(e6, i6), this._afterImageUpdated(e6);
          }
          updateImage(e6, t5) {
            this.imageManager.updateImage(e6, t5);
          }
          getImage(e6) {
            return this.imageManager.getImage(e6);
          }
          removeImage(e6) {
            if (!this.getImage(e6)) return this.fire(new t4.k(new Error(`An image named "${e6}" does not exist.`)));
            this.imageManager.removeImage(e6), this._afterImageUpdated(e6);
          }
          _afterImageUpdated(e6) {
            this._availableImages = this.imageManager.listImages(), this._changedImages[e6] = true, this._changed = true, this.dispatcher.broadcast("SI", this._availableImages), this.fire(new t4.l("data", { dataType: "style" }));
          }
          listImages() {
            return this._checkLoaded(), this.imageManager.listImages();
          }
          addSource(e6, i6, r8 = {}) {
            if (this._checkLoaded(), void 0 !== this.sourceCaches[e6]) throw new Error(`Source "${e6}" already exists.`);
            if (!i6.type) throw new Error(`The type property must be defined, but only the following properties were given: ${Object.keys(i6).join(", ")}.`);
            if (["vector", "raster", "geojson", "video", "image"].indexOf(i6.type) >= 0 && this._validate(t4.y.source, `sources.${e6}`, i6, null, r8)) return;
            this.map && this.map._collectResourceTiming && (i6.collectResourceTiming = true);
            const o6 = this.sourceCaches[e6] = new de(e6, i6, this.dispatcher);
            o6.style = this, o6.setEventedParent(this, () => ({ isSourceLoaded: o6.loaded(), source: o6.serialize(), sourceId: e6 })), o6.onAdd(this.map), this._changed = true;
          }
          removeSource(e6) {
            if (this._checkLoaded(), void 0 === this.sourceCaches[e6]) throw new Error("There is no source with this ID");
            for (const i7 in this._layers) if (this._layers[i7].source === e6) return this.fire(new t4.k(new Error(`Source "${e6}" cannot be removed while layer "${i7}" is using it.`)));
            const i6 = this.sourceCaches[e6];
            delete this.sourceCaches[e6], delete this._updatedSources[e6], i6.fire(new t4.l("data", { sourceDataType: "metadata", dataType: "source", sourceId: e6 })), i6.setEventedParent(null), i6.onRemove(this.map), this._changed = true;
          }
          setGeoJSONSourceData(e6, t5) {
            if (this._checkLoaded(), void 0 === this.sourceCaches[e6]) throw new Error(`There is no source with this ID=${e6}`);
            const i6 = this.sourceCaches[e6].getSource();
            if ("geojson" !== i6.type) throw new Error(`geojsonSource.type is ${i6.type}, which is !== 'geojson`);
            i6.setData(t5), this._changed = true;
          }
          getSource(e6) {
            return this.sourceCaches[e6] && this.sourceCaches[e6].getSource();
          }
          addLayer(e6, i6, r8 = {}) {
            this._checkLoaded();
            const o6 = e6.id;
            if (this.getLayer(o6)) return void this.fire(new t4.k(new Error(`Layer "${o6}" already exists on this map.`)));
            let a4;
            if ("custom" === e6.type) {
              if (mi(this, t4.bB(e6))) return;
              a4 = t4.by(e6);
            } else {
              if ("source" in e6 && "object" == typeof e6.source && (this.addSource(o6, e6.source), e6 = t4.bz(e6), e6 = t4.e(e6, { source: o6 })), this._validate(t4.y.layer, `layers.${o6}`, e6, { arrayIndex: -1 }, r8)) return;
              a4 = t4.by(e6), this._validateLayer(a4), a4.setEventedParent(this, { layer: { id: o6 } });
            }
            const s4 = i6 ? this._order.indexOf(i6) : this._order.length;
            if (i6 && -1 === s4) this.fire(new t4.k(new Error(`Cannot add layer "${o6}" before non-existing layer "${i6}".`)));
            else {
              if (this._order.splice(s4, 0, o6), this._layerOrderChanged = true, this._layers[o6] = a4, this._removedLayers[o6] && a4.source && "custom" !== a4.type) {
                const e7 = this._removedLayers[o6];
                delete this._removedLayers[o6], e7.type !== a4.type ? this._updatedSources[a4.source] = "clear" : (this._updatedSources[a4.source] = "reload", this.sourceCaches[a4.source].pause());
              }
              this._updateLayer(a4), a4.onAdd && a4.onAdd(this.map);
            }
          }
          moveLayer(e6, i6) {
            if (this._checkLoaded(), this._changed = true, !this._layers[e6]) return void this.fire(new t4.k(new Error(`The layer '${e6}' does not exist in the map's style and cannot be moved.`)));
            if (e6 === i6) return;
            const r8 = this._order.indexOf(e6);
            this._order.splice(r8, 1);
            const o6 = i6 ? this._order.indexOf(i6) : this._order.length;
            i6 && -1 === o6 ? this.fire(new t4.k(new Error(`Cannot move layer "${e6}" before non-existing layer "${i6}".`))) : (this._order.splice(o6, 0, e6), this._layerOrderChanged = true);
          }
          removeLayer(e6) {
            this._checkLoaded();
            const i6 = this._layers[e6];
            if (!i6) return void this.fire(new t4.k(new Error(`Cannot remove non-existing layer "${e6}".`)));
            i6.setEventedParent(null);
            const r8 = this._order.indexOf(e6);
            this._order.splice(r8, 1), this._layerOrderChanged = true, this._changed = true, this._removedLayers[e6] = i6, delete this._layers[e6], this._serializedLayers && delete this._serializedLayers[e6], delete this._updatedLayers[e6], delete this._updatedPaintProps[e6], i6.onRemove && i6.onRemove(this.map);
          }
          getLayer(e6) {
            return this._layers[e6];
          }
          getLayersOrder() {
            return [...this._order];
          }
          hasLayer(e6) {
            return e6 in this._layers;
          }
          setLayerZoomRange(e6, i6, r8) {
            this._checkLoaded();
            const o6 = this.getLayer(e6);
            o6 ? o6.minzoom === i6 && o6.maxzoom === r8 || (null != i6 && (o6.minzoom = i6), null != r8 && (o6.maxzoom = r8), this._updateLayer(o6)) : this.fire(new t4.k(new Error(`Cannot set the zoom range of non-existing layer "${e6}".`)));
          }
          setFilter(e6, i6, r8 = {}) {
            this._checkLoaded();
            const o6 = this.getLayer(e6);
            if (o6) {
              if (!t4.bC(o6.filter, i6)) return null == i6 ? (o6.filter = void 0, void this._updateLayer(o6)) : void (this._validate(t4.y.filter, `layers.${o6.id}.filter`, i6, null, r8) || (o6.filter = t4.bz(i6), this._updateLayer(o6)));
            } else this.fire(new t4.k(new Error(`Cannot filter non-existing layer "${e6}".`)));
          }
          getFilter(e6) {
            return t4.bz(this.getLayer(e6).filter);
          }
          setLayoutProperty(e6, i6, r8, o6 = {}) {
            this._checkLoaded();
            const a4 = this.getLayer(e6);
            a4 ? t4.bC(a4.getLayoutProperty(i6), r8) || (a4.setLayoutProperty(i6, r8, o6), this._updateLayer(a4)) : this.fire(new t4.k(new Error(`Cannot style non-existing layer "${e6}".`)));
          }
          getLayoutProperty(e6, i6) {
            const r8 = this.getLayer(e6);
            if (r8) return r8.getLayoutProperty(i6);
            this.fire(new t4.k(new Error(`Cannot get style of non-existing layer "${e6}".`)));
          }
          setPaintProperty(e6, i6, r8, o6 = {}) {
            this._checkLoaded();
            const a4 = this.getLayer(e6);
            a4 ? t4.bC(a4.getPaintProperty(i6), r8) || (a4.setPaintProperty(i6, r8, o6) && this._updateLayer(a4), this._changed = true, this._updatedPaintProps[e6] = true, this._serializedLayers = null) : this.fire(new t4.k(new Error(`Cannot style non-existing layer "${e6}".`)));
          }
          getPaintProperty(e6, t5) {
            return this.getLayer(e6).getPaintProperty(t5);
          }
          setFeatureState(e6, i6) {
            this._checkLoaded();
            const r8 = e6.source, o6 = e6.sourceLayer, a4 = this.sourceCaches[r8];
            if (void 0 === a4) return void this.fire(new t4.k(new Error(`The source '${r8}' does not exist in the map's style.`)));
            const s4 = a4.getSource().type;
            "geojson" === s4 && o6 ? this.fire(new t4.k(new Error("GeoJSON sources cannot have a sourceLayer parameter."))) : "vector" !== s4 || o6 ? (void 0 === e6.id && this.fire(new t4.k(new Error("The feature id parameter must be provided."))), a4.setFeatureState(o6, e6.id, i6)) : this.fire(new t4.k(new Error("The sourceLayer parameter must be provided for vector source types.")));
          }
          removeFeatureState(e6, i6) {
            this._checkLoaded();
            const r8 = e6.source, o6 = this.sourceCaches[r8];
            if (void 0 === o6) return void this.fire(new t4.k(new Error(`The source '${r8}' does not exist in the map's style.`)));
            const a4 = o6.getSource().type, s4 = "vector" === a4 ? e6.sourceLayer : void 0;
            "vector" !== a4 || s4 ? i6 && "string" != typeof e6.id && "number" != typeof e6.id ? this.fire(new t4.k(new Error("A feature id is required to remove its specific state property."))) : o6.removeFeatureState(s4, e6.id, i6) : this.fire(new t4.k(new Error("The sourceLayer parameter must be provided for vector source types.")));
          }
          getFeatureState(e6) {
            this._checkLoaded();
            const i6 = e6.source, r8 = e6.sourceLayer, o6 = this.sourceCaches[i6];
            if (void 0 !== o6) return "vector" !== o6.getSource().type || r8 ? (void 0 === e6.id && this.fire(new t4.k(new Error("The feature id parameter must be provided."))), o6.getFeatureState(r8, e6.id)) : void this.fire(new t4.k(new Error("The sourceLayer parameter must be provided for vector source types.")));
            this.fire(new t4.k(new Error(`The source '${i6}' does not exist in the map's style.`)));
          }
          getTransition() {
            return t4.e({ duration: 300, delay: 0 }, this.stylesheet && this.stylesheet.transition);
          }
          serialize() {
            if (!this._loaded) return;
            const e6 = t4.bD(this.sourceCaches, (e7) => e7.serialize()), i6 = this._serializeByIds(this._order, true), r8 = this.map.getTerrain() || void 0, o6 = this.stylesheet;
            return t4.bE({ version: o6.version, name: o6.name, metadata: o6.metadata, light: o6.light, sky: o6.sky, center: o6.center, zoom: o6.zoom, bearing: o6.bearing, pitch: o6.pitch, sprite: o6.sprite, glyphs: o6.glyphs, transition: o6.transition, projection: o6.projection, sources: e6, layers: i6, terrain: r8 }, (e7) => void 0 !== e7);
          }
          _updateLayer(e6) {
            this._updatedLayers[e6.id] = true, e6.source && !this._updatedSources[e6.source] && "raster" !== this.sourceCaches[e6.source].getSource().type && (this._updatedSources[e6.source] = "reload", this.sourceCaches[e6.source].pause()), this._serializedLayers = null, this._changed = true;
          }
          _flattenAndSortRenderedFeatures(e6) {
            const t5 = (e7) => "fill-extrusion" === this._layers[e7].type, i6 = {}, r8 = [];
            for (let o7 = this._order.length - 1; o7 >= 0; o7--) {
              const a4 = this._order[o7];
              if (t5(a4)) {
                i6[a4] = o7;
                for (const t6 of e6) {
                  const e7 = t6[a4];
                  if (e7) for (const t7 of e7) r8.push(t7);
                }
              }
            }
            r8.sort((e7, t6) => t6.intersectionZ - e7.intersectionZ);
            const o6 = [];
            for (let a4 = this._order.length - 1; a4 >= 0; a4--) {
              const s4 = this._order[a4];
              if (t5(s4)) for (let e7 = r8.length - 1; e7 >= 0; e7--) {
                const t6 = r8[e7].feature;
                if (i6[t6.layer.id] < a4) break;
                o6.push(t6), r8.pop();
              }
              else for (const t6 of e6) {
                const e7 = t6[s4];
                if (e7) for (const t7 of e7) o6.push(t7.feature);
              }
            }
            return o6;
          }
          queryRenderedFeatures(e6, i6, r8) {
            i6 && i6.filter && this._validate(t4.y.filter, "queryRenderedFeatures.filter", i6.filter, null, i6);
            const o6 = {};
            if (i6 && i6.layers) {
              if (!(Array.isArray(i6.layers) || i6.layers instanceof Set)) return this.fire(new t4.k(new Error("parameters.layers must be an Array or a Set of strings"))), [];
              for (const e7 of i6.layers) {
                const i7 = this._layers[e7];
                if (!i7) return this.fire(new t4.k(new Error(`The layer '${e7}' does not exist in the map's style and cannot be queried for features.`))), [];
                o6[i7.source] = true;
              }
            }
            const a4 = [];
            i6.availableImages = this._availableImages;
            const s4 = this._serializedAllLayers(), n6 = i6.layers instanceof Set ? i6.layers : Array.isArray(i6.layers) ? new Set(i6.layers) : null, l5 = Object.assign(Object.assign({}, i6), { layers: n6 });
            for (const t5 in this.sourceCaches) i6.layers && !o6[t5] || a4.push(Z2(this.sourceCaches[t5], this._layers, s4, e6, l5, r8, this.map.terrain ? (e7, t6, i7) => this.map.terrain.getElevation(e7, t6, i7) : void 0));
            return this.placement && a4.push(function(e7, t5, i7, r9, o7, a5, s5) {
              const n7 = {}, l6 = a5.queryRenderedSymbols(r9), c5 = [];
              for (const e8 of Object.keys(l6).map(Number)) c5.push(s5[e8]);
              c5.sort(N3);
              for (const i8 of c5) {
                const r10 = i8.featureIndex.lookupSymbolFeatures(l6[i8.bucketInstanceId], t5, i8.bucketIndex, i8.sourceLayerIndex, o7.filter, o7.layers, o7.availableImages, e7);
                for (const e8 in r10) {
                  const t6 = n7[e8] = n7[e8] || [], o8 = r10[e8];
                  o8.sort((e9, t7) => {
                    const r11 = i8.featureSortOrder;
                    if (r11) {
                      const i9 = r11.indexOf(e9.featureIndex);
                      return r11.indexOf(t7.featureIndex) - i9;
                    }
                    return t7.featureIndex - e9.featureIndex;
                  });
                  for (const e9 of o8) t6.push(e9);
                }
              }
              return function(e8, t6, i8) {
                for (const r10 in e8) for (const o8 of e8[r10]) G2(o8, i8[t6[r10].source]);
                return e8;
              }(n7, e7, i7);
            }(this._layers, s4, this.sourceCaches, e6, l5, this.placement.collisionIndex, this.placement.retainedQueryData)), this._flattenAndSortRenderedFeatures(a4);
          }
          querySourceFeatures(e6, i6) {
            i6 && i6.filter && this._validate(t4.y.filter, "querySourceFeatures.filter", i6.filter, null, i6);
            const r8 = this.sourceCaches[e6];
            return r8 ? function(e7, t5) {
              const i7 = e7.getRenderableIds().map((t6) => e7.getTileByID(t6)), r9 = [], o6 = {};
              for (let e8 = 0; e8 < i7.length; e8++) {
                const a4 = i7[e8], s4 = a4.tileID.canonical.key;
                o6[s4] || (o6[s4] = true, a4.querySourceFeatures(r9, t5));
              }
              return r9;
            }(r8, i6) : [];
          }
          getLight() {
            return this.light.getLight();
          }
          setLight(e6, i6 = {}) {
            this._checkLoaded();
            const r8 = this.light.getLight();
            let o6 = false;
            for (const i7 in e6) if (!t4.bC(e6[i7], r8[i7])) {
              o6 = true;
              break;
            }
            if (!o6) return;
            const a4 = { now: s3.now(), transition: t4.e({ duration: 300, delay: 0 }, this.stylesheet.transition) };
            this.light.setLight(e6, i6), this.light.updateTransitions(a4);
          }
          getProjection() {
            var e6;
            return null === (e6 = this.stylesheet) || void 0 === e6 ? void 0 : e6.projection;
          }
          setProjection(e6) {
            if (this._checkLoaded(), this.projection) {
              if (this.projection.name === e6.type) return;
              this.projection.destroy(), delete this.projection;
            }
            this.stylesheet.projection = e6, this._setProjectionInternal(e6.type);
          }
          getSky() {
            var e6;
            return null === (e6 = this.stylesheet) || void 0 === e6 ? void 0 : e6.sky;
          }
          setSky(e6, i6 = {}) {
            this._checkLoaded();
            const r8 = this.getSky();
            let o6 = false;
            if (!e6 && !r8) return;
            if (e6 && !r8) o6 = true;
            else if (!e6 && r8) o6 = true;
            else for (const i7 in e6) if (!t4.bC(e6[i7], r8[i7])) {
              o6 = true;
              break;
            }
            if (!o6) return;
            const a4 = { now: s3.now(), transition: t4.e({ duration: 300, delay: 0 }, this.stylesheet.transition) };
            this.stylesheet.sky = e6, this.sky.setSky(e6, i6), this.sky.updateTransitions(a4);
          }
          _setProjectionInternal(e6) {
            const i6 = function(e7) {
              if (Array.isArray(e7)) {
                const t5 = new Xt({ type: e7 });
                return { projection: t5, transform: new di(), cameraHelper: new pi(t5) };
              }
              switch (e7) {
                case "mercator":
                  return { projection: new vt(), transform: new Dt(), cameraHelper: new kt() };
                case "globe": {
                  const e8 = new Xt({ type: ["interpolate", ["linear"], ["zoom"], 11, "vertical-perspective", 12, "mercator"] });
                  return { projection: e8, transform: new di(), cameraHelper: new pi(e8) };
                }
                case "vertical-perspective":
                  return { projection: new Ht(), transform: new ui(), cameraHelper: new _i() };
                default:
                  return t4.w(`Unknown projection name: ${e7}. Falling back to mercator projection.`), { projection: new vt(), transform: new Dt(), cameraHelper: new kt() };
              }
            }(e6);
            this.projection = i6.projection, this.map.migrateProjection(i6.transform, i6.cameraHelper);
            for (const e7 in this.sourceCaches) this.sourceCaches[e7].reload();
          }
          _validate(e6, i6, r8, o6, a4 = {}) {
            return (!a4 || false !== a4.validate) && mi(this, e6.call(t4.y, t4.e({ key: i6, style: this.serialize(), value: r8, styleSpec: t4.v }, o6)));
          }
          _remove(e6 = true) {
            this._frameRequest && (this._frameRequest.abort(), this._frameRequest = null), this._loadStyleRequest && (this._loadStyleRequest.abort(), this._loadStyleRequest = null), this._spriteRequest && (this._spriteRequest.abort(), this._spriteRequest = null), oe().off(te, this._rtlPluginLoaded);
            for (const e7 in this._layers) this._layers[e7].setEventedParent(null);
            for (const e7 in this.sourceCaches) {
              const t5 = this.sourceCaches[e7];
              t5.setEventedParent(null), t5.onRemove(this.map);
            }
            this.imageManager.setEventedParent(null), this.setEventedParent(null), e6 && this.dispatcher.broadcast("RM", void 0), this.dispatcher.remove(e6);
          }
          _clearSource(e6) {
            this.sourceCaches[e6].clearTiles();
          }
          _reloadSource(e6) {
            this.sourceCaches[e6].resume(), this.sourceCaches[e6].reload();
          }
          _updateSources(e6) {
            for (const t5 in this.sourceCaches) this.sourceCaches[t5].update(e6, this.map.terrain);
          }
          _generateCollisionBoxes() {
            for (const e6 in this.sourceCaches) this._reloadSource(e6);
          }
          _updatePlacement(e6, t5, i6, r8, o6 = false) {
            let a4 = false, n6 = false;
            const l5 = {};
            for (const t6 of this._order) {
              const i7 = this._layers[t6];
              if ("symbol" !== i7.type) continue;
              if (!l5[i7.source]) {
                const e7 = this.sourceCaches[i7.source];
                l5[i7.source] = e7.getRenderableIds(true).map((t7) => e7.getTileByID(t7)).sort((e8, t7) => t7.tileID.overscaledZ - e8.tileID.overscaledZ || (e8.tileID.isLessThan(t7.tileID) ? -1 : 1));
              }
              const r9 = this.crossTileSymbolIndex.addLayer(i7, l5[i7.source], e6.center.lng);
              a4 = a4 || r9;
            }
            if (this.crossTileSymbolIndex.pruneUnusedLayers(this._order), ((o6 = o6 || this._layerOrderChanged || 0 === i6) || !this.pauseablePlacement || this.pauseablePlacement.isDone() && !this.placement.stillRecent(s3.now(), e6.zoom)) && (this.pauseablePlacement = new at(e6, this.map.terrain, this._order, o6, t5, i6, r8, this.placement), this._layerOrderChanged = false), this.pauseablePlacement.isDone() ? this.placement.setStale() : (this.pauseablePlacement.continuePlacement(this._order, this._layers, l5), this.pauseablePlacement.isDone() && (this.placement = this.pauseablePlacement.commit(s3.now()), n6 = true), a4 && this.pauseablePlacement.placement.setStale()), n6 || a4) for (const e7 of this._order) {
              const t6 = this._layers[e7];
              "symbol" === t6.type && this.placement.updateLayerOpacities(t6, l5[t6.source]);
            }
            return !this.pauseablePlacement.isDone() || this.placement.hasTransitions(s3.now());
          }
          _releaseSymbolFadeTiles() {
            for (const e6 in this.sourceCaches) this.sourceCaches[e6].releaseSymbolFadeTiles();
          }
          getImages(e6, i6) {
            return t4._(this, void 0, void 0, function* () {
              const e7 = yield this.imageManager.getImages(i6.icons);
              this._updateTilesForChangedImages();
              const t5 = this.sourceCaches[i6.source];
              return t5 && t5.setDependencies(i6.tileID.key, i6.type, i6.icons), e7;
            });
          }
          getGlyphs(e6, i6) {
            return t4._(this, void 0, void 0, function* () {
              const e7 = yield this.glyphManager.getGlyphs(i6.stacks), t5 = this.sourceCaches[i6.source];
              return t5 && t5.setDependencies(i6.tileID.key, i6.type, [""]), e7;
            });
          }
          getGlyphsUrl() {
            return this.stylesheet.glyphs || null;
          }
          setGlyphs(e6, i6 = {}) {
            this._checkLoaded(), e6 && this._validate(t4.y.glyphs, "glyphs", e6, null, i6) || (this._glyphsDidChange = true, this.stylesheet.glyphs = e6, this.glyphManager.entries = {}, this.glyphManager.setURL(e6));
          }
          addSprite(e6, i6, r8 = {}, o6) {
            this._checkLoaded();
            const a4 = [{ id: e6, url: i6 }], s4 = [...f3(this.stylesheet.sprite), ...a4];
            this._validate(t4.y.sprite, "sprite", s4, null, r8) || (this.stylesheet.sprite = s4, this._loadSprite(a4, true, o6));
          }
          removeSprite(e6) {
            this._checkLoaded();
            const i6 = f3(this.stylesheet.sprite);
            if (i6.find((t5) => t5.id === e6)) {
              if (this._spritesImagesIds[e6]) for (const t5 of this._spritesImagesIds[e6]) this.imageManager.removeImage(t5), this._changedImages[t5] = true;
              i6.splice(i6.findIndex((t5) => t5.id === e6), 1), this.stylesheet.sprite = i6.length > 0 ? i6 : void 0, delete this._spritesImagesIds[e6], this._availableImages = this.imageManager.listImages(), this._changed = true, this.dispatcher.broadcast("SI", this._availableImages), this.fire(new t4.l("data", { dataType: "style" }));
            } else this.fire(new t4.k(new Error(`Sprite "${e6}" doesn't exists on this map.`)));
          }
          getSprite() {
            return f3(this.stylesheet.sprite);
          }
          setSprite(e6, i6 = {}, r8) {
            this._checkLoaded(), e6 && this._validate(t4.y.sprite, "sprite", e6, null, i6) || (this.stylesheet.sprite = e6, e6 ? this._loadSprite(e6, true, r8) : (this._unloadSprite(), r8 && r8(null)));
          }
        }
        var vi = t4.aD([{ name: "a_pos", type: "Int16", components: 2 }, { name: "a_texture_pos", type: "Int16", components: 2 }]);
        class xi {
          constructor() {
            this.boundProgram = null, this.boundLayoutVertexBuffer = null, this.boundPaintVertexBuffers = [], this.boundIndexBuffer = null, this.boundVertexOffset = null, this.boundDynamicVertexBuffer = null, this.vao = null;
          }
          bind(e6, t5, i6, r8, o6, a4, s4, n6, l5) {
            this.context = e6;
            let c5 = this.boundPaintVertexBuffers.length !== r8.length;
            for (let e7 = 0; !c5 && e7 < r8.length; e7++) this.boundPaintVertexBuffers[e7] !== r8[e7] && (c5 = true);
            !this.vao || this.boundProgram !== t5 || this.boundLayoutVertexBuffer !== i6 || c5 || this.boundIndexBuffer !== o6 || this.boundVertexOffset !== a4 || this.boundDynamicVertexBuffer !== s4 || this.boundDynamicVertexBuffer2 !== n6 || this.boundDynamicVertexBuffer3 !== l5 ? this.freshBind(t5, i6, r8, o6, a4, s4, n6, l5) : (e6.bindVertexArray.set(this.vao), s4 && s4.bind(), o6 && o6.dynamicDraw && o6.bind(), n6 && n6.bind(), l5 && l5.bind());
          }
          freshBind(e6, t5, i6, r8, o6, a4, s4, n6) {
            const l5 = e6.numAttributes, c5 = this.context, h4 = c5.gl;
            this.vao && this.destroy(), this.vao = c5.createVertexArray(), c5.bindVertexArray.set(this.vao), this.boundProgram = e6, this.boundLayoutVertexBuffer = t5, this.boundPaintVertexBuffers = i6, this.boundIndexBuffer = r8, this.boundVertexOffset = o6, this.boundDynamicVertexBuffer = a4, this.boundDynamicVertexBuffer2 = s4, this.boundDynamicVertexBuffer3 = n6, t5.enableAttributes(h4, e6);
            for (const t6 of i6) t6.enableAttributes(h4, e6);
            a4 && a4.enableAttributes(h4, e6), s4 && s4.enableAttributes(h4, e6), n6 && n6.enableAttributes(h4, e6), t5.bind(), t5.setVertexAttribPointers(h4, e6, o6);
            for (const t6 of i6) t6.bind(), t6.setVertexAttribPointers(h4, e6, o6);
            a4 && (a4.bind(), a4.setVertexAttribPointers(h4, e6, o6)), r8 && r8.bind(), s4 && (s4.bind(), s4.setVertexAttribPointers(h4, e6, o6)), n6 && (n6.bind(), n6.setVertexAttribPointers(h4, e6, o6)), c5.currentNumAttributes = l5;
          }
          destroy() {
            this.vao && (this.context.deleteVertexArray(this.vao), this.vao = null);
          }
        }
        const bi = (e6, i6, r8, o6, a4) => ({ u_texture: 0, u_ele_delta: e6, u_fog_matrix: i6, u_fog_color: r8 ? r8.properties.get("fog-color") : t4.b7.white, u_fog_ground_blend: r8 ? r8.properties.get("fog-ground-blend") : 1, u_fog_ground_blend_opacity: a4 ? 0 : r8 ? r8.calculateFogBlendOpacity(o6) : 0, u_horizon_color: r8 ? r8.properties.get("horizon-color") : t4.b7.white, u_horizon_fog_blend: r8 ? r8.properties.get("horizon-fog-blend") : 1, u_is_globe_mode: a4 ? 1 : 0 }), yi = { mainMatrix: "u_projection_matrix", tileMercatorCoords: "u_projection_tile_mercator_coords", clippingPlane: "u_projection_clipping_plane", projectionTransition: "u_projection_transition", fallbackMatrix: "u_projection_fallback_matrix" };
        function wi(e6) {
          const t5 = [];
          for (let i6 = 0; i6 < e6.length; i6++) {
            if (null === e6[i6]) continue;
            const r8 = e6[i6].split(" ");
            t5.push(r8.pop());
          }
          return t5;
        }
        class Ti {
          constructor(e6, i6, r8, o6, a4, s4, n6, l5) {
            const c5 = e6.gl;
            this.program = c5.createProgram();
            const h4 = wi(i6.staticAttributes), u4 = r8 ? r8.getBinderAttributes() : [], d4 = h4.concat(u4), _4 = dt.prelude.staticUniforms ? wi(dt.prelude.staticUniforms) : [], p4 = n6.staticUniforms ? wi(n6.staticUniforms) : [], m4 = i6.staticUniforms ? wi(i6.staticUniforms) : [], f4 = r8 ? r8.getBinderUniforms() : [], g4 = _4.concat(p4).concat(m4).concat(f4), v4 = [];
            for (const e7 of g4) v4.indexOf(e7) < 0 && v4.push(e7);
            const x4 = r8 ? r8.defines() : [];
            Ut(c5) && x4.unshift("#version 300 es"), a4 && x4.push("#define OVERDRAW_INSPECTOR;"), s4 && x4.push("#define TERRAIN3D;"), l5 && x4.push(l5);
            let b5 = x4.concat(dt.prelude.fragmentSource, n6.fragmentSource, i6.fragmentSource).join("\n"), y4 = x4.concat(dt.prelude.vertexSource, n6.vertexSource, i6.vertexSource).join("\n");
            Ut(c5) || (b5 = function(e7) {
              return e7.replace(/\bin\s/g, "varying ").replace("out highp vec4 fragColor;", "").replace(/fragColor/g, "gl_FragColor").replace(/texture\(/g, "texture2D(");
            }(b5), y4 = function(e7) {
              return e7.replace(/\bin\s/g, "attribute ").replace(/\bout\s/g, "varying ").replace(/texture\(/g, "texture2D(");
            }(y4));
            const w4 = c5.createShader(c5.FRAGMENT_SHADER);
            if (c5.isContextLost()) return void (this.failedToCreate = true);
            if (c5.shaderSource(w4, b5), c5.compileShader(w4), !c5.getShaderParameter(w4, c5.COMPILE_STATUS)) throw new Error(`Could not compile fragment shader: ${c5.getShaderInfoLog(w4)}`);
            c5.attachShader(this.program, w4);
            const T5 = c5.createShader(c5.VERTEX_SHADER);
            if (c5.isContextLost()) return void (this.failedToCreate = true);
            if (c5.shaderSource(T5, y4), c5.compileShader(T5), !c5.getShaderParameter(T5, c5.COMPILE_STATUS)) throw new Error(`Could not compile vertex shader: ${c5.getShaderInfoLog(T5)}`);
            c5.attachShader(this.program, T5), this.attributes = {};
            const P4 = {};
            this.numAttributes = d4.length;
            for (let e7 = 0; e7 < this.numAttributes; e7++) d4[e7] && (c5.bindAttribLocation(this.program, e7, d4[e7]), this.attributes[d4[e7]] = e7);
            if (c5.linkProgram(this.program), !c5.getProgramParameter(this.program, c5.LINK_STATUS)) throw new Error(`Program failed to link: ${c5.getProgramInfoLog(this.program)}`);
            c5.deleteShader(T5), c5.deleteShader(w4);
            for (let e7 = 0; e7 < v4.length; e7++) {
              const t5 = v4[e7];
              if (t5 && !P4[t5]) {
                const e8 = c5.getUniformLocation(this.program, t5);
                e8 && (P4[t5] = e8);
              }
            }
            this.fixedUniforms = o6(e6, P4), this.terrainUniforms = ((e7, i7) => ({ u_depth: new t4.bF(e7, i7.u_depth), u_terrain: new t4.bF(e7, i7.u_terrain), u_terrain_dim: new t4.b8(e7, i7.u_terrain_dim), u_terrain_matrix: new t4.bH(e7, i7.u_terrain_matrix), u_terrain_unpack: new t4.bI(e7, i7.u_terrain_unpack), u_terrain_exaggeration: new t4.b8(e7, i7.u_terrain_exaggeration) }))(e6, P4), this.projectionUniforms = ((e7, i7) => ({ u_projection_matrix: new t4.bH(e7, i7.u_projection_matrix), u_projection_tile_mercator_coords: new t4.bI(e7, i7.u_projection_tile_mercator_coords), u_projection_clipping_plane: new t4.bI(e7, i7.u_projection_clipping_plane), u_projection_transition: new t4.b8(e7, i7.u_projection_transition), u_projection_fallback_matrix: new t4.bH(e7, i7.u_projection_fallback_matrix) }))(e6, P4), this.binderUniforms = r8 ? r8.getUniforms(e6, P4) : [];
          }
          draw(e6, t5, i6, r8, o6, a4, s4, n6, l5, c5, h4, u4, d4, _4, p4, m4, f4, g4, v4) {
            const x4 = e6.gl;
            if (this.failedToCreate) return;
            if (e6.program.set(this.program), e6.setDepthMode(i6), e6.setStencilMode(r8), e6.setColorMode(o6), e6.setCullFace(a4), n6) {
              e6.activeTexture.set(x4.TEXTURE2), x4.bindTexture(x4.TEXTURE_2D, n6.depthTexture), e6.activeTexture.set(x4.TEXTURE3), x4.bindTexture(x4.TEXTURE_2D, n6.texture);
              for (const e7 in this.terrainUniforms) this.terrainUniforms[e7].set(n6[e7]);
            }
            if (l5) for (const e7 in l5) this.projectionUniforms[yi[e7]].set(l5[e7]);
            if (s4) for (const e7 in this.fixedUniforms) this.fixedUniforms[e7].set(s4[e7]);
            m4 && m4.setUniforms(e6, this.binderUniforms, _4, { zoom: p4 });
            let b5 = 0;
            switch (t5) {
              case x4.LINES:
                b5 = 2;
                break;
              case x4.TRIANGLES:
                b5 = 3;
                break;
              case x4.LINE_STRIP:
                b5 = 1;
            }
            for (const i7 of d4.get()) {
              const r9 = i7.vaos || (i7.vaos = {});
              (r9[c5] || (r9[c5] = new xi())).bind(e6, this, h4, m4 ? m4.getPaintVertexBuffers() : [], u4, i7.vertexOffset, f4, g4, v4), x4.drawElements(t5, i7.primitiveLength * b5, x4.UNSIGNED_SHORT, i7.primitiveOffset * b5 * 2);
            }
          }
        }
        function Pi(e6, i6, r8) {
          const o6 = 1 / t4.aw(r8, 1, i6.transform.tileZoom), a4 = Math.pow(2, r8.tileID.overscaledZ), s4 = r8.tileSize * Math.pow(2, i6.transform.tileZoom) / a4, n6 = s4 * (r8.tileID.canonical.x + r8.tileID.wrap * a4), l5 = s4 * r8.tileID.canonical.y;
          return { u_image: 0, u_texsize: r8.imageAtlasTexture.size, u_scale: [o6, e6.fromScale, e6.toScale], u_fade: e6.t, u_pixel_coord_upper: [n6 >> 16, l5 >> 16], u_pixel_coord_lower: [65535 & n6, 65535 & l5] };
        }
        const Ci = (e6, i6, r8, o6) => {
          const a4 = e6.style.light, s4 = a4.properties.get("position"), n6 = [s4.x, s4.y, s4.z], l5 = t4.bL();
          "viewport" === a4.properties.get("anchor") && t4.bM(l5, e6.transform.bearingInRadians), t4.bN(n6, n6, l5);
          const c5 = e6.transform.transformLightDirection(n6), h4 = a4.properties.get("color");
          return { u_lightpos: n6, u_lightpos_globe: c5, u_lightintensity: a4.properties.get("intensity"), u_lightcolor: [h4.r, h4.g, h4.b], u_vertical_gradient: +i6, u_opacity: r8, u_fill_translate: o6 };
        }, Ii = (e6, i6, r8, o6, a4, s4, n6) => t4.e(Ci(e6, i6, r8, o6), Pi(s4, e6, n6), { u_height_factor: -Math.pow(2, a4.overscaledZ) / n6.tileSize / 8 }), Mi = (e6, i6, r8, o6) => t4.e(Pi(i6, e6, r8), { u_fill_translate: o6 }), Ei = (e6, t5) => ({ u_world: e6, u_fill_translate: t5 }), Si = (e6, i6, r8, o6, a4) => t4.e(Mi(e6, i6, r8, a4), { u_world: o6 }), Ri = (e6, i6, r8, o6, a4) => {
          const s4 = e6.transform;
          let n6, l5, c5 = 0;
          if ("map" === r8.paint.get("circle-pitch-alignment")) {
            const e7 = t4.aw(i6, 1, s4.zoom);
            n6 = true, l5 = [e7, e7], c5 = e7 / (t4.Z * Math.pow(2, i6.tileID.overscaledZ)) * 2 * Math.PI * a4;
          } else n6 = false, l5 = s4.pixelsToGLUnits;
          return { u_camera_to_center_distance: s4.cameraToCenterDistance, u_scale_with_map: +("map" === r8.paint.get("circle-pitch-scale")), u_pitch_with_map: +n6, u_device_pixel_ratio: e6.pixelRatio, u_extrude_scale: l5, u_globe_extrude_scale: c5, u_translate: o6 };
        }, Di = (e6) => ({ u_pixel_extrude_scale: [1 / e6.width, 1 / e6.height] }), zi = (e6) => ({ u_viewport_size: [e6.width, e6.height] }), Ai = (e6, t5 = 1) => ({ u_color: e6, u_overlay: 0, u_overlay_scale: t5 }), Li = (e6, i6, r8, o6) => {
          const a4 = t4.aw(e6, 1, i6) / (t4.Z * Math.pow(2, e6.tileID.overscaledZ)) * 2 * Math.PI * o6;
          return { u_extrude_scale: t4.aw(e6, 1, i6), u_intensity: r8, u_globe_extrude_scale: a4 };
        }, ki = (e6, i6, r8, o6) => {
          const a4 = t4.K();
          t4.bO(a4, 0, e6.width, e6.height, 0, 0, 1);
          const s4 = e6.context.gl;
          return { u_matrix: a4, u_world: [s4.drawingBufferWidth, s4.drawingBufferHeight], u_image: r8, u_color_ramp: o6, u_opacity: i6.paint.get("heatmap-opacity") };
        }, Fi = (e6, t5, i6) => {
          const r8 = i6.paint.get("hillshade-shadow-color"), o6 = i6.paint.get("hillshade-highlight-color"), a4 = i6.paint.get("hillshade-accent-color");
          let s4 = i6.paint.get("hillshade-illumination-direction") * (Math.PI / 180);
          return "viewport" === i6.paint.get("hillshade-illumination-anchor") && (s4 += e6.transform.bearingInRadians), { u_image: 0, u_latrange: Oi(0, t5.tileID), u_light: [i6.paint.get("hillshade-exaggeration"), s4], u_shadow: r8, u_highlight: o6, u_accent: a4 };
        }, Bi = (e6, i6) => {
          const r8 = i6.stride, o6 = t4.K();
          return t4.bO(o6, 0, t4.Z, -8192, 0, 0, 1), t4.L(o6, o6, [0, -8192, 0]), { u_matrix: o6, u_image: 1, u_dimension: [r8, r8], u_zoom: e6.overscaledZ, u_unpack: i6.getUnpackVector() };
        };
        function Oi(e6, i6) {
          const r8 = Math.pow(2, i6.canonical.z), o6 = i6.canonical.y;
          return [new t4.$(0, o6 / r8).toLngLat().lat, new t4.$(0, (o6 + 1) / r8).toLngLat().lat];
        }
        const ji = (e6, i6, r8, o6) => {
          const a4 = e6.transform;
          return { u_translation: Vi(e6, i6, r8), u_ratio: o6 / t4.aw(i6, 1, a4.zoom), u_device_pixel_ratio: e6.pixelRatio, u_units_to_pixels: [1 / a4.pixelsToGLUnits[0], 1 / a4.pixelsToGLUnits[1]] };
        }, Zi = (e6, i6, r8, o6, a4) => t4.e(ji(e6, i6, r8, o6), { u_image: 0, u_image_height: a4 }), Ni = (e6, i6, r8, o6, a4) => {
          const s4 = e6.transform, n6 = Ui(i6, s4);
          return { u_translation: Vi(e6, i6, r8), u_texsize: i6.imageAtlasTexture.size, u_ratio: o6 / t4.aw(i6, 1, s4.zoom), u_device_pixel_ratio: e6.pixelRatio, u_image: 0, u_scale: [n6, a4.fromScale, a4.toScale], u_fade: a4.t, u_units_to_pixels: [1 / s4.pixelsToGLUnits[0], 1 / s4.pixelsToGLUnits[1]] };
        }, Gi = (e6, i6, r8, o6, a4, s4) => {
          const n6 = e6.lineAtlas, l5 = Ui(i6, e6.transform), c5 = "round" === r8.layout.get("line-cap"), h4 = n6.getDash(a4.from, c5), u4 = n6.getDash(a4.to, c5), d4 = h4.width * s4.fromScale, _4 = u4.width * s4.toScale;
          return t4.e(ji(e6, i6, r8, o6), { u_patternscale_a: [l5 / d4, -h4.height / 2], u_patternscale_b: [l5 / _4, -u4.height / 2], u_sdfgamma: n6.width / (256 * Math.min(d4, _4) * e6.pixelRatio) / 2, u_image: 0, u_tex_y_a: h4.y, u_tex_y_b: u4.y, u_mix: s4.t });
        };
        function Ui(e6, i6) {
          return 1 / t4.aw(e6, 1, i6.tileZoom);
        }
        function Vi(e6, i6, r8) {
          return t4.ax(e6.transform, i6, r8.paint.get("line-translate"), r8.paint.get("line-translate-anchor"));
        }
        const qi = (e6, t5, i6, r8, o6) => {
          return { u_tl_parent: e6, u_scale_parent: t5, u_buffer_scale: 1, u_fade_t: i6.mix, u_opacity: i6.opacity * r8.paint.get("raster-opacity"), u_image0: 0, u_image1: 1, u_brightness_low: r8.paint.get("raster-brightness-min"), u_brightness_high: r8.paint.get("raster-brightness-max"), u_saturation_factor: (s4 = r8.paint.get("raster-saturation"), s4 > 0 ? 1 - 1 / (1.001 - s4) : -s4), u_contrast_factor: (a4 = r8.paint.get("raster-contrast"), a4 > 0 ? 1 / (1 - a4) : 1 + a4), u_spin_weights: Wi(r8.paint.get("raster-hue-rotate")), u_coords_top: [o6[0].x, o6[0].y, o6[1].x, o6[1].y], u_coords_bottom: [o6[3].x, o6[3].y, o6[2].x, o6[2].y] };
          var a4, s4;
        };
        function Wi(e6) {
          e6 *= Math.PI / 180;
          const t5 = Math.sin(e6), i6 = Math.cos(e6);
          return [(2 * i6 + 1) / 3, (-Math.sqrt(3) * t5 - i6 + 1) / 3, (Math.sqrt(3) * t5 - i6 + 1) / 3];
        }
        const $i = (e6, t5, i6, r8, o6, a4, s4, n6, l5, c5, h4, u4, d4) => {
          const _4 = s4.transform;
          return { u_is_size_zoom_constant: +("constant" === e6 || "source" === e6), u_is_size_feature_constant: +("constant" === e6 || "camera" === e6), u_size_t: t5 ? t5.uSizeT : 0, u_size: t5 ? t5.uSize : 0, u_camera_to_center_distance: _4.cameraToCenterDistance, u_pitch: _4.pitch / 360 * 2 * Math.PI, u_rotate_symbol: +i6, u_aspect_ratio: _4.width / _4.height, u_fade_change: s4.options.fadeDuration ? s4.symbolFadeChange : 1, u_label_plane_matrix: n6, u_coord_matrix: l5, u_is_text: +h4, u_pitch_with_map: +r8, u_is_along_line: o6, u_is_variable_anchor: a4, u_texsize: u4, u_texture: 0, u_translation: c5, u_pitched_scale: d4 };
        }, Hi = (e6, i6, r8, o6, a4, s4, n6, l5, c5, h4, u4, d4, _4, p4) => {
          const m4 = n6.transform;
          return t4.e($i(e6, i6, r8, o6, a4, s4, n6, l5, c5, h4, u4, d4, p4), { u_gamma_scale: o6 ? Math.cos(m4.pitch * Math.PI / 180) * m4.cameraToCenterDistance : 1, u_device_pixel_ratio: n6.pixelRatio, u_is_halo: 1 });
        }, Ki = (e6, i6, r8, o6, a4, s4, n6, l5, c5, h4, u4, d4, _4) => t4.e(Hi(e6, i6, r8, o6, a4, s4, n6, l5, c5, h4, true, u4, 0, _4), { u_texsize_icon: d4, u_texture_icon: 1 }), Xi = (e6, t5) => ({ u_opacity: e6, u_color: t5 }), Qi = (e6, i6, r8, o6, a4) => t4.e(function(e7, i7, r9, o7) {
          const a5 = r9.imageManager.getPattern(e7.from.toString()), s4 = r9.imageManager.getPattern(e7.to.toString()), { width: n6, height: l5 } = r9.imageManager.getPixelSize(), c5 = Math.pow(2, o7.tileID.overscaledZ), h4 = o7.tileSize * Math.pow(2, r9.transform.tileZoom) / c5, u4 = h4 * (o7.tileID.canonical.x + o7.tileID.wrap * c5), d4 = h4 * o7.tileID.canonical.y;
          return { u_image: 0, u_pattern_tl_a: a5.tl, u_pattern_br_a: a5.br, u_pattern_tl_b: s4.tl, u_pattern_br_b: s4.br, u_texsize: [n6, l5], u_mix: i7.t, u_pattern_size_a: a5.displaySize, u_pattern_size_b: s4.displaySize, u_scale_a: i7.fromScale, u_scale_b: i7.toScale, u_tile_units_to_pixels: 1 / t4.aw(o7, 1, r9.transform.tileZoom), u_pixel_coord_upper: [u4 >> 16, d4 >> 16], u_pixel_coord_lower: [65535 & u4, 65535 & d4] };
        }(r8, a4, i6, o6), { u_opacity: e6 }), Yi = (e6, t5) => {
        }, Ji = { fillExtrusion: (e6, i6) => ({ u_lightpos: new t4.bJ(e6, i6.u_lightpos), u_lightpos_globe: new t4.bJ(e6, i6.u_lightpos_globe), u_lightintensity: new t4.b8(e6, i6.u_lightintensity), u_lightcolor: new t4.bJ(e6, i6.u_lightcolor), u_vertical_gradient: new t4.b8(e6, i6.u_vertical_gradient), u_opacity: new t4.b8(e6, i6.u_opacity), u_fill_translate: new t4.bK(e6, i6.u_fill_translate) }), fillExtrusionPattern: (e6, i6) => ({ u_lightpos: new t4.bJ(e6, i6.u_lightpos), u_lightpos_globe: new t4.bJ(e6, i6.u_lightpos_globe), u_lightintensity: new t4.b8(e6, i6.u_lightintensity), u_lightcolor: new t4.bJ(e6, i6.u_lightcolor), u_vertical_gradient: new t4.b8(e6, i6.u_vertical_gradient), u_height_factor: new t4.b8(e6, i6.u_height_factor), u_opacity: new t4.b8(e6, i6.u_opacity), u_fill_translate: new t4.bK(e6, i6.u_fill_translate), u_image: new t4.bF(e6, i6.u_image), u_texsize: new t4.bK(e6, i6.u_texsize), u_pixel_coord_upper: new t4.bK(e6, i6.u_pixel_coord_upper), u_pixel_coord_lower: new t4.bK(e6, i6.u_pixel_coord_lower), u_scale: new t4.bJ(e6, i6.u_scale), u_fade: new t4.b8(e6, i6.u_fade) }), fill: (e6, i6) => ({ u_fill_translate: new t4.bK(e6, i6.u_fill_translate) }), fillPattern: (e6, i6) => ({ u_image: new t4.bF(e6, i6.u_image), u_texsize: new t4.bK(e6, i6.u_texsize), u_pixel_coord_upper: new t4.bK(e6, i6.u_pixel_coord_upper), u_pixel_coord_lower: new t4.bK(e6, i6.u_pixel_coord_lower), u_scale: new t4.bJ(e6, i6.u_scale), u_fade: new t4.b8(e6, i6.u_fade), u_fill_translate: new t4.bK(e6, i6.u_fill_translate) }), fillOutline: (e6, i6) => ({ u_world: new t4.bK(e6, i6.u_world), u_fill_translate: new t4.bK(e6, i6.u_fill_translate) }), fillOutlinePattern: (e6, i6) => ({ u_world: new t4.bK(e6, i6.u_world), u_image: new t4.bF(e6, i6.u_image), u_texsize: new t4.bK(e6, i6.u_texsize), u_pixel_coord_upper: new t4.bK(e6, i6.u_pixel_coord_upper), u_pixel_coord_lower: new t4.bK(e6, i6.u_pixel_coord_lower), u_scale: new t4.bJ(e6, i6.u_scale), u_fade: new t4.b8(e6, i6.u_fade), u_fill_translate: new t4.bK(e6, i6.u_fill_translate) }), circle: (e6, i6) => ({ u_camera_to_center_distance: new t4.b8(e6, i6.u_camera_to_center_distance), u_scale_with_map: new t4.bF(e6, i6.u_scale_with_map), u_pitch_with_map: new t4.bF(e6, i6.u_pitch_with_map), u_extrude_scale: new t4.bK(e6, i6.u_extrude_scale), u_device_pixel_ratio: new t4.b8(e6, i6.u_device_pixel_ratio), u_globe_extrude_scale: new t4.b8(e6, i6.u_globe_extrude_scale), u_translate: new t4.bK(e6, i6.u_translate) }), collisionBox: (e6, i6) => ({ u_pixel_extrude_scale: new t4.bK(e6, i6.u_pixel_extrude_scale) }), collisionCircle: (e6, i6) => ({ u_viewport_size: new t4.bK(e6, i6.u_viewport_size) }), debug: (e6, i6) => ({ u_color: new t4.bG(e6, i6.u_color), u_overlay: new t4.bF(e6, i6.u_overlay), u_overlay_scale: new t4.b8(e6, i6.u_overlay_scale) }), depth: Yi, clippingMask: Yi, heatmap: (e6, i6) => ({ u_extrude_scale: new t4.b8(e6, i6.u_extrude_scale), u_intensity: new t4.b8(e6, i6.u_intensity), u_globe_extrude_scale: new t4.b8(e6, i6.u_globe_extrude_scale) }), heatmapTexture: (e6, i6) => ({ u_matrix: new t4.bH(e6, i6.u_matrix), u_world: new t4.bK(e6, i6.u_world), u_image: new t4.bF(e6, i6.u_image), u_color_ramp: new t4.bF(e6, i6.u_color_ramp), u_opacity: new t4.b8(e6, i6.u_opacity) }), hillshade: (e6, i6) => ({ u_image: new t4.bF(e6, i6.u_image), u_latrange: new t4.bK(e6, i6.u_latrange), u_light: new t4.bK(e6, i6.u_light), u_shadow: new t4.bG(e6, i6.u_shadow), u_highlight: new t4.bG(e6, i6.u_highlight), u_accent: new t4.bG(e6, i6.u_accent) }), hillshadePrepare: (e6, i6) => ({ u_matrix: new t4.bH(e6, i6.u_matrix), u_image: new t4.bF(e6, i6.u_image), u_dimension: new t4.bK(e6, i6.u_dimension), u_zoom: new t4.b8(e6, i6.u_zoom), u_unpack: new t4.bI(e6, i6.u_unpack) }), line: (e6, i6) => ({ u_translation: new t4.bK(e6, i6.u_translation), u_ratio: new t4.b8(e6, i6.u_ratio), u_device_pixel_ratio: new t4.b8(e6, i6.u_device_pixel_ratio), u_units_to_pixels: new t4.bK(e6, i6.u_units_to_pixels) }), lineGradient: (e6, i6) => ({ u_translation: new t4.bK(e6, i6.u_translation), u_ratio: new t4.b8(e6, i6.u_ratio), u_device_pixel_ratio: new t4.b8(e6, i6.u_device_pixel_ratio), u_units_to_pixels: new t4.bK(e6, i6.u_units_to_pixels), u_image: new t4.bF(e6, i6.u_image), u_image_height: new t4.b8(e6, i6.u_image_height) }), linePattern: (e6, i6) => ({ u_translation: new t4.bK(e6, i6.u_translation), u_texsize: new t4.bK(e6, i6.u_texsize), u_ratio: new t4.b8(e6, i6.u_ratio), u_device_pixel_ratio: new t4.b8(e6, i6.u_device_pixel_ratio), u_image: new t4.bF(e6, i6.u_image), u_units_to_pixels: new t4.bK(e6, i6.u_units_to_pixels), u_scale: new t4.bJ(e6, i6.u_scale), u_fade: new t4.b8(e6, i6.u_fade) }), lineSDF: (e6, i6) => ({ u_translation: new t4.bK(e6, i6.u_translation), u_ratio: new t4.b8(e6, i6.u_ratio), u_device_pixel_ratio: new t4.b8(e6, i6.u_device_pixel_ratio), u_units_to_pixels: new t4.bK(e6, i6.u_units_to_pixels), u_patternscale_a: new t4.bK(e6, i6.u_patternscale_a), u_patternscale_b: new t4.bK(e6, i6.u_patternscale_b), u_sdfgamma: new t4.b8(e6, i6.u_sdfgamma), u_image: new t4.bF(e6, i6.u_image), u_tex_y_a: new t4.b8(e6, i6.u_tex_y_a), u_tex_y_b: new t4.b8(e6, i6.u_tex_y_b), u_mix: new t4.b8(e6, i6.u_mix) }), raster: (e6, i6) => ({ u_tl_parent: new t4.bK(e6, i6.u_tl_parent), u_scale_parent: new t4.b8(e6, i6.u_scale_parent), u_buffer_scale: new t4.b8(e6, i6.u_buffer_scale), u_fade_t: new t4.b8(e6, i6.u_fade_t), u_opacity: new t4.b8(e6, i6.u_opacity), u_image0: new t4.bF(e6, i6.u_image0), u_image1: new t4.bF(e6, i6.u_image1), u_brightness_low: new t4.b8(e6, i6.u_brightness_low), u_brightness_high: new t4.b8(e6, i6.u_brightness_high), u_saturation_factor: new t4.b8(e6, i6.u_saturation_factor), u_contrast_factor: new t4.b8(e6, i6.u_contrast_factor), u_spin_weights: new t4.bJ(e6, i6.u_spin_weights), u_coords_top: new t4.bI(e6, i6.u_coords_top), u_coords_bottom: new t4.bI(e6, i6.u_coords_bottom) }), symbolIcon: (e6, i6) => ({ u_is_size_zoom_constant: new t4.bF(e6, i6.u_is_size_zoom_constant), u_is_size_feature_constant: new t4.bF(e6, i6.u_is_size_feature_constant), u_size_t: new t4.b8(e6, i6.u_size_t), u_size: new t4.b8(e6, i6.u_size), u_camera_to_center_distance: new t4.b8(e6, i6.u_camera_to_center_distance), u_pitch: new t4.b8(e6, i6.u_pitch), u_rotate_symbol: new t4.bF(e6, i6.u_rotate_symbol), u_aspect_ratio: new t4.b8(e6, i6.u_aspect_ratio), u_fade_change: new t4.b8(e6, i6.u_fade_change), u_label_plane_matrix: new t4.bH(e6, i6.u_label_plane_matrix), u_coord_matrix: new t4.bH(e6, i6.u_coord_matrix), u_is_text: new t4.bF(e6, i6.u_is_text), u_pitch_with_map: new t4.bF(e6, i6.u_pitch_with_map), u_is_along_line: new t4.bF(e6, i6.u_is_along_line), u_is_variable_anchor: new t4.bF(e6, i6.u_is_variable_anchor), u_texsize: new t4.bK(e6, i6.u_texsize), u_texture: new t4.bF(e6, i6.u_texture), u_translation: new t4.bK(e6, i6.u_translation), u_pitched_scale: new t4.b8(e6, i6.u_pitched_scale) }), symbolSDF: (e6, i6) => ({ u_is_size_zoom_constant: new t4.bF(e6, i6.u_is_size_zoom_constant), u_is_size_feature_constant: new t4.bF(e6, i6.u_is_size_feature_constant), u_size_t: new t4.b8(e6, i6.u_size_t), u_size: new t4.b8(e6, i6.u_size), u_camera_to_center_distance: new t4.b8(e6, i6.u_camera_to_center_distance), u_pitch: new t4.b8(e6, i6.u_pitch), u_rotate_symbol: new t4.bF(e6, i6.u_rotate_symbol), u_aspect_ratio: new t4.b8(e6, i6.u_aspect_ratio), u_fade_change: new t4.b8(e6, i6.u_fade_change), u_label_plane_matrix: new t4.bH(e6, i6.u_label_plane_matrix), u_coord_matrix: new t4.bH(e6, i6.u_coord_matrix), u_is_text: new t4.bF(e6, i6.u_is_text), u_pitch_with_map: new t4.bF(e6, i6.u_pitch_with_map), u_is_along_line: new t4.bF(e6, i6.u_is_along_line), u_is_variable_anchor: new t4.bF(e6, i6.u_is_variable_anchor), u_texsize: new t4.bK(e6, i6.u_texsize), u_texture: new t4.bF(e6, i6.u_texture), u_gamma_scale: new t4.b8(e6, i6.u_gamma_scale), u_device_pixel_ratio: new t4.b8(e6, i6.u_device_pixel_ratio), u_is_halo: new t4.bF(e6, i6.u_is_halo), u_translation: new t4.bK(e6, i6.u_translation), u_pitched_scale: new t4.b8(e6, i6.u_pitched_scale) }), symbolTextAndIcon: (e6, i6) => ({ u_is_size_zoom_constant: new t4.bF(e6, i6.u_is_size_zoom_constant), u_is_size_feature_constant: new t4.bF(e6, i6.u_is_size_feature_constant), u_size_t: new t4.b8(e6, i6.u_size_t), u_size: new t4.b8(e6, i6.u_size), u_camera_to_center_distance: new t4.b8(e6, i6.u_camera_to_center_distance), u_pitch: new t4.b8(e6, i6.u_pitch), u_rotate_symbol: new t4.bF(e6, i6.u_rotate_symbol), u_aspect_ratio: new t4.b8(e6, i6.u_aspect_ratio), u_fade_change: new t4.b8(e6, i6.u_fade_change), u_label_plane_matrix: new t4.bH(e6, i6.u_label_plane_matrix), u_coord_matrix: new t4.bH(e6, i6.u_coord_matrix), u_is_text: new t4.bF(e6, i6.u_is_text), u_pitch_with_map: new t4.bF(e6, i6.u_pitch_with_map), u_is_along_line: new t4.bF(e6, i6.u_is_along_line), u_is_variable_anchor: new t4.bF(e6, i6.u_is_variable_anchor), u_texsize: new t4.bK(e6, i6.u_texsize), u_texsize_icon: new t4.bK(e6, i6.u_texsize_icon), u_texture: new t4.bF(e6, i6.u_texture), u_texture_icon: new t4.bF(e6, i6.u_texture_icon), u_gamma_scale: new t4.b8(e6, i6.u_gamma_scale), u_device_pixel_ratio: new t4.b8(e6, i6.u_device_pixel_ratio), u_is_halo: new t4.bF(e6, i6.u_is_halo), u_translation: new t4.bK(e6, i6.u_translation), u_pitched_scale: new t4.b8(e6, i6.u_pitched_scale) }), background: (e6, i6) => ({ u_opacity: new t4.b8(e6, i6.u_opacity), u_color: new t4.bG(e6, i6.u_color) }), backgroundPattern: (e6, i6) => ({ u_opacity: new t4.b8(e6, i6.u_opacity), u_image: new t4.bF(e6, i6.u_image), u_pattern_tl_a: new t4.bK(e6, i6.u_pattern_tl_a), u_pattern_br_a: new t4.bK(e6, i6.u_pattern_br_a), u_pattern_tl_b: new t4.bK(e6, i6.u_pattern_tl_b), u_pattern_br_b: new t4.bK(e6, i6.u_pattern_br_b), u_texsize: new t4.bK(e6, i6.u_texsize), u_mix: new t4.b8(e6, i6.u_mix), u_pattern_size_a: new t4.bK(e6, i6.u_pattern_size_a), u_pattern_size_b: new t4.bK(e6, i6.u_pattern_size_b), u_scale_a: new t4.b8(e6, i6.u_scale_a), u_scale_b: new t4.b8(e6, i6.u_scale_b), u_pixel_coord_upper: new t4.bK(e6, i6.u_pixel_coord_upper), u_pixel_coord_lower: new t4.bK(e6, i6.u_pixel_coord_lower), u_tile_units_to_pixels: new t4.b8(e6, i6.u_tile_units_to_pixels) }), terrain: (e6, i6) => ({ u_texture: new t4.bF(e6, i6.u_texture), u_ele_delta: new t4.b8(e6, i6.u_ele_delta), u_fog_matrix: new t4.bH(e6, i6.u_fog_matrix), u_fog_color: new t4.bG(e6, i6.u_fog_color), u_fog_ground_blend: new t4.b8(e6, i6.u_fog_ground_blend), u_fog_ground_blend_opacity: new t4.b8(e6, i6.u_fog_ground_blend_opacity), u_horizon_color: new t4.bG(e6, i6.u_horizon_color), u_horizon_fog_blend: new t4.b8(e6, i6.u_horizon_fog_blend), u_is_globe_mode: new t4.b8(e6, i6.u_is_globe_mode) }), terrainDepth: (e6, i6) => ({ u_ele_delta: new t4.b8(e6, i6.u_ele_delta) }), terrainCoords: (e6, i6) => ({ u_texture: new t4.bF(e6, i6.u_texture), u_terrain_coords_id: new t4.b8(e6, i6.u_terrain_coords_id), u_ele_delta: new t4.b8(e6, i6.u_ele_delta) }), projectionErrorMeasurement: (e6, i6) => ({ u_input: new t4.b8(e6, i6.u_input), u_output_expected: new t4.b8(e6, i6.u_output_expected) }), atmosphere: (e6, i6) => ({ u_sun_pos: new t4.bJ(e6, i6.u_sun_pos), u_atmosphere_blend: new t4.b8(e6, i6.u_atmosphere_blend), u_globe_position: new t4.bJ(e6, i6.u_globe_position), u_globe_radius: new t4.b8(e6, i6.u_globe_radius), u_inv_proj_matrix: new t4.bH(e6, i6.u_inv_proj_matrix) }), sky: (e6, i6) => ({ u_sky_color: new t4.bG(e6, i6.u_sky_color), u_horizon_color: new t4.bG(e6, i6.u_horizon_color), u_horizon: new t4.bK(e6, i6.u_horizon), u_horizon_normal: new t4.bK(e6, i6.u_horizon_normal), u_sky_horizon_blend: new t4.b8(e6, i6.u_sky_horizon_blend), u_sky_blend: new t4.b8(e6, i6.u_sky_blend) }) };
        class er {
          constructor(e6, t5, i6) {
            this.context = e6;
            const r8 = e6.gl;
            this.buffer = r8.createBuffer(), this.dynamicDraw = Boolean(i6), this.context.unbindVAO(), e6.bindElementBuffer.set(this.buffer), r8.bufferData(r8.ELEMENT_ARRAY_BUFFER, t5.arrayBuffer, this.dynamicDraw ? r8.DYNAMIC_DRAW : r8.STATIC_DRAW), this.dynamicDraw || delete t5.arrayBuffer;
          }
          bind() {
            this.context.bindElementBuffer.set(this.buffer);
          }
          updateData(e6) {
            const t5 = this.context.gl;
            if (!this.dynamicDraw) throw new Error("Attempted to update data while not in dynamic mode.");
            this.context.unbindVAO(), this.bind(), t5.bufferSubData(t5.ELEMENT_ARRAY_BUFFER, 0, e6.arrayBuffer);
          }
          destroy() {
            this.buffer && (this.context.gl.deleteBuffer(this.buffer), delete this.buffer);
          }
        }
        const tr = { Int8: "BYTE", Uint8: "UNSIGNED_BYTE", Int16: "SHORT", Uint16: "UNSIGNED_SHORT", Int32: "INT", Uint32: "UNSIGNED_INT", Float32: "FLOAT" };
        class ir {
          constructor(e6, t5, i6, r8) {
            this.length = t5.length, this.attributes = i6, this.itemSize = t5.bytesPerElement, this.dynamicDraw = r8, this.context = e6;
            const o6 = e6.gl;
            this.buffer = o6.createBuffer(), e6.bindVertexBuffer.set(this.buffer), o6.bufferData(o6.ARRAY_BUFFER, t5.arrayBuffer, this.dynamicDraw ? o6.DYNAMIC_DRAW : o6.STATIC_DRAW), this.dynamicDraw || delete t5.arrayBuffer;
          }
          bind() {
            this.context.bindVertexBuffer.set(this.buffer);
          }
          updateData(e6) {
            if (e6.length !== this.length) throw new Error(`Length of new data is ${e6.length}, which doesn't match current length of ${this.length}`);
            const t5 = this.context.gl;
            this.bind(), t5.bufferSubData(t5.ARRAY_BUFFER, 0, e6.arrayBuffer);
          }
          enableAttributes(e6, t5) {
            for (let i6 = 0; i6 < this.attributes.length; i6++) {
              const r8 = t5.attributes[this.attributes[i6].name];
              void 0 !== r8 && e6.enableVertexAttribArray(r8);
            }
          }
          setVertexAttribPointers(e6, t5, i6) {
            for (let r8 = 0; r8 < this.attributes.length; r8++) {
              const o6 = this.attributes[r8], a4 = t5.attributes[o6.name];
              void 0 !== a4 && e6.vertexAttribPointer(a4, o6.components, e6[tr[o6.type]], false, this.itemSize, o6.offset + this.itemSize * (i6 || 0));
            }
          }
          destroy() {
            this.buffer && (this.context.gl.deleteBuffer(this.buffer), delete this.buffer);
          }
        }
        class rr {
          constructor(e6) {
            this.gl = e6.gl, this.default = this.getDefault(), this.current = this.default, this.dirty = false;
          }
          get() {
            return this.current;
          }
          set(e6) {
          }
          getDefault() {
            return this.default;
          }
          setDefault() {
            this.set(this.default);
          }
        }
        class or extends rr {
          getDefault() {
            return t4.b7.transparent;
          }
          set(e6) {
            const t5 = this.current;
            (e6.r !== t5.r || e6.g !== t5.g || e6.b !== t5.b || e6.a !== t5.a || this.dirty) && (this.gl.clearColor(e6.r, e6.g, e6.b, e6.a), this.current = e6, this.dirty = false);
          }
        }
        class ar extends rr {
          getDefault() {
            return 1;
          }
          set(e6) {
            (e6 !== this.current || this.dirty) && (this.gl.clearDepth(e6), this.current = e6, this.dirty = false);
          }
        }
        class sr extends rr {
          getDefault() {
            return 0;
          }
          set(e6) {
            (e6 !== this.current || this.dirty) && (this.gl.clearStencil(e6), this.current = e6, this.dirty = false);
          }
        }
        class nr extends rr {
          getDefault() {
            return [true, true, true, true];
          }
          set(e6) {
            const t5 = this.current;
            (e6[0] !== t5[0] || e6[1] !== t5[1] || e6[2] !== t5[2] || e6[3] !== t5[3] || this.dirty) && (this.gl.colorMask(e6[0], e6[1], e6[2], e6[3]), this.current = e6, this.dirty = false);
          }
        }
        class lr extends rr {
          getDefault() {
            return true;
          }
          set(e6) {
            (e6 !== this.current || this.dirty) && (this.gl.depthMask(e6), this.current = e6, this.dirty = false);
          }
        }
        class cr extends rr {
          getDefault() {
            return 255;
          }
          set(e6) {
            (e6 !== this.current || this.dirty) && (this.gl.stencilMask(e6), this.current = e6, this.dirty = false);
          }
        }
        class hr extends rr {
          getDefault() {
            return { func: this.gl.ALWAYS, ref: 0, mask: 255 };
          }
          set(e6) {
            const t5 = this.current;
            (e6.func !== t5.func || e6.ref !== t5.ref || e6.mask !== t5.mask || this.dirty) && (this.gl.stencilFunc(e6.func, e6.ref, e6.mask), this.current = e6, this.dirty = false);
          }
        }
        class ur extends rr {
          getDefault() {
            const e6 = this.gl;
            return [e6.KEEP, e6.KEEP, e6.KEEP];
          }
          set(e6) {
            const t5 = this.current;
            (e6[0] !== t5[0] || e6[1] !== t5[1] || e6[2] !== t5[2] || this.dirty) && (this.gl.stencilOp(e6[0], e6[1], e6[2]), this.current = e6, this.dirty = false);
          }
        }
        class dr extends rr {
          getDefault() {
            return false;
          }
          set(e6) {
            if (e6 === this.current && !this.dirty) return;
            const t5 = this.gl;
            e6 ? t5.enable(t5.STENCIL_TEST) : t5.disable(t5.STENCIL_TEST), this.current = e6, this.dirty = false;
          }
        }
        class _r extends rr {
          getDefault() {
            return [0, 1];
          }
          set(e6) {
            const t5 = this.current;
            (e6[0] !== t5[0] || e6[1] !== t5[1] || this.dirty) && (this.gl.depthRange(e6[0], e6[1]), this.current = e6, this.dirty = false);
          }
        }
        class pr extends rr {
          getDefault() {
            return false;
          }
          set(e6) {
            if (e6 === this.current && !this.dirty) return;
            const t5 = this.gl;
            e6 ? t5.enable(t5.DEPTH_TEST) : t5.disable(t5.DEPTH_TEST), this.current = e6, this.dirty = false;
          }
        }
        class mr extends rr {
          getDefault() {
            return this.gl.LESS;
          }
          set(e6) {
            (e6 !== this.current || this.dirty) && (this.gl.depthFunc(e6), this.current = e6, this.dirty = false);
          }
        }
        class fr extends rr {
          getDefault() {
            return false;
          }
          set(e6) {
            if (e6 === this.current && !this.dirty) return;
            const t5 = this.gl;
            e6 ? t5.enable(t5.BLEND) : t5.disable(t5.BLEND), this.current = e6, this.dirty = false;
          }
        }
        class gr extends rr {
          getDefault() {
            const e6 = this.gl;
            return [e6.ONE, e6.ZERO];
          }
          set(e6) {
            const t5 = this.current;
            (e6[0] !== t5[0] || e6[1] !== t5[1] || this.dirty) && (this.gl.blendFunc(e6[0], e6[1]), this.current = e6, this.dirty = false);
          }
        }
        class vr extends rr {
          getDefault() {
            return t4.b7.transparent;
          }
          set(e6) {
            const t5 = this.current;
            (e6.r !== t5.r || e6.g !== t5.g || e6.b !== t5.b || e6.a !== t5.a || this.dirty) && (this.gl.blendColor(e6.r, e6.g, e6.b, e6.a), this.current = e6, this.dirty = false);
          }
        }
        class xr extends rr {
          getDefault() {
            return this.gl.FUNC_ADD;
          }
          set(e6) {
            (e6 !== this.current || this.dirty) && (this.gl.blendEquation(e6), this.current = e6, this.dirty = false);
          }
        }
        class br extends rr {
          getDefault() {
            return false;
          }
          set(e6) {
            if (e6 === this.current && !this.dirty) return;
            const t5 = this.gl;
            e6 ? t5.enable(t5.CULL_FACE) : t5.disable(t5.CULL_FACE), this.current = e6, this.dirty = false;
          }
        }
        class yr extends rr {
          getDefault() {
            return this.gl.BACK;
          }
          set(e6) {
            (e6 !== this.current || this.dirty) && (this.gl.cullFace(e6), this.current = e6, this.dirty = false);
          }
        }
        class wr extends rr {
          getDefault() {
            return this.gl.CCW;
          }
          set(e6) {
            (e6 !== this.current || this.dirty) && (this.gl.frontFace(e6), this.current = e6, this.dirty = false);
          }
        }
        class Tr extends rr {
          getDefault() {
            return null;
          }
          set(e6) {
            (e6 !== this.current || this.dirty) && (this.gl.useProgram(e6), this.current = e6, this.dirty = false);
          }
        }
        class Pr extends rr {
          getDefault() {
            return this.gl.TEXTURE0;
          }
          set(e6) {
            (e6 !== this.current || this.dirty) && (this.gl.activeTexture(e6), this.current = e6, this.dirty = false);
          }
        }
        class Cr extends rr {
          getDefault() {
            const e6 = this.gl;
            return [0, 0, e6.drawingBufferWidth, e6.drawingBufferHeight];
          }
          set(e6) {
            const t5 = this.current;
            (e6[0] !== t5[0] || e6[1] !== t5[1] || e6[2] !== t5[2] || e6[3] !== t5[3] || this.dirty) && (this.gl.viewport(e6[0], e6[1], e6[2], e6[3]), this.current = e6, this.dirty = false);
          }
        }
        class Ir extends rr {
          getDefault() {
            return null;
          }
          set(e6) {
            if (e6 === this.current && !this.dirty) return;
            const t5 = this.gl;
            t5.bindFramebuffer(t5.FRAMEBUFFER, e6), this.current = e6, this.dirty = false;
          }
        }
        class Mr extends rr {
          getDefault() {
            return null;
          }
          set(e6) {
            if (e6 === this.current && !this.dirty) return;
            const t5 = this.gl;
            t5.bindRenderbuffer(t5.RENDERBUFFER, e6), this.current = e6, this.dirty = false;
          }
        }
        class Er extends rr {
          getDefault() {
            return null;
          }
          set(e6) {
            if (e6 === this.current && !this.dirty) return;
            const t5 = this.gl;
            t5.bindTexture(t5.TEXTURE_2D, e6), this.current = e6, this.dirty = false;
          }
        }
        class Sr extends rr {
          getDefault() {
            return null;
          }
          set(e6) {
            if (e6 === this.current && !this.dirty) return;
            const t5 = this.gl;
            t5.bindBuffer(t5.ARRAY_BUFFER, e6), this.current = e6, this.dirty = false;
          }
        }
        class Rr extends rr {
          getDefault() {
            return null;
          }
          set(e6) {
            const t5 = this.gl;
            t5.bindBuffer(t5.ELEMENT_ARRAY_BUFFER, e6), this.current = e6, this.dirty = false;
          }
        }
        class Dr extends rr {
          getDefault() {
            return null;
          }
          set(e6) {
            var t5;
            if (e6 === this.current && !this.dirty) return;
            const i6 = this.gl;
            Ut(i6) ? i6.bindVertexArray(e6) : null === (t5 = i6.getExtension("OES_vertex_array_object")) || void 0 === t5 || t5.bindVertexArrayOES(e6), this.current = e6, this.dirty = false;
          }
        }
        class zr extends rr {
          getDefault() {
            return 4;
          }
          set(e6) {
            if (e6 === this.current && !this.dirty) return;
            const t5 = this.gl;
            t5.pixelStorei(t5.UNPACK_ALIGNMENT, e6), this.current = e6, this.dirty = false;
          }
        }
        class Ar extends rr {
          getDefault() {
            return false;
          }
          set(e6) {
            if (e6 === this.current && !this.dirty) return;
            const t5 = this.gl;
            t5.pixelStorei(t5.UNPACK_PREMULTIPLY_ALPHA_WEBGL, e6), this.current = e6, this.dirty = false;
          }
        }
        class Lr extends rr {
          getDefault() {
            return false;
          }
          set(e6) {
            if (e6 === this.current && !this.dirty) return;
            const t5 = this.gl;
            t5.pixelStorei(t5.UNPACK_FLIP_Y_WEBGL, e6), this.current = e6, this.dirty = false;
          }
        }
        class kr extends rr {
          constructor(e6, t5) {
            super(e6), this.context = e6, this.parent = t5;
          }
          getDefault() {
            return null;
          }
        }
        class Fr extends kr {
          setDirty() {
            this.dirty = true;
          }
          set(e6) {
            if (e6 === this.current && !this.dirty) return;
            this.context.bindFramebuffer.set(this.parent);
            const t5 = this.gl;
            t5.framebufferTexture2D(t5.FRAMEBUFFER, t5.COLOR_ATTACHMENT0, t5.TEXTURE_2D, e6, 0), this.current = e6, this.dirty = false;
          }
        }
        class Br extends kr {
          set(e6) {
            if (e6 === this.current && !this.dirty) return;
            this.context.bindFramebuffer.set(this.parent);
            const t5 = this.gl;
            t5.framebufferRenderbuffer(t5.FRAMEBUFFER, t5.DEPTH_ATTACHMENT, t5.RENDERBUFFER, e6), this.current = e6, this.dirty = false;
          }
        }
        class Or extends kr {
          set(e6) {
            if (e6 === this.current && !this.dirty) return;
            this.context.bindFramebuffer.set(this.parent);
            const t5 = this.gl;
            t5.framebufferRenderbuffer(t5.FRAMEBUFFER, t5.DEPTH_STENCIL_ATTACHMENT, t5.RENDERBUFFER, e6), this.current = e6, this.dirty = false;
          }
        }
        const jr = "Framebuffer is not complete";
        class Zr {
          constructor(e6, t5, i6, r8, o6) {
            this.context = e6, this.width = t5, this.height = i6;
            const a4 = e6.gl, s4 = this.framebuffer = a4.createFramebuffer();
            if (this.colorAttachment = new Fr(e6, s4), r8) this.depthAttachment = o6 ? new Or(e6, s4) : new Br(e6, s4);
            else if (o6) throw new Error("Stencil cannot be set without depth");
            if (a4.checkFramebufferStatus(a4.FRAMEBUFFER) !== a4.FRAMEBUFFER_COMPLETE) throw new Error(jr);
          }
          destroy() {
            const e6 = this.context.gl, t5 = this.colorAttachment.get();
            if (t5 && e6.deleteTexture(t5), this.depthAttachment) {
              const t6 = this.depthAttachment.get();
              t6 && e6.deleteRenderbuffer(t6);
            }
            e6.deleteFramebuffer(this.framebuffer);
          }
        }
        class Nr {
          constructor(e6) {
            var t5, i6;
            if (this.gl = e6, this.clearColor = new or(this), this.clearDepth = new ar(this), this.clearStencil = new sr(this), this.colorMask = new nr(this), this.depthMask = new lr(this), this.stencilMask = new cr(this), this.stencilFunc = new hr(this), this.stencilOp = new ur(this), this.stencilTest = new dr(this), this.depthRange = new _r(this), this.depthTest = new pr(this), this.depthFunc = new mr(this), this.blend = new fr(this), this.blendFunc = new gr(this), this.blendColor = new vr(this), this.blendEquation = new xr(this), this.cullFace = new br(this), this.cullFaceSide = new yr(this), this.frontFace = new wr(this), this.program = new Tr(this), this.activeTexture = new Pr(this), this.viewport = new Cr(this), this.bindFramebuffer = new Ir(this), this.bindRenderbuffer = new Mr(this), this.bindTexture = new Er(this), this.bindVertexBuffer = new Sr(this), this.bindElementBuffer = new Rr(this), this.bindVertexArray = new Dr(this), this.pixelStoreUnpack = new zr(this), this.pixelStoreUnpackPremultiplyAlpha = new Ar(this), this.pixelStoreUnpackFlipY = new Lr(this), this.extTextureFilterAnisotropic = e6.getExtension("EXT_texture_filter_anisotropic") || e6.getExtension("MOZ_EXT_texture_filter_anisotropic") || e6.getExtension("WEBKIT_EXT_texture_filter_anisotropic"), this.extTextureFilterAnisotropic && (this.extTextureFilterAnisotropicMax = e6.getParameter(this.extTextureFilterAnisotropic.MAX_TEXTURE_MAX_ANISOTROPY_EXT)), this.maxTextureSize = e6.getParameter(e6.MAX_TEXTURE_SIZE), Ut(e6)) {
              this.HALF_FLOAT = e6.HALF_FLOAT;
              const r8 = e6.getExtension("EXT_color_buffer_half_float");
              this.RGBA16F = null !== (t5 = e6.RGBA16F) && void 0 !== t5 ? t5 : null == r8 ? void 0 : r8.RGBA16F_EXT, this.RGB16F = null !== (i6 = e6.RGB16F) && void 0 !== i6 ? i6 : null == r8 ? void 0 : r8.RGB16F_EXT, e6.getExtension("EXT_color_buffer_float");
            } else {
              e6.getExtension("EXT_color_buffer_half_float"), e6.getExtension("OES_texture_half_float_linear");
              const t6 = e6.getExtension("OES_texture_half_float");
              this.HALF_FLOAT = null == t6 ? void 0 : t6.HALF_FLOAT_OES;
            }
          }
          setDefault() {
            this.unbindVAO(), this.clearColor.setDefault(), this.clearDepth.setDefault(), this.clearStencil.setDefault(), this.colorMask.setDefault(), this.depthMask.setDefault(), this.stencilMask.setDefault(), this.stencilFunc.setDefault(), this.stencilOp.setDefault(), this.stencilTest.setDefault(), this.depthRange.setDefault(), this.depthTest.setDefault(), this.depthFunc.setDefault(), this.blend.setDefault(), this.blendFunc.setDefault(), this.blendColor.setDefault(), this.blendEquation.setDefault(), this.cullFace.setDefault(), this.cullFaceSide.setDefault(), this.frontFace.setDefault(), this.program.setDefault(), this.activeTexture.setDefault(), this.bindFramebuffer.setDefault(), this.pixelStoreUnpack.setDefault(), this.pixelStoreUnpackPremultiplyAlpha.setDefault(), this.pixelStoreUnpackFlipY.setDefault();
          }
          setDirty() {
            this.clearColor.dirty = true, this.clearDepth.dirty = true, this.clearStencil.dirty = true, this.colorMask.dirty = true, this.depthMask.dirty = true, this.stencilMask.dirty = true, this.stencilFunc.dirty = true, this.stencilOp.dirty = true, this.stencilTest.dirty = true, this.depthRange.dirty = true, this.depthTest.dirty = true, this.depthFunc.dirty = true, this.blend.dirty = true, this.blendFunc.dirty = true, this.blendColor.dirty = true, this.blendEquation.dirty = true, this.cullFace.dirty = true, this.cullFaceSide.dirty = true, this.frontFace.dirty = true, this.program.dirty = true, this.activeTexture.dirty = true, this.viewport.dirty = true, this.bindFramebuffer.dirty = true, this.bindRenderbuffer.dirty = true, this.bindTexture.dirty = true, this.bindVertexBuffer.dirty = true, this.bindElementBuffer.dirty = true, this.bindVertexArray.dirty = true, this.pixelStoreUnpack.dirty = true, this.pixelStoreUnpackPremultiplyAlpha.dirty = true, this.pixelStoreUnpackFlipY.dirty = true;
          }
          createIndexBuffer(e6, t5) {
            return new er(this, e6, t5);
          }
          createVertexBuffer(e6, t5, i6) {
            return new ir(this, e6, t5, i6);
          }
          createRenderbuffer(e6, t5, i6) {
            const r8 = this.gl, o6 = r8.createRenderbuffer();
            return this.bindRenderbuffer.set(o6), r8.renderbufferStorage(r8.RENDERBUFFER, e6, t5, i6), this.bindRenderbuffer.set(null), o6;
          }
          createFramebuffer(e6, t5, i6, r8) {
            return new Zr(this, e6, t5, i6, r8);
          }
          clear({ color: e6, depth: t5, stencil: i6 }) {
            const r8 = this.gl;
            let o6 = 0;
            e6 && (o6 |= r8.COLOR_BUFFER_BIT, this.clearColor.set(e6), this.colorMask.set([true, true, true, true])), void 0 !== t5 && (o6 |= r8.DEPTH_BUFFER_BIT, this.depthRange.set([0, 1]), this.clearDepth.set(t5), this.depthMask.set(true)), void 0 !== i6 && (o6 |= r8.STENCIL_BUFFER_BIT, this.clearStencil.set(i6), this.stencilMask.set(255)), r8.clear(o6);
          }
          setCullFace(e6) {
            false === e6.enable ? this.cullFace.set(false) : (this.cullFace.set(true), this.cullFaceSide.set(e6.mode), this.frontFace.set(e6.frontFace));
          }
          setDepthMode(e6) {
            e6.func !== this.gl.ALWAYS || e6.mask ? (this.depthTest.set(true), this.depthFunc.set(e6.func), this.depthMask.set(e6.mask), this.depthRange.set(e6.range)) : this.depthTest.set(false);
          }
          setStencilMode(e6) {
            e6.test.func !== this.gl.ALWAYS || e6.mask ? (this.stencilTest.set(true), this.stencilMask.set(e6.mask), this.stencilOp.set([e6.fail, e6.depthFail, e6.pass]), this.stencilFunc.set({ func: e6.test.func, ref: e6.ref, mask: e6.test.mask })) : this.stencilTest.set(false);
          }
          setColorMode(e6) {
            t4.bC(e6.blendFunction, Ft.Replace) ? this.blend.set(false) : (this.blend.set(true), this.blendFunc.set(e6.blendFunction), this.blendColor.set(e6.blendColor)), this.colorMask.set(e6.mask);
          }
          createVertexArray() {
            var e6;
            return Ut(this.gl) ? this.gl.createVertexArray() : null === (e6 = this.gl.getExtension("OES_vertex_array_object")) || void 0 === e6 ? void 0 : e6.createVertexArrayOES();
          }
          deleteVertexArray(e6) {
            var t5;
            return Ut(this.gl) ? this.gl.deleteVertexArray(e6) : null === (t5 = this.gl.getExtension("OES_vertex_array_object")) || void 0 === t5 ? void 0 : t5.deleteVertexArrayOES(e6);
          }
          unbindVAO() {
            this.bindVertexArray.set(null);
          }
        }
        let Gr;
        function Ur(e6, i6, r8, o6, a4) {
          const s4 = e6.context, n6 = e6.transform, l5 = s4.gl, c5 = e6.useProgram("collisionBox"), h4 = [];
          let u4 = 0, d4 = 0;
          for (let t5 = 0; t5 < o6.length; t5++) {
            const _5 = o6[t5], p5 = i6.getTile(_5).getBucket(r8);
            if (!p5) continue;
            const m5 = a4 ? p5.textCollisionBox : p5.iconCollisionBox, f5 = p5.collisionCircleArray;
            f5.length > 0 && (h4.push({ circleArray: f5, circleOffset: d4, coord: _5 }), u4 += f5.length / 4, d4 = u4), m5 && c5.draw(s4, l5.LINES, jt.disabled, Nt.disabled, e6.colorModeForRenderPass(), Ot.disabled, Di(e6.transform), e6.style.map.terrain && e6.style.map.terrain.getTerrainData(_5), n6.getProjectionData({ overscaledTileID: _5, applyGlobeMatrix: true, applyTerrainMatrix: true }), r8.id, m5.layoutVertexBuffer, m5.indexBuffer, m5.segments, null, e6.transform.zoom, null, null, m5.collisionVertexBuffer);
          }
          if (!a4 || !h4.length) return;
          const _4 = e6.useProgram("collisionCircle"), p4 = new t4.bP();
          p4.resize(4 * u4), p4._trim();
          let m4 = 0;
          for (const e7 of h4) for (let t5 = 0; t5 < e7.circleArray.length / 4; t5++) {
            const i7 = 4 * t5, r9 = e7.circleArray[i7 + 0], o7 = e7.circleArray[i7 + 1], a5 = e7.circleArray[i7 + 2], s5 = e7.circleArray[i7 + 3];
            p4.emplace(m4++, r9, o7, a5, s5, 0), p4.emplace(m4++, r9, o7, a5, s5, 1), p4.emplace(m4++, r9, o7, a5, s5, 2), p4.emplace(m4++, r9, o7, a5, s5, 3);
          }
          (!Gr || Gr.length < 2 * u4) && (Gr = function(e7) {
            const i7 = 2 * e7, r9 = new t4.bR();
            r9.resize(i7), r9._trim();
            for (let e8 = 0; e8 < i7; e8++) {
              const t5 = 6 * e8;
              r9.uint16[t5 + 0] = 4 * e8 + 0, r9.uint16[t5 + 1] = 4 * e8 + 1, r9.uint16[t5 + 2] = 4 * e8 + 2, r9.uint16[t5 + 3] = 4 * e8 + 2, r9.uint16[t5 + 4] = 4 * e8 + 3, r9.uint16[t5 + 5] = 4 * e8 + 0;
            }
            return r9;
          }(u4));
          const f4 = s4.createIndexBuffer(Gr, true), g4 = s4.createVertexBuffer(p4, t4.bQ.members, true);
          for (const i7 of h4) {
            const o7 = zi(e6.transform);
            _4.draw(s4, l5.TRIANGLES, jt.disabled, Nt.disabled, e6.colorModeForRenderPass(), Ot.disabled, o7, e6.style.map.terrain && e6.style.map.terrain.getTerrainData(i7.coord), null, r8.id, g4, f4, t4.aG.simpleSegment(0, 2 * i7.circleOffset, i7.circleArray.length, i7.circleArray.length / 2), null, e6.transform.zoom, null, null, null);
          }
          g4.destroy(), f4.destroy();
        }
        const Vr = t4.at(new Float32Array(16));
        function qr(e6, i6, r8, o6, a4, s4) {
          const { horizontalAlign: n6, verticalAlign: l5 } = t4.aB(e6);
          return new t4.P((-(n6 - 0.5) * i6 / a4 + o6[0]) * s4, (-(l5 - 0.5) * r8 / a4 + o6[1]) * s4);
        }
        function Wr(e6, i6, r8, o6, a4, s4) {
          const n6 = i6.tileAnchorPoint.add(new t4.P(i6.translation[0], i6.translation[1]));
          if (i6.pitchWithMap) {
            let e7 = o6.mult(s4);
            r8 || (e7 = e7.rotate(-a4));
            const t5 = n6.add(e7);
            return ye(t5.x, t5.y, i6.pitchedLabelPlaneMatrix, i6.getElevation).point;
          }
          if (r8) {
            const t5 = Re(i6.tileAnchorPoint.x + 1, i6.tileAnchorPoint.y, i6).point.sub(e6), r9 = Math.atan(t5.y / t5.x) + (t5.x < 0 ? Math.PI : 0);
            return e6.add(o6.rotate(r9));
          }
          return e6.add(o6);
        }
        function $r(e6, i6, r8, o6, a4, s4, n6, l5, c5, h4, u4, d4) {
          const _4 = e6.text.placedSymbolArray, p4 = e6.text.dynamicLayoutVertexArray, m4 = e6.icon.dynamicLayoutVertexArray, f4 = {};
          p4.clear();
          for (let m5 = 0; m5 < _4.length; m5++) {
            const g4 = _4.get(m5), v4 = g4.hidden || !g4.crossTileID || e6.allowVerticalPlacement && !g4.placedOrientation ? null : o6[g4.crossTileID];
            if (v4) {
              const o7 = new t4.P(g4.anchorX, g4.anchorY), _5 = { getElevation: d4, width: a4.width, height: a4.height, pitchedLabelPlaneMatrix: s4, pitchWithMap: r8, transform: a4, tileAnchorPoint: o7, translation: h4, unwrappedTileID: u4 }, m6 = r8 ? ze(o7.x, o7.y, _5) : Re(o7.x, o7.y, _5), x4 = we(a4.cameraToCenterDistance, m6.signedDistanceFromCamera);
              let b5 = t4.ai(e6.textSizeData, l5, g4) * x4 / t4.av;
              r8 && (b5 *= e6.tilePixelRatio / n6);
              const { width: y4, height: w4, anchor: T5, textOffset: P4, textBoxScale: C4 } = v4, I4 = qr(T5, y4, w4, P4, C4, b5), M5 = a4.getPitchedTextCorrection(o7.x + h4[0], o7.y + h4[1], u4), E4 = Wr(m6.point, _5, i6, I4, -a4.bearingInRadians, M5), S5 = e6.allowVerticalPlacement && g4.placedOrientation === t4.ah.vertical ? Math.PI / 2 : 0;
              for (let e7 = 0; e7 < g4.numGlyphs; e7++) t4.ao(p4, E4, S5);
              c5 && g4.associatedIconIndex >= 0 && (f4[g4.associatedIconIndex] = { shiftedAnchor: E4, angle: S5 });
            } else Be(g4.numGlyphs, p4);
          }
          if (c5) {
            m4.clear();
            const i7 = e6.icon.placedSymbolArray;
            for (let e7 = 0; e7 < i7.length; e7++) {
              const r9 = i7.get(e7);
              if (r9.hidden) Be(r9.numGlyphs, m4);
              else {
                const i8 = f4[e7];
                if (i8) for (let e8 = 0; e8 < r9.numGlyphs; e8++) t4.ao(m4, i8.shiftedAnchor, i8.angle);
                else Be(r9.numGlyphs, m4);
              }
            }
            e6.icon.dynamicLayoutVertexBuffer.updateData(m4);
          }
          e6.text.dynamicLayoutVertexBuffer.updateData(p4);
        }
        function Hr(e6, t5, i6) {
          return i6.iconsInText && t5 ? "symbolTextAndIcon" : e6 ? "symbolSDF" : "symbolIcon";
        }
        function Kr(e6, i6, r8, o6, a4, s4, n6, l5, c5, h4, u4, d4, _4) {
          const p4 = e6.context, m4 = p4.gl, f4 = e6.transform, g4 = "map" === l5, v4 = "map" === c5, x4 = "viewport" !== l5 && "point" !== r8.layout.get("symbol-placement"), b5 = g4 && !v4 && !x4, y4 = !r8.layout.get("symbol-sort-key").isConstant();
          let w4 = false;
          const T5 = e6.getDepthModeForSublayer(0, jt.ReadOnly), P4 = r8._unevaluatedLayout.hasValue("text-variable-anchor") || r8._unevaluatedLayout.hasValue("text-variable-anchor-offset"), C4 = [], I4 = f4.getCircleRadiusCorrection();
          for (const l6 of o6) {
            const o7 = i6.getTile(l6), c6 = o7.getBucket(r8);
            if (!c6) continue;
            const u5 = a4 ? c6.text : c6.icon;
            if (!u5 || !u5.segments.get().length || !u5.hasVisibleVertices) continue;
            const d5 = u5.programConfigurations.get(r8.id), p5 = a4 || c6.sdfIcons, T6 = a4 ? c6.textSizeData : c6.iconSizeData, M5 = v4 || 0 !== f4.pitch, E4 = e6.useProgram(Hr(p5, a4, c6), d5), S5 = t4.ag(T6, f4.zoom), R5 = e6.style.map.terrain && e6.style.map.terrain.getTerrainData(l6);
            let D3, z4, A5, L4, k4 = [0, 0], F3 = null;
            if (a4) z4 = o7.glyphAtlasTexture, A5 = m4.LINEAR, D3 = o7.glyphAtlasTexture.size, c6.iconsInText && (k4 = o7.imageAtlasTexture.size, F3 = o7.imageAtlasTexture, L4 = M5 || e6.options.rotating || e6.options.zooming || "composite" === T6.kind || "camera" === T6.kind ? m4.LINEAR : m4.NEAREST);
            else {
              const t5 = 1 !== r8.layout.get("icon-size").constantOr(0) || c6.iconsNeedLinear;
              z4 = o7.imageAtlasTexture, A5 = p5 || e6.options.rotating || e6.options.zooming || t5 || M5 ? m4.LINEAR : m4.NEAREST, D3 = o7.imageAtlasTexture.size;
            }
            const B5 = t4.aw(o7, 1, e6.transform.zoom), O3 = ve(g4, e6.transform, B5), j4 = t4.K();
            t4.aj(j4, O3);
            const Z3 = xe(v4, g4, e6.transform, B5), N4 = t4.ax(f4, o7, s4, n6), G3 = f4.getProjectionData({ overscaledTileID: l6, applyGlobeMatrix: !_4, applyTerrainMatrix: true }), U4 = P4 && c6.hasTextData(), V3 = "none" !== r8.layout.get("icon-text-fit") && U4 && c6.hasIconData();
            if (x4) {
              const t5 = e6.style.map.terrain ? (t6, i8) => e6.style.map.terrain.getElevation(l6, t6, i8) : null, i7 = "map" === r8.layout.get("text-rotation-alignment");
              Pe(c6, e6, a4, O3, j4, v4, h4, i7, l6.toUnwrapped(), f4.width, f4.height, N4, t5);
            }
            const q3 = a4 && P4 || V3, W2 = x4 || q3 ? Vr : v4 ? O3 : e6.transform.clipSpaceToPixelsMatrix, $3 = p5 && 0 !== r8.paint.get(a4 ? "text-halo-width" : "icon-halo-width").constantOr(1);
            let H5;
            H5 = p5 ? c6.iconsInText ? Ki(T6.kind, S5, b5, v4, x4, q3, e6, W2, Z3, N4, D3, k4, I4) : Hi(T6.kind, S5, b5, v4, x4, q3, e6, W2, Z3, N4, a4, D3, 0, I4) : $i(T6.kind, S5, b5, v4, x4, q3, e6, W2, Z3, N4, a4, D3, I4);
            const K3 = { program: E4, buffers: u5, uniformValues: H5, projectionData: G3, atlasTexture: z4, atlasTextureIcon: F3, atlasInterpolation: A5, atlasInterpolationIcon: L4, isSDF: p5, hasHalo: $3 };
            if (y4 && c6.canOverlap) {
              w4 = true;
              const e7 = u5.segments.get();
              for (const i7 of e7) C4.push({ segments: new t4.aG([i7]), sortKey: i7.sortKey, state: K3, terrainData: R5 });
            } else C4.push({ segments: u5.segments, sortKey: 0, state: K3, terrainData: R5 });
          }
          w4 && C4.sort((e7, t5) => e7.sortKey - t5.sortKey);
          for (const t5 of C4) {
            const i7 = t5.state;
            if (p4.activeTexture.set(m4.TEXTURE0), i7.atlasTexture.bind(i7.atlasInterpolation, m4.CLAMP_TO_EDGE), i7.atlasTextureIcon && (p4.activeTexture.set(m4.TEXTURE1), i7.atlasTextureIcon && i7.atlasTextureIcon.bind(i7.atlasInterpolationIcon, m4.CLAMP_TO_EDGE)), i7.isSDF) {
              const o7 = i7.uniformValues;
              i7.hasHalo && (o7.u_is_halo = 1, Xr(i7.buffers, t5.segments, r8, e6, i7.program, T5, u4, d4, o7, i7.projectionData, t5.terrainData)), o7.u_is_halo = 0;
            }
            Xr(i7.buffers, t5.segments, r8, e6, i7.program, T5, u4, d4, i7.uniformValues, i7.projectionData, t5.terrainData);
          }
        }
        function Xr(e6, t5, i6, r8, o6, a4, s4, n6, l5, c5, h4) {
          const u4 = r8.context;
          o6.draw(u4, u4.gl.TRIANGLES, a4, s4, n6, Ot.backCCW, l5, h4, c5, i6.id, e6.layoutVertexBuffer, e6.indexBuffer, t5, i6.paint, r8.transform.zoom, e6.programConfigurations.get(i6.id), e6.dynamicLayoutVertexBuffer, e6.opacityVertexBuffer);
        }
        function Qr(e6, i6, r8, o6, a4) {
          const s4 = e6.context, n6 = s4.gl, l5 = Nt.disabled, c5 = new Ft([n6.ONE, n6.ONE], t4.b7.transparent, [true, true, true, true]), h4 = i6.getBucket(r8);
          if (!h4) return;
          const u4 = o6.key;
          let d4 = r8.heatmapFbos.get(u4);
          d4 || (d4 = Jr(s4, i6.tileSize, i6.tileSize), r8.heatmapFbos.set(u4, d4)), s4.bindFramebuffer.set(d4.framebuffer), s4.viewport.set([0, 0, i6.tileSize, i6.tileSize]), s4.clear({ color: t4.b7.transparent });
          const _4 = h4.programConfigurations.get(r8.id), p4 = e6.useProgram("heatmap", _4, !a4), m4 = e6.transform.getProjectionData({ overscaledTileID: i6.tileID, applyGlobeMatrix: true, applyTerrainMatrix: true }), f4 = e6.style.map.terrain.getTerrainData(o6);
          p4.draw(s4, n6.TRIANGLES, jt.disabled, l5, c5, Ot.disabled, Li(i6, e6.transform.zoom, r8.paint.get("heatmap-intensity"), 1), f4, m4, r8.id, h4.layoutVertexBuffer, h4.indexBuffer, h4.segments, r8.paint, e6.transform.zoom, _4);
        }
        function Yr(e6, t5, i6, r8, o6) {
          const a4 = e6.context, s4 = a4.gl, n6 = e6.transform;
          a4.setColorMode(e6.colorModeForRenderPass());
          const l5 = eo(a4, t5), c5 = i6.key, h4 = t5.heatmapFbos.get(c5);
          if (!h4) return;
          a4.activeTexture.set(s4.TEXTURE0), s4.bindTexture(s4.TEXTURE_2D, h4.colorAttachment.get()), a4.activeTexture.set(s4.TEXTURE1), l5.bind(s4.LINEAR, s4.CLAMP_TO_EDGE);
          const u4 = n6.getProjectionData({ overscaledTileID: i6, applyTerrainMatrix: o6, applyGlobeMatrix: !r8 });
          e6.useProgram("heatmapTexture").draw(a4, s4.TRIANGLES, jt.disabled, Nt.disabled, e6.colorModeForRenderPass(), Ot.disabled, ki(e6, t5, 0, 1), null, u4, t5.id, e6.rasterBoundsBuffer, e6.quadTriangleIndexBuffer, e6.rasterBoundsSegments, t5.paint, n6.zoom), h4.destroy(), t5.heatmapFbos.delete(c5);
        }
        function Jr(e6, t5, i6) {
          var r8, o6;
          const a4 = e6.gl, s4 = a4.createTexture();
          a4.bindTexture(a4.TEXTURE_2D, s4), a4.texParameteri(a4.TEXTURE_2D, a4.TEXTURE_WRAP_S, a4.CLAMP_TO_EDGE), a4.texParameteri(a4.TEXTURE_2D, a4.TEXTURE_WRAP_T, a4.CLAMP_TO_EDGE), a4.texParameteri(a4.TEXTURE_2D, a4.TEXTURE_MIN_FILTER, a4.LINEAR), a4.texParameteri(a4.TEXTURE_2D, a4.TEXTURE_MAG_FILTER, a4.LINEAR);
          const n6 = null !== (r8 = e6.HALF_FLOAT) && void 0 !== r8 ? r8 : a4.UNSIGNED_BYTE, l5 = null !== (o6 = e6.RGBA16F) && void 0 !== o6 ? o6 : a4.RGBA;
          a4.texImage2D(a4.TEXTURE_2D, 0, l5, t5, i6, 0, a4.RGBA, n6, null);
          const c5 = e6.createFramebuffer(t5, i6, false, false);
          return c5.colorAttachment.set(s4), c5;
        }
        function eo(e6, t5) {
          return t5.colorRampTexture || (t5.colorRampTexture = new v3(e6, t5.colorRamp, e6.gl.RGBA)), t5.colorRampTexture;
        }
        function to(e6, t5, i6, r8, o6) {
          if (!i6 || !r8 || !r8.imageAtlas) return;
          const a4 = r8.imageAtlas.patternPositions;
          let s4 = a4[i6.to.toString()], n6 = a4[i6.from.toString()];
          if (!s4 && n6 && (s4 = n6), !n6 && s4 && (n6 = s4), !s4 || !n6) {
            const e7 = o6.getPaintProperty(t5);
            s4 = a4[e7], n6 = a4[e7];
          }
          s4 && n6 && e6.setConstantPatternPositions(s4, n6);
        }
        function io(e6, i6, r8, o6, a4, s4, n6, l5) {
          const c5 = e6.context.gl, h4 = "fill-pattern", u4 = r8.paint.get(h4), d4 = u4 && u4.constantOr(1), _4 = r8.getCrossfadeParameters();
          let p4, m4, f4, g4, v4;
          const x4 = e6.transform, b5 = r8.paint.get("fill-translate"), y4 = r8.paint.get("fill-translate-anchor");
          n6 ? (m4 = d4 && !r8.getPaintProperty("fill-outline-color") ? "fillOutlinePattern" : "fillOutline", p4 = c5.LINES) : (m4 = d4 ? "fillPattern" : "fill", p4 = c5.TRIANGLES);
          const w4 = u4.constantOr(null);
          for (const u5 of o6) {
            const T5 = i6.getTile(u5);
            if (d4 && !T5.patternsLoaded()) continue;
            const P4 = T5.getBucket(r8);
            if (!P4) continue;
            const C4 = P4.programConfigurations.get(r8.id), I4 = e6.useProgram(m4, C4), M5 = e6.style.map.terrain && e6.style.map.terrain.getTerrainData(u5);
            d4 && (e6.context.activeTexture.set(c5.TEXTURE0), T5.imageAtlasTexture.bind(c5.LINEAR, c5.CLAMP_TO_EDGE), C4.updatePaintBuffers(_4)), to(C4, h4, w4, T5, r8);
            const E4 = x4.getProjectionData({ overscaledTileID: u5, applyGlobeMatrix: !l5, applyTerrainMatrix: true }), S5 = t4.ax(x4, T5, b5, y4);
            if (n6) {
              g4 = P4.indexBuffer2, v4 = P4.segments2;
              const t5 = [c5.drawingBufferWidth, c5.drawingBufferHeight];
              f4 = "fillOutlinePattern" === m4 && d4 ? Si(e6, _4, T5, t5, S5) : Ei(t5, S5);
            } else g4 = P4.indexBuffer, v4 = P4.segments, f4 = d4 ? Mi(e6, _4, T5, S5) : { u_fill_translate: S5 };
            let R5;
            if ("translucent" === e6.renderPass && l5) {
              const [t5] = e6.getStencilConfigForOverlapAndUpdateStencilID(o6);
              R5 = t5[u5.overscaledZ];
            } else R5 = e6.stencilModeForClipping(u5);
            I4.draw(e6.context, p4, a4, R5, s4, Ot.backCCW, f4, M5, E4, r8.id, P4.layoutVertexBuffer, g4, v4, r8.paint, e6.transform.zoom, C4);
          }
        }
        function ro(e6, i6, r8, o6, a4, s4, n6, l5) {
          const c5 = e6.context, h4 = c5.gl, u4 = "fill-extrusion-pattern", d4 = r8.paint.get(u4), _4 = d4.constantOr(1), p4 = r8.getCrossfadeParameters(), m4 = r8.paint.get("fill-extrusion-opacity"), f4 = d4.constantOr(null), g4 = e6.transform;
          for (const d5 of o6) {
            const o7 = i6.getTile(d5), v4 = o7.getBucket(r8);
            if (!v4) continue;
            const x4 = e6.style.map.terrain && e6.style.map.terrain.getTerrainData(d5), b5 = v4.programConfigurations.get(r8.id), y4 = e6.useProgram(_4 ? "fillExtrusionPattern" : "fillExtrusion", b5);
            _4 && (e6.context.activeTexture.set(h4.TEXTURE0), o7.imageAtlasTexture.bind(h4.LINEAR, h4.CLAMP_TO_EDGE), b5.updatePaintBuffers(p4));
            const w4 = g4.getProjectionData({ overscaledTileID: d5, applyGlobeMatrix: !l5, applyTerrainMatrix: true });
            to(b5, u4, f4, o7, r8);
            const T5 = t4.ax(g4, o7, r8.paint.get("fill-extrusion-translate"), r8.paint.get("fill-extrusion-translate-anchor")), P4 = r8.paint.get("fill-extrusion-vertical-gradient"), C4 = _4 ? Ii(e6, P4, m4, T5, d5, p4, o7) : Ci(e6, P4, m4, T5);
            y4.draw(c5, c5.gl.TRIANGLES, a4, s4, n6, Ot.backCCW, C4, x4, w4, r8.id, v4.layoutVertexBuffer, v4.indexBuffer, v4.segments, r8.paint, e6.transform.zoom, b5, e6.style.map.terrain && v4.centroidVertexBuffer);
          }
        }
        function oo(e6, t5, i6, r8, o6, a4, s4, n6, l5) {
          var c5;
          const h4 = e6.style.projection, u4 = e6.context, d4 = e6.transform, _4 = u4.gl, p4 = e6.useProgram("hillshade"), m4 = !e6.options.moving;
          for (const f4 of r8) {
            const r9 = t5.getTile(f4), g4 = r9.fbo;
            if (!g4) continue;
            const v4 = h4.getMeshFromTileID(u4, f4.canonical, n6, true, "raster"), x4 = null === (c5 = e6.style.map.terrain) || void 0 === c5 ? void 0 : c5.getTerrainData(f4);
            u4.activeTexture.set(_4.TEXTURE0), _4.bindTexture(_4.TEXTURE_2D, g4.colorAttachment.get());
            const b5 = d4.getProjectionData({ overscaledTileID: f4, aligned: m4, applyGlobeMatrix: !l5, applyTerrainMatrix: true });
            p4.draw(u4, _4.TRIANGLES, a4, o6[f4.overscaledZ], s4, Ot.backCCW, Fi(e6, r9, i6), x4, b5, i6.id, v4.vertexBuffer, v4.indexBuffer, v4.segments);
          }
        }
        const ao = [new t4.P(0, 0), new t4.P(t4.Z, 0), new t4.P(t4.Z, t4.Z), new t4.P(0, t4.Z)];
        function so(e6, t5, i6, r8, o6, a4, s4, n6, l5 = false, c5 = false) {
          const h4 = r8[r8.length - 1].overscaledZ, u4 = e6.context, d4 = u4.gl, _4 = e6.useProgram("raster"), p4 = e6.transform, m4 = e6.style.projection, f4 = e6.colorModeForRenderPass(), g4 = !e6.options.moving;
          for (const v4 of r8) {
            const r9 = e6.getDepthModeForSublayer(v4.overscaledZ - h4, 1 === i6.paint.get("raster-opacity") ? jt.ReadWrite : jt.ReadOnly, d4.LESS), x4 = t5.getTile(v4);
            x4.registerFadeDuration(i6.paint.get("raster-fade-duration"));
            const b5 = t5.findLoadedParent(v4, 0), y4 = t5.findLoadedSibling(v4), w4 = no(x4, b5 || y4 || null, t5, i6, e6.transform, e6.style.map.terrain);
            let T5, P4;
            const C4 = "nearest" === i6.paint.get("raster-resampling") ? d4.NEAREST : d4.LINEAR;
            u4.activeTexture.set(d4.TEXTURE0), x4.texture.bind(C4, d4.CLAMP_TO_EDGE, d4.LINEAR_MIPMAP_NEAREST), u4.activeTexture.set(d4.TEXTURE1), b5 ? (b5.texture.bind(C4, d4.CLAMP_TO_EDGE, d4.LINEAR_MIPMAP_NEAREST), T5 = Math.pow(2, b5.tileID.overscaledZ - x4.tileID.overscaledZ), P4 = [x4.tileID.canonical.x * T5 % 1, x4.tileID.canonical.y * T5 % 1]) : x4.texture.bind(C4, d4.CLAMP_TO_EDGE, d4.LINEAR_MIPMAP_NEAREST), x4.texture.useMipmap && u4.extTextureFilterAnisotropic && e6.transform.pitch > 20 && d4.texParameterf(d4.TEXTURE_2D, u4.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, u4.extTextureFilterAnisotropicMax);
            const I4 = e6.style.map.terrain && e6.style.map.terrain.getTerrainData(v4), M5 = p4.getProjectionData({ overscaledTileID: v4, aligned: g4, applyGlobeMatrix: !c5, applyTerrainMatrix: true }), E4 = qi(P4 || [0, 0], T5 || 1, w4, i6, n6), S5 = m4.getMeshFromTileID(u4, v4.canonical, a4, s4, "raster");
            _4.draw(u4, d4.TRIANGLES, r9, o6 ? o6[v4.overscaledZ] : Nt.disabled, f4, l5 ? Ot.frontCCW : Ot.backCCW, E4, I4, M5, i6.id, S5.vertexBuffer, S5.indexBuffer, S5.segments);
          }
        }
        function no(e6, i6, r8, o6, a4, n6) {
          const l5 = o6.paint.get("raster-fade-duration");
          if (!n6 && l5 > 0) {
            const o7 = s3.now(), n7 = (o7 - e6.timeAdded) / l5, c5 = i6 ? (o7 - i6.timeAdded) / l5 : -1, h4 = r8.getSource(), u4 = he(a4, { tileSize: h4.tileSize, roundZoom: h4.roundZoom }), d4 = !i6 || Math.abs(i6.tileID.overscaledZ - u4) > Math.abs(e6.tileID.overscaledZ - u4), _4 = d4 && e6.refreshedUponExpiration ? 1 : t4.ae(d4 ? n7 : 1 - c5, 0, 1);
            return e6.refreshedUponExpiration && n7 >= 1 && (e6.refreshedUponExpiration = false), i6 ? { opacity: 1, mix: 1 - _4 } : { opacity: _4, mix: 0 };
          }
          return { opacity: 1, mix: 0 };
        }
        const lo = new t4.b7(1, 0, 0, 1), co = new t4.b7(0, 1, 0, 1), ho = new t4.b7(0, 0, 1, 1), uo = new t4.b7(1, 0, 1, 1), _o = new t4.b7(0, 1, 1, 1);
        function po(e6, t5, i6, r8) {
          fo(e6, 0, t5 + i6 / 2, e6.transform.width, i6, r8);
        }
        function mo(e6, t5, i6, r8) {
          fo(e6, t5 - i6 / 2, 0, i6, e6.transform.height, r8);
        }
        function fo(e6, t5, i6, r8, o6, a4) {
          const s4 = e6.context, n6 = s4.gl;
          n6.enable(n6.SCISSOR_TEST), n6.scissor(t5 * e6.pixelRatio, i6 * e6.pixelRatio, r8 * e6.pixelRatio, o6 * e6.pixelRatio), s4.clear({ color: a4 }), n6.disable(n6.SCISSOR_TEST);
        }
        function go(e6, i6, r8) {
          const o6 = e6.context, a4 = o6.gl, s4 = e6.useProgram("debug"), n6 = jt.disabled, l5 = Nt.disabled, c5 = e6.colorModeForRenderPass(), h4 = "$debug", u4 = e6.style.map.terrain && e6.style.map.terrain.getTerrainData(r8);
          o6.activeTexture.set(a4.TEXTURE0);
          const d4 = i6.getTileByID(r8.key).latestRawTileData, _4 = Math.floor((d4 && d4.byteLength || 0) / 1024), p4 = i6.getTile(r8).tileSize, m4 = 512 / Math.min(p4, 512) * (r8.overscaledZ / e6.transform.zoom) * 0.5;
          let f4 = r8.canonical.toString();
          r8.overscaledZ !== r8.canonical.z && (f4 += ` => ${r8.overscaledZ}`), function(e7, t5) {
            e7.initDebugOverlayCanvas();
            const i7 = e7.debugOverlayCanvas, r9 = e7.context.gl, o7 = e7.debugOverlayCanvas.getContext("2d");
            o7.clearRect(0, 0, i7.width, i7.height), o7.shadowColor = "white", o7.shadowBlur = 2, o7.lineWidth = 1.5, o7.strokeStyle = "white", o7.textBaseline = "top", o7.font = "bold 36px Open Sans, sans-serif", o7.fillText(t5, 5, 5), o7.strokeText(t5, 5, 5), e7.debugOverlayTexture.update(i7), e7.debugOverlayTexture.bind(r9.LINEAR, r9.CLAMP_TO_EDGE);
          }(e6, `${f4} ${_4}kB`);
          const g4 = e6.transform.getProjectionData({ overscaledTileID: r8, applyGlobeMatrix: true, applyTerrainMatrix: true });
          s4.draw(o6, a4.TRIANGLES, n6, l5, Ft.alphaBlended, Ot.disabled, Ai(t4.b7.transparent, m4), null, g4, h4, e6.debugBuffer, e6.quadTriangleIndexBuffer, e6.debugSegments), s4.draw(o6, a4.LINE_STRIP, n6, l5, c5, Ot.disabled, Ai(t4.b7.red), u4, g4, h4, e6.debugBuffer, e6.tileBorderIndexBuffer, e6.debugSegments);
        }
        function vo(e6, t5, i6, r8) {
          const { isRenderingGlobe: o6 } = r8, a4 = e6.context, s4 = a4.gl, n6 = e6.transform, l5 = e6.colorModeForRenderPass(), c5 = e6.getDepthModeFor3D(), h4 = e6.useProgram("terrain");
          a4.bindFramebuffer.set(null), a4.viewport.set([0, 0, e6.width, e6.height]);
          for (const r9 of i6) {
            const i7 = t5.getTerrainMesh(r9.tileID), u4 = e6.renderToTexture.getTexture(r9), d4 = t5.getTerrainData(r9.tileID);
            a4.activeTexture.set(s4.TEXTURE0), s4.bindTexture(s4.TEXTURE_2D, u4.texture);
            const _4 = t5.getMeshFrameDelta(n6.zoom), p4 = n6.calculateFogMatrix(r9.tileID.toUnwrapped()), m4 = bi(_4, p4, e6.style.sky, n6.pitch, o6), f4 = n6.getProjectionData({ overscaledTileID: r9.tileID, applyTerrainMatrix: false, applyGlobeMatrix: true });
            h4.draw(a4, s4.TRIANGLES, c5, Nt.disabled, l5, Ot.backCCW, m4, d4, f4, "terrain", i7.vertexBuffer, i7.indexBuffer, i7.segments);
          }
        }
        function xo(e6, i6) {
          if (!i6.mesh) {
            const r8 = new t4.aF();
            r8.emplaceBack(-1, -1), r8.emplaceBack(1, -1), r8.emplaceBack(1, 1), r8.emplaceBack(-1, 1);
            const o6 = new t4.aH();
            o6.emplaceBack(0, 1, 2), o6.emplaceBack(0, 2, 3), i6.mesh = new pt(e6.createVertexBuffer(r8, mt.members), e6.createIndexBuffer(o6), t4.aG.simpleSegment(0, 0, r8.length, o6.length));
          }
          return i6.mesh;
        }
        class bo {
          constructor(e6, i6) {
            this.context = new Nr(e6), this.transform = i6, this._tileTextures = {}, this.terrainFacilitator = { dirty: true, matrix: t4.at(new Float64Array(16)), renderTime: 0 }, this.setup(), this.numSublayers = de.maxUnderzooming + de.maxOverzooming + 1, this.depthEpsilon = 1 / Math.pow(2, 16), this.crossTileSymbolIndex = new ht();
          }
          resize(e6, t5, i6) {
            if (this.width = Math.floor(e6 * i6), this.height = Math.floor(t5 * i6), this.pixelRatio = i6, this.context.viewport.set([0, 0, this.width, this.height]), this.style) for (const e7 of this.style._order) this.style._layers[e7].resize();
          }
          setup() {
            const e6 = this.context, i6 = new t4.aF();
            i6.emplaceBack(0, 0), i6.emplaceBack(t4.Z, 0), i6.emplaceBack(0, t4.Z), i6.emplaceBack(t4.Z, t4.Z), this.tileExtentBuffer = e6.createVertexBuffer(i6, mt.members), this.tileExtentSegments = t4.aG.simpleSegment(0, 0, 4, 2);
            const r8 = new t4.aF();
            r8.emplaceBack(0, 0), r8.emplaceBack(t4.Z, 0), r8.emplaceBack(0, t4.Z), r8.emplaceBack(t4.Z, t4.Z), this.debugBuffer = e6.createVertexBuffer(r8, mt.members), this.debugSegments = t4.aG.simpleSegment(0, 0, 4, 5);
            const o6 = new t4.bW();
            o6.emplaceBack(0, 0, 0, 0), o6.emplaceBack(t4.Z, 0, t4.Z, 0), o6.emplaceBack(0, t4.Z, 0, t4.Z), o6.emplaceBack(t4.Z, t4.Z, t4.Z, t4.Z), this.rasterBoundsBuffer = e6.createVertexBuffer(o6, vi.members), this.rasterBoundsSegments = t4.aG.simpleSegment(0, 0, 4, 2);
            const a4 = new t4.aF();
            a4.emplaceBack(0, 0), a4.emplaceBack(t4.Z, 0), a4.emplaceBack(0, t4.Z), a4.emplaceBack(t4.Z, t4.Z), this.rasterBoundsBufferPosOnly = e6.createVertexBuffer(a4, mt.members), this.rasterBoundsSegmentsPosOnly = t4.aG.simpleSegment(0, 0, 4, 5);
            const s4 = new t4.aF();
            s4.emplaceBack(0, 0), s4.emplaceBack(1, 0), s4.emplaceBack(0, 1), s4.emplaceBack(1, 1), this.viewportBuffer = e6.createVertexBuffer(s4, mt.members), this.viewportSegments = t4.aG.simpleSegment(0, 0, 4, 2);
            const n6 = new t4.bX();
            n6.emplaceBack(0), n6.emplaceBack(1), n6.emplaceBack(3), n6.emplaceBack(2), n6.emplaceBack(0), this.tileBorderIndexBuffer = e6.createIndexBuffer(n6);
            const l5 = new t4.aH();
            l5.emplaceBack(1, 0, 2), l5.emplaceBack(1, 2, 3), this.quadTriangleIndexBuffer = e6.createIndexBuffer(l5);
            const c5 = this.context.gl;
            this.stencilClearMode = new Nt({ func: c5.ALWAYS, mask: 0 }, 0, 255, c5.ZERO, c5.ZERO, c5.ZERO), this.tileExtentMesh = new pt(this.tileExtentBuffer, this.quadTriangleIndexBuffer, this.tileExtentSegments);
          }
          clearStencil() {
            const e6 = this.context, i6 = e6.gl;
            this.nextStencilID = 1, this.currentStencilSource = void 0;
            const r8 = t4.K();
            t4.bO(r8, 0, this.width, this.height, 0, 0, 1), t4.M(r8, r8, [i6.drawingBufferWidth, i6.drawingBufferHeight, 0]);
            const o6 = { mainMatrix: r8, tileMercatorCoords: [0, 0, 1, 1], clippingPlane: [0, 0, 0, 0], projectionTransition: 0, fallbackMatrix: r8 };
            this.useProgram("clippingMask", null, true).draw(e6, i6.TRIANGLES, jt.disabled, this.stencilClearMode, Ft.disabled, Ot.disabled, null, null, o6, "$clipping", this.viewportBuffer, this.quadTriangleIndexBuffer, this.viewportSegments);
          }
          _renderTileClippingMasks(e6, t5, i6) {
            if (this.currentStencilSource === e6.source || !e6.isTileClipped() || !t5 || !t5.length) return;
            this.currentStencilSource = e6.source, this.nextStencilID + t5.length > 256 && this.clearStencil();
            const r8 = this.context;
            r8.setColorMode(Ft.disabled), r8.setDepthMode(jt.disabled);
            const o6 = {};
            for (const e7 of t5) o6[e7.key] = this.nextStencilID++;
            this._renderTileMasks(o6, t5, i6, true), this._renderTileMasks(o6, t5, i6, false), this._tileClippingMaskIDs = o6;
          }
          _renderTileMasks(e6, t5, i6, r8) {
            const o6 = this.context, a4 = o6.gl, s4 = this.style.projection, n6 = this.transform, l5 = this.useProgram("clippingMask");
            for (const c5 of t5) {
              const t6 = e6[c5.key], h4 = this.style.map.terrain && this.style.map.terrain.getTerrainData(c5), u4 = s4.getMeshFromTileID(this.context, c5.canonical, r8, true, "stencil"), d4 = n6.getProjectionData({ overscaledTileID: c5, applyGlobeMatrix: true, applyTerrainMatrix: true });
              l5.draw(o6, a4.TRIANGLES, jt.disabled, new Nt({ func: a4.ALWAYS, mask: 0 }, t6, 255, a4.KEEP, a4.KEEP, a4.REPLACE), Ft.disabled, i6 ? Ot.disabled : Ot.backCCW, null, h4, d4, "$clipping", u4.vertexBuffer, u4.indexBuffer, u4.segments);
            }
          }
          _renderTilesDepthBuffer() {
            const e6 = this.context, t5 = e6.gl, i6 = this.style.projection, r8 = this.transform, o6 = this.useProgram("depth"), a4 = this.getDepthModeFor3D(), s4 = ue(r8, { tileSize: r8.tileSize });
            for (const n6 of s4) {
              const s5 = this.style.map.terrain && this.style.map.terrain.getTerrainData(n6), l5 = i6.getMeshFromTileID(this.context, n6.canonical, true, true, "raster"), c5 = r8.getProjectionData({ overscaledTileID: n6, applyGlobeMatrix: true, applyTerrainMatrix: true });
              o6.draw(e6, t5.TRIANGLES, a4, Nt.disabled, Ft.disabled, Ot.backCCW, null, s5, c5, "$clipping", l5.vertexBuffer, l5.indexBuffer, l5.segments);
            }
          }
          stencilModeFor3D() {
            this.currentStencilSource = void 0, this.nextStencilID + 1 > 256 && this.clearStencil();
            const e6 = this.nextStencilID++, t5 = this.context.gl;
            return new Nt({ func: t5.NOTEQUAL, mask: 255 }, e6, 255, t5.KEEP, t5.KEEP, t5.REPLACE);
          }
          stencilModeForClipping(e6) {
            const t5 = this.context.gl;
            return new Nt({ func: t5.EQUAL, mask: 255 }, this._tileClippingMaskIDs[e6.key], 0, t5.KEEP, t5.KEEP, t5.REPLACE);
          }
          getStencilConfigForOverlapAndUpdateStencilID(e6) {
            const t5 = this.context.gl, i6 = e6.sort((e7, t6) => t6.overscaledZ - e7.overscaledZ), r8 = i6[i6.length - 1].overscaledZ, o6 = i6[0].overscaledZ - r8 + 1;
            if (o6 > 1) {
              this.currentStencilSource = void 0, this.nextStencilID + o6 > 256 && this.clearStencil();
              const e7 = {};
              for (let i7 = 0; i7 < o6; i7++) e7[i7 + r8] = new Nt({ func: t5.GEQUAL, mask: 255 }, i7 + this.nextStencilID, 255, t5.KEEP, t5.KEEP, t5.REPLACE);
              return this.nextStencilID += o6, [e7, i6];
            }
            return [{ [r8]: Nt.disabled }, i6];
          }
          stencilConfigForOverlapTwoPass(e6) {
            const t5 = this.context.gl, i6 = e6.sort((e7, t6) => t6.overscaledZ - e7.overscaledZ), r8 = i6[i6.length - 1].overscaledZ, o6 = i6[0].overscaledZ - r8 + 1;
            if (this.clearStencil(), o6 > 1) {
              const e7 = {}, a4 = {};
              for (let i7 = 0; i7 < o6; i7++) e7[i7 + r8] = new Nt({ func: t5.GREATER, mask: 255 }, o6 + 1 + i7, 255, t5.KEEP, t5.KEEP, t5.REPLACE), a4[i7 + r8] = new Nt({ func: t5.GREATER, mask: 255 }, 1 + i7, 255, t5.KEEP, t5.KEEP, t5.REPLACE);
              return this.nextStencilID = 2 * o6 + 1, [e7, a4, i6];
            }
            return this.nextStencilID = 3, [{ [r8]: new Nt({ func: t5.GREATER, mask: 255 }, 2, 255, t5.KEEP, t5.KEEP, t5.REPLACE) }, { [r8]: new Nt({ func: t5.GREATER, mask: 255 }, 1, 255, t5.KEEP, t5.KEEP, t5.REPLACE) }, i6];
          }
          colorModeForRenderPass() {
            const e6 = this.context.gl;
            if (this._showOverdrawInspector) {
              const i6 = 1 / 8;
              return new Ft([e6.CONSTANT_COLOR, e6.ONE], new t4.b7(i6, i6, i6, 0), [true, true, true, true]);
            }
            return "opaque" === this.renderPass ? Ft.unblended : Ft.alphaBlended;
          }
          getDepthModeForSublayer(e6, t5, i6) {
            if (!this.opaquePassEnabledForLayer()) return jt.disabled;
            const r8 = 1 - ((1 + this.currentLayer) * this.numSublayers + e6) * this.depthEpsilon;
            return new jt(i6 || this.context.gl.LEQUAL, t5, [r8, r8]);
          }
          getDepthModeFor3D() {
            return new jt(this.context.gl.LEQUAL, jt.ReadWrite, this.depthRangeFor3D);
          }
          opaquePassEnabledForLayer() {
            return this.currentLayer < this.opaquePassCutoff;
          }
          render(e6, i6) {
            var r8, o6;
            this.style = e6, this.options = i6, this.lineAtlas = e6.lineAtlas, this.imageManager = e6.imageManager, this.glyphManager = e6.glyphManager, this.symbolFadeChange = e6.placement.symbolFadeChange(s3.now()), this.imageManager.beginFrame();
            const a4 = this.style._order, n6 = this.style.sourceCaches, l5 = {}, c5 = {}, h4 = {}, u4 = { isRenderingToTexture: false, isRenderingGlobe: (null === (r8 = e6.projection) || void 0 === r8 ? void 0 : r8.transitionState) > 0 };
            for (const e7 in n6) {
              const t5 = n6[e7];
              t5.used && t5.prepare(this.context), l5[e7] = t5.getVisibleCoordinates(false), c5[e7] = l5[e7].slice().reverse(), h4[e7] = t5.getVisibleCoordinates(true).reverse();
            }
            this.opaquePassCutoff = 1 / 0;
            for (let e7 = 0; e7 < a4.length; e7++) if (this.style._layers[a4[e7]].is3D()) {
              this.opaquePassCutoff = e7;
              break;
            }
            this.maybeDrawDepthAndCoords(false), this.renderToTexture && (this.renderToTexture.prepareForRender(this.style, this.transform.zoom), this.opaquePassCutoff = 0), this.renderPass = "offscreen";
            for (const e7 of a4) {
              const t5 = this.style._layers[e7];
              if (!t5.hasOffscreenPass() || t5.isHidden(this.transform.zoom)) continue;
              const i7 = c5[t5.source];
              ("custom" === t5.type || i7.length) && this.renderLayer(this, n6[t5.source], t5, i7, u4);
            }
            if (null === (o6 = this.style.projection) || void 0 === o6 || o6.updateGPUdependent({ context: this.context, useProgram: (e7) => this.useProgram(e7) }), this.context.viewport.set([0, 0, this.width, this.height]), this.context.bindFramebuffer.set(null), this.context.clear({ color: i6.showOverdrawInspector ? t4.b7.black : t4.b7.transparent, depth: 1 }), this.clearStencil(), this.style.sky && function(e7, t5) {
              const i7 = e7.context, r9 = i7.gl, o7 = ((e8, t6, i8) => {
                const r10 = Math.cos(t6.rollInRadians), o8 = Math.sin(t6.rollInRadians), a6 = yt(t6), s5 = t6.getProjectionData({ overscaledTileID: null, applyGlobeMatrix: true, applyTerrainMatrix: true }).projectionTransition;
                return { u_sky_color: e8.properties.get("sky-color"), u_horizon_color: e8.properties.get("horizon-color"), u_horizon: [(t6.width / 2 - a6 * o8) * i8, (t6.height / 2 + a6 * r10) * i8], u_horizon_normal: [-o8, r10], u_sky_horizon_blend: e8.properties.get("sky-horizon-blend") * t6.height / 2 * i8, u_sky_blend: s5 };
              })(t5, e7.style.map.transform, e7.pixelRatio), a5 = new jt(r9.LEQUAL, jt.ReadWrite, [0, 1]), s4 = Nt.disabled, n7 = e7.colorModeForRenderPass(), l6 = e7.useProgram("sky"), c6 = xo(i7, t5);
              l6.draw(i7, r9.TRIANGLES, a5, s4, n7, Ot.disabled, o7, null, void 0, "sky", c6.vertexBuffer, c6.indexBuffer, c6.segments);
            }(this, this.style.sky), this._showOverdrawInspector = i6.showOverdrawInspector, this.depthRangeFor3D = [0, 1 - (e6._order.length + 2) * this.numSublayers * this.depthEpsilon], !this.renderToTexture) for (this.renderPass = "opaque", this.currentLayer = a4.length - 1; this.currentLayer >= 0; this.currentLayer--) {
              const e7 = this.style._layers[a4[this.currentLayer]], t5 = n6[e7.source], i7 = l5[e7.source];
              this._renderTileClippingMasks(e7, i7, false), this.renderLayer(this, t5, e7, i7, u4);
            }
            this.renderPass = "translucent";
            let d4 = false;
            for (this.currentLayer = 0; this.currentLayer < a4.length; this.currentLayer++) {
              const e7 = this.style._layers[a4[this.currentLayer]], t5 = n6[e7.source];
              if (this.renderToTexture && this.renderToTexture.renderLayer(e7, u4)) continue;
              this.opaquePassEnabledForLayer() || d4 || (d4 = true, u4.isRenderingGlobe && !this.style.map.terrain && this._renderTilesDepthBuffer());
              const i7 = ("symbol" === e7.type ? h4 : c5)[e7.source];
              this._renderTileClippingMasks(e7, l5[e7.source], false), this.renderLayer(this, t5, e7, i7, u4);
            }
            if (u4.isRenderingGlobe && function(e7, i7, r9) {
              const o7 = e7.context, a5 = o7.gl, s4 = e7.useProgram("atmosphere"), n7 = new jt(a5.LEQUAL, jt.ReadOnly, [0, 1]), l6 = e7.transform, c6 = function(e8, i8) {
                const r10 = e8.properties.get("position"), o8 = [-r10.x, -r10.y, -r10.z], a6 = t4.at(new Float64Array(16));
                return "map" === e8.properties.get("anchor") && (t4.a_(a6, a6, i8.rollInRadians), t4.a$(a6, a6, -i8.pitchInRadians), t4.a_(a6, a6, i8.bearingInRadians), t4.a$(a6, a6, i8.center.lat * Math.PI / 180), t4.bm(a6, a6, -i8.center.lng * Math.PI / 180)), t4.bV(o8, o8, a6), o8;
              }(r9, e7.transform), h5 = l6.getProjectionData({ overscaledTileID: null, applyGlobeMatrix: true, applyTerrainMatrix: true }), u5 = i7.properties.get("atmosphere-blend") * h5.projectionTransition;
              if (0 === u5) return;
              const d5 = ei(l6.worldSize, l6.center.lat), _4 = l6.inverseProjectionMatrix, p4 = new Float64Array(4);
              p4[3] = 1, t4.ap(p4, p4, l6.modelViewProjectionMatrix), p4[0] /= p4[3], p4[1] /= p4[3], p4[2] /= p4[3], p4[3] = 1, t4.ap(p4, p4, _4), p4[0] /= p4[3], p4[1] /= p4[3], p4[2] /= p4[3], p4[3] = 1;
              const m4 = /* @__PURE__ */ ((e8, t5, i8, r10, o8) => ({ u_sun_pos: e8, u_atmosphere_blend: t5, u_globe_position: i8, u_globe_radius: r10, u_inv_proj_matrix: o8 }))(c6, u5, [p4[0], p4[1], p4[2]], d5, _4), f4 = xo(o7, i7);
              s4.draw(o7, a5.TRIANGLES, n7, Nt.disabled, Ft.alphaBlended, Ot.disabled, m4, null, null, "atmosphere", f4.vertexBuffer, f4.indexBuffer, f4.segments);
            }(this, this.style.sky, this.style.light), this.options.showTileBoundaries) {
              const e7 = function(e8, t5) {
                let i7 = null;
                const r9 = Object.values(e8._layers).flatMap((i8) => i8.source && !i8.isHidden(t5) ? [e8.sourceCaches[i8.source]] : []), o7 = r9.filter((e9) => "vector" === e9.getSource().type), a5 = r9.filter((e9) => "vector" !== e9.getSource().type), s4 = (e9) => {
                  (!i7 || i7.getSource().maxzoom < e9.getSource().maxzoom) && (i7 = e9);
                };
                return o7.forEach((e9) => s4(e9)), i7 || a5.forEach((e9) => s4(e9)), i7;
              }(this.style, this.transform.zoom);
              e7 && function(e8, t5, i7) {
                for (let r9 = 0; r9 < i7.length; r9++) go(e8, t5, i7[r9]);
              }(this, e7, e7.getVisibleCoordinates());
            }
            this.options.showPadding && function(e7) {
              const t5 = e7.transform.padding;
              po(e7, e7.transform.height - (t5.top || 0), 3, lo), po(e7, t5.bottom || 0, 3, co), mo(e7, t5.left || 0, 3, ho), mo(e7, e7.transform.width - (t5.right || 0), 3, uo);
              const i7 = e7.transform.centerPoint;
              !function(e8, t6, i8, r9) {
                fo(e8, t6 - 1, i8 - 10, 2, 20, r9), fo(e8, t6 - 10, i8 - 1, 20, 2, r9);
              }(e7, i7.x, e7.transform.height - i7.y, _o);
            }(this), this.context.setDefault();
          }
          maybeDrawDepthAndCoords(e6) {
            if (!this.style || !this.style.map || !this.style.map.terrain) return;
            const i6 = this.terrainFacilitator.matrix, r8 = this.transform.modelViewProjectionMatrix;
            let o6 = this.terrainFacilitator.dirty;
            o6 || (o6 = e6 ? !t4.bY(i6, r8) : !t4.bZ(i6, r8)), o6 || (o6 = this.style.map.terrain.sourceCache.anyTilesAfterTime(this.terrainFacilitator.renderTime)), o6 && (t4.b_(i6, r8), this.terrainFacilitator.renderTime = Date.now(), this.terrainFacilitator.dirty = false, function(e7, i7) {
              const r9 = e7.context, o7 = r9.gl, a4 = e7.transform, s4 = Ft.unblended, n6 = new jt(o7.LEQUAL, jt.ReadWrite, [0, 1]), l5 = i7.sourceCache.getRenderableTiles(), c5 = e7.useProgram("terrainDepth");
              r9.bindFramebuffer.set(i7.getFramebuffer("depth").framebuffer), r9.viewport.set([0, 0, e7.width / devicePixelRatio, e7.height / devicePixelRatio]), r9.clear({ color: t4.b7.transparent, depth: 1 });
              for (const e8 of l5) {
                const t5 = i7.getTerrainMesh(e8.tileID), l6 = i7.getTerrainData(e8.tileID), h4 = a4.getProjectionData({ overscaledTileID: e8.tileID, applyTerrainMatrix: false, applyGlobeMatrix: true }), u4 = { u_ele_delta: i7.getMeshFrameDelta(a4.zoom) };
                c5.draw(r9, o7.TRIANGLES, n6, Nt.disabled, s4, Ot.backCCW, u4, l6, h4, "terrain", t5.vertexBuffer, t5.indexBuffer, t5.segments);
              }
              r9.bindFramebuffer.set(null), r9.viewport.set([0, 0, e7.width, e7.height]);
            }(this, this.style.map.terrain), function(e7, i7) {
              const r9 = e7.context, o7 = r9.gl, a4 = e7.transform, s4 = Ft.unblended, n6 = new jt(o7.LEQUAL, jt.ReadWrite, [0, 1]), l5 = i7.getCoordsTexture(), c5 = i7.sourceCache.getRenderableTiles(), h4 = e7.useProgram("terrainCoords");
              r9.bindFramebuffer.set(i7.getFramebuffer("coords").framebuffer), r9.viewport.set([0, 0, e7.width / devicePixelRatio, e7.height / devicePixelRatio]), r9.clear({ color: t4.b7.transparent, depth: 1 }), i7.coordsIndex = [];
              for (const e8 of c5) {
                const t5 = i7.getTerrainMesh(e8.tileID), c6 = i7.getTerrainData(e8.tileID);
                r9.activeTexture.set(o7.TEXTURE0), o7.bindTexture(o7.TEXTURE_2D, l5.texture);
                const u4 = { u_terrain_coords_id: (255 - i7.coordsIndex.length) / 255, u_texture: 0, u_ele_delta: i7.getMeshFrameDelta(a4.zoom) }, d4 = a4.getProjectionData({ overscaledTileID: e8.tileID, applyTerrainMatrix: false, applyGlobeMatrix: true });
                h4.draw(r9, o7.TRIANGLES, n6, Nt.disabled, s4, Ot.backCCW, u4, c6, d4, "terrain", t5.vertexBuffer, t5.indexBuffer, t5.segments), i7.coordsIndex.push(e8.tileID.key);
              }
              r9.bindFramebuffer.set(null), r9.viewport.set([0, 0, e7.width, e7.height]);
            }(this, this.style.map.terrain));
          }
          renderLayer(e6, i6, r8, o6, a4) {
            r8.isHidden(this.transform.zoom) || ("background" === r8.type || "custom" === r8.type || (o6 || []).length) && (this.id = r8.id, t4.b$(r8) ? function(e7, i7, r9, o7, a5, s4) {
              if ("translucent" !== e7.renderPass) return;
              const { isRenderingToTexture: n6 } = s4, l5 = Nt.disabled, c5 = e7.colorModeForRenderPass();
              (r9._unevaluatedLayout.hasValue("text-variable-anchor") || r9._unevaluatedLayout.hasValue("text-variable-anchor-offset")) && function(e8, i8, r10, o8, a6, s5, n7, l6, c6) {
                const h4 = i8.transform, u4 = i8.style.map.terrain, d4 = "map" === a6, _4 = "map" === s5;
                for (const a7 of e8) {
                  const e9 = o8.getTile(a7), s6 = e9.getBucket(r10);
                  if (!s6 || !s6.text || !s6.text.segments.get().length) continue;
                  const p4 = t4.ag(s6.textSizeData, h4.zoom), m4 = t4.aw(e9, 1, i8.transform.zoom), f4 = ve(d4, i8.transform, m4), g4 = "none" !== r10.layout.get("icon-text-fit") && s6.hasIconData();
                  if (p4) {
                    const i9 = Math.pow(2, h4.zoom - e9.tileID.overscaledZ), r11 = u4 ? (e10, t5) => u4.getElevation(a7, e10, t5) : null;
                    $r(s6, d4, _4, c6, h4, f4, i9, p4, g4, t4.ax(h4, e9, n7, l6), a7.toUnwrapped(), r11);
                  }
                }
              }(o7, e7, r9, i7, r9.layout.get("text-rotation-alignment"), r9.layout.get("text-pitch-alignment"), r9.paint.get("text-translate"), r9.paint.get("text-translate-anchor"), a5), 0 !== r9.paint.get("icon-opacity").constantOr(1) && Kr(e7, i7, r9, o7, false, r9.paint.get("icon-translate"), r9.paint.get("icon-translate-anchor"), r9.layout.get("icon-rotation-alignment"), r9.layout.get("icon-pitch-alignment"), r9.layout.get("icon-keep-upright"), l5, c5, n6), 0 !== r9.paint.get("text-opacity").constantOr(1) && Kr(e7, i7, r9, o7, true, r9.paint.get("text-translate"), r9.paint.get("text-translate-anchor"), r9.layout.get("text-rotation-alignment"), r9.layout.get("text-pitch-alignment"), r9.layout.get("text-keep-upright"), l5, c5, n6), i7.map.showCollisionBoxes && (Ur(e7, i7, r9, o7, true), Ur(e7, i7, r9, o7, false));
            }(e6, i6, r8, o6, this.style.placement.variableOffsets, a4) : t4.c0(r8) ? function(e7, i7, r9, o7, a5) {
              if ("translucent" !== e7.renderPass) return;
              const { isRenderingToTexture: s4 } = a5, n6 = r9.paint.get("circle-opacity"), l5 = r9.paint.get("circle-stroke-width"), c5 = r9.paint.get("circle-stroke-opacity"), h4 = !r9.layout.get("circle-sort-key").isConstant();
              if (0 === n6.constantOr(1) && (0 === l5.constantOr(1) || 0 === c5.constantOr(1))) return;
              const u4 = e7.context, d4 = u4.gl, _4 = e7.transform, p4 = e7.getDepthModeForSublayer(0, jt.ReadOnly), m4 = Nt.disabled, f4 = e7.colorModeForRenderPass(), g4 = [], v4 = _4.getCircleRadiusCorrection();
              for (let a6 = 0; a6 < o7.length; a6++) {
                const n7 = o7[a6], l6 = i7.getTile(n7), c6 = l6.getBucket(r9);
                if (!c6) continue;
                const u5 = r9.paint.get("circle-translate"), d5 = r9.paint.get("circle-translate-anchor"), p5 = t4.ax(_4, l6, u5, d5), m5 = c6.programConfigurations.get(r9.id), f5 = e7.useProgram("circle", m5), x4 = c6.layoutVertexBuffer, b5 = c6.indexBuffer, y4 = e7.style.map.terrain && e7.style.map.terrain.getTerrainData(n7), w4 = { programConfiguration: m5, program: f5, layoutVertexBuffer: x4, indexBuffer: b5, uniformValues: Ri(e7, l6, r9, p5, v4), terrainData: y4, projectionData: _4.getProjectionData({ overscaledTileID: n7, applyGlobeMatrix: !s4, applyTerrainMatrix: true }) };
                if (h4) {
                  const e8 = c6.segments.get();
                  for (const i8 of e8) g4.push({ segments: new t4.aG([i8]), sortKey: i8.sortKey, state: w4 });
                } else g4.push({ segments: c6.segments, sortKey: 0, state: w4 });
              }
              h4 && g4.sort((e8, t5) => e8.sortKey - t5.sortKey);
              for (const t5 of g4) {
                const { programConfiguration: i8, program: o8, layoutVertexBuffer: a6, indexBuffer: s5, uniformValues: n7, terrainData: l6, projectionData: c6 } = t5.state;
                o8.draw(u4, d4.TRIANGLES, p4, m4, f4, Ot.backCCW, n7, l6, c6, r9.id, a6, s5, t5.segments, r9.paint, e7.transform.zoom, i8);
              }
            }(e6, i6, r8, o6, a4) : t4.c1(r8) ? function(e7, i7, r9, o7, a5) {
              if (0 === r9.paint.get("heatmap-opacity")) return;
              const s4 = e7.context, { isRenderingToTexture: n6, isRenderingGlobe: l5 } = a5;
              if (e7.style.map.terrain) {
                for (const t5 of o7) {
                  const o8 = i7.getTile(t5);
                  i7.hasRenderableParent(t5) || ("offscreen" === e7.renderPass ? Qr(e7, o8, r9, t5, l5) : "translucent" === e7.renderPass && Yr(e7, r9, t5, n6, l5));
                }
                s4.viewport.set([0, 0, e7.width, e7.height]);
              } else "offscreen" === e7.renderPass ? function(e8, i8, r10, o8) {
                const a6 = e8.context, s5 = a6.gl, n7 = e8.transform, l6 = Nt.disabled, c5 = new Ft([s5.ONE, s5.ONE], t4.b7.transparent, [true, true, true, true]);
                (function(e9, i9, r11) {
                  const o9 = e9.gl;
                  e9.activeTexture.set(o9.TEXTURE1), e9.viewport.set([0, 0, i9.width / 4, i9.height / 4]);
                  let a7 = r11.heatmapFbos.get(t4.bS);
                  a7 ? (o9.bindTexture(o9.TEXTURE_2D, a7.colorAttachment.get()), e9.bindFramebuffer.set(a7.framebuffer)) : (a7 = Jr(e9, i9.width / 4, i9.height / 4), r11.heatmapFbos.set(t4.bS, a7));
                })(a6, e8, r10), a6.clear({ color: t4.b7.transparent });
                for (let t5 = 0; t5 < o8.length; t5++) {
                  const h4 = o8[t5];
                  if (i8.hasRenderableParent(h4)) continue;
                  const u4 = i8.getTile(h4), d4 = u4.getBucket(r10);
                  if (!d4) continue;
                  const _4 = d4.programConfigurations.get(r10.id), p4 = e8.useProgram("heatmap", _4), m4 = n7.getProjectionData({ overscaledTileID: h4, applyGlobeMatrix: true, applyTerrainMatrix: false }), f4 = n7.getCircleRadiusCorrection();
                  p4.draw(a6, s5.TRIANGLES, jt.disabled, l6, c5, Ot.backCCW, Li(u4, n7.zoom, r10.paint.get("heatmap-intensity"), f4), null, m4, r10.id, d4.layoutVertexBuffer, d4.indexBuffer, d4.segments, r10.paint, n7.zoom, _4);
                }
                a6.viewport.set([0, 0, e8.width, e8.height]);
              }(e7, i7, r9, o7) : "translucent" === e7.renderPass && function(e8, i8) {
                const r10 = e8.context, o8 = r10.gl;
                r10.setColorMode(e8.colorModeForRenderPass());
                const a6 = i8.heatmapFbos.get(t4.bS);
                a6 && (r10.activeTexture.set(o8.TEXTURE0), o8.bindTexture(o8.TEXTURE_2D, a6.colorAttachment.get()), r10.activeTexture.set(o8.TEXTURE1), eo(r10, i8).bind(o8.LINEAR, o8.CLAMP_TO_EDGE), e8.useProgram("heatmapTexture").draw(r10, o8.TRIANGLES, jt.disabled, Nt.disabled, e8.colorModeForRenderPass(), Ot.disabled, ki(e8, i8, 0, 1), null, null, i8.id, e8.viewportBuffer, e8.quadTriangleIndexBuffer, e8.viewportSegments, i8.paint, e8.transform.zoom));
              }(e7, r9);
            }(e6, i6, r8, o6, a4) : t4.c2(r8) ? function(e7, i7, r9, o7, a5) {
              if ("translucent" !== e7.renderPass) return;
              const { isRenderingToTexture: s4 } = a5, n6 = r9.paint.get("line-opacity"), l5 = r9.paint.get("line-width");
              if (0 === n6.constantOr(1) || 0 === l5.constantOr(1)) return;
              const c5 = e7.getDepthModeForSublayer(0, jt.ReadOnly), h4 = e7.colorModeForRenderPass(), u4 = r9.paint.get("line-dasharray"), d4 = r9.paint.get("line-pattern"), _4 = d4.constantOr(1), p4 = r9.paint.get("line-gradient"), m4 = r9.getCrossfadeParameters(), f4 = _4 ? "linePattern" : u4 ? "lineSDF" : p4 ? "lineGradient" : "line", g4 = e7.context, x4 = g4.gl, b5 = e7.transform;
              let y4 = true;
              for (const a6 of o7) {
                const n7 = i7.getTile(a6);
                if (_4 && !n7.patternsLoaded()) continue;
                const l6 = n7.getBucket(r9);
                if (!l6) continue;
                const w4 = l6.programConfigurations.get(r9.id), T5 = e7.context.program.get(), P4 = e7.useProgram(f4, w4), C4 = y4 || P4.program !== T5, I4 = e7.style.map.terrain && e7.style.map.terrain.getTerrainData(a6), M5 = d4.constantOr(null);
                if (M5 && n7.imageAtlas) {
                  const e8 = n7.imageAtlas, t5 = e8.patternPositions[M5.to.toString()], i8 = e8.patternPositions[M5.from.toString()];
                  t5 && i8 && w4.setConstantPatternPositions(t5, i8);
                }
                const E4 = b5.getProjectionData({ overscaledTileID: a6, applyGlobeMatrix: !s4, applyTerrainMatrix: true }), S5 = b5.getPixelScale(), R5 = _4 ? Ni(e7, n7, r9, S5, m4) : u4 ? Gi(e7, n7, r9, S5, u4, m4) : p4 ? Zi(e7, n7, r9, S5, l6.lineClipsArray.length) : ji(e7, n7, r9, S5);
                if (_4) g4.activeTexture.set(x4.TEXTURE0), n7.imageAtlasTexture.bind(x4.LINEAR, x4.CLAMP_TO_EDGE), w4.updatePaintBuffers(m4);
                else if (u4 && (C4 || e7.lineAtlas.dirty)) g4.activeTexture.set(x4.TEXTURE0), e7.lineAtlas.bind(g4);
                else if (p4) {
                  const o8 = l6.gradients[r9.id];
                  let s5 = o8.texture;
                  if (r9.gradientVersion !== o8.version) {
                    let n8 = 256;
                    if (r9.stepInterpolant) {
                      const r10 = i7.getSource().maxzoom, o9 = a6.canonical.z === r10 ? Math.ceil(1 << e7.transform.maxZoom - a6.canonical.z) : 1;
                      n8 = t4.ae(t4.bT(l6.maxLineLength / t4.Z * 1024 * o9), 256, g4.maxTextureSize);
                    }
                    o8.gradient = t4.bU({ expression: r9.gradientExpression(), evaluationKey: "lineProgress", resolution: n8, image: o8.gradient || void 0, clips: l6.lineClipsArray }), o8.texture ? o8.texture.update(o8.gradient) : o8.texture = new v3(g4, o8.gradient, x4.RGBA), o8.version = r9.gradientVersion, s5 = o8.texture;
                  }
                  g4.activeTexture.set(x4.TEXTURE0), s5.bind(r9.stepInterpolant ? x4.NEAREST : x4.LINEAR, x4.CLAMP_TO_EDGE);
                }
                let D3;
                if (s4) {
                  const [t5] = e7.getStencilConfigForOverlapAndUpdateStencilID(o7);
                  D3 = t5[a6.overscaledZ];
                } else D3 = e7.stencilModeForClipping(a6);
                P4.draw(g4, x4.TRIANGLES, c5, D3, h4, Ot.disabled, R5, I4, E4, r9.id, l6.layoutVertexBuffer, l6.indexBuffer, l6.segments, r9.paint, e7.transform.zoom, w4, l6.layoutVertexBuffer2), y4 = false;
              }
            }(e6, i6, r8, o6, a4) : t4.c3(r8) ? function(e7, i7, r9, o7, a5) {
              const s4 = r9.paint.get("fill-color"), n6 = r9.paint.get("fill-opacity");
              if (0 === n6.constantOr(1)) return;
              const { isRenderingToTexture: l5 } = a5, c5 = e7.colorModeForRenderPass(), h4 = r9.paint.get("fill-pattern"), u4 = e7.opaquePassEnabledForLayer() && !h4.constantOr(1) && 1 === s4.constantOr(t4.b7.transparent).a && 1 === n6.constantOr(0) ? "opaque" : "translucent";
              if (e7.renderPass === u4) {
                const t5 = e7.getDepthModeForSublayer(1, "opaque" === e7.renderPass ? jt.ReadWrite : jt.ReadOnly);
                io(e7, i7, r9, o7, t5, c5, false, l5);
              }
              if ("translucent" === e7.renderPass && r9.paint.get("fill-antialias")) {
                const t5 = e7.getDepthModeForSublayer(r9.getPaintProperty("fill-outline-color") ? 2 : 0, jt.ReadOnly);
                io(e7, i7, r9, o7, t5, c5, true, l5);
              }
            }(e6, i6, r8, o6, a4) : t4.c4(r8) ? function(e7, t5, i7, r9, o7) {
              const a5 = i7.paint.get("fill-extrusion-opacity");
              if (0 === a5) return;
              const { isRenderingToTexture: s4 } = o7;
              if ("translucent" === e7.renderPass) {
                const o8 = new jt(e7.context.gl.LEQUAL, jt.ReadWrite, e7.depthRangeFor3D);
                if (1 !== a5 || i7.paint.get("fill-extrusion-pattern").constantOr(1)) ro(e7, t5, i7, r9, o8, Nt.disabled, Ft.disabled, s4), ro(e7, t5, i7, r9, o8, e7.stencilModeFor3D(), e7.colorModeForRenderPass(), s4);
                else {
                  const a6 = e7.colorModeForRenderPass();
                  ro(e7, t5, i7, r9, o8, Nt.disabled, a6, s4);
                }
              }
            }(e6, i6, r8, o6, a4) : t4.c5(r8) ? function(e7, t5, i7, r9, o7) {
              if ("offscreen" !== e7.renderPass && "translucent" !== e7.renderPass) return;
              const { isRenderingToTexture: a5 } = o7, s4 = e7.context, n6 = e7.style.projection.useSubdivision, l5 = e7.getDepthModeForSublayer(0, jt.ReadOnly), c5 = e7.colorModeForRenderPass();
              if ("offscreen" === e7.renderPass) !function(e8, t6, i8, r10, o8, a6, s5) {
                const n7 = e8.context, l6 = n7.gl;
                for (const c6 of i8) {
                  const i9 = t6.getTile(c6), h4 = i9.dem;
                  if (!h4 || !h4.data) continue;
                  if (!i9.needsHillshadePrepare) continue;
                  const u4 = h4.dim, d4 = h4.stride, _4 = h4.getPixels();
                  if (n7.activeTexture.set(l6.TEXTURE1), n7.pixelStoreUnpackPremultiplyAlpha.set(false), i9.demTexture = i9.demTexture || e8.getTileTexture(d4), i9.demTexture) {
                    const e9 = i9.demTexture;
                    e9.update(_4, { premultiply: false }), e9.bind(l6.NEAREST, l6.CLAMP_TO_EDGE);
                  } else i9.demTexture = new v3(n7, _4, l6.RGBA, { premultiply: false }), i9.demTexture.bind(l6.NEAREST, l6.CLAMP_TO_EDGE);
                  n7.activeTexture.set(l6.TEXTURE0);
                  let p4 = i9.fbo;
                  if (!p4) {
                    const e9 = new v3(n7, { width: u4, height: u4, data: null }, l6.RGBA);
                    e9.bind(l6.LINEAR, l6.CLAMP_TO_EDGE), p4 = i9.fbo = n7.createFramebuffer(u4, u4, true, false), p4.colorAttachment.set(e9.texture);
                  }
                  n7.bindFramebuffer.set(p4.framebuffer), n7.viewport.set([0, 0, u4, u4]), e8.useProgram("hillshadePrepare").draw(n7, l6.TRIANGLES, o8, a6, s5, Ot.disabled, Bi(i9.tileID, h4), null, null, r10.id, e8.rasterBoundsBuffer, e8.quadTriangleIndexBuffer, e8.rasterBoundsSegments), i9.needsHillshadePrepare = false;
                }
              }(e7, t5, r9, i7, l5, Nt.disabled, c5), s4.viewport.set([0, 0, e7.width, e7.height]);
              else if ("translucent" === e7.renderPass) if (n6) {
                const [o8, s5, n7] = e7.stencilConfigForOverlapTwoPass(r9);
                oo(e7, t5, i7, n7, o8, l5, c5, false, a5), oo(e7, t5, i7, n7, s5, l5, c5, true, a5);
              } else {
                const [o8, s5] = e7.getStencilConfigForOverlapAndUpdateStencilID(r9);
                oo(e7, t5, i7, s5, o8, l5, c5, false, a5);
              }
            }(e6, i6, r8, o6, a4) : t4.c6(r8) ? function(e7, t5, i7, r9, o7) {
              if ("translucent" !== e7.renderPass) return;
              if (0 === i7.paint.get("raster-opacity")) return;
              if (!r9.length) return;
              const { isRenderingToTexture: a5 } = o7, s4 = t5.getSource(), n6 = e7.style.projection.useSubdivision;
              if (s4 instanceof X2) so(e7, t5, i7, r9, null, false, false, s4.tileCoords, s4.flippedWindingOrder, a5);
              else if (n6) {
                const [o8, s5, n7] = e7.stencilConfigForOverlapTwoPass(r9);
                so(e7, t5, i7, n7, o8, false, true, ao, false, a5), so(e7, t5, i7, n7, s5, true, true, ao, false, a5);
              } else {
                const [o8, s5] = e7.getStencilConfigForOverlapAndUpdateStencilID(r9);
                so(e7, t5, i7, s5, o8, false, true, ao, false, a5);
              }
            }(e6, i6, r8, o6, a4) : t4.c7(r8) ? function(e7, t5, i7, r9, o7) {
              const a5 = i7.paint.get("background-color"), s4 = i7.paint.get("background-opacity");
              if (0 === s4) return;
              const { isRenderingToTexture: n6 } = o7, l5 = e7.context, c5 = l5.gl, h4 = e7.style.projection, u4 = e7.transform, d4 = u4.tileSize, _4 = i7.paint.get("background-pattern");
              if (e7.isPatternMissing(_4)) return;
              const p4 = !_4 && 1 === a5.a && 1 === s4 && e7.opaquePassEnabledForLayer() ? "opaque" : "translucent";
              if (e7.renderPass !== p4) return;
              const m4 = Nt.disabled, f4 = e7.getDepthModeForSublayer(0, "opaque" === p4 ? jt.ReadWrite : jt.ReadOnly), g4 = e7.colorModeForRenderPass(), v4 = e7.useProgram(_4 ? "backgroundPattern" : "background"), x4 = r9 || ue(u4, { tileSize: d4, terrain: e7.style.map.terrain });
              _4 && (l5.activeTexture.set(c5.TEXTURE0), e7.imageManager.bind(e7.context));
              const b5 = i7.getCrossfadeParameters();
              for (const t6 of x4) {
                const r10 = u4.getProjectionData({ overscaledTileID: t6, applyGlobeMatrix: !n6, applyTerrainMatrix: true }), o8 = _4 ? Qi(s4, e7, _4, { tileID: t6, tileSize: d4 }, b5) : Xi(s4, a5), p5 = e7.style.map.terrain && e7.style.map.terrain.getTerrainData(t6), x5 = h4.getMeshFromTileID(l5, t6.canonical, false, true, "raster");
                v4.draw(l5, c5.TRIANGLES, f4, m4, g4, Ot.backCCW, o8, p5, r10, i7.id, x5.vertexBuffer, x5.indexBuffer, x5.segments);
              }
            }(e6, 0, r8, o6, a4) : t4.c8(r8) && function(e7, t5, i7, r9) {
              const { isRenderingGlobe: o7 } = r9, a5 = e7.context, s4 = i7.implementation, n6 = e7.style.projection, l5 = e7.transform, c5 = l5.getProjectionDataForCustomLayer(o7), h4 = { farZ: l5.farZ, nearZ: l5.nearZ, fov: l5.fov * Math.PI / 180, modelViewProjectionMatrix: l5.modelViewProjectionMatrix, projectionMatrix: l5.projectionMatrix, shaderData: { variantName: n6.shaderVariantName, vertexShaderPrelude: `const float PI = 3.141592653589793;
uniform mat4 u_projection_matrix;
${n6.shaderPreludeCode.vertexSource}`, define: n6.shaderDefine }, defaultProjectionData: c5 }, u4 = s4.renderingMode ? s4.renderingMode : "2d";
              if ("offscreen" === e7.renderPass) {
                const t6 = s4.prerender;
                t6 && (e7.setCustomLayerDefaults(), a5.setColorMode(e7.colorModeForRenderPass()), t6.call(s4, a5.gl, h4), a5.setDirty(), e7.setBaseState());
              } else if ("translucent" === e7.renderPass) {
                e7.setCustomLayerDefaults(), a5.setColorMode(e7.colorModeForRenderPass()), a5.setStencilMode(Nt.disabled);
                const t6 = "3d" === u4 ? e7.getDepthModeFor3D() : e7.getDepthModeForSublayer(0, jt.ReadOnly);
                a5.setDepthMode(t6), s4.render(a5.gl, h4), a5.setDirty(), e7.setBaseState(), a5.bindFramebuffer.set(null);
              }
            }(e6, 0, r8, a4));
          }
          saveTileTexture(e6) {
            const t5 = this._tileTextures[e6.size[0]];
            t5 ? t5.push(e6) : this._tileTextures[e6.size[0]] = [e6];
          }
          getTileTexture(e6) {
            const t5 = this._tileTextures[e6];
            return t5 && t5.length > 0 ? t5.pop() : null;
          }
          isPatternMissing(e6) {
            if (!e6) return false;
            if (!e6.from || !e6.to) return true;
            const t5 = this.imageManager.getPattern(e6.from.toString()), i6 = this.imageManager.getPattern(e6.to.toString());
            return !t5 || !i6;
          }
          useProgram(e6, t5, i6 = false) {
            this.cache = this.cache || {};
            const r8 = !!this.style.map.terrain, o6 = this.style.projection, a4 = e6 + (t5 ? t5.cacheKey : "") + `/${i6 ? gt : o6.shaderVariantName}` + (this._showOverdrawInspector ? "/overdraw" : "") + (r8 ? "/terrain" : "");
            return this.cache[a4] || (this.cache[a4] = new Ti(this.context, dt[e6], t5, Ji[e6], this._showOverdrawInspector, r8, i6 ? dt.projectionMercator : o6.shaderPreludeCode, i6 ? ft : o6.shaderDefine)), this.cache[a4];
          }
          setCustomLayerDefaults() {
            this.context.unbindVAO(), this.context.cullFace.setDefault(), this.context.activeTexture.setDefault(), this.context.pixelStoreUnpack.setDefault(), this.context.pixelStoreUnpackPremultiplyAlpha.setDefault(), this.context.pixelStoreUnpackFlipY.setDefault();
          }
          setBaseState() {
            const e6 = this.context.gl;
            this.context.cullFace.set(false), this.context.viewport.set([0, 0, this.width, this.height]), this.context.blendEquation.set(e6.FUNC_ADD);
          }
          initDebugOverlayCanvas() {
            null == this.debugOverlayCanvas && (this.debugOverlayCanvas = document.createElement("canvas"), this.debugOverlayCanvas.width = 512, this.debugOverlayCanvas.height = 512, this.debugOverlayTexture = new v3(this.context, this.debugOverlayCanvas, this.context.gl.RGBA));
          }
          destroy() {
            this.debugOverlayTexture && this.debugOverlayTexture.destroy();
          }
          overLimit() {
            const { drawingBufferWidth: e6, drawingBufferHeight: t5 } = this.context.gl;
            return this.width !== e6 || this.height !== t5;
          }
        }
        function yo(e6, t5) {
          let i6, r8 = false, o6 = null, a4 = null;
          const s4 = () => {
            o6 = null, r8 && (e6.apply(a4, i6), o6 = setTimeout(s4, t5), r8 = false);
          };
          return (...e7) => (r8 = true, a4 = this, i6 = e7, o6 || s4(), o6);
        }
        class wo {
          constructor(e6) {
            this._getCurrentHash = () => {
              const e7 = window.location.hash.replace("#", "");
              if (this._hashName) {
                let t5;
                return e7.split("&").map((e8) => e8.split("=")).forEach((e8) => {
                  e8[0] === this._hashName && (t5 = e8);
                }), (t5 && t5[1] || "").split("/");
              }
              return e7.split("/");
            }, this._onHashChange = () => {
              const e7 = this._getCurrentHash();
              if (!this._isValidHash(e7)) return false;
              const t5 = this._map.dragRotate.isEnabled() && this._map.touchZoomRotate.isEnabled() ? +(e7[3] || 0) : this._map.getBearing();
              return this._map.jumpTo({ center: [+e7[2], +e7[1]], zoom: +e7[0], bearing: t5, pitch: +(e7[4] || 0) }), true;
            }, this._updateHashUnthrottled = () => {
              const e7 = window.location.href.replace(/(#.*)?$/, this.getHashString());
              window.history.replaceState(window.history.state, null, e7);
            }, this._removeHash = () => {
              const e7 = this._getCurrentHash();
              if (0 === e7.length) return;
              const t5 = e7.join("/");
              let i6 = t5;
              i6.split("&").length > 0 && (i6 = i6.split("&")[0]), this._hashName && (i6 = `${this._hashName}=${t5}`);
              let r8 = window.location.hash.replace(i6, "");
              r8.startsWith("#&") ? r8 = r8.slice(0, 1) + r8.slice(2) : "#" === r8 && (r8 = "");
              let o6 = window.location.href.replace(/(#.+)?$/, r8);
              o6 = o6.replace("&&", "&"), window.history.replaceState(window.history.state, null, o6);
            }, this._updateHash = yo(this._updateHashUnthrottled, 300), this._hashName = e6 && encodeURIComponent(e6);
          }
          addTo(e6) {
            return this._map = e6, addEventListener("hashchange", this._onHashChange, false), this._map.on("moveend", this._updateHash), this;
          }
          remove() {
            return removeEventListener("hashchange", this._onHashChange, false), this._map.off("moveend", this._updateHash), clearTimeout(this._updateHash()), this._removeHash(), delete this._map, this;
          }
          getHashString(e6) {
            const t5 = this._map.getCenter(), i6 = Math.round(100 * this._map.getZoom()) / 100, r8 = Math.ceil((i6 * Math.LN2 + Math.log(512 / 360 / 0.5)) / Math.LN10), o6 = Math.pow(10, r8), a4 = Math.round(t5.lng * o6) / o6, s4 = Math.round(t5.lat * o6) / o6, n6 = this._map.getBearing(), l5 = this._map.getPitch();
            let c5 = "";
            if (c5 += e6 ? `/${a4}/${s4}/${i6}` : `${i6}/${s4}/${a4}`, (n6 || l5) && (c5 += "/" + Math.round(10 * n6) / 10), l5 && (c5 += `/${Math.round(l5)}`), this._hashName) {
              const e7 = this._hashName;
              let t6 = false;
              const i7 = window.location.hash.slice(1).split("&").map((i8) => {
                const r9 = i8.split("=")[0];
                return r9 === e7 ? (t6 = true, `${r9}=${c5}`) : i8;
              }).filter((e8) => e8);
              return t6 || i7.push(`${e7}=${c5}`), `#${i7.join("&")}`;
            }
            return `#${c5}`;
          }
          _isValidHash(e6) {
            if (e6.length < 3 || e6.some(isNaN)) return false;
            try {
              new t4.Q(+e6[2], +e6[1]);
            } catch (e7) {
              return false;
            }
            const i6 = +e6[0], r8 = +(e6[3] || 0), o6 = +(e6[4] || 0);
            return i6 >= this._map.getMinZoom() && i6 <= this._map.getMaxZoom() && r8 >= -180 && r8 <= 180 && o6 >= this._map.getMinPitch() && o6 <= this._map.getMaxPitch();
          }
        }
        const To = { linearity: 0.3, easing: t4.c9(0, 0, 0.3, 1) }, Po = t4.e({ deceleration: 2500, maxSpeed: 1400 }, To), Co = t4.e({ deceleration: 20, maxSpeed: 1400 }, To), Io = t4.e({ deceleration: 1e3, maxSpeed: 360 }, To), Mo = t4.e({ deceleration: 1e3, maxSpeed: 90 }, To), Eo = t4.e({ deceleration: 1e3, maxSpeed: 360 }, To);
        class So {
          constructor(e6) {
            this._map = e6, this.clear();
          }
          clear() {
            this._inertiaBuffer = [];
          }
          record(e6) {
            this._drainInertiaBuffer(), this._inertiaBuffer.push({ time: s3.now(), settings: e6 });
          }
          _drainInertiaBuffer() {
            const e6 = this._inertiaBuffer, t5 = s3.now();
            for (; e6.length > 0 && t5 - e6[0].time > 160; ) e6.shift();
          }
          _onMoveEnd(e6) {
            if (this._drainInertiaBuffer(), this._inertiaBuffer.length < 2) return;
            const i6 = { zoom: 0, bearing: 0, pitch: 0, roll: 0, pan: new t4.P(0, 0), pinchAround: void 0, around: void 0 };
            for (const { settings: e7 } of this._inertiaBuffer) i6.zoom += e7.zoomDelta || 0, i6.bearing += e7.bearingDelta || 0, i6.pitch += e7.pitchDelta || 0, i6.roll += e7.rollDelta || 0, e7.panDelta && i6.pan._add(e7.panDelta), e7.around && (i6.around = e7.around), e7.pinchAround && (i6.pinchAround = e7.pinchAround);
            const r8 = this._inertiaBuffer[this._inertiaBuffer.length - 1].time - this._inertiaBuffer[0].time, o6 = {};
            if (i6.pan.mag()) {
              const a4 = Do(i6.pan.mag(), r8, t4.e({}, Po, e6 || {})), s4 = i6.pan.mult(a4.amount / i6.pan.mag()), n6 = this._map.cameraHelper.handlePanInertia(s4, this._map.transform);
              o6.center = n6.easingCenter, o6.offset = n6.easingOffset, Ro(o6, a4);
            }
            if (i6.zoom) {
              const e7 = Do(i6.zoom, r8, Co);
              o6.zoom = this._map.transform.zoom + e7.amount, Ro(o6, e7);
            }
            if (i6.bearing) {
              const e7 = Do(i6.bearing, r8, Io);
              o6.bearing = this._map.transform.bearing + t4.ae(e7.amount, -179, 179), Ro(o6, e7);
            }
            if (i6.pitch) {
              const e7 = Do(i6.pitch, r8, Mo);
              o6.pitch = this._map.transform.pitch + e7.amount, Ro(o6, e7);
            }
            if (i6.roll) {
              const e7 = Do(i6.roll, r8, Eo);
              o6.roll = this._map.transform.roll + t4.ae(e7.amount, -179, 179), Ro(o6, e7);
            }
            if (o6.zoom || o6.bearing) {
              const e7 = void 0 === i6.pinchAround ? i6.around : i6.pinchAround;
              o6.around = e7 ? this._map.unproject(e7) : this._map.getCenter();
            }
            return this.clear(), t4.e(o6, { noMoveStart: true });
          }
        }
        function Ro(e6, t5) {
          (!e6.duration || e6.duration < t5.duration) && (e6.duration = t5.duration, e6.easing = t5.easing);
        }
        function Do(e6, i6, r8) {
          const { maxSpeed: o6, linearity: a4, deceleration: s4 } = r8, n6 = t4.ae(e6 * a4 / (i6 / 1e3), -o6, o6), l5 = Math.abs(n6) / (s4 * a4);
          return { easing: r8.easing, duration: 1e3 * l5, amount: n6 * (l5 / 2) };
        }
        class zo extends t4.l {
          preventDefault() {
            this._defaultPrevented = true;
          }
          get defaultPrevented() {
            return this._defaultPrevented;
          }
          constructor(e6, i6, r8, o6 = {}) {
            r8 = r8 instanceof MouseEvent ? r8 : new MouseEvent(e6, r8);
            const a4 = n5.mousePos(i6.getCanvas(), r8), s4 = i6.unproject(a4);
            super(e6, t4.e({ point: a4, lngLat: s4, originalEvent: r8 }, o6)), this._defaultPrevented = false, this.target = i6;
          }
        }
        class Ao extends t4.l {
          preventDefault() {
            this._defaultPrevented = true;
          }
          get defaultPrevented() {
            return this._defaultPrevented;
          }
          constructor(e6, i6, r8) {
            const o6 = "touchend" === e6 ? r8.changedTouches : r8.touches, a4 = n5.touchPos(i6.getCanvasContainer(), o6), s4 = a4.map((e7) => i6.unproject(e7)), l5 = a4.reduce((e7, t5, i7, r9) => e7.add(t5.div(r9.length)), new t4.P(0, 0));
            super(e6, { points: a4, point: l5, lngLats: s4, lngLat: i6.unproject(l5), originalEvent: r8 }), this._defaultPrevented = false;
          }
        }
        class Lo extends t4.l {
          preventDefault() {
            this._defaultPrevented = true;
          }
          get defaultPrevented() {
            return this._defaultPrevented;
          }
          constructor(e6, t5, i6) {
            super(e6, { originalEvent: i6 }), this._defaultPrevented = false;
          }
        }
        class ko {
          constructor(e6, t5) {
            this._map = e6, this._clickTolerance = t5.clickTolerance;
          }
          reset() {
            delete this._mousedownPos;
          }
          wheel(e6) {
            return this._firePreventable(new Lo(e6.type, this._map, e6));
          }
          mousedown(e6, t5) {
            return this._mousedownPos = t5, this._firePreventable(new zo(e6.type, this._map, e6));
          }
          mouseup(e6) {
            this._map.fire(new zo(e6.type, this._map, e6));
          }
          click(e6, t5) {
            this._mousedownPos && this._mousedownPos.dist(t5) >= this._clickTolerance || this._map.fire(new zo(e6.type, this._map, e6));
          }
          dblclick(e6) {
            return this._firePreventable(new zo(e6.type, this._map, e6));
          }
          mouseover(e6) {
            this._map.fire(new zo(e6.type, this._map, e6));
          }
          mouseout(e6) {
            this._map.fire(new zo(e6.type, this._map, e6));
          }
          touchstart(e6) {
            return this._firePreventable(new Ao(e6.type, this._map, e6));
          }
          touchmove(e6) {
            this._map.fire(new Ao(e6.type, this._map, e6));
          }
          touchend(e6) {
            this._map.fire(new Ao(e6.type, this._map, e6));
          }
          touchcancel(e6) {
            this._map.fire(new Ao(e6.type, this._map, e6));
          }
          _firePreventable(e6) {
            if (this._map.fire(e6), e6.defaultPrevented) return {};
          }
          isEnabled() {
            return true;
          }
          isActive() {
            return false;
          }
          enable() {
          }
          disable() {
          }
        }
        class Fo {
          constructor(e6) {
            this._map = e6;
          }
          reset() {
            this._delayContextMenu = false, this._ignoreContextMenu = true, delete this._contextMenuEvent;
          }
          mousemove(e6) {
            this._map.fire(new zo(e6.type, this._map, e6));
          }
          mousedown() {
            this._delayContextMenu = true, this._ignoreContextMenu = false;
          }
          mouseup() {
            this._delayContextMenu = false, this._contextMenuEvent && (this._map.fire(new zo("contextmenu", this._map, this._contextMenuEvent)), delete this._contextMenuEvent);
          }
          contextmenu(e6) {
            this._delayContextMenu ? this._contextMenuEvent = e6 : this._ignoreContextMenu || this._map.fire(new zo(e6.type, this._map, e6)), this._map.listens("contextmenu") && e6.preventDefault();
          }
          isEnabled() {
            return true;
          }
          isActive() {
            return false;
          }
          enable() {
          }
          disable() {
          }
        }
        class Bo {
          constructor(e6) {
            this._map = e6;
          }
          get transform() {
            return this._map._requestedCameraState || this._map.transform;
          }
          get center() {
            return { lng: this.transform.center.lng, lat: this.transform.center.lat };
          }
          get zoom() {
            return this.transform.zoom;
          }
          get pitch() {
            return this.transform.pitch;
          }
          get bearing() {
            return this.transform.bearing;
          }
          unproject(e6) {
            return this.transform.screenPointToLocation(t4.P.convert(e6), this._map.terrain);
          }
        }
        class Oo {
          constructor(e6, t5) {
            this._map = e6, this._tr = new Bo(e6), this._el = e6.getCanvasContainer(), this._container = e6.getContainer(), this._clickTolerance = t5.clickTolerance || 1;
          }
          isEnabled() {
            return !!this._enabled;
          }
          isActive() {
            return !!this._active;
          }
          enable() {
            this.isEnabled() || (this._enabled = true);
          }
          disable() {
            this.isEnabled() && (this._enabled = false);
          }
          mousedown(e6, t5) {
            this.isEnabled() && e6.shiftKey && 0 === e6.button && (n5.disableDrag(), this._startPos = this._lastPos = t5, this._active = true);
          }
          mousemoveWindow(e6, t5) {
            if (!this._active) return;
            const i6 = t5;
            if (this._lastPos.equals(i6) || !this._box && i6.dist(this._startPos) < this._clickTolerance) return;
            const r8 = this._startPos;
            this._lastPos = i6, this._box || (this._box = n5.create("div", "maplibregl-boxzoom", this._container), this._container.classList.add("maplibregl-crosshair"), this._fireEvent("boxzoomstart", e6));
            const o6 = Math.min(r8.x, i6.x), a4 = Math.max(r8.x, i6.x), s4 = Math.min(r8.y, i6.y), l5 = Math.max(r8.y, i6.y);
            n5.setTransform(this._box, `translate(${o6}px,${s4}px)`), this._box.style.width = a4 - o6 + "px", this._box.style.height = l5 - s4 + "px";
          }
          mouseupWindow(e6, i6) {
            if (!this._active) return;
            if (0 !== e6.button) return;
            const r8 = this._startPos, o6 = i6;
            if (this.reset(), n5.suppressClick(), r8.x !== o6.x || r8.y !== o6.y) return this._map.fire(new t4.l("boxzoomend", { originalEvent: e6 })), { cameraAnimation: (e7) => e7.fitScreenCoordinates(r8, o6, this._tr.bearing, { linear: true }) };
            this._fireEvent("boxzoomcancel", e6);
          }
          keydown(e6) {
            this._active && 27 === e6.keyCode && (this.reset(), this._fireEvent("boxzoomcancel", e6));
          }
          reset() {
            this._active = false, this._container.classList.remove("maplibregl-crosshair"), this._box && (n5.remove(this._box), this._box = null), n5.enableDrag(), delete this._startPos, delete this._lastPos;
          }
          _fireEvent(e6, i6) {
            return this._map.fire(new t4.l(e6, { originalEvent: i6 }));
          }
        }
        function jo(e6, t5) {
          if (e6.length !== t5.length) throw new Error(`The number of touches and points are not equal - touches ${e6.length}, points ${t5.length}`);
          const i6 = {};
          for (let r8 = 0; r8 < e6.length; r8++) i6[e6[r8].identifier] = t5[r8];
          return i6;
        }
        class Zo {
          constructor(e6) {
            this.reset(), this.numTouches = e6.numTouches;
          }
          reset() {
            delete this.centroid, delete this.startTime, delete this.touches, this.aborted = false;
          }
          touchstart(e6, i6, r8) {
            (this.centroid || r8.length > this.numTouches) && (this.aborted = true), this.aborted || (void 0 === this.startTime && (this.startTime = e6.timeStamp), r8.length === this.numTouches && (this.centroid = function(e7) {
              const i7 = new t4.P(0, 0);
              for (const t5 of e7) i7._add(t5);
              return i7.div(e7.length);
            }(i6), this.touches = jo(r8, i6)));
          }
          touchmove(e6, t5, i6) {
            if (this.aborted || !this.centroid) return;
            const r8 = jo(i6, t5);
            for (const e7 in this.touches) {
              const t6 = r8[e7];
              (!t6 || t6.dist(this.touches[e7]) > 30) && (this.aborted = true);
            }
          }
          touchend(e6, t5, i6) {
            if ((!this.centroid || e6.timeStamp - this.startTime > 500) && (this.aborted = true), 0 === i6.length) {
              const e7 = !this.aborted && this.centroid;
              if (this.reset(), e7) return e7;
            }
          }
        }
        class No {
          constructor(e6) {
            this.singleTap = new Zo(e6), this.numTaps = e6.numTaps, this.reset();
          }
          reset() {
            this.lastTime = 1 / 0, delete this.lastTap, this.count = 0, this.singleTap.reset();
          }
          touchstart(e6, t5, i6) {
            this.singleTap.touchstart(e6, t5, i6);
          }
          touchmove(e6, t5, i6) {
            this.singleTap.touchmove(e6, t5, i6);
          }
          touchend(e6, t5, i6) {
            const r8 = this.singleTap.touchend(e6, t5, i6);
            if (r8) {
              const t6 = e6.timeStamp - this.lastTime < 500, i7 = !this.lastTap || this.lastTap.dist(r8) < 30;
              if (t6 && i7 || this.reset(), this.count++, this.lastTime = e6.timeStamp, this.lastTap = r8, this.count === this.numTaps) return this.reset(), r8;
            }
          }
        }
        class Go {
          constructor(e6) {
            this._tr = new Bo(e6), this._zoomIn = new No({ numTouches: 1, numTaps: 2 }), this._zoomOut = new No({ numTouches: 2, numTaps: 1 }), this.reset();
          }
          reset() {
            this._active = false, this._zoomIn.reset(), this._zoomOut.reset();
          }
          touchstart(e6, t5, i6) {
            this._zoomIn.touchstart(e6, t5, i6), this._zoomOut.touchstart(e6, t5, i6);
          }
          touchmove(e6, t5, i6) {
            this._zoomIn.touchmove(e6, t5, i6), this._zoomOut.touchmove(e6, t5, i6);
          }
          touchend(e6, t5, i6) {
            const r8 = this._zoomIn.touchend(e6, t5, i6), o6 = this._zoomOut.touchend(e6, t5, i6), a4 = this._tr;
            return r8 ? (this._active = true, e6.preventDefault(), setTimeout(() => this.reset(), 0), { cameraAnimation: (t6) => t6.easeTo({ duration: 300, zoom: a4.zoom + 1, around: a4.unproject(r8) }, { originalEvent: e6 }) }) : o6 ? (this._active = true, e6.preventDefault(), setTimeout(() => this.reset(), 0), { cameraAnimation: (t6) => t6.easeTo({ duration: 300, zoom: a4.zoom - 1, around: a4.unproject(o6) }, { originalEvent: e6 }) }) : void 0;
          }
          touchcancel() {
            this.reset();
          }
          enable() {
            this._enabled = true;
          }
          disable() {
            this._enabled = false, this.reset();
          }
          isEnabled() {
            return this._enabled;
          }
          isActive() {
            return this._active;
          }
        }
        class Uo {
          constructor(e6) {
            this._enabled = !!e6.enable, this._moveStateManager = e6.moveStateManager, this._clickTolerance = e6.clickTolerance || 1, this._moveFunction = e6.move, this._activateOnStart = !!e6.activateOnStart, e6.assignEvents(this), this.reset();
          }
          reset(e6) {
            this._active = false, this._moved = false, delete this._lastPoint, this._moveStateManager.endMove(e6);
          }
          _move(...e6) {
            const t5 = this._moveFunction(...e6);
            if (t5.bearingDelta || t5.pitchDelta || t5.rollDelta || t5.around || t5.panDelta) return this._active = true, t5;
          }
          dragStart(e6, t5) {
            this.isEnabled() && !this._lastPoint && this._moveStateManager.isValidStartEvent(e6) && (this._moveStateManager.startMove(e6), this._lastPoint = Array.isArray(t5) ? t5[0] : t5, this._activateOnStart && this._lastPoint && (this._active = true));
          }
          dragMove(e6, t5) {
            if (!this.isEnabled()) return;
            const i6 = this._lastPoint;
            if (!i6) return;
            if (e6.preventDefault(), !this._moveStateManager.isValidMoveEvent(e6)) return void this.reset(e6);
            const r8 = Array.isArray(t5) ? t5[0] : t5;
            return !this._moved && r8.dist(i6) < this._clickTolerance ? void 0 : (this._moved = true, this._lastPoint = r8, this._move(i6, r8));
          }
          dragEnd(e6) {
            this.isEnabled() && this._lastPoint && this._moveStateManager.isValidEndEvent(e6) && (this._moved && n5.suppressClick(), this.reset(e6));
          }
          enable() {
            this._enabled = true;
          }
          disable() {
            this._enabled = false, this.reset();
          }
          isEnabled() {
            return this._enabled;
          }
          isActive() {
            return this._active;
          }
          getClickTolerance() {
            return this._clickTolerance;
          }
        }
        const Vo = { 0: 1, 2: 2 };
        class qo {
          constructor(e6) {
            this._correctEvent = e6.checkCorrectEvent;
          }
          startMove(e6) {
            const t5 = n5.mouseButton(e6);
            this._eventButton = t5;
          }
          endMove(e6) {
            delete this._eventButton;
          }
          isValidStartEvent(e6) {
            return this._correctEvent(e6);
          }
          isValidMoveEvent(e6) {
            return !function(e7, t5) {
              const i6 = Vo[t5];
              return void 0 === e7.buttons || (e7.buttons & i6) !== i6;
            }(e6, this._eventButton);
          }
          isValidEndEvent(e6) {
            return n5.mouseButton(e6) === this._eventButton;
          }
        }
        class Wo {
          constructor() {
            this._firstTouch = void 0;
          }
          _isOneFingerTouch(e6) {
            return 1 === e6.targetTouches.length;
          }
          _isSameTouchEvent(e6) {
            return e6.targetTouches[0].identifier === this._firstTouch;
          }
          startMove(e6) {
            this._firstTouch = e6.targetTouches[0].identifier;
          }
          endMove(e6) {
            delete this._firstTouch;
          }
          isValidStartEvent(e6) {
            return this._isOneFingerTouch(e6);
          }
          isValidMoveEvent(e6) {
            return this._isOneFingerTouch(e6) && this._isSameTouchEvent(e6);
          }
          isValidEndEvent(e6) {
            return this._isOneFingerTouch(e6) && this._isSameTouchEvent(e6);
          }
        }
        class $o {
          constructor(e6 = new qo({ checkCorrectEvent: () => true }), t5 = new Wo()) {
            this.mouseMoveStateManager = e6, this.oneFingerTouchMoveStateManager = t5;
          }
          _executeRelevantHandler(e6, t5, i6) {
            return e6 instanceof MouseEvent ? t5(e6) : "undefined" != typeof TouchEvent && e6 instanceof TouchEvent ? i6(e6) : void 0;
          }
          startMove(e6) {
            this._executeRelevantHandler(e6, (e7) => this.mouseMoveStateManager.startMove(e7), (e7) => this.oneFingerTouchMoveStateManager.startMove(e7));
          }
          endMove(e6) {
            this._executeRelevantHandler(e6, (e7) => this.mouseMoveStateManager.endMove(e7), (e7) => this.oneFingerTouchMoveStateManager.endMove(e7));
          }
          isValidStartEvent(e6) {
            return this._executeRelevantHandler(e6, (e7) => this.mouseMoveStateManager.isValidStartEvent(e7), (e7) => this.oneFingerTouchMoveStateManager.isValidStartEvent(e7));
          }
          isValidMoveEvent(e6) {
            return this._executeRelevantHandler(e6, (e7) => this.mouseMoveStateManager.isValidMoveEvent(e7), (e7) => this.oneFingerTouchMoveStateManager.isValidMoveEvent(e7));
          }
          isValidEndEvent(e6) {
            return this._executeRelevantHandler(e6, (e7) => this.mouseMoveStateManager.isValidEndEvent(e7), (e7) => this.oneFingerTouchMoveStateManager.isValidEndEvent(e7));
          }
        }
        const Ho = (e6) => {
          e6.mousedown = e6.dragStart, e6.mousemoveWindow = e6.dragMove, e6.mouseup = e6.dragEnd, e6.contextmenu = (e7) => {
            e7.preventDefault();
          };
        };
        class Ko {
          constructor(e6, t5) {
            this._clickTolerance = e6.clickTolerance || 1, this._map = t5, this.reset();
          }
          reset() {
            this._active = false, this._touches = {}, this._sum = new t4.P(0, 0);
          }
          _shouldBePrevented(e6) {
            return e6 < (this._map.cooperativeGestures.isEnabled() ? 2 : 1);
          }
          touchstart(e6, t5, i6) {
            return this._calculateTransform(e6, t5, i6);
          }
          touchmove(e6, t5, i6) {
            if (this._active) {
              if (!this._shouldBePrevented(i6.length)) return e6.preventDefault(), this._calculateTransform(e6, t5, i6);
              this._map.cooperativeGestures.notifyGestureBlocked("touch_pan", e6);
            }
          }
          touchend(e6, t5, i6) {
            this._calculateTransform(e6, t5, i6), this._active && this._shouldBePrevented(i6.length) && this.reset();
          }
          touchcancel() {
            this.reset();
          }
          _calculateTransform(e6, i6, r8) {
            r8.length > 0 && (this._active = true);
            const o6 = jo(r8, i6), a4 = new t4.P(0, 0), s4 = new t4.P(0, 0);
            let n6 = 0;
            for (const e7 in o6) {
              const t5 = o6[e7], i7 = this._touches[e7];
              i7 && (a4._add(t5), s4._add(t5.sub(i7)), n6++, o6[e7] = t5);
            }
            if (this._touches = o6, this._shouldBePrevented(n6) || !s4.mag()) return;
            const l5 = s4.div(n6);
            return this._sum._add(l5), this._sum.mag() < this._clickTolerance ? void 0 : { around: a4.div(n6), panDelta: l5 };
          }
          enable() {
            this._enabled = true;
          }
          disable() {
            this._enabled = false, this.reset();
          }
          isEnabled() {
            return this._enabled;
          }
          isActive() {
            return this._active;
          }
        }
        class Xo {
          constructor() {
            this.reset();
          }
          reset() {
            this._active = false, delete this._firstTwoTouches;
          }
          touchstart(e6, t5, i6) {
            this._firstTwoTouches || i6.length < 2 || (this._firstTwoTouches = [i6[0].identifier, i6[1].identifier], this._start([t5[0], t5[1]]));
          }
          touchmove(e6, t5, i6) {
            if (!this._firstTwoTouches) return;
            e6.preventDefault();
            const [r8, o6] = this._firstTwoTouches, a4 = Qo(i6, t5, r8), s4 = Qo(i6, t5, o6);
            if (!a4 || !s4) return;
            const n6 = this._aroundCenter ? null : a4.add(s4).div(2);
            return this._move([a4, s4], n6, e6);
          }
          touchend(e6, t5, i6) {
            if (!this._firstTwoTouches) return;
            const [r8, o6] = this._firstTwoTouches, a4 = Qo(i6, t5, r8), s4 = Qo(i6, t5, o6);
            a4 && s4 || (this._active && n5.suppressClick(), this.reset());
          }
          touchcancel() {
            this.reset();
          }
          enable(e6) {
            this._enabled = true, this._aroundCenter = !!e6 && "center" === e6.around;
          }
          disable() {
            this._enabled = false, this.reset();
          }
          isEnabled() {
            return !!this._enabled;
          }
          isActive() {
            return !!this._active;
          }
        }
        function Qo(e6, t5, i6) {
          for (let r8 = 0; r8 < e6.length; r8++) if (e6[r8].identifier === i6) return t5[r8];
        }
        function Yo(e6, t5) {
          return Math.log(e6 / t5) / Math.LN2;
        }
        class Jo extends Xo {
          reset() {
            super.reset(), delete this._distance, delete this._startDistance;
          }
          _start(e6) {
            this._startDistance = this._distance = e6[0].dist(e6[1]);
          }
          _move(e6, t5) {
            const i6 = this._distance;
            if (this._distance = e6[0].dist(e6[1]), this._active || !(Math.abs(Yo(this._distance, this._startDistance)) < 0.1)) return this._active = true, { zoomDelta: Yo(this._distance, i6), pinchAround: t5 };
          }
        }
        function ea(e6, t5) {
          return 180 * e6.angleWith(t5) / Math.PI;
        }
        class ta extends Xo {
          reset() {
            super.reset(), delete this._minDiameter, delete this._startVector, delete this._vector;
          }
          _start(e6) {
            this._startVector = this._vector = e6[0].sub(e6[1]), this._minDiameter = e6[0].dist(e6[1]);
          }
          _move(e6, t5, i6) {
            const r8 = this._vector;
            if (this._vector = e6[0].sub(e6[1]), this._active || !this._isBelowThreshold(this._vector)) return this._active = true, { bearingDelta: ea(this._vector, r8), pinchAround: t5 };
          }
          _isBelowThreshold(e6) {
            this._minDiameter = Math.min(this._minDiameter, e6.mag());
            const t5 = 25 / (Math.PI * this._minDiameter) * 360, i6 = ea(e6, this._startVector);
            return Math.abs(i6) < t5;
          }
        }
        function ia(e6) {
          return Math.abs(e6.y) > Math.abs(e6.x);
        }
        class ra extends Xo {
          constructor(e6) {
            super(), this._currentTouchCount = 0, this._map = e6;
          }
          reset() {
            super.reset(), this._valid = void 0, delete this._firstMove, delete this._lastPoints;
          }
          touchstart(e6, t5, i6) {
            super.touchstart(e6, t5, i6), this._currentTouchCount = i6.length;
          }
          _start(e6) {
            this._lastPoints = e6, ia(e6[0].sub(e6[1])) && (this._valid = false);
          }
          _move(e6, t5, i6) {
            if (this._map.cooperativeGestures.isEnabled() && this._currentTouchCount < 3) return;
            const r8 = e6[0].sub(this._lastPoints[0]), o6 = e6[1].sub(this._lastPoints[1]);
            return this._valid = this.gestureBeginsVertically(r8, o6, i6.timeStamp), this._valid ? (this._lastPoints = e6, this._active = true, { pitchDelta: (r8.y + o6.y) / 2 * -0.5 }) : void 0;
          }
          gestureBeginsVertically(e6, t5, i6) {
            if (void 0 !== this._valid) return this._valid;
            const r8 = e6.mag() >= 2, o6 = t5.mag() >= 2;
            if (!r8 && !o6) return;
            if (!r8 || !o6) return void 0 === this._firstMove && (this._firstMove = i6), i6 - this._firstMove < 100 && void 0;
            const a4 = e6.y > 0 == t5.y > 0;
            return ia(e6) && ia(t5) && a4;
          }
        }
        const oa = { panStep: 100, bearingStep: 15, pitchStep: 10 };
        class aa {
          constructor(e6) {
            this._tr = new Bo(e6);
            const t5 = oa;
            this._panStep = t5.panStep, this._bearingStep = t5.bearingStep, this._pitchStep = t5.pitchStep, this._rotationDisabled = false;
          }
          reset() {
            this._active = false;
          }
          keydown(e6) {
            if (e6.altKey || e6.ctrlKey || e6.metaKey) return;
            let t5 = 0, i6 = 0, r8 = 0, o6 = 0, a4 = 0;
            switch (e6.keyCode) {
              case 61:
              case 107:
              case 171:
              case 187:
                t5 = 1;
                break;
              case 189:
              case 109:
              case 173:
                t5 = -1;
                break;
              case 37:
                e6.shiftKey ? i6 = -1 : (e6.preventDefault(), o6 = -1);
                break;
              case 39:
                e6.shiftKey ? i6 = 1 : (e6.preventDefault(), o6 = 1);
                break;
              case 38:
                e6.shiftKey ? r8 = 1 : (e6.preventDefault(), a4 = -1);
                break;
              case 40:
                e6.shiftKey ? r8 = -1 : (e6.preventDefault(), a4 = 1);
                break;
              default:
                return;
            }
            return this._rotationDisabled && (i6 = 0, r8 = 0), { cameraAnimation: (s4) => {
              const n6 = this._tr;
              s4.easeTo({ duration: 300, easeId: "keyboardHandler", easing: sa, zoom: t5 ? Math.round(n6.zoom) + t5 * (e6.shiftKey ? 2 : 1) : n6.zoom, bearing: n6.bearing + i6 * this._bearingStep, pitch: n6.pitch + r8 * this._pitchStep, offset: [-o6 * this._panStep, -a4 * this._panStep], center: n6.center }, { originalEvent: e6 });
            } };
          }
          enable() {
            this._enabled = true;
          }
          disable() {
            this._enabled = false, this.reset();
          }
          isEnabled() {
            return this._enabled;
          }
          isActive() {
            return this._active;
          }
          disableRotation() {
            this._rotationDisabled = true;
          }
          enableRotation() {
            this._rotationDisabled = false;
          }
        }
        function sa(e6) {
          return e6 * (2 - e6);
        }
        const na = 4.000244140625;
        class la {
          constructor(e6, t5) {
            this._onTimeout = (e7) => {
              this._type = "wheel", this._delta -= this._lastValue, this._active || this._start(e7);
            }, this._map = e6, this._tr = new Bo(e6), this._triggerRenderFrame = t5, this._delta = 0, this._defaultZoomRate = 0.01, this._wheelZoomRate = 0.0022222222222222222;
          }
          setZoomRate(e6) {
            this._defaultZoomRate = e6;
          }
          setWheelZoomRate(e6) {
            this._wheelZoomRate = e6;
          }
          isEnabled() {
            return !!this._enabled;
          }
          isActive() {
            return !!this._active || void 0 !== this._finishTimeout;
          }
          isZooming() {
            return !!this._zooming;
          }
          enable(e6) {
            this.isEnabled() || (this._enabled = true, this._aroundCenter = !!e6 && "center" === e6.around);
          }
          disable() {
            this.isEnabled() && (this._enabled = false);
          }
          _shouldBePrevented(e6) {
            return !!this._map.cooperativeGestures.isEnabled() && !(e6.ctrlKey || this._map.cooperativeGestures.isBypassed(e6));
          }
          wheel(e6) {
            if (!this.isEnabled()) return;
            if (this._shouldBePrevented(e6)) return void this._map.cooperativeGestures.notifyGestureBlocked("wheel_zoom", e6);
            let t5 = e6.deltaMode === WheelEvent.DOM_DELTA_LINE ? 40 * e6.deltaY : e6.deltaY;
            const i6 = s3.now(), r8 = i6 - (this._lastWheelEventTime || 0);
            this._lastWheelEventTime = i6, 0 !== t5 && t5 % na == 0 ? this._type = "wheel" : 0 !== t5 && Math.abs(t5) < 4 ? this._type = "trackpad" : r8 > 400 ? (this._type = null, this._lastValue = t5, this._timeout = setTimeout(this._onTimeout, 40, e6)) : this._type || (this._type = Math.abs(r8 * t5) < 200 ? "trackpad" : "wheel", this._timeout && (clearTimeout(this._timeout), this._timeout = null, t5 += this._lastValue)), e6.shiftKey && t5 && (t5 /= 4), this._type && (this._lastWheelEvent = e6, this._delta -= t5, this._active || this._start(e6)), e6.preventDefault();
          }
          _start(e6) {
            if (!this._delta) return;
            this._frameId && (this._frameId = null), this._active = true, this.isZooming() || (this._zooming = true), this._finishTimeout && (clearTimeout(this._finishTimeout), delete this._finishTimeout);
            const i6 = n5.mousePos(this._map.getCanvas(), e6), r8 = this._tr;
            this._aroundPoint = this._aroundCenter ? r8.transform.locationToScreenPoint(t4.Q.convert(r8.center)) : i6, this._frameId || (this._frameId = true, this._triggerRenderFrame());
          }
          renderFrame() {
            if (!this._frameId) return;
            if (this._frameId = null, !this.isActive()) return;
            const e6 = this._tr.transform;
            if ("number" == typeof this._lastExpectedZoom) {
              const t5 = e6.zoom - this._lastExpectedZoom;
              "number" == typeof this._startZoom && (this._startZoom += t5), "number" == typeof this._targetZoom && (this._targetZoom += t5);
            }
            if (0 !== this._delta) {
              const i7 = "wheel" === this._type && Math.abs(this._delta) > na ? this._wheelZoomRate : this._defaultZoomRate;
              let r9 = 2 / (1 + Math.exp(-Math.abs(this._delta * i7)));
              this._delta < 0 && 0 !== r9 && (r9 = 1 / r9);
              const o7 = "number" != typeof this._targetZoom ? e6.scale : t4.aI(this._targetZoom);
              this._targetZoom = Math.min(e6.maxZoom, Math.max(e6.minZoom, t4.ab(o7 * r9))), "wheel" === this._type && (this._startZoom = e6.zoom, this._easing = this._smoothOutEasing(200)), this._delta = 0;
            }
            const i6 = "number" != typeof this._targetZoom ? e6.zoom : this._targetZoom, r8 = this._startZoom, o6 = this._easing;
            let a4, n6 = false;
            if ("wheel" === this._type && r8 && o6) {
              const e7 = s3.now() - this._lastWheelEventTime, l5 = Math.min((e7 + 5) / 200, 1), c5 = o6(l5);
              a4 = t4.B.number(r8, i6, c5), l5 < 1 ? this._frameId || (this._frameId = true) : n6 = true;
            } else a4 = i6, n6 = true;
            return this._active = true, n6 && (this._active = false, this._finishTimeout = setTimeout(() => {
              this._zooming = false, this._triggerRenderFrame(), delete this._targetZoom, delete this._lastExpectedZoom, delete this._finishTimeout;
            }, 200)), this._lastExpectedZoom = a4, { noInertia: true, needsRenderFrame: !n6, zoomDelta: a4 - e6.zoom, around: this._aroundPoint, originalEvent: this._lastWheelEvent };
          }
          _smoothOutEasing(e6) {
            let i6 = t4.cb;
            if (this._prevEase) {
              const e7 = this._prevEase, r8 = (s3.now() - e7.start) / e7.duration, o6 = e7.easing(r8 + 0.01) - e7.easing(r8), a4 = 0.27 / Math.sqrt(o6 * o6 + 1e-4) * 0.01, n6 = Math.sqrt(0.0729 - a4 * a4);
              i6 = t4.c9(a4, n6, 0.25, 1);
            }
            return this._prevEase = { start: s3.now(), duration: e6, easing: i6 }, i6;
          }
          reset() {
            this._active = false, this._zooming = false, delete this._targetZoom, delete this._lastExpectedZoom, this._finishTimeout && (clearTimeout(this._finishTimeout), delete this._finishTimeout);
          }
        }
        class ca {
          constructor(e6, t5) {
            this._clickZoom = e6, this._tapZoom = t5;
          }
          enable() {
            this._clickZoom.enable(), this._tapZoom.enable();
          }
          disable() {
            this._clickZoom.disable(), this._tapZoom.disable();
          }
          isEnabled() {
            return this._clickZoom.isEnabled() && this._tapZoom.isEnabled();
          }
          isActive() {
            return this._clickZoom.isActive() || this._tapZoom.isActive();
          }
        }
        class ha {
          constructor(e6) {
            this._tr = new Bo(e6), this.reset();
          }
          reset() {
            this._active = false;
          }
          dblclick(e6, t5) {
            return e6.preventDefault(), { cameraAnimation: (i6) => {
              i6.easeTo({ duration: 300, zoom: this._tr.zoom + (e6.shiftKey ? -1 : 1), around: this._tr.unproject(t5) }, { originalEvent: e6 });
            } };
          }
          enable() {
            this._enabled = true;
          }
          disable() {
            this._enabled = false, this.reset();
          }
          isEnabled() {
            return this._enabled;
          }
          isActive() {
            return this._active;
          }
        }
        class ua {
          constructor() {
            this._tap = new No({ numTouches: 1, numTaps: 1 }), this.reset();
          }
          reset() {
            this._active = false, delete this._swipePoint, delete this._swipeTouch, delete this._tapTime, delete this._tapPoint, this._tap.reset();
          }
          touchstart(e6, t5, i6) {
            if (!this._swipePoint) if (this._tapTime) {
              const r8 = t5[0], o6 = e6.timeStamp - this._tapTime < 500, a4 = this._tapPoint.dist(r8) < 30;
              o6 && a4 ? i6.length > 0 && (this._swipePoint = r8, this._swipeTouch = i6[0].identifier) : this.reset();
            } else this._tap.touchstart(e6, t5, i6);
          }
          touchmove(e6, t5, i6) {
            if (this._tapTime) {
              if (this._swipePoint) {
                if (i6[0].identifier !== this._swipeTouch) return;
                const r8 = t5[0], o6 = r8.y - this._swipePoint.y;
                return this._swipePoint = r8, e6.preventDefault(), this._active = true, { zoomDelta: o6 / 128 };
              }
            } else this._tap.touchmove(e6, t5, i6);
          }
          touchend(e6, t5, i6) {
            if (this._tapTime) this._swipePoint && 0 === i6.length && this.reset();
            else {
              const r8 = this._tap.touchend(e6, t5, i6);
              r8 && (this._tapTime = e6.timeStamp, this._tapPoint = r8);
            }
          }
          touchcancel() {
            this.reset();
          }
          enable() {
            this._enabled = true;
          }
          disable() {
            this._enabled = false, this.reset();
          }
          isEnabled() {
            return this._enabled;
          }
          isActive() {
            return this._active;
          }
        }
        class da {
          constructor(e6, t5, i6) {
            this._el = e6, this._mousePan = t5, this._touchPan = i6;
          }
          enable(e6) {
            this._inertiaOptions = e6 || {}, this._mousePan.enable(), this._touchPan.enable(), this._el.classList.add("maplibregl-touch-drag-pan");
          }
          disable() {
            this._mousePan.disable(), this._touchPan.disable(), this._el.classList.remove("maplibregl-touch-drag-pan");
          }
          isEnabled() {
            return this._mousePan.isEnabled() && this._touchPan.isEnabled();
          }
          isActive() {
            return this._mousePan.isActive() || this._touchPan.isActive();
          }
        }
        class _a6 {
          constructor(e6, t5, i6, r8) {
            this._pitchWithRotate = e6.pitchWithRotate, this._rollEnabled = e6.rollEnabled, this._mouseRotate = t5, this._mousePitch = i6, this._mouseRoll = r8;
          }
          enable() {
            this._mouseRotate.enable(), this._pitchWithRotate && this._mousePitch.enable(), this._rollEnabled && this._mouseRoll.enable();
          }
          disable() {
            this._mouseRotate.disable(), this._mousePitch.disable(), this._mouseRoll.disable();
          }
          isEnabled() {
            return this._mouseRotate.isEnabled() && (!this._pitchWithRotate || this._mousePitch.isEnabled()) && (!this._rollEnabled || this._mouseRoll.isEnabled());
          }
          isActive() {
            return this._mouseRotate.isActive() || this._mousePitch.isActive() || this._mouseRoll.isActive();
          }
        }
        class pa {
          constructor(e6, t5, i6, r8) {
            this._el = e6, this._touchZoom = t5, this._touchRotate = i6, this._tapDragZoom = r8, this._rotationDisabled = false, this._enabled = true;
          }
          enable(e6) {
            this._touchZoom.enable(e6), this._rotationDisabled || this._touchRotate.enable(e6), this._tapDragZoom.enable(), this._el.classList.add("maplibregl-touch-zoom-rotate");
          }
          disable() {
            this._touchZoom.disable(), this._touchRotate.disable(), this._tapDragZoom.disable(), this._el.classList.remove("maplibregl-touch-zoom-rotate");
          }
          isEnabled() {
            return this._touchZoom.isEnabled() && (this._rotationDisabled || this._touchRotate.isEnabled()) && this._tapDragZoom.isEnabled();
          }
          isActive() {
            return this._touchZoom.isActive() || this._touchRotate.isActive() || this._tapDragZoom.isActive();
          }
          disableRotation() {
            this._rotationDisabled = true, this._touchRotate.disable();
          }
          enableRotation() {
            this._rotationDisabled = false, this._touchZoom.isEnabled() && this._touchRotate.enable();
          }
        }
        class ma {
          constructor(e6, t5) {
            this._bypassKey = -1 !== navigator.userAgent.indexOf("Mac") ? "metaKey" : "ctrlKey", this._map = e6, this._options = t5, this._enabled = false;
          }
          isActive() {
            return false;
          }
          reset() {
          }
          _setupUI() {
            if (this._container) return;
            const e6 = this._map.getCanvasContainer();
            e6.classList.add("maplibregl-cooperative-gestures"), this._container = n5.create("div", "maplibregl-cooperative-gesture-screen", e6);
            let t5 = this._map._getUIString("CooperativeGesturesHandler.WindowsHelpText");
            "metaKey" === this._bypassKey && (t5 = this._map._getUIString("CooperativeGesturesHandler.MacHelpText"));
            const i6 = this._map._getUIString("CooperativeGesturesHandler.MobileHelpText"), r8 = document.createElement("div");
            r8.className = "maplibregl-desktop-message", r8.textContent = t5, this._container.appendChild(r8);
            const o6 = document.createElement("div");
            o6.className = "maplibregl-mobile-message", o6.textContent = i6, this._container.appendChild(o6), this._container.setAttribute("aria-hidden", "true");
          }
          _destroyUI() {
            this._container && (n5.remove(this._container), this._map.getCanvasContainer().classList.remove("maplibregl-cooperative-gestures")), delete this._container;
          }
          enable() {
            this._setupUI(), this._enabled = true;
          }
          disable() {
            this._enabled = false, this._destroyUI();
          }
          isEnabled() {
            return this._enabled;
          }
          isBypassed(e6) {
            return e6[this._bypassKey];
          }
          notifyGestureBlocked(e6, i6) {
            this._enabled && (this._map.fire(new t4.l("cooperativegestureprevented", { gestureType: e6, originalEvent: i6 })), this._container.classList.add("maplibregl-show"), setTimeout(() => {
              this._container.classList.remove("maplibregl-show");
            }, 100));
          }
        }
        const fa = (e6) => e6.zoom || e6.drag || e6.roll || e6.pitch || e6.rotate;
        class ga extends t4.l {
        }
        function va(e6) {
          return e6.panDelta && e6.panDelta.mag() || e6.zoomDelta || e6.bearingDelta || e6.pitchDelta || e6.rollDelta;
        }
        class xa {
          constructor(e6, i6) {
            this.handleWindowEvent = (e7) => {
              this.handleEvent(e7, `${e7.type}Window`);
            }, this.handleEvent = (e7, i7) => {
              if ("blur" === e7.type) return void this.stop(true);
              this._updatingCamera = true;
              const r9 = "renderFrame" === e7.type ? void 0 : e7, o6 = { needsRenderFrame: false }, a4 = {}, s4 = {};
              for (const { handlerName: l6, handler: c6, allowed: h4 } of this._handlers) {
                if (!c6.isEnabled()) continue;
                let u4;
                if (this._blockedByActive(s4, h4, l6)) c6.reset();
                else if (c6[i7 || e7.type]) {
                  if (t4.cc(e7, i7 || e7.type)) {
                    const t5 = n5.mousePos(this._map.getCanvas(), e7);
                    u4 = c6[i7 || e7.type](e7, t5);
                  } else if (t4.cd(e7, i7 || e7.type)) {
                    const t5 = this._getMapTouches(e7.touches), r10 = n5.touchPos(this._map.getCanvas(), t5);
                    u4 = c6[i7 || e7.type](e7, r10, t5);
                  } else t4.ce(i7 || e7.type) || (u4 = c6[i7 || e7.type](e7));
                  this.mergeHandlerResult(o6, a4, u4, l6, r9), u4 && u4.needsRenderFrame && this._triggerRenderFrame();
                }
                (u4 || c6.isActive()) && (s4[l6] = c6);
              }
              const l5 = {};
              for (const e8 in this._previousActiveHandlers) s4[e8] || (l5[e8] = r9);
              this._previousActiveHandlers = s4, (Object.keys(l5).length || va(o6)) && (this._changes.push([o6, a4, l5]), this._triggerRenderFrame()), (Object.keys(s4).length || va(o6)) && this._map._stop(true), this._updatingCamera = false;
              const { cameraAnimation: c5 } = o6;
              c5 && (this._inertia.clear(), this._fireEvents({}, {}, true), this._changes = [], c5(this._map));
            }, this._map = e6, this._el = this._map.getCanvasContainer(), this._handlers = [], this._handlersById = {}, this._changes = [], this._inertia = new So(e6), this._bearingSnap = i6.bearingSnap, this._previousActiveHandlers = {}, this._eventsInProgress = {}, this._addDefaultHandlers(i6);
            const r8 = this._el;
            this._listeners = [[r8, "touchstart", { passive: true }], [r8, "touchmove", { passive: false }], [r8, "touchend", void 0], [r8, "touchcancel", void 0], [r8, "mousedown", void 0], [r8, "mousemove", void 0], [r8, "mouseup", void 0], [document, "mousemove", { capture: true }], [document, "mouseup", void 0], [r8, "mouseover", void 0], [r8, "mouseout", void 0], [r8, "dblclick", void 0], [r8, "click", void 0], [r8, "keydown", { capture: false }], [r8, "keyup", void 0], [r8, "wheel", { passive: false }], [r8, "contextmenu", void 0], [window, "blur", void 0]];
            for (const [e7, t5, i7] of this._listeners) n5.addEventListener(e7, t5, e7 === document ? this.handleWindowEvent : this.handleEvent, i7);
          }
          destroy() {
            for (const [e6, t5, i6] of this._listeners) n5.removeEventListener(e6, t5, e6 === document ? this.handleWindowEvent : this.handleEvent, i6);
          }
          _addDefaultHandlers(e6) {
            const i6 = this._map, r8 = i6.getCanvasContainer();
            this._add("mapEvent", new ko(i6, e6));
            const o6 = i6.boxZoom = new Oo(i6, e6);
            this._add("boxZoom", o6), e6.interactive && e6.boxZoom && o6.enable();
            const a4 = i6.cooperativeGestures = new ma(i6, e6.cooperativeGestures);
            this._add("cooperativeGestures", a4), e6.cooperativeGestures && a4.enable();
            const s4 = new Go(i6), l5 = new ha(i6);
            i6.doubleClickZoom = new ca(l5, s4), this._add("tapZoom", s4), this._add("clickZoom", l5), e6.interactive && e6.doubleClickZoom && i6.doubleClickZoom.enable();
            const c5 = new ua();
            this._add("tapDragZoom", c5);
            const h4 = i6.touchPitch = new ra(i6);
            this._add("touchPitch", h4), e6.interactive && e6.touchPitch && i6.touchPitch.enable(e6.touchPitch);
            const u4 = () => i6.project(i6.getCenter()), d4 = function({ enable: e7, clickTolerance: i7, aroundCenter: r9 = true, minPixelCenterThreshold: o7 = 100, rotateDegreesPerPixelMoved: a5 = 0.8 }, s5) {
              const l6 = new qo({ checkCorrectEvent: (e8) => 0 === n5.mouseButton(e8) && e8.ctrlKey || 2 === n5.mouseButton(e8) && !e8.ctrlKey });
              return new Uo({ clickTolerance: i7, move: (e8, i8) => {
                const n6 = s5();
                if (r9 && Math.abs(n6.y - e8.y) > o7) return { bearingDelta: t4.ca(new t4.P(e8.x, i8.y), i8, n6) };
                let l7 = (i8.x - e8.x) * a5;
                return r9 && i8.y < n6.y && (l7 = -l7), { bearingDelta: l7 };
              }, moveStateManager: l6, enable: e7, assignEvents: Ho });
            }(e6, u4), _4 = function({ enable: e7, clickTolerance: t5, pitchDegreesPerPixelMoved: i7 = -0.5 }) {
              const r9 = new qo({ checkCorrectEvent: (e8) => 0 === n5.mouseButton(e8) && e8.ctrlKey || 2 === n5.mouseButton(e8) });
              return new Uo({ clickTolerance: t5, move: (e8, t6) => ({ pitchDelta: (t6.y - e8.y) * i7 }), moveStateManager: r9, enable: e7, assignEvents: Ho });
            }(e6), p4 = function({ enable: e7, clickTolerance: t5, rollDegreesPerPixelMoved: i7 = 0.3 }, r9) {
              const o7 = new qo({ checkCorrectEvent: (e8) => 2 === n5.mouseButton(e8) && e8.ctrlKey });
              return new Uo({ clickTolerance: t5, move: (e8, t6) => {
                const o8 = r9();
                let a5 = (t6.x - e8.x) * i7;
                return t6.y < o8.y && (a5 = -a5), { rollDelta: a5 };
              }, moveStateManager: o7, enable: e7, assignEvents: Ho });
            }(e6, u4);
            i6.dragRotate = new _a6(e6, d4, _4, p4), this._add("mouseRotate", d4, ["mousePitch"]), this._add("mousePitch", _4, ["mouseRotate", "mouseRoll"]), this._add("mouseRoll", p4, ["mousePitch"]), e6.interactive && e6.dragRotate && i6.dragRotate.enable();
            const m4 = function({ enable: e7, clickTolerance: t5 }) {
              const i7 = new qo({ checkCorrectEvent: (e8) => 0 === n5.mouseButton(e8) && !e8.ctrlKey });
              return new Uo({ clickTolerance: t5, move: (e8, t6) => ({ around: t6, panDelta: t6.sub(e8) }), activateOnStart: true, moveStateManager: i7, enable: e7, assignEvents: Ho });
            }(e6), f4 = new Ko(e6, i6);
            i6.dragPan = new da(r8, m4, f4), this._add("mousePan", m4), this._add("touchPan", f4, ["touchZoom", "touchRotate"]), e6.interactive && e6.dragPan && i6.dragPan.enable(e6.dragPan);
            const g4 = new ta(), v4 = new Jo();
            i6.touchZoomRotate = new pa(r8, v4, g4, c5), this._add("touchRotate", g4, ["touchPan", "touchZoom"]), this._add("touchZoom", v4, ["touchPan", "touchRotate"]), e6.interactive && e6.touchZoomRotate && i6.touchZoomRotate.enable(e6.touchZoomRotate);
            const x4 = i6.scrollZoom = new la(i6, () => this._triggerRenderFrame());
            this._add("scrollZoom", x4, ["mousePan"]), e6.interactive && e6.scrollZoom && i6.scrollZoom.enable(e6.scrollZoom);
            const b5 = i6.keyboard = new aa(i6);
            this._add("keyboard", b5), e6.interactive && e6.keyboard && i6.keyboard.enable(), this._add("blockableMapEvent", new Fo(i6));
          }
          _add(e6, t5, i6) {
            this._handlers.push({ handlerName: e6, handler: t5, allowed: i6 }), this._handlersById[e6] = t5;
          }
          stop(e6) {
            if (!this._updatingCamera) {
              for (const { handler: e7 } of this._handlers) e7.reset();
              this._inertia.clear(), this._fireEvents({}, {}, e6), this._changes = [];
            }
          }
          isActive() {
            for (const { handler: e6 } of this._handlers) if (e6.isActive()) return true;
            return false;
          }
          isZooming() {
            return !!this._eventsInProgress.zoom || this._map.scrollZoom.isZooming();
          }
          isRotating() {
            return !!this._eventsInProgress.rotate;
          }
          isMoving() {
            return Boolean(fa(this._eventsInProgress)) || this.isZooming();
          }
          _blockedByActive(e6, t5, i6) {
            for (const r8 in e6) if (r8 !== i6 && (!t5 || t5.indexOf(r8) < 0)) return true;
            return false;
          }
          _getMapTouches(e6) {
            const t5 = [];
            for (const i6 of e6) this._el.contains(i6.target) && t5.push(i6);
            return t5;
          }
          mergeHandlerResult(e6, i6, r8, o6, a4) {
            if (!r8) return;
            t4.e(e6, r8);
            const s4 = { handlerName: o6, originalEvent: r8.originalEvent || a4 };
            void 0 !== r8.zoomDelta && (i6.zoom = s4), void 0 !== r8.panDelta && (i6.drag = s4), void 0 !== r8.rollDelta && (i6.roll = s4), void 0 !== r8.pitchDelta && (i6.pitch = s4), void 0 !== r8.bearingDelta && (i6.rotate = s4);
          }
          _applyChanges() {
            const e6 = {}, i6 = {}, r8 = {};
            for (const [o6, a4, s4] of this._changes) o6.panDelta && (e6.panDelta = (e6.panDelta || new t4.P(0, 0))._add(o6.panDelta)), o6.zoomDelta && (e6.zoomDelta = (e6.zoomDelta || 0) + o6.zoomDelta), o6.bearingDelta && (e6.bearingDelta = (e6.bearingDelta || 0) + o6.bearingDelta), o6.pitchDelta && (e6.pitchDelta = (e6.pitchDelta || 0) + o6.pitchDelta), o6.rollDelta && (e6.rollDelta = (e6.rollDelta || 0) + o6.rollDelta), void 0 !== o6.around && (e6.around = o6.around), void 0 !== o6.pinchAround && (e6.pinchAround = o6.pinchAround), o6.noInertia && (e6.noInertia = o6.noInertia), t4.e(i6, a4), t4.e(r8, s4);
            this._updateMapTransform(e6, i6, r8), this._changes = [];
          }
          _updateMapTransform(e6, t5, i6) {
            const r8 = this._map, o6 = r8._getTransformForUpdate(), a4 = r8.terrain;
            if (!(va(e6) || a4 && this._terrainMovement)) return this._fireEvents(t5, i6, true);
            r8._stop(true);
            let { panDelta: s4, zoomDelta: n6, bearingDelta: l5, pitchDelta: c5, rollDelta: h4, around: u4, pinchAround: d4 } = e6;
            void 0 !== d4 && (u4 = d4), u4 = u4 || r8.transform.centerPoint, a4 && !o6.isPointOnMapSurface(u4) && (u4 = o6.centerPoint);
            const _4 = { panDelta: s4, zoomDelta: n6, rollDelta: h4, pitchDelta: c5, bearingDelta: l5, around: u4 };
            this._map.cameraHelper.useGlobeControls && !o6.isPointOnMapSurface(u4) && (u4 = o6.centerPoint);
            const p4 = u4.distSqr(o6.centerPoint) < 0.01 ? o6.center : o6.screenPointToLocation(s4 ? u4.sub(s4) : u4);
            a4 ? (this._map.cameraHelper.handleMapControlsRollPitchBearingZoom(_4, o6), this._terrainMovement || !t5.drag && !t5.zoom ? t5.drag && this._terrainMovement ? o6.setCenter(o6.screenPointToLocation(o6.centerPoint.sub(s4))) : this._map.cameraHelper.handleMapControlsPan(_4, o6, p4) : (this._terrainMovement = true, this._map._elevationFreeze = true, this._map.cameraHelper.handleMapControlsPan(_4, o6, p4))) : (this._map.cameraHelper.handleMapControlsRollPitchBearingZoom(_4, o6), this._map.cameraHelper.handleMapControlsPan(_4, o6, p4)), r8._applyUpdatedTransform(o6), this._map._update(), e6.noInertia || this._inertia.record(e6), this._fireEvents(t5, i6, true);
          }
          _fireEvents(e6, i6, r8) {
            const o6 = fa(this._eventsInProgress), a4 = fa(e6), n6 = {};
            for (const t5 in e6) {
              const { originalEvent: i7 } = e6[t5];
              this._eventsInProgress[t5] || (n6[`${t5}start`] = i7), this._eventsInProgress[t5] = e6[t5];
            }
            !o6 && a4 && this._fireEvent("movestart", a4.originalEvent);
            for (const e7 in n6) this._fireEvent(e7, n6[e7]);
            a4 && this._fireEvent("move", a4.originalEvent);
            for (const t5 in e6) {
              const { originalEvent: i7 } = e6[t5];
              this._fireEvent(t5, i7);
            }
            const l5 = {};
            let c5;
            for (const e7 in this._eventsInProgress) {
              const { handlerName: t5, originalEvent: r9 } = this._eventsInProgress[e7];
              this._handlersById[t5].isActive() || (delete this._eventsInProgress[e7], c5 = i6[t5] || r9, l5[`${e7}end`] = c5);
            }
            for (const e7 in l5) this._fireEvent(e7, l5[e7]);
            const h4 = fa(this._eventsInProgress), u4 = (o6 || a4) && !h4;
            if (u4 && this._terrainMovement) {
              this._map._elevationFreeze = false, this._terrainMovement = false;
              const e7 = this._map._getTransformForUpdate();
              this._map.getCenterClampedToGround() && e7.recalculateZoomAndCenter(this._map.terrain), this._map._applyUpdatedTransform(e7);
            }
            if (r8 && u4) {
              this._updatingCamera = true;
              const e7 = this._inertia._onMoveEnd(this._map.dragPan._inertiaOptions), i7 = (e8) => 0 !== e8 && -this._bearingSnap < e8 && e8 < this._bearingSnap;
              !e7 || !e7.essential && s3.prefersReducedMotion ? (this._map.fire(new t4.l("moveend", { originalEvent: c5 })), i7(this._map.getBearing()) && this._map.resetNorth()) : (i7(e7.bearing || this._map.getBearing()) && (e7.bearing = 0), e7.freezeElevation = true, this._map.easeTo(e7, { originalEvent: c5 })), this._updatingCamera = false;
            }
          }
          _fireEvent(e6, i6) {
            this._map.fire(new t4.l(e6, i6 ? { originalEvent: i6 } : {}));
          }
          _requestFrame() {
            return this._map.triggerRepaint(), this._map._renderTaskQueue.add((e6) => {
              delete this._frameId, this.handleEvent(new ga("renderFrame", { timeStamp: e6 })), this._applyChanges();
            });
          }
          _triggerRenderFrame() {
            void 0 === this._frameId && (this._frameId = this._requestFrame());
          }
        }
        class ba extends t4.E {
          constructor(e6, t5, i6) {
            super(), this._renderFrameCallback = () => {
              const e7 = Math.min((s3.now() - this._easeStart) / this._easeOptions.duration, 1);
              this._onEaseFrame(this._easeOptions.easing(e7)), e7 < 1 && this._easeFrameId ? this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback) : this.stop();
            }, this._moving = false, this._zooming = false, this.transform = e6, this._bearingSnap = i6.bearingSnap, this.cameraHelper = t5, this.on("moveend", () => {
              delete this._requestedCameraState;
            });
          }
          migrateProjection(e6, t5) {
            e6.apply(this.transform), this.transform = e6, this.cameraHelper = t5;
          }
          getCenter() {
            return new t4.Q(this.transform.center.lng, this.transform.center.lat);
          }
          setCenter(e6, t5) {
            return this.jumpTo({ center: e6 }, t5);
          }
          getCenterElevation() {
            return this.transform.elevation;
          }
          setCenterElevation(e6, t5) {
            return this.jumpTo({ elevation: e6 }, t5), this;
          }
          getCenterClampedToGround() {
            return this._centerClampedToGround;
          }
          setCenterClampedToGround(e6) {
            this._centerClampedToGround = e6;
          }
          panBy(e6, i6, r8) {
            return e6 = t4.P.convert(e6).mult(-1), this.panTo(this.transform.center, t4.e({ offset: e6 }, i6), r8);
          }
          panTo(e6, i6, r8) {
            return this.easeTo(t4.e({ center: e6 }, i6), r8);
          }
          getZoom() {
            return this.transform.zoom;
          }
          setZoom(e6, t5) {
            return this.jumpTo({ zoom: e6 }, t5), this;
          }
          zoomTo(e6, i6, r8) {
            return this.easeTo(t4.e({ zoom: e6 }, i6), r8);
          }
          zoomIn(e6, t5) {
            return this.zoomTo(this.getZoom() + 1, e6, t5), this;
          }
          zoomOut(e6, t5) {
            return this.zoomTo(this.getZoom() - 1, e6, t5), this;
          }
          getVerticalFieldOfView() {
            return this.transform.fov;
          }
          setVerticalFieldOfView(e6, i6) {
            return e6 != this.transform.fov && (this.transform.setFov(e6), this.fire(new t4.l("movestart", i6)).fire(new t4.l("move", i6)).fire(new t4.l("moveend", i6))), this;
          }
          getBearing() {
            return this.transform.bearing;
          }
          setBearing(e6, t5) {
            return this.jumpTo({ bearing: e6 }, t5), this;
          }
          getPadding() {
            return this.transform.padding;
          }
          setPadding(e6, t5) {
            return this.jumpTo({ padding: e6 }, t5), this;
          }
          rotateTo(e6, i6, r8) {
            return this.easeTo(t4.e({ bearing: e6 }, i6), r8);
          }
          resetNorth(e6, i6) {
            return this.rotateTo(0, t4.e({ duration: 1e3 }, e6), i6), this;
          }
          resetNorthPitch(e6, i6) {
            return this.easeTo(t4.e({ bearing: 0, pitch: 0, roll: 0, duration: 1e3 }, e6), i6), this;
          }
          snapToNorth(e6, t5) {
            return Math.abs(this.getBearing()) < this._bearingSnap ? this.resetNorth(e6, t5) : this;
          }
          getPitch() {
            return this.transform.pitch;
          }
          setPitch(e6, t5) {
            return this.jumpTo({ pitch: e6 }, t5), this;
          }
          getRoll() {
            return this.transform.roll;
          }
          setRoll(e6, t5) {
            return this.jumpTo({ roll: e6 }, t5), this;
          }
          cameraForBounds(e6, t5) {
            e6 = V2.convert(e6).adjustAntiMeridian();
            const i6 = t5 && t5.bearing || 0;
            return this._cameraForBoxAndBearing(e6.getNorthWest(), e6.getSouthEast(), i6, t5);
          }
          _cameraForBoxAndBearing(e6, i6, r8, o6) {
            const a4 = { top: 0, bottom: 0, right: 0, left: 0 };
            if ("number" == typeof (o6 = t4.e({ padding: a4, offset: [0, 0], maxZoom: this.transform.maxZoom }, o6)).padding) {
              const e7 = o6.padding;
              o6.padding = { top: e7, bottom: e7, right: e7, left: e7 };
            }
            const s4 = t4.e(a4, o6.padding);
            o6.padding = s4;
            const n6 = this.transform, l5 = new V2(e6, i6);
            return this.cameraHelper.cameraForBoxAndBearing(o6, s4, l5, r8, n6);
          }
          fitBounds(e6, t5, i6) {
            return this._fitInternal(this.cameraForBounds(e6, t5), t5, i6);
          }
          fitScreenCoordinates(e6, i6, r8, o6, a4) {
            return this._fitInternal(this._cameraForBoxAndBearing(this.transform.screenPointToLocation(t4.P.convert(e6)), this.transform.screenPointToLocation(t4.P.convert(i6)), r8, o6), o6, a4);
          }
          _fitInternal(e6, i6, r8) {
            return e6 ? (delete (i6 = t4.e(e6, i6)).padding, i6.linear ? this.easeTo(i6, r8) : this.flyTo(i6, r8)) : this;
          }
          jumpTo(e6, i6) {
            this.stop();
            const r8 = this._getTransformForUpdate();
            let o6 = false, a4 = false, s4 = false;
            const n6 = r8.zoom;
            this.cameraHelper.handleJumpToCenterZoom(r8, e6);
            const l5 = r8.zoom !== n6;
            return "elevation" in e6 && r8.elevation !== +e6.elevation && r8.setElevation(+e6.elevation), "bearing" in e6 && r8.bearing !== +e6.bearing && (o6 = true, r8.setBearing(+e6.bearing)), "pitch" in e6 && r8.pitch !== +e6.pitch && (a4 = true, r8.setPitch(+e6.pitch)), "roll" in e6 && r8.roll !== +e6.roll && (s4 = true, r8.setRoll(+e6.roll)), null == e6.padding || r8.isPaddingEqual(e6.padding) || r8.setPadding(e6.padding), this._applyUpdatedTransform(r8), this.fire(new t4.l("movestart", i6)).fire(new t4.l("move", i6)), l5 && this.fire(new t4.l("zoomstart", i6)).fire(new t4.l("zoom", i6)).fire(new t4.l("zoomend", i6)), o6 && this.fire(new t4.l("rotatestart", i6)).fire(new t4.l("rotate", i6)).fire(new t4.l("rotateend", i6)), a4 && this.fire(new t4.l("pitchstart", i6)).fire(new t4.l("pitch", i6)).fire(new t4.l("pitchend", i6)), s4 && this.fire(new t4.l("rollstart", i6)).fire(new t4.l("roll", i6)).fire(new t4.l("rollend", i6)), this.fire(new t4.l("moveend", i6));
          }
          calculateCameraOptionsFromTo(e6, i6, r8, o6 = 0) {
            const a4 = t4.$.fromLngLat(e6, i6), s4 = t4.$.fromLngLat(r8, o6), n6 = s4.x - a4.x, l5 = s4.y - a4.y, c5 = s4.z - a4.z, h4 = Math.hypot(n6, l5, c5);
            if (0 === h4) throw new Error("Can't calculate camera options with same From and To");
            const u4 = Math.hypot(n6, l5), d4 = t4.ab(this.transform.cameraToCenterDistance / h4 / this.transform.tileSize), _4 = 180 * Math.atan2(n6, -l5) / Math.PI;
            let p4 = 180 * Math.acos(u4 / h4) / Math.PI;
            return p4 = c5 < 0 ? 90 - p4 : 90 + p4, { center: s4.toLngLat(), elevation: o6, zoom: d4, pitch: p4, bearing: _4 };
          }
          calculateCameraOptionsFromCameraLngLatAltRotation(e6, t5, i6, r8, o6) {
            const a4 = this.transform.calculateCenterFromCameraLngLatAlt(e6, t5, i6, r8);
            return { center: a4.center, elevation: a4.elevation, zoom: a4.zoom, bearing: i6, pitch: r8, roll: o6 };
          }
          easeTo(e6, i6) {
            this._stop(false, e6.easeId), (false === (e6 = t4.e({ offset: [0, 0], duration: 500, easing: t4.cb }, e6)).animate || !e6.essential && s3.prefersReducedMotion) && (e6.duration = 0);
            const r8 = this._getTransformForUpdate(), o6 = this.getBearing(), a4 = r8.pitch, n6 = r8.roll, l5 = "bearing" in e6 ? this._normalizeBearing(e6.bearing, o6) : o6, c5 = "pitch" in e6 ? +e6.pitch : a4, h4 = "roll" in e6 ? this._normalizeBearing(e6.roll, n6) : n6, u4 = "padding" in e6 ? e6.padding : r8.padding, d4 = t4.P.convert(e6.offset);
            let _4, p4;
            e6.around && (_4 = t4.Q.convert(e6.around), p4 = r8.locationToScreenPoint(_4));
            const m4 = { moving: this._moving, zooming: this._zooming, rotating: this._rotating, pitching: this._pitching, rolling: this._rolling }, f4 = this.cameraHelper.handleEaseTo(r8, { bearing: l5, pitch: c5, roll: h4, padding: u4, around: _4, aroundPoint: p4, offsetAsPoint: d4, offset: e6.offset, zoom: e6.zoom, center: e6.center });
            return this._rotating = this._rotating || o6 !== l5, this._pitching = this._pitching || c5 !== a4, this._rolling = this._rolling || h4 !== n6, this._padding = !r8.isPaddingEqual(u4), this._zooming = this._zooming || f4.isZooming, this._easeId = e6.easeId, this._prepareEase(i6, e6.noMoveStart, m4), this.terrain && this._prepareElevation(f4.elevationCenter), this._ease((t5) => {
              f4.easeFunc(t5), this.terrain && !e6.freezeElevation && this._updateElevation(t5), this._applyUpdatedTransform(r8), this._fireMoveEvents(i6);
            }, (t5) => {
              this.terrain && e6.freezeElevation && this._finalizeElevation(), this._afterEase(i6, t5);
            }, e6), this;
          }
          _prepareEase(e6, i6, r8 = {}) {
            this._moving = true, i6 || r8.moving || this.fire(new t4.l("movestart", e6)), this._zooming && !r8.zooming && this.fire(new t4.l("zoomstart", e6)), this._rotating && !r8.rotating && this.fire(new t4.l("rotatestart", e6)), this._pitching && !r8.pitching && this.fire(new t4.l("pitchstart", e6)), this._rolling && !r8.rolling && this.fire(new t4.l("rollstart", e6));
          }
          _prepareElevation(e6) {
            this._elevationCenter = e6, this._elevationStart = this.transform.elevation, this._elevationTarget = this.terrain.getElevationForLngLatZoom(e6, this.transform.tileZoom), this._elevationFreeze = true;
          }
          _updateElevation(e6) {
            this.transform.setMinElevationForCurrentTile(this.terrain.getMinTileElevationForLngLatZoom(this._elevationCenter, this.transform.tileZoom));
            const i6 = this.terrain.getElevationForLngLatZoom(this._elevationCenter, this.transform.tileZoom);
            if (e6 < 1 && i6 !== this._elevationTarget) {
              const t5 = this._elevationTarget - this._elevationStart;
              this._elevationStart += e6 * (t5 - (i6 - (t5 * e6 + this._elevationStart)) / (1 - e6)), this._elevationTarget = i6;
            }
            this.transform.setElevation(t4.B.number(this._elevationStart, this._elevationTarget, e6));
          }
          _finalizeElevation() {
            this._elevationFreeze = false, this.getCenterClampedToGround() && this.transform.recalculateZoomAndCenter(this.terrain);
          }
          _getTransformForUpdate() {
            return this.transformCameraUpdate || this.terrain ? (this._requestedCameraState || (this._requestedCameraState = this.transform.clone()), this._requestedCameraState) : this.transform;
          }
          _elevateCameraIfInsideTerrain(e6) {
            if (!this.terrain && e6.elevation >= 0 && e6.pitch <= 90) return {};
            const t5 = e6.getCameraLngLat(), i6 = e6.getCameraAltitude(), r8 = this.terrain ? this.terrain.getElevationForLngLatZoom(t5, e6.zoom) : 0;
            if (i6 < r8) {
              const i7 = this.calculateCameraOptionsFromTo(t5, r8, e6.center, e6.elevation);
              return { pitch: i7.pitch, zoom: i7.zoom };
            }
            return {};
          }
          _applyUpdatedTransform(e6) {
            const t5 = [];
            if (t5.push((e7) => this._elevateCameraIfInsideTerrain(e7)), this.transformCameraUpdate && t5.push((e7) => this.transformCameraUpdate(e7)), !t5.length) return;
            const i6 = e6.clone();
            for (const e7 of t5) {
              const t6 = i6.clone(), { center: r8, zoom: o6, roll: a4, pitch: s4, bearing: n6, elevation: l5 } = e7(t6);
              r8 && t6.setCenter(r8), void 0 !== l5 && t6.setElevation(l5), void 0 !== o6 && t6.setZoom(o6), void 0 !== a4 && t6.setRoll(a4), void 0 !== s4 && t6.setPitch(s4), void 0 !== n6 && t6.setBearing(n6), i6.apply(t6);
            }
            this.transform.apply(i6);
          }
          _fireMoveEvents(e6) {
            this.fire(new t4.l("move", e6)), this._zooming && this.fire(new t4.l("zoom", e6)), this._rotating && this.fire(new t4.l("rotate", e6)), this._pitching && this.fire(new t4.l("pitch", e6)), this._rolling && this.fire(new t4.l("roll", e6));
          }
          _afterEase(e6, i6) {
            if (this._easeId && i6 && this._easeId === i6) return;
            delete this._easeId;
            const r8 = this._zooming, o6 = this._rotating, a4 = this._pitching, s4 = this._rolling;
            this._moving = false, this._zooming = false, this._rotating = false, this._pitching = false, this._rolling = false, this._padding = false, r8 && this.fire(new t4.l("zoomend", e6)), o6 && this.fire(new t4.l("rotateend", e6)), a4 && this.fire(new t4.l("pitchend", e6)), s4 && this.fire(new t4.l("rollend", e6)), this.fire(new t4.l("moveend", e6));
          }
          flyTo(e6, i6) {
            if (!e6.essential && s3.prefersReducedMotion) {
              const r9 = t4.O(e6, ["center", "zoom", "bearing", "pitch", "roll", "elevation"]);
              return this.jumpTo(r9, i6);
            }
            this.stop(), e6 = t4.e({ offset: [0, 0], speed: 1.2, curve: 1.42, easing: t4.cb }, e6);
            const r8 = this._getTransformForUpdate(), o6 = r8.bearing, a4 = r8.pitch, n6 = r8.roll, l5 = r8.padding, c5 = "bearing" in e6 ? this._normalizeBearing(e6.bearing, o6) : o6, h4 = "pitch" in e6 ? +e6.pitch : a4, u4 = "roll" in e6 ? this._normalizeBearing(e6.roll, n6) : n6, d4 = "padding" in e6 ? e6.padding : r8.padding, _4 = t4.P.convert(e6.offset);
            let p4 = r8.centerPoint.add(_4);
            const m4 = r8.screenPointToLocation(p4), f4 = this.cameraHelper.handleFlyTo(r8, { bearing: c5, pitch: h4, roll: u4, padding: d4, locationAtOffset: m4, offsetAsPoint: _4, center: e6.center, minZoom: e6.minZoom, zoom: e6.zoom });
            let g4 = e6.curve;
            const v4 = Math.max(r8.width, r8.height), x4 = v4 / f4.scaleOfZoom, b5 = f4.pixelPathLength;
            "number" == typeof f4.scaleOfMinZoom && (g4 = Math.sqrt(v4 / f4.scaleOfMinZoom / b5 * 2));
            const y4 = g4 * g4;
            function w4(e7) {
              const t5 = (x4 * x4 - v4 * v4 + (e7 ? -1 : 1) * y4 * y4 * b5 * b5) / (2 * (e7 ? x4 : v4) * y4 * b5);
              return Math.log(Math.sqrt(t5 * t5 + 1) - t5);
            }
            function T5(e7) {
              return (Math.exp(e7) - Math.exp(-e7)) / 2;
            }
            function P4(e7) {
              return (Math.exp(e7) + Math.exp(-e7)) / 2;
            }
            const C4 = w4(false);
            let I4 = function(e7) {
              return P4(C4) / P4(C4 + g4 * e7);
            }, M5 = function(e7) {
              return v4 * ((P4(C4) * (T5(t5 = C4 + g4 * e7) / P4(t5)) - T5(C4)) / y4) / b5;
              var t5;
            }, E4 = (w4(true) - C4) / g4;
            if (Math.abs(b5) < 2e-6 || !isFinite(E4)) {
              if (Math.abs(v4 - x4) < 1e-6) return this.easeTo(e6, i6);
              const t5 = x4 < v4 ? -1 : 1;
              E4 = Math.abs(Math.log(x4 / v4)) / g4, M5 = () => 0, I4 = (e7) => Math.exp(t5 * g4 * e7);
            }
            return e6.duration = "duration" in e6 ? +e6.duration : 1e3 * E4 / ("screenSpeed" in e6 ? +e6.screenSpeed / g4 : +e6.speed), e6.maxDuration && e6.duration > e6.maxDuration && (e6.duration = 0), this._zooming = true, this._rotating = o6 !== c5, this._pitching = h4 !== a4, this._rolling = u4 !== n6, this._padding = !r8.isPaddingEqual(d4), this._prepareEase(i6, false), this.terrain && this._prepareElevation(f4.targetCenter), this._ease((s4) => {
              const m5 = s4 * E4, g5 = 1 / I4(m5), v5 = M5(m5);
              this._rotating && r8.setBearing(t4.B.number(o6, c5, s4)), this._pitching && r8.setPitch(t4.B.number(a4, h4, s4)), this._rolling && r8.setRoll(t4.B.number(n6, u4, s4)), this._padding && (r8.interpolatePadding(l5, d4, s4), p4 = r8.centerPoint.add(_4)), f4.easeFunc(s4, g5, v5, p4), this.terrain && !e6.freezeElevation && this._updateElevation(s4), this._applyUpdatedTransform(r8), this._fireMoveEvents(i6);
            }, () => {
              this.terrain && e6.freezeElevation && this._finalizeElevation(), this._afterEase(i6);
            }, e6), this;
          }
          isEasing() {
            return !!this._easeFrameId;
          }
          stop() {
            return this._stop();
          }
          _stop(e6, t5) {
            var i6;
            if (this._easeFrameId && (this._cancelRenderFrame(this._easeFrameId), delete this._easeFrameId, delete this._onEaseFrame), this._onEaseEnd) {
              const e7 = this._onEaseEnd;
              delete this._onEaseEnd, e7.call(this, t5);
            }
            return e6 || null === (i6 = this.handlers) || void 0 === i6 || i6.stop(false), this;
          }
          _ease(e6, t5, i6) {
            false === i6.animate || 0 === i6.duration ? (e6(1), t5()) : (this._easeStart = s3.now(), this._easeOptions = i6, this._onEaseFrame = e6, this._onEaseEnd = t5, this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback));
          }
          _normalizeBearing(e6, i6) {
            e6 = t4.aL(e6, -180, 180);
            const r8 = Math.abs(e6 - i6);
            return Math.abs(e6 - 360 - i6) < r8 && (e6 -= 360), Math.abs(e6 + 360 - i6) < r8 && (e6 += 360), e6;
          }
          queryTerrainElevation(e6) {
            return this.terrain ? this.terrain.getElevationForLngLatZoom(t4.Q.convert(e6), this.transform.tileZoom) : null;
          }
        }
        const ya = { compact: true, customAttribution: '<a href="https://maplibre.org/" target="_blank">MapLibre</a>' };
        class wa {
          constructor(e6 = ya) {
            this._toggleAttribution = () => {
              this._container.classList.contains("maplibregl-compact") && (this._container.classList.contains("maplibregl-compact-show") ? (this._container.setAttribute("open", ""), this._container.classList.remove("maplibregl-compact-show")) : (this._container.classList.add("maplibregl-compact-show"), this._container.removeAttribute("open")));
            }, this._updateData = (e7) => {
              !e7 || "metadata" !== e7.sourceDataType && "visibility" !== e7.sourceDataType && "style" !== e7.dataType && "terrain" !== e7.type || this._updateAttributions();
            }, this._updateCompact = () => {
              this._map.getCanvasContainer().offsetWidth <= 640 || this._compact ? false === this._compact ? this._container.setAttribute("open", "") : this._container.classList.contains("maplibregl-compact") || this._container.classList.contains("maplibregl-attrib-empty") || (this._container.setAttribute("open", ""), this._container.classList.add("maplibregl-compact", "maplibregl-compact-show")) : (this._container.setAttribute("open", ""), this._container.classList.contains("maplibregl-compact") && this._container.classList.remove("maplibregl-compact", "maplibregl-compact-show"));
            }, this._updateCompactMinimize = () => {
              this._container.classList.contains("maplibregl-compact") && this._container.classList.contains("maplibregl-compact-show") && this._container.classList.remove("maplibregl-compact-show");
            }, this.options = e6;
          }
          getDefaultPosition() {
            return "bottom-right";
          }
          onAdd(e6) {
            return this._map = e6, this._compact = this.options.compact, this._container = n5.create("details", "maplibregl-ctrl maplibregl-ctrl-attrib"), this._compactButton = n5.create("summary", "maplibregl-ctrl-attrib-button", this._container), this._compactButton.addEventListener("click", this._toggleAttribution), this._setElementTitle(this._compactButton, "ToggleAttribution"), this._innerContainer = n5.create("div", "maplibregl-ctrl-attrib-inner", this._container), this._updateAttributions(), this._updateCompact(), this._map.on("styledata", this._updateData), this._map.on("sourcedata", this._updateData), this._map.on("terrain", this._updateData), this._map.on("resize", this._updateCompact), this._map.on("drag", this._updateCompactMinimize), this._container;
          }
          onRemove() {
            n5.remove(this._container), this._map.off("styledata", this._updateData), this._map.off("sourcedata", this._updateData), this._map.off("terrain", this._updateData), this._map.off("resize", this._updateCompact), this._map.off("drag", this._updateCompactMinimize), this._map = void 0, this._compact = void 0, this._attribHTML = void 0;
          }
          _setElementTitle(e6, t5) {
            const i6 = this._map._getUIString(`AttributionControl.${t5}`);
            e6.title = i6, e6.setAttribute("aria-label", i6);
          }
          _updateAttributions() {
            if (!this._map.style) return;
            let e6 = [];
            if (this.options.customAttribution && (Array.isArray(this.options.customAttribution) ? e6 = e6.concat(this.options.customAttribution.map((e7) => "string" != typeof e7 ? "" : e7)) : "string" == typeof this.options.customAttribution && e6.push(this.options.customAttribution)), this._map.style.stylesheet) {
              const e7 = this._map.style.stylesheet;
              this.styleOwner = e7.owner, this.styleId = e7.id;
            }
            const t5 = this._map.style.sourceCaches;
            for (const i7 in t5) {
              const r8 = t5[i7];
              if (r8.used || r8.usedForTerrain) {
                const t6 = r8.getSource();
                t6.attribution && e6.indexOf(t6.attribution) < 0 && e6.push(t6.attribution);
              }
            }
            e6 = e6.filter((e7) => String(e7).trim()), e6.sort((e7, t6) => e7.length - t6.length), e6 = e6.filter((t6, i7) => {
              for (let r8 = i7 + 1; r8 < e6.length; r8++) if (e6[r8].indexOf(t6) >= 0) return false;
              return true;
            });
            const i6 = e6.join(" | ");
            i6 !== this._attribHTML && (this._attribHTML = i6, e6.length ? (this._innerContainer.innerHTML = n5.sanitize(i6), this._container.classList.remove("maplibregl-attrib-empty")) : this._container.classList.add("maplibregl-attrib-empty"), this._updateCompact(), this._editLink = null);
          }
        }
        class Ta {
          constructor(e6 = {}) {
            this._updateCompact = () => {
              const e7 = this._container.children;
              if (e7.length) {
                const t5 = e7[0];
                this._map.getCanvasContainer().offsetWidth <= 640 || this._compact ? false !== this._compact && t5.classList.add("maplibregl-compact") : t5.classList.remove("maplibregl-compact");
              }
            }, this.options = e6;
          }
          getDefaultPosition() {
            return "bottom-left";
          }
          onAdd(e6) {
            this._map = e6, this._compact = this.options && this.options.compact, this._container = n5.create("div", "maplibregl-ctrl");
            const t5 = n5.create("a", "maplibregl-ctrl-logo");
            return t5.target = "_blank", t5.rel = "noopener nofollow", t5.href = "https://maplibre.org/", t5.setAttribute("aria-label", this._map._getUIString("LogoControl.Title")), t5.setAttribute("rel", "noopener nofollow"), this._container.appendChild(t5), this._container.style.display = "block", this._map.on("resize", this._updateCompact), this._updateCompact(), this._container;
          }
          onRemove() {
            n5.remove(this._container), this._map.off("resize", this._updateCompact), this._map = void 0, this._compact = void 0;
          }
        }
        class Pa {
          constructor() {
            this._queue = [], this._id = 0, this._cleared = false, this._currentlyRunning = false;
          }
          add(e6) {
            const t5 = ++this._id;
            return this._queue.push({ callback: e6, id: t5, cancelled: false }), t5;
          }
          remove(e6) {
            const t5 = this._currentlyRunning, i6 = t5 ? this._queue.concat(t5) : this._queue;
            for (const t6 of i6) if (t6.id === e6) return void (t6.cancelled = true);
          }
          run(e6 = 0) {
            if (this._currentlyRunning) throw new Error("Attempting to run(), but is already running.");
            const t5 = this._currentlyRunning = this._queue;
            this._queue = [];
            for (const i6 of t5) if (!i6.cancelled && (i6.callback(e6), this._cleared)) break;
            this._cleared = false, this._currentlyRunning = false;
          }
          clear() {
            this._currentlyRunning && (this._cleared = true), this._queue = [];
          }
        }
        var Ca = t4.aD([{ name: "a_pos3d", type: "Int16", components: 3 }]);
        class Ia extends t4.E {
          constructor(e6) {
            super(), this._lastTilesetChange = s3.now(), this.sourceCache = e6, this._tiles = {}, this._renderableTilesKeys = [], this._sourceTileCache = {}, this.minzoom = 0, this.maxzoom = 22, this.deltaZoom = 1, this.tileSize = e6._source.tileSize * 2 ** this.deltaZoom, e6.usedForTerrain = true, e6.tileSize = this.tileSize;
          }
          destruct() {
            this.sourceCache.usedForTerrain = false, this.sourceCache.tileSize = null;
          }
          update(e6, i6) {
            this.sourceCache.update(e6, i6), this._renderableTilesKeys = [];
            const r8 = {};
            for (const o6 of ue(e6, { tileSize: this.tileSize, minzoom: this.minzoom, maxzoom: this.maxzoom, reparseOverscaled: false, terrain: i6, calculateTileZoom: this.sourceCache._source.calculateTileZoom })) r8[o6.key] = true, this._renderableTilesKeys.push(o6.key), this._tiles[o6.key] || (o6.terrainRttPosMatrix32f = new Float64Array(16), t4.bO(o6.terrainRttPosMatrix32f, 0, t4.Z, t4.Z, 0, 0, 1), this._tiles[o6.key] = new ae(o6, this.tileSize), this._lastTilesetChange = s3.now());
            for (const e7 in this._tiles) r8[e7] || delete this._tiles[e7];
          }
          freeRtt(e6) {
            for (const t5 in this._tiles) {
              const i6 = this._tiles[t5];
              (!e6 || i6.tileID.equals(e6) || i6.tileID.isChildOf(e6) || e6.isChildOf(i6.tileID)) && (i6.rtt = []);
            }
          }
          getRenderableTiles() {
            return this._renderableTilesKeys.map((e6) => this.getTileByID(e6));
          }
          getTileByID(e6) {
            return this._tiles[e6];
          }
          getTerrainCoords(e6, t5) {
            return t5 ? this._getTerrainCoordsForTileRanges(e6, t5) : this._getTerrainCoordsForRegularTile(e6);
          }
          _getTerrainCoordsForRegularTile(e6) {
            const i6 = {};
            for (const r8 of this._renderableTilesKeys) {
              const o6 = this._tiles[r8].tileID, a4 = e6.clone(), s4 = t4.b2();
              if (o6.canonical.equals(e6.canonical)) t4.bO(s4, 0, t4.Z, t4.Z, 0, 0, 1);
              else if (o6.canonical.isChildOf(e6.canonical)) {
                const i7 = o6.canonical.z - e6.canonical.z, r9 = o6.canonical.x - (o6.canonical.x >> i7 << i7), a5 = o6.canonical.y - (o6.canonical.y >> i7 << i7), n6 = t4.Z >> i7;
                t4.bO(s4, 0, n6, n6, 0, 0, 1), t4.L(s4, s4, [-r9 * n6, -a5 * n6, 0]);
              } else {
                if (!e6.canonical.isChildOf(o6.canonical)) continue;
                {
                  const i7 = e6.canonical.z - o6.canonical.z, r9 = e6.canonical.x - (e6.canonical.x >> i7 << i7), a5 = e6.canonical.y - (e6.canonical.y >> i7 << i7), n6 = t4.Z >> i7;
                  t4.bO(s4, 0, t4.Z, t4.Z, 0, 0, 1), t4.L(s4, s4, [r9 * n6, a5 * n6, 0]), t4.M(s4, s4, [1 / 2 ** i7, 1 / 2 ** i7, 0]);
                }
              }
              a4.terrainRttPosMatrix32f = new Float32Array(s4), i6[r8] = a4;
            }
            return i6;
          }
          _getTerrainCoordsForTileRanges(e6, i6) {
            const r8 = {};
            for (const o6 of this._renderableTilesKeys) {
              const a4 = this._tiles[o6].tileID;
              if (!this._isWithinTileRanges(a4, i6)) continue;
              const s4 = e6.clone(), n6 = t4.b2();
              if (a4.canonical.z === e6.canonical.z) {
                const i7 = e6.canonical.x - a4.canonical.x, r9 = e6.canonical.y - a4.canonical.y;
                t4.bO(n6, 0, t4.Z, t4.Z, 0, 0, 1), t4.L(n6, n6, [i7 * t4.Z, r9 * t4.Z, 0]);
              } else if (a4.canonical.z > e6.canonical.z) {
                const i7 = a4.canonical.z - e6.canonical.z, r9 = a4.canonical.x - (a4.canonical.x >> i7 << i7), o7 = a4.canonical.y - (a4.canonical.y >> i7 << i7), s5 = e6.canonical.x - (a4.canonical.x >> i7), l5 = e6.canonical.y - (a4.canonical.y >> i7), c5 = t4.Z >> i7;
                t4.bO(n6, 0, c5, c5, 0, 0, 1), t4.L(n6, n6, [-r9 * c5 + s5 * t4.Z, -o7 * c5 + l5 * t4.Z, 0]);
              } else {
                const i7 = e6.canonical.z - a4.canonical.z, r9 = e6.canonical.x - (e6.canonical.x >> i7 << i7), o7 = e6.canonical.y - (e6.canonical.y >> i7 << i7), s5 = (e6.canonical.x >> i7) - a4.canonical.x, l5 = (e6.canonical.y >> i7) - a4.canonical.y, c5 = t4.Z << i7;
                t4.bO(n6, 0, c5, c5, 0, 0, 1), t4.L(n6, n6, [r9 * t4.Z + s5 * c5, o7 * t4.Z + l5 * c5, 0]);
              }
              s4.terrainRttPosMatrix32f = new Float32Array(n6), r8[o6] = s4;
            }
            return r8;
          }
          getSourceTile(e6, t5) {
            const i6 = this.sourceCache._source;
            let r8 = e6.overscaledZ - this.deltaZoom;
            if (r8 > i6.maxzoom && (r8 = i6.maxzoom), r8 < i6.minzoom) return null;
            this._sourceTileCache[e6.key] || (this._sourceTileCache[e6.key] = e6.scaledTo(r8).key);
            let o6 = this.sourceCache.getTileByID(this._sourceTileCache[e6.key]);
            if ((!o6 || !o6.dem) && t5) for (; r8 >= i6.minzoom && (!o6 || !o6.dem); ) o6 = this.sourceCache.getTileByID(e6.scaledTo(r8--).key);
            return o6;
          }
          anyTilesAfterTime(e6 = Date.now()) {
            return this._lastTilesetChange >= e6;
          }
          _isWithinTileRanges(e6, t5) {
            return t5[e6.canonical.z] && e6.canonical.x >= t5[e6.canonical.z].minTileX && e6.canonical.x <= t5[e6.canonical.z].maxTileX && e6.canonical.y >= t5[e6.canonical.z].minTileY && e6.canonical.y <= t5[e6.canonical.z].maxTileY;
          }
        }
        class Ma {
          constructor(e6, t5, i6) {
            this._meshCache = {}, this.painter = e6, this.sourceCache = new Ia(t5), this.options = i6, this.exaggeration = "number" == typeof i6.exaggeration ? i6.exaggeration : 1, this.qualityFactor = 2, this.meshSize = 128, this._demMatrixCache = {}, this.coordsIndex = [], this._coordsTextureSize = 1024;
          }
          getDEMElevation(e6, i6, r8, o6 = t4.Z) {
            var a4;
            if (!(i6 >= 0 && i6 < o6 && r8 >= 0 && r8 < o6)) return 0;
            const s4 = this.getTerrainData(e6), n6 = null === (a4 = s4.tile) || void 0 === a4 ? void 0 : a4.dem;
            if (!n6) return 0;
            const l5 = t4.cf([], [i6 / o6 * t4.Z, r8 / o6 * t4.Z], s4.u_terrain_matrix), c5 = [l5[0] * n6.dim, l5[1] * n6.dim], h4 = Math.floor(c5[0]), u4 = Math.floor(c5[1]), d4 = c5[0] - h4, _4 = c5[1] - u4;
            return n6.get(h4, u4) * (1 - d4) * (1 - _4) + n6.get(h4 + 1, u4) * d4 * (1 - _4) + n6.get(h4, u4 + 1) * (1 - d4) * _4 + n6.get(h4 + 1, u4 + 1) * d4 * _4;
          }
          getElevationForLngLatZoom(e6, i6) {
            if (!t4.cg(i6, e6.wrap())) return 0;
            const { tileID: r8, mercatorX: o6, mercatorY: a4 } = this._getOverscaledTileIDFromLngLatZoom(e6, i6);
            return this.getElevation(r8, o6 % t4.Z, a4 % t4.Z, t4.Z);
          }
          getElevation(e6, i6, r8, o6 = t4.Z) {
            return this.getDEMElevation(e6, i6, r8, o6) * this.exaggeration;
          }
          getTerrainData(e6) {
            if (!this._emptyDemTexture) {
              const e7 = this.painter.context, i7 = new t4.R({ width: 1, height: 1 }, new Uint8Array(4));
              this._emptyDepthTexture = new v3(e7, i7, e7.gl.RGBA, { premultiply: false }), this._emptyDemUnpack = [0, 0, 0, 0], this._emptyDemTexture = new v3(e7, new t4.R({ width: 1, height: 1 }), e7.gl.RGBA, { premultiply: false }), this._emptyDemTexture.bind(e7.gl.NEAREST, e7.gl.CLAMP_TO_EDGE), this._emptyDemMatrix = t4.at([]);
            }
            const i6 = this.sourceCache.getSourceTile(e6, true);
            if (i6 && i6.dem && (!i6.demTexture || i6.needsTerrainPrepare)) {
              const e7 = this.painter.context;
              i6.demTexture = this.painter.getTileTexture(i6.dem.stride), i6.demTexture ? i6.demTexture.update(i6.dem.getPixels(), { premultiply: false }) : i6.demTexture = new v3(e7, i6.dem.getPixels(), e7.gl.RGBA, { premultiply: false }), i6.demTexture.bind(e7.gl.NEAREST, e7.gl.CLAMP_TO_EDGE), i6.needsTerrainPrepare = false;
            }
            const r8 = i6 && i6 + i6.tileID.key + e6.key;
            if (r8 && !this._demMatrixCache[r8]) {
              const r9 = this.sourceCache.sourceCache._source.maxzoom;
              let o6 = e6.canonical.z - i6.tileID.canonical.z;
              e6.overscaledZ > e6.canonical.z && (e6.canonical.z >= r9 ? o6 = e6.canonical.z - r9 : t4.w("cannot calculate elevation if elevation maxzoom > source.maxzoom"));
              const a4 = e6.canonical.x - (e6.canonical.x >> o6 << o6), s4 = e6.canonical.y - (e6.canonical.y >> o6 << o6), n6 = t4.ch(new Float64Array(16), [1 / (t4.Z << o6), 1 / (t4.Z << o6), 0]);
              t4.L(n6, n6, [a4 * t4.Z, s4 * t4.Z, 0]), this._demMatrixCache[e6.key] = { matrix: n6, coord: e6 };
            }
            return { u_depth: 2, u_terrain: 3, u_terrain_dim: i6 && i6.dem && i6.dem.dim || 1, u_terrain_matrix: r8 ? this._demMatrixCache[e6.key].matrix : this._emptyDemMatrix, u_terrain_unpack: i6 && i6.dem && i6.dem.getUnpackVector() || this._emptyDemUnpack, u_terrain_exaggeration: this.exaggeration, texture: (i6 && i6.demTexture || this._emptyDemTexture).texture, depthTexture: (this._fboDepthTexture || this._emptyDepthTexture).texture, tile: i6 };
          }
          getFramebuffer(e6) {
            const t5 = this.painter, i6 = t5.width / devicePixelRatio, r8 = t5.height / devicePixelRatio;
            return !this._fbo || this._fbo.width === i6 && this._fbo.height === r8 || (this._fbo.destroy(), this._fboCoordsTexture.destroy(), this._fboDepthTexture.destroy(), delete this._fbo, delete this._fboDepthTexture, delete this._fboCoordsTexture), this._fboCoordsTexture || (this._fboCoordsTexture = new v3(t5.context, { width: i6, height: r8, data: null }, t5.context.gl.RGBA, { premultiply: false }), this._fboCoordsTexture.bind(t5.context.gl.NEAREST, t5.context.gl.CLAMP_TO_EDGE)), this._fboDepthTexture || (this._fboDepthTexture = new v3(t5.context, { width: i6, height: r8, data: null }, t5.context.gl.RGBA, { premultiply: false }), this._fboDepthTexture.bind(t5.context.gl.NEAREST, t5.context.gl.CLAMP_TO_EDGE)), this._fbo || (this._fbo = t5.context.createFramebuffer(i6, r8, true, false), this._fbo.depthAttachment.set(t5.context.createRenderbuffer(t5.context.gl.DEPTH_COMPONENT16, i6, r8))), this._fbo.colorAttachment.set("coords" === e6 ? this._fboCoordsTexture.texture : this._fboDepthTexture.texture), this._fbo;
          }
          getCoordsTexture() {
            const e6 = this.painter.context;
            if (this._coordsTexture) return this._coordsTexture;
            const i6 = new Uint8Array(this._coordsTextureSize * this._coordsTextureSize * 4);
            for (let e7 = 0, t5 = 0; e7 < this._coordsTextureSize; e7++) for (let r9 = 0; r9 < this._coordsTextureSize; r9++, t5 += 4) i6[t5 + 0] = 255 & r9, i6[t5 + 1] = 255 & e7, i6[t5 + 2] = r9 >> 8 << 4 | e7 >> 8, i6[t5 + 3] = 0;
            const r8 = new t4.R({ width: this._coordsTextureSize, height: this._coordsTextureSize }, new Uint8Array(i6.buffer)), o6 = new v3(e6, r8, e6.gl.RGBA, { premultiply: false });
            return o6.bind(e6.gl.NEAREST, e6.gl.CLAMP_TO_EDGE), this._coordsTexture = o6, o6;
          }
          pointCoordinate(e6) {
            this.painter.maybeDrawDepthAndCoords(true);
            const i6 = new Uint8Array(4), r8 = this.painter.context, o6 = r8.gl, a4 = Math.round(e6.x * this.painter.pixelRatio / devicePixelRatio), s4 = Math.round(e6.y * this.painter.pixelRatio / devicePixelRatio), n6 = Math.round(this.painter.height / devicePixelRatio);
            r8.bindFramebuffer.set(this.getFramebuffer("coords").framebuffer), o6.readPixels(a4, n6 - s4 - 1, 1, 1, o6.RGBA, o6.UNSIGNED_BYTE, i6), r8.bindFramebuffer.set(null);
            const l5 = i6[0] + (i6[2] >> 4 << 8), c5 = i6[1] + ((15 & i6[2]) << 8), h4 = this.coordsIndex[255 - i6[3]], u4 = h4 && this.sourceCache.getTileByID(h4);
            if (!u4) return null;
            const d4 = this._coordsTextureSize, _4 = (1 << u4.tileID.canonical.z) * d4;
            return new t4.$((u4.tileID.canonical.x * d4 + l5) / _4 + u4.tileID.wrap, (u4.tileID.canonical.y * d4 + c5) / _4, this.getElevation(u4.tileID, l5, c5, d4));
          }
          depthAtPoint(e6) {
            const t5 = new Uint8Array(4), i6 = this.painter.context, r8 = i6.gl;
            return i6.bindFramebuffer.set(this.getFramebuffer("depth").framebuffer), r8.readPixels(e6.x, this.painter.height / devicePixelRatio - e6.y - 1, 1, 1, r8.RGBA, r8.UNSIGNED_BYTE, t5), i6.bindFramebuffer.set(null), (t5[0] / 16777216 + t5[1] / 65536 + t5[2] / 256 + t5[3]) / 256;
          }
          getTerrainMesh(e6) {
            var i6;
            const r8 = (null === (i6 = this.painter.style.projection) || void 0 === i6 ? void 0 : i6.transitionState) > 0, o6 = r8 && 0 === e6.canonical.y, a4 = r8 && e6.canonical.y === (1 << e6.canonical.z) - 1, s4 = `m_${o6 ? "n" : ""}_${a4 ? "s" : ""}`;
            if (this._meshCache[s4]) return this._meshCache[s4];
            const n6 = this.painter.context, l5 = new t4.ci(), c5 = new t4.aH(), h4 = this.meshSize, u4 = t4.Z / h4, d4 = h4 * h4;
            for (let e7 = 0; e7 <= h4; e7++) for (let t5 = 0; t5 <= h4; t5++) l5.emplaceBack(t5 * u4, e7 * u4, 0);
            for (let e7 = 0; e7 < d4; e7 += h4 + 1) for (let t5 = 0; t5 < h4; t5++) c5.emplaceBack(t5 + e7, h4 + t5 + e7 + 1, h4 + t5 + e7 + 2), c5.emplaceBack(t5 + e7, h4 + t5 + e7 + 2, t5 + e7 + 1);
            const _4 = l5.length, p4 = _4 + (h4 + 1), m4 = (h4 + 1) * h4, f4 = o6 ? t4.b9 : 0, g4 = o6 ? 0 : 1, v4 = a4 ? t4.ba : t4.Z, x4 = a4 ? 0 : 1;
            for (let e7 = 0; e7 <= h4; e7++) l5.emplaceBack(e7 * u4, f4, g4);
            for (let e7 = 0; e7 <= h4; e7++) l5.emplaceBack(e7 * u4, v4, x4);
            for (let e7 = 0; e7 < h4; e7++) c5.emplaceBack(m4 + e7, p4 + e7, p4 + e7 + 1), c5.emplaceBack(m4 + e7, p4 + e7 + 1, m4 + e7 + 1), c5.emplaceBack(0 + e7, _4 + e7 + 1, _4 + e7), c5.emplaceBack(0 + e7, 0 + e7 + 1, _4 + e7 + 1);
            const b5 = l5.length, y4 = b5 + 2 * (h4 + 1);
            for (const e7 of [0, 1]) for (let i7 = 0; i7 <= h4; i7++) for (const r9 of [0, 1]) l5.emplaceBack(e7 * t4.Z, i7 * u4, r9);
            for (let e7 = 0; e7 < 2 * h4; e7 += 2) c5.emplaceBack(b5 + e7, b5 + e7 + 1, b5 + e7 + 3), c5.emplaceBack(b5 + e7, b5 + e7 + 3, b5 + e7 + 2), c5.emplaceBack(y4 + e7, y4 + e7 + 3, y4 + e7 + 1), c5.emplaceBack(y4 + e7, y4 + e7 + 2, y4 + e7 + 3);
            const w4 = new pt(n6.createVertexBuffer(l5, Ca.members), n6.createIndexBuffer(c5), t4.aG.simpleSegment(0, 0, l5.length, c5.length));
            return this._meshCache[s4] = w4, w4;
          }
          getMeshFrameDelta(e6) {
            return 2 * Math.PI * t4.br / Math.pow(2, Math.max(e6, 0)) / 5;
          }
          getMinTileElevationForLngLatZoom(e6, t5) {
            var i6;
            const { tileID: r8 } = this._getOverscaledTileIDFromLngLatZoom(e6, t5);
            return null !== (i6 = this.getMinMaxElevation(r8).minElevation) && void 0 !== i6 ? i6 : 0;
          }
          getMinMaxElevation(e6) {
            const t5 = this.getTerrainData(e6).tile, i6 = { minElevation: null, maxElevation: null };
            return t5 && t5.dem && (i6.minElevation = t5.dem.min * this.exaggeration, i6.maxElevation = t5.dem.max * this.exaggeration), i6;
          }
          _getOverscaledTileIDFromLngLatZoom(e6, i6) {
            const r8 = t4.$.fromLngLat(e6.wrap()), o6 = (1 << i6) * t4.Z, a4 = r8.x * o6, s4 = r8.y * o6, n6 = Math.floor(a4 / t4.Z), l5 = Math.floor(s4 / t4.Z);
            return { tileID: new t4.Y(i6, 0, i6, n6, l5), mercatorX: a4, mercatorY: s4 };
          }
        }
        class Ea {
          constructor(e6, t5, i6) {
            this._context = e6, this._size = t5, this._tileSize = i6, this._objects = [], this._recentlyUsed = [], this._stamp = 0;
          }
          destruct() {
            for (const e6 of this._objects) e6.texture.destroy(), e6.fbo.destroy();
          }
          _createObject(e6) {
            const t5 = this._context.createFramebuffer(this._tileSize, this._tileSize, true, true), i6 = new v3(this._context, { width: this._tileSize, height: this._tileSize, data: null }, this._context.gl.RGBA);
            return i6.bind(this._context.gl.LINEAR, this._context.gl.CLAMP_TO_EDGE), this._context.extTextureFilterAnisotropic && this._context.gl.texParameterf(this._context.gl.TEXTURE_2D, this._context.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, this._context.extTextureFilterAnisotropicMax), t5.depthAttachment.set(this._context.createRenderbuffer(this._context.gl.DEPTH_STENCIL, this._tileSize, this._tileSize)), t5.colorAttachment.set(i6.texture), { id: e6, fbo: t5, texture: i6, stamp: -1, inUse: false };
          }
          getObjectForId(e6) {
            return this._objects[e6];
          }
          useObject(e6) {
            e6.inUse = true, this._recentlyUsed = this._recentlyUsed.filter((t5) => e6.id !== t5), this._recentlyUsed.push(e6.id);
          }
          stampObject(e6) {
            e6.stamp = ++this._stamp;
          }
          getOrCreateFreeObject() {
            for (const e7 of this._recentlyUsed) if (!this._objects[e7].inUse) return this._objects[e7];
            if (this._objects.length >= this._size) throw new Error("No free RenderPool available, call freeAllObjects() required!");
            const e6 = this._createObject(this._objects.length);
            return this._objects.push(e6), e6;
          }
          freeObject(e6) {
            e6.inUse = false;
          }
          freeAllObjects() {
            for (const e6 of this._objects) this.freeObject(e6);
          }
          isFull() {
            return !(this._objects.length < this._size) && false === this._objects.some((e6) => !e6.inUse);
          }
        }
        const Sa = { background: true, fill: true, line: true, raster: true, hillshade: true };
        class Ra {
          constructor(e6, t5) {
            this.painter = e6, this.terrain = t5, this.pool = new Ea(e6.context, 30, t5.sourceCache.tileSize * t5.qualityFactor);
          }
          destruct() {
            this.pool.destruct();
          }
          getTexture(e6) {
            return this.pool.getObjectForId(e6.rtt[this._stacks.length - 1].id).texture;
          }
          prepareForRender(e6, t5) {
            this._stacks = [], this._prevType = null, this._rttTiles = [], this._renderableTiles = this.terrain.sourceCache.getRenderableTiles(), this._renderableLayerIds = e6._order.filter((i6) => !e6._layers[i6].isHidden(t5)), this._coordsAscending = {};
            for (const t6 in e6.sourceCaches) {
              this._coordsAscending[t6] = {};
              const i6 = e6.sourceCaches[t6].getVisibleCoordinates(), r8 = e6.sourceCaches[t6].getSource(), o6 = r8 instanceof X2 ? r8.terrainTileRanges : null;
              for (const e7 of i6) {
                const i7 = this.terrain.sourceCache.getTerrainCoords(e7, o6);
                for (const e8 in i7) this._coordsAscending[t6][e8] || (this._coordsAscending[t6][e8] = []), this._coordsAscending[t6][e8].push(i7[e8]);
              }
            }
            this._coordsAscendingStr = {};
            for (const t6 of e6._order) {
              const i6 = e6._layers[t6], r8 = i6.source;
              if (Sa[i6.type] && !this._coordsAscendingStr[r8]) {
                this._coordsAscendingStr[r8] = {};
                for (const e7 in this._coordsAscending[r8]) this._coordsAscendingStr[r8][e7] = this._coordsAscending[r8][e7].map((e8) => e8.key).sort().join();
              }
            }
            for (const e7 of this._renderableTiles) for (const t6 in this._coordsAscendingStr) {
              const i6 = this._coordsAscendingStr[t6][e7.tileID.key];
              i6 && i6 !== e7.rttCoords[t6] && (e7.rtt = []);
            }
          }
          renderLayer(e6, i6) {
            if (e6.isHidden(this.painter.transform.zoom)) return false;
            const r8 = Object.assign(Object.assign({}, i6), { isRenderingToTexture: true }), o6 = e6.type, a4 = this.painter, s4 = this._renderableLayerIds[this._renderableLayerIds.length - 1] === e6.id;
            if (Sa[o6] && (this._prevType && Sa[this._prevType] || this._stacks.push([]), this._prevType = o6, this._stacks[this._stacks.length - 1].push(e6.id), !s4)) return true;
            if (Sa[this._prevType] || Sa[o6] && s4) {
              this._prevType = o6;
              const e7 = this._stacks.length - 1, i7 = this._stacks[e7] || [];
              for (const o7 of this._renderableTiles) {
                if (this.pool.isFull() && (vo(this.painter, this.terrain, this._rttTiles, r8), this._rttTiles = [], this.pool.freeAllObjects()), this._rttTiles.push(o7), o7.rtt[e7]) {
                  const t5 = this.pool.getObjectForId(o7.rtt[e7].id);
                  if (t5.stamp === o7.rtt[e7].stamp) {
                    this.pool.useObject(t5);
                    continue;
                  }
                }
                const s5 = this.pool.getOrCreateFreeObject();
                this.pool.useObject(s5), this.pool.stampObject(s5), o7.rtt[e7] = { id: s5.id, stamp: s5.stamp }, a4.context.bindFramebuffer.set(s5.fbo.framebuffer), a4.context.clear({ color: t4.b7.transparent, stencil: 0 }), a4.currentStencilSource = void 0;
                for (let e8 = 0; e8 < i7.length; e8++) {
                  const t5 = a4.style._layers[i7[e8]], n6 = t5.source ? this._coordsAscending[t5.source][o7.tileID.key] : [o7.tileID];
                  a4.context.viewport.set([0, 0, s5.fbo.width, s5.fbo.height]), a4._renderTileClippingMasks(t5, n6, true), a4.renderLayer(a4, a4.style.sourceCaches[t5.source], t5, n6, r8), t5.source && (o7.rttCoords[t5.source] = this._coordsAscendingStr[t5.source][o7.tileID.key]);
                }
              }
              return vo(this.painter, this.terrain, this._rttTiles, r8), this._rttTiles = [], this.pool.freeAllObjects(), Sa[o6];
            }
            return false;
          }
        }
        const Da = { "AttributionControl.ToggleAttribution": "Toggle attribution", "AttributionControl.MapFeedback": "Map feedback", "FullscreenControl.Enter": "Enter fullscreen", "FullscreenControl.Exit": "Exit fullscreen", "GeolocateControl.FindMyLocation": "Find my location", "GeolocateControl.LocationNotAvailable": "Location not available", "LogoControl.Title": "MapLibre logo", "Map.Title": "Map", "Marker.Title": "Map marker", "NavigationControl.ResetBearing": "Reset bearing to north", "NavigationControl.ZoomIn": "Zoom in", "NavigationControl.ZoomOut": "Zoom out", "Popup.Close": "Close popup", "ScaleControl.Feet": "ft", "ScaleControl.Meters": "m", "ScaleControl.Kilometers": "km", "ScaleControl.Miles": "mi", "ScaleControl.NauticalMiles": "nm", "GlobeControl.Enable": "Enable globe", "GlobeControl.Disable": "Disable globe", "TerrainControl.Enable": "Enable terrain", "TerrainControl.Disable": "Disable terrain", "CooperativeGesturesHandler.WindowsHelpText": "Use Ctrl + scroll to zoom the map", "CooperativeGesturesHandler.MacHelpText": "Use \u2318 + scroll to zoom the map", "CooperativeGesturesHandler.MobileHelpText": "Use two fingers to move the map" }, za = i5, Aa = { hash: false, interactive: true, bearingSnap: 7, attributionControl: ya, maplibreLogo: false, refreshExpiredTiles: true, canvasContextAttributes: { antialias: false, preserveDrawingBuffer: false, powerPreference: "high-performance", failIfMajorPerformanceCaveat: false, desynchronized: false, contextType: void 0 }, scrollZoom: true, minZoom: -2, maxZoom: 22, minPitch: 0, maxPitch: 60, boxZoom: true, dragRotate: true, dragPan: true, keyboard: true, doubleClickZoom: true, touchZoomRotate: true, touchPitch: true, cooperativeGestures: false, trackResize: true, center: [0, 0], elevation: 0, zoom: 0, bearing: 0, pitch: 0, roll: 0, renderWorldCopies: true, maxTileCacheSize: null, maxTileCacheZoomLevels: t4.a.MAX_TILE_CACHE_ZOOM_LEVELS, transformRequest: null, transformCameraUpdate: null, fadeDuration: 300, crossSourceCollisions: true, clickTolerance: 3, localIdeographFontFamily: "sans-serif", pitchWithRotate: true, rollEnabled: false, validateStyle: true, maxCanvasSize: [4096, 4096], cancelPendingTileRequestsWhileZooming: true, centerClampedToGround: true }, La = { showCompass: true, showZoom: true, visualizePitch: false, visualizeRoll: true };
        class ka {
          constructor(e6, i6, r8 = false) {
            this.mousedown = (e7) => {
              this.startMove(e7, n5.mousePos(this.element, e7)), n5.addEventListener(window, "mousemove", this.mousemove), n5.addEventListener(window, "mouseup", this.mouseup);
            }, this.mousemove = (e7) => {
              this.move(e7, n5.mousePos(this.element, e7));
            }, this.mouseup = (e7) => {
              this._rotatePitchHanlder.dragEnd(e7), this.offTemp();
            }, this.touchstart = (e7) => {
              1 !== e7.targetTouches.length ? this.reset() : (this._startPos = this._lastPos = n5.touchPos(this.element, e7.targetTouches)[0], this.startMove(e7, this._startPos), n5.addEventListener(window, "touchmove", this.touchmove, { passive: false }), n5.addEventListener(window, "touchend", this.touchend));
            }, this.touchmove = (e7) => {
              1 !== e7.targetTouches.length ? this.reset() : (this._lastPos = n5.touchPos(this.element, e7.targetTouches)[0], this.move(e7, this._lastPos));
            }, this.touchend = (e7) => {
              0 === e7.targetTouches.length && this._startPos && this._lastPos && this._startPos.dist(this._lastPos) < this._clickTolerance && this.element.click(), delete this._startPos, delete this._lastPos, this.offTemp();
            }, this.reset = () => {
              this._rotatePitchHanlder.reset(), delete this._startPos, delete this._lastPos, this.offTemp();
            }, this._clickTolerance = 10, this.element = i6;
            const o6 = new $o();
            this._rotatePitchHanlder = new Uo({ clickTolerance: 3, move: (e7, o7) => {
              const a4 = i6.getBoundingClientRect(), s4 = new t4.P((a4.bottom - a4.top) / 2, (a4.right - a4.left) / 2);
              return { bearingDelta: t4.ca(new t4.P(e7.x, o7.y), o7, s4), pitchDelta: r8 ? -0.5 * (o7.y - e7.y) : void 0 };
            }, moveStateManager: o6, enable: true, assignEvents: () => {
            } }), this.map = e6, n5.addEventListener(i6, "mousedown", this.mousedown), n5.addEventListener(i6, "touchstart", this.touchstart, { passive: false }), n5.addEventListener(i6, "touchcancel", this.reset);
          }
          startMove(e6, t5) {
            this._rotatePitchHanlder.dragStart(e6, t5), n5.disableDrag();
          }
          move(e6, t5) {
            const i6 = this.map, { bearingDelta: r8, pitchDelta: o6 } = this._rotatePitchHanlder.dragMove(e6, t5) || {};
            r8 && i6.setBearing(i6.getBearing() + r8), o6 && i6.setPitch(i6.getPitch() + o6);
          }
          off() {
            const e6 = this.element;
            n5.removeEventListener(e6, "mousedown", this.mousedown), n5.removeEventListener(e6, "touchstart", this.touchstart, { passive: false }), n5.removeEventListener(window, "touchmove", this.touchmove, { passive: false }), n5.removeEventListener(window, "touchend", this.touchend), n5.removeEventListener(e6, "touchcancel", this.reset), this.offTemp();
          }
          offTemp() {
            n5.enableDrag(), n5.removeEventListener(window, "mousemove", this.mousemove), n5.removeEventListener(window, "mouseup", this.mouseup), n5.removeEventListener(window, "touchmove", this.touchmove, { passive: false }), n5.removeEventListener(window, "touchend", this.touchend);
          }
        }
        let Fa;
        function Ba(e6, i6, r8) {
          const o6 = new t4.Q(e6.lng, e6.lat);
          if (e6 = new t4.Q(e6.lng, e6.lat), i6) {
            const o7 = new t4.Q(e6.lng - 360, e6.lat), a4 = new t4.Q(e6.lng + 360, e6.lat), s4 = r8.locationToScreenPoint(e6).distSqr(i6);
            r8.locationToScreenPoint(o7).distSqr(i6) < s4 ? e6 = o7 : r8.locationToScreenPoint(a4).distSqr(i6) < s4 && (e6 = a4);
          }
          for (; Math.abs(e6.lng - r8.center.lng) > 180; ) {
            const t5 = r8.locationToScreenPoint(e6);
            if (t5.x >= 0 && t5.y >= 0 && t5.x <= r8.width && t5.y <= r8.height) break;
            e6.lng > r8.center.lng ? e6.lng -= 360 : e6.lng += 360;
          }
          return e6.lng !== o6.lng && r8.isPointOnMapSurface(r8.locationToScreenPoint(e6)) ? e6 : o6;
        }
        const Oa = { center: "translate(-50%,-50%)", top: "translate(-50%,0)", "top-left": "translate(0,0)", "top-right": "translate(-100%,0)", bottom: "translate(-50%,-100%)", "bottom-left": "translate(0,-100%)", "bottom-right": "translate(-100%,-100%)", left: "translate(0,-50%)", right: "translate(-100%,-50%)" };
        function ja(e6, t5, i6) {
          const r8 = e6.classList;
          for (const e7 in Oa) r8.remove(`maplibregl-${i6}-anchor-${e7}`);
          r8.add(`maplibregl-${i6}-anchor-${t5}`);
        }
        class Za extends t4.E {
          constructor(e6) {
            if (super(), this._onKeyPress = (e7) => {
              const t5 = e7.code, i6 = e7.charCode || e7.keyCode;
              "Space" !== t5 && "Enter" !== t5 && 32 !== i6 && 13 !== i6 || this.togglePopup();
            }, this._onMapClick = (e7) => {
              const t5 = e7.originalEvent.target, i6 = this._element;
              this._popup && (t5 === i6 || i6.contains(t5)) && this.togglePopup();
            }, this._update = (e7) => {
              var t5;
              if (!this._map) return;
              const i6 = this._map.loaded() && !this._map.isMoving();
              ("terrain" === (null == e7 ? void 0 : e7.type) || "render" === (null == e7 ? void 0 : e7.type) && !i6) && this._map.once("render", this._update), this._lngLat = this._map.transform.renderWorldCopies ? Ba(this._lngLat, this._flatPos, this._map.transform) : null === (t5 = this._lngLat) || void 0 === t5 ? void 0 : t5.wrap(), this._flatPos = this._pos = this._map.project(this._lngLat)._add(this._offset), this._map.terrain && (this._flatPos = this._map.transform.locationToScreenPoint(this._lngLat)._add(this._offset));
              let r8 = "";
              "viewport" === this._rotationAlignment || "auto" === this._rotationAlignment ? r8 = `rotateZ(${this._rotation}deg)` : "map" === this._rotationAlignment && (r8 = `rotateZ(${this._rotation - this._map.getBearing()}deg)`);
              let o6 = "";
              "viewport" === this._pitchAlignment || "auto" === this._pitchAlignment ? o6 = "rotateX(0deg)" : "map" === this._pitchAlignment && (o6 = `rotateX(${this._map.getPitch()}deg)`), this._subpixelPositioning || e7 && "moveend" !== e7.type || (this._pos = this._pos.round()), n5.setTransform(this._element, `${Oa[this._anchor]} translate(${this._pos.x}px, ${this._pos.y}px) ${o6} ${r8}`), s3.frameAsync(new AbortController()).then(() => {
                this._updateOpacity(e7 && "moveend" === e7.type);
              }).catch(() => {
              });
            }, this._onMove = (e7) => {
              if (!this._isDragging) {
                const t5 = this._clickTolerance || this._map._clickTolerance;
                this._isDragging = e7.point.dist(this._pointerdownPos) >= t5;
              }
              this._isDragging && (this._pos = e7.point.sub(this._positionDelta), this._lngLat = this._map.unproject(this._pos), this.setLngLat(this._lngLat), this._element.style.pointerEvents = "none", "pending" === this._state && (this._state = "active", this.fire(new t4.l("dragstart"))), this.fire(new t4.l("drag")));
            }, this._onUp = () => {
              this._element.style.pointerEvents = "auto", this._positionDelta = null, this._pointerdownPos = null, this._isDragging = false, this._map.off("mousemove", this._onMove), this._map.off("touchmove", this._onMove), "active" === this._state && this.fire(new t4.l("dragend")), this._state = "inactive";
            }, this._addDragHandler = (e7) => {
              this._element.contains(e7.originalEvent.target) && (e7.preventDefault(), this._positionDelta = e7.point.sub(this._pos).add(this._offset), this._pointerdownPos = e7.point, this._state = "pending", this._map.on("mousemove", this._onMove), this._map.on("touchmove", this._onMove), this._map.once("mouseup", this._onUp), this._map.once("touchend", this._onUp));
            }, this._anchor = e6 && e6.anchor || "center", this._color = e6 && e6.color || "#3FB1CE", this._scale = e6 && e6.scale || 1, this._draggable = e6 && e6.draggable || false, this._clickTolerance = e6 && e6.clickTolerance || 0, this._subpixelPositioning = e6 && e6.subpixelPositioning || false, this._isDragging = false, this._state = "inactive", this._rotation = e6 && e6.rotation || 0, this._rotationAlignment = e6 && e6.rotationAlignment || "auto", this._pitchAlignment = e6 && e6.pitchAlignment && "auto" !== e6.pitchAlignment ? e6.pitchAlignment : this._rotationAlignment, this.setOpacity(null == e6 ? void 0 : e6.opacity, null == e6 ? void 0 : e6.opacityWhenCovered), e6 && e6.element) this._element = e6.element, this._offset = t4.P.convert(e6 && e6.offset || [0, 0]);
            else {
              this._defaultMarker = true, this._element = n5.create("div");
              const i6 = n5.createNS("http://www.w3.org/2000/svg", "svg"), r8 = 41, o6 = 27;
              i6.setAttributeNS(null, "display", "block"), i6.setAttributeNS(null, "height", `${r8}px`), i6.setAttributeNS(null, "width", `${o6}px`), i6.setAttributeNS(null, "viewBox", `0 0 ${o6} ${r8}`);
              const a4 = n5.createNS("http://www.w3.org/2000/svg", "g");
              a4.setAttributeNS(null, "stroke", "none"), a4.setAttributeNS(null, "stroke-width", "1"), a4.setAttributeNS(null, "fill", "none"), a4.setAttributeNS(null, "fill-rule", "evenodd");
              const s4 = n5.createNS("http://www.w3.org/2000/svg", "g");
              s4.setAttributeNS(null, "fill-rule", "nonzero");
              const l5 = n5.createNS("http://www.w3.org/2000/svg", "g");
              l5.setAttributeNS(null, "transform", "translate(3.0, 29.0)"), l5.setAttributeNS(null, "fill", "#000000");
              const c5 = [{ rx: "10.5", ry: "5.25002273" }, { rx: "10.5", ry: "5.25002273" }, { rx: "9.5", ry: "4.77275007" }, { rx: "8.5", ry: "4.29549936" }, { rx: "7.5", ry: "3.81822308" }, { rx: "6.5", ry: "3.34094679" }, { rx: "5.5", ry: "2.86367051" }, { rx: "4.5", ry: "2.38636864" }];
              for (const e7 of c5) {
                const t5 = n5.createNS("http://www.w3.org/2000/svg", "ellipse");
                t5.setAttributeNS(null, "opacity", "0.04"), t5.setAttributeNS(null, "cx", "10.5"), t5.setAttributeNS(null, "cy", "5.80029008"), t5.setAttributeNS(null, "rx", e7.rx), t5.setAttributeNS(null, "ry", e7.ry), l5.appendChild(t5);
              }
              const h4 = n5.createNS("http://www.w3.org/2000/svg", "g");
              h4.setAttributeNS(null, "fill", this._color);
              const u4 = n5.createNS("http://www.w3.org/2000/svg", "path");
              u4.setAttributeNS(null, "d", "M27,13.5 C27,19.074644 20.250001,27.000002 14.75,34.500002 C14.016665,35.500004 12.983335,35.500004 12.25,34.500002 C6.7499993,27.000002 0,19.222562 0,13.5 C0,6.0441559 6.0441559,0 13.5,0 C20.955844,0 27,6.0441559 27,13.5 Z"), h4.appendChild(u4);
              const d4 = n5.createNS("http://www.w3.org/2000/svg", "g");
              d4.setAttributeNS(null, "opacity", "0.25"), d4.setAttributeNS(null, "fill", "#000000");
              const _4 = n5.createNS("http://www.w3.org/2000/svg", "path");
              _4.setAttributeNS(null, "d", "M13.5,0 C6.0441559,0 0,6.0441559 0,13.5 C0,19.222562 6.7499993,27 12.25,34.5 C13,35.522727 14.016664,35.500004 14.75,34.5 C20.250001,27 27,19.074644 27,13.5 C27,6.0441559 20.955844,0 13.5,0 Z M13.5,1 C20.415404,1 26,6.584596 26,13.5 C26,15.898657 24.495584,19.181431 22.220703,22.738281 C19.945823,26.295132 16.705119,30.142167 13.943359,33.908203 C13.743445,34.180814 13.612715,34.322738 13.5,34.441406 C13.387285,34.322738 13.256555,34.180814 13.056641,33.908203 C10.284481,30.127985 7.4148684,26.314159 5.015625,22.773438 C2.6163816,19.232715 1,15.953538 1,13.5 C1,6.584596 6.584596,1 13.5,1 Z"), d4.appendChild(_4);
              const p4 = n5.createNS("http://www.w3.org/2000/svg", "g");
              p4.setAttributeNS(null, "transform", "translate(6.0, 7.0)"), p4.setAttributeNS(null, "fill", "#FFFFFF");
              const m4 = n5.createNS("http://www.w3.org/2000/svg", "g");
              m4.setAttributeNS(null, "transform", "translate(8.0, 8.0)");
              const f4 = n5.createNS("http://www.w3.org/2000/svg", "circle");
              f4.setAttributeNS(null, "fill", "#000000"), f4.setAttributeNS(null, "opacity", "0.25"), f4.setAttributeNS(null, "cx", "5.5"), f4.setAttributeNS(null, "cy", "5.5"), f4.setAttributeNS(null, "r", "5.4999962");
              const g4 = n5.createNS("http://www.w3.org/2000/svg", "circle");
              g4.setAttributeNS(null, "fill", "#FFFFFF"), g4.setAttributeNS(null, "cx", "5.5"), g4.setAttributeNS(null, "cy", "5.5"), g4.setAttributeNS(null, "r", "5.4999962"), m4.appendChild(f4), m4.appendChild(g4), s4.appendChild(l5), s4.appendChild(h4), s4.appendChild(d4), s4.appendChild(p4), s4.appendChild(m4), i6.appendChild(s4), i6.setAttributeNS(null, "height", r8 * this._scale + "px"), i6.setAttributeNS(null, "width", o6 * this._scale + "px"), this._element.appendChild(i6), this._offset = t4.P.convert(e6 && e6.offset || [0, -14]);
            }
            if (this._element.classList.add("maplibregl-marker"), this._element.addEventListener("dragstart", (e7) => {
              e7.preventDefault();
            }), this._element.addEventListener("mousedown", (e7) => {
              e7.preventDefault();
            }), ja(this._element, this._anchor, "marker"), e6 && e6.className) for (const t5 of e6.className.split(" ")) this._element.classList.add(t5);
            this._popup = null;
          }
          addTo(e6) {
            return this.remove(), this._map = e6, this._element.setAttribute("aria-label", e6._getUIString("Marker.Title")), e6.getCanvasContainer().appendChild(this._element), e6.on("move", this._update), e6.on("moveend", this._update), e6.on("terrain", this._update), e6.on("projectiontransition", this._update), this.setDraggable(this._draggable), this._update(), this._map.on("click", this._onMapClick), this;
          }
          remove() {
            return this._opacityTimeout && (clearTimeout(this._opacityTimeout), delete this._opacityTimeout), this._map && (this._map.off("click", this._onMapClick), this._map.off("move", this._update), this._map.off("moveend", this._update), this._map.off("terrain", this._update), this._map.off("projectiontransition", this._update), this._map.off("mousedown", this._addDragHandler), this._map.off("touchstart", this._addDragHandler), this._map.off("mouseup", this._onUp), this._map.off("touchend", this._onUp), this._map.off("mousemove", this._onMove), this._map.off("touchmove", this._onMove), delete this._map), n5.remove(this._element), this._popup && this._popup.remove(), this;
          }
          getLngLat() {
            return this._lngLat;
          }
          setLngLat(e6) {
            return this._lngLat = t4.Q.convert(e6), this._pos = null, this._popup && this._popup.setLngLat(this._lngLat), this._update(), this;
          }
          getElement() {
            return this._element;
          }
          setPopup(e6) {
            if (this._popup && (this._popup.remove(), this._popup = null, this._element.removeEventListener("keypress", this._onKeyPress), this._originalTabIndex || this._element.removeAttribute("tabindex")), e6) {
              if (!("offset" in e6.options)) {
                const t5 = 38.1, i6 = 13.5, r8 = Math.abs(i6) / Math.SQRT2;
                e6.options.offset = this._defaultMarker ? { top: [0, 0], "top-left": [0, 0], "top-right": [0, 0], bottom: [0, -38.1], "bottom-left": [r8, -1 * (t5 - i6 + r8)], "bottom-right": [-r8, -1 * (t5 - i6 + r8)], left: [i6, -1 * (t5 - i6)], right: [-13.5, -1 * (t5 - i6)] } : this._offset;
              }
              this._popup = e6, this._originalTabIndex = this._element.getAttribute("tabindex"), this._originalTabIndex || this._element.setAttribute("tabindex", "0"), this._element.addEventListener("keypress", this._onKeyPress);
            }
            return this;
          }
          setSubpixelPositioning(e6) {
            return this._subpixelPositioning = e6, this;
          }
          getPopup() {
            return this._popup;
          }
          togglePopup() {
            const e6 = this._popup;
            return this._element.style.opacity === this._opacityWhenCovered ? this : e6 ? (e6.isOpen() ? e6.remove() : (e6.setLngLat(this._lngLat), e6.addTo(this._map)), this) : this;
          }
          _updateOpacity(e6 = false) {
            var i6, r8;
            if (!(null === (i6 = this._map) || void 0 === i6 ? void 0 : i6.terrain)) {
              const e7 = this._map.transform.isLocationOccluded(this._lngLat) ? this._opacityWhenCovered : this._opacity;
              return void (this._element.style.opacity !== e7 && (this._element.style.opacity = e7));
            }
            if (e6) this._opacityTimeout = null;
            else {
              if (this._opacityTimeout) return;
              this._opacityTimeout = setTimeout(() => {
                this._opacityTimeout = null;
              }, 100);
            }
            const o6 = this._map, a4 = o6.terrain.depthAtPoint(this._pos), s4 = o6.terrain.getElevationForLngLatZoom(this._lngLat, o6.transform.tileZoom);
            if (o6.transform.lngLatToCameraDepth(this._lngLat, s4) - a4 < 6e-3) return void (this._element.style.opacity = this._opacity);
            const n6 = -this._offset.y / o6.transform.pixelsPerMeter, l5 = Math.sin(o6.getPitch() * Math.PI / 180) * n6, c5 = o6.terrain.depthAtPoint(new t4.P(this._pos.x, this._pos.y - this._offset.y)), h4 = o6.transform.lngLatToCameraDepth(this._lngLat, s4 + l5) - c5 > 6e-3;
            (null === (r8 = this._popup) || void 0 === r8 ? void 0 : r8.isOpen()) && h4 && this._popup.remove(), this._element.style.opacity = h4 ? this._opacityWhenCovered : this._opacity;
          }
          getOffset() {
            return this._offset;
          }
          setOffset(e6) {
            return this._offset = t4.P.convert(e6), this._update(), this;
          }
          addClassName(e6) {
            this._element.classList.add(e6);
          }
          removeClassName(e6) {
            this._element.classList.remove(e6);
          }
          toggleClassName(e6) {
            return this._element.classList.toggle(e6);
          }
          setDraggable(e6) {
            return this._draggable = !!e6, this._map && (e6 ? (this._map.on("mousedown", this._addDragHandler), this._map.on("touchstart", this._addDragHandler)) : (this._map.off("mousedown", this._addDragHandler), this._map.off("touchstart", this._addDragHandler))), this;
          }
          isDraggable() {
            return this._draggable;
          }
          setRotation(e6) {
            return this._rotation = e6 || 0, this._update(), this;
          }
          getRotation() {
            return this._rotation;
          }
          setRotationAlignment(e6) {
            return this._rotationAlignment = e6 || "auto", this._update(), this;
          }
          getRotationAlignment() {
            return this._rotationAlignment;
          }
          setPitchAlignment(e6) {
            return this._pitchAlignment = e6 && "auto" !== e6 ? e6 : this._rotationAlignment, this._update(), this;
          }
          getPitchAlignment() {
            return this._pitchAlignment;
          }
          setOpacity(e6, t5) {
            return (void 0 === this._opacity || void 0 === e6 && void 0 === t5) && (this._opacity = "1", this._opacityWhenCovered = "0.2"), void 0 !== e6 && (this._opacity = e6), void 0 !== t5 && (this._opacityWhenCovered = t5), this._map && this._updateOpacity(true), this;
          }
        }
        const Na = { positionOptions: { enableHighAccuracy: false, maximumAge: 0, timeout: 6e3 }, fitBoundsOptions: { maxZoom: 15 }, trackUserLocation: false, showAccuracyCircle: true, showUserLocation: true };
        let Ga = 0, Ua = false;
        const Va = { maxWidth: 100, unit: "metric" };
        function qa(e6, t5, i6) {
          const r8 = i6 && i6.maxWidth || 100, o6 = e6._container.clientHeight / 2, a4 = e6._container.clientWidth / 2, s4 = e6.unproject([a4 - r8 / 2, o6]), n6 = e6.unproject([a4 + r8 / 2, o6]), l5 = Math.round(e6.project(n6).x - e6.project(s4).x), c5 = Math.min(r8, l5, e6._container.clientWidth), h4 = s4.distanceTo(n6);
          if (i6 && "imperial" === i6.unit) {
            const i7 = 3.2808 * h4;
            i7 > 5280 ? Wa(t5, c5, i7 / 5280, e6._getUIString("ScaleControl.Miles")) : Wa(t5, c5, i7, e6._getUIString("ScaleControl.Feet"));
          } else i6 && "nautical" === i6.unit ? Wa(t5, c5, h4 / 1852, e6._getUIString("ScaleControl.NauticalMiles")) : h4 >= 1e3 ? Wa(t5, c5, h4 / 1e3, e6._getUIString("ScaleControl.Kilometers")) : Wa(t5, c5, h4, e6._getUIString("ScaleControl.Meters"));
        }
        function Wa(e6, t5, i6, r8) {
          const o6 = function(e7) {
            const t6 = Math.pow(10, `${Math.floor(e7)}`.length - 1);
            let i7 = e7 / t6;
            return i7 = i7 >= 10 ? 10 : i7 >= 5 ? 5 : i7 >= 3 ? 3 : i7 >= 2 ? 2 : i7 >= 1 ? 1 : function(e8) {
              const t7 = Math.pow(10, Math.ceil(-Math.log(e8) / Math.LN10));
              return Math.round(e8 * t7) / t7;
            }(i7), t6 * i7;
          }(i6);
          e6.style.width = t5 * (o6 / i6) + "px", e6.innerHTML = `${o6}&nbsp;${r8}`;
        }
        const $a = { closeButton: true, closeOnClick: true, focusAfterOpen: true, className: "", maxWidth: "240px", subpixelPositioning: false, locationOccludedOpacity: void 0 }, Ha = ["a[href]", "[tabindex]:not([tabindex='-1'])", "[contenteditable]:not([contenteditable='false'])", "button:not([disabled])", "input:not([disabled])", "select:not([disabled])", "textarea:not([disabled])"].join(", ");
        function Ka(e6) {
          if (e6) {
            if ("number" == typeof e6) {
              const i6 = Math.round(Math.abs(e6) / Math.SQRT2);
              return { center: new t4.P(0, 0), top: new t4.P(0, e6), "top-left": new t4.P(i6, i6), "top-right": new t4.P(-i6, i6), bottom: new t4.P(0, -e6), "bottom-left": new t4.P(i6, -i6), "bottom-right": new t4.P(-i6, -i6), left: new t4.P(e6, 0), right: new t4.P(-e6, 0) };
            }
            if (e6 instanceof t4.P || Array.isArray(e6)) {
              const i6 = t4.P.convert(e6);
              return { center: i6, top: i6, "top-left": i6, "top-right": i6, bottom: i6, "bottom-left": i6, "bottom-right": i6, left: i6, right: i6 };
            }
            return { center: t4.P.convert(e6.center || [0, 0]), top: t4.P.convert(e6.top || [0, 0]), "top-left": t4.P.convert(e6["top-left"] || [0, 0]), "top-right": t4.P.convert(e6["top-right"] || [0, 0]), bottom: t4.P.convert(e6.bottom || [0, 0]), "bottom-left": t4.P.convert(e6["bottom-left"] || [0, 0]), "bottom-right": t4.P.convert(e6["bottom-right"] || [0, 0]), left: t4.P.convert(e6.left || [0, 0]), right: t4.P.convert(e6.right || [0, 0]) };
          }
          return Ka(new t4.P(0, 0));
        }
        const Xa = i5;
        e5.AJAXError = t4.cm, e5.Event = t4.l, e5.Evented = t4.E, e5.LngLat = t4.Q, e5.MercatorCoordinate = t4.$, e5.Point = t4.P, e5.addProtocol = t4.cn, e5.config = t4.a, e5.removeProtocol = t4.co, e5.AttributionControl = wa, e5.BoxZoomHandler = Oo, e5.CanvasSource = Y2, e5.CooperativeGesturesHandler = ma, e5.DoubleClickZoomHandler = ca, e5.DragPanHandler = da, e5.DragRotateHandler = _a6, e5.EdgeInsets = Pt, e5.FullscreenControl = class extends t4.E {
          constructor(e6 = {}) {
            super(), this._onFullscreenChange = () => {
              var e7;
              let t5 = window.document.fullscreenElement || window.document.mozFullScreenElement || window.document.webkitFullscreenElement || window.document.msFullscreenElement;
              for (; null === (e7 = null == t5 ? void 0 : t5.shadowRoot) || void 0 === e7 ? void 0 : e7.fullscreenElement; ) t5 = t5.shadowRoot.fullscreenElement;
              t5 === this._container !== this._fullscreen && this._handleFullscreenChange();
            }, this._onClickFullscreen = () => {
              this._isFullscreen() ? this._exitFullscreen() : this._requestFullscreen();
            }, this._fullscreen = false, e6 && e6.container && (e6.container instanceof HTMLElement ? this._container = e6.container : t4.w("Full screen control 'container' must be a DOM element.")), "onfullscreenchange" in document ? this._fullscreenchange = "fullscreenchange" : "onmozfullscreenchange" in document ? this._fullscreenchange = "mozfullscreenchange" : "onwebkitfullscreenchange" in document ? this._fullscreenchange = "webkitfullscreenchange" : "onmsfullscreenchange" in document && (this._fullscreenchange = "MSFullscreenChange");
          }
          onAdd(e6) {
            return this._map = e6, this._container || (this._container = this._map.getContainer()), this._controlContainer = n5.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._setupUI(), this._controlContainer;
          }
          onRemove() {
            n5.remove(this._controlContainer), this._map = null, window.document.removeEventListener(this._fullscreenchange, this._onFullscreenChange);
          }
          _setupUI() {
            const e6 = this._fullscreenButton = n5.create("button", "maplibregl-ctrl-fullscreen", this._controlContainer);
            n5.create("span", "maplibregl-ctrl-icon", e6).setAttribute("aria-hidden", "true"), e6.type = "button", this._updateTitle(), this._fullscreenButton.addEventListener("click", this._onClickFullscreen), window.document.addEventListener(this._fullscreenchange, this._onFullscreenChange);
          }
          _updateTitle() {
            const e6 = this._getTitle();
            this._fullscreenButton.setAttribute("aria-label", e6), this._fullscreenButton.title = e6;
          }
          _getTitle() {
            return this._map._getUIString(this._isFullscreen() ? "FullscreenControl.Exit" : "FullscreenControl.Enter");
          }
          _isFullscreen() {
            return this._fullscreen;
          }
          _handleFullscreenChange() {
            this._fullscreen = !this._fullscreen, this._fullscreenButton.classList.toggle("maplibregl-ctrl-shrink"), this._fullscreenButton.classList.toggle("maplibregl-ctrl-fullscreen"), this._updateTitle(), this._fullscreen ? (this.fire(new t4.l("fullscreenstart")), this._prevCooperativeGesturesEnabled = this._map.cooperativeGestures.isEnabled(), this._map.cooperativeGestures.disable()) : (this.fire(new t4.l("fullscreenend")), this._prevCooperativeGesturesEnabled && this._map.cooperativeGestures.enable());
          }
          _exitFullscreen() {
            window.document.exitFullscreen ? window.document.exitFullscreen() : window.document.mozCancelFullScreen ? window.document.mozCancelFullScreen() : window.document.msExitFullscreen ? window.document.msExitFullscreen() : window.document.webkitCancelFullScreen ? window.document.webkitCancelFullScreen() : this._togglePseudoFullScreen();
          }
          _requestFullscreen() {
            this._container.requestFullscreen ? this._container.requestFullscreen() : this._container.mozRequestFullScreen ? this._container.mozRequestFullScreen() : this._container.msRequestFullscreen ? this._container.msRequestFullscreen() : this._container.webkitRequestFullscreen ? this._container.webkitRequestFullscreen() : this._togglePseudoFullScreen();
          }
          _togglePseudoFullScreen() {
            this._container.classList.toggle("maplibregl-pseudo-fullscreen"), this._handleFullscreenChange(), this._map.resize();
          }
        }, e5.GeoJSONSource = K2, e5.GeolocateControl = class extends t4.E {
          constructor(e6) {
            super(), this._onSuccess = (e7) => {
              if (this._map) {
                if (this._isOutOfMapMaxBounds(e7)) return this._setErrorState(), this.fire(new t4.l("outofmaxbounds", e7)), this._updateMarker(), void this._finish();
                if (this.options.trackUserLocation) switch (this._lastKnownPosition = e7, this._watchState) {
                  case "WAITING_ACTIVE":
                  case "ACTIVE_LOCK":
                  case "ACTIVE_ERROR":
                    this._watchState = "ACTIVE_LOCK", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active");
                    break;
                  case "BACKGROUND":
                  case "BACKGROUND_ERROR":
                    this._watchState = "BACKGROUND", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-background");
                    break;
                  default:
                    throw new Error(`Unexpected watchState ${this._watchState}`);
                }
                this.options.showUserLocation && "OFF" !== this._watchState && this._updateMarker(e7), this.options.trackUserLocation && "ACTIVE_LOCK" !== this._watchState || this._updateCamera(e7), this.options.showUserLocation && this._dotElement.classList.remove("maplibregl-user-location-dot-stale"), this.fire(new t4.l("geolocate", e7)), this._finish();
              }
            }, this._updateCamera = (e7) => {
              const i6 = new t4.Q(e7.coords.longitude, e7.coords.latitude), r8 = e7.coords.accuracy, o6 = this._map.getBearing(), a4 = t4.e({ bearing: o6 }, this.options.fitBoundsOptions), s4 = V2.fromLngLat(i6, r8);
              this._map.fitBounds(s4, a4, { geolocateSource: true });
            }, this._updateMarker = (e7) => {
              if (e7) {
                const i6 = new t4.Q(e7.coords.longitude, e7.coords.latitude);
                this._accuracyCircleMarker.setLngLat(i6).addTo(this._map), this._userLocationDotMarker.setLngLat(i6).addTo(this._map), this._accuracy = e7.coords.accuracy, this.options.showUserLocation && this.options.showAccuracyCircle && this._updateCircleRadius();
              } else this._userLocationDotMarker.remove(), this._accuracyCircleMarker.remove();
            }, this._onZoom = () => {
              this.options.showUserLocation && this.options.showAccuracyCircle && this._updateCircleRadius();
            }, this._onError = (e7) => {
              if (this._map) {
                if (this.options.trackUserLocation) if (1 === e7.code) {
                  this._watchState = "OFF", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active-error"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background-error"), this._geolocateButton.disabled = true;
                  const e8 = this._map._getUIString("GeolocateControl.LocationNotAvailable");
                  this._geolocateButton.title = e8, this._geolocateButton.setAttribute("aria-label", e8), void 0 !== this._geolocationWatchID && this._clearWatch();
                } else {
                  if (3 === e7.code && Ua) return;
                  this._setErrorState();
                }
                "OFF" !== this._watchState && this.options.showUserLocation && this._dotElement.classList.add("maplibregl-user-location-dot-stale"), this.fire(new t4.l("error", e7)), this._finish();
              }
            }, this._finish = () => {
              this._timeoutId && clearTimeout(this._timeoutId), this._timeoutId = void 0;
            }, this._setupUI = () => {
              this._map && (this._container.addEventListener("contextmenu", (e7) => e7.preventDefault()), this._geolocateButton = n5.create("button", "maplibregl-ctrl-geolocate", this._container), n5.create("span", "maplibregl-ctrl-icon", this._geolocateButton).setAttribute("aria-hidden", "true"), this._geolocateButton.type = "button", this._geolocateButton.disabled = true);
            }, this._finishSetupUI = (e7) => {
              if (this._map) {
                if (false === e7) {
                  t4.w("Geolocation support is not available so the GeolocateControl will be disabled.");
                  const e8 = this._map._getUIString("GeolocateControl.LocationNotAvailable");
                  this._geolocateButton.disabled = true, this._geolocateButton.title = e8, this._geolocateButton.setAttribute("aria-label", e8);
                } else {
                  const e8 = this._map._getUIString("GeolocateControl.FindMyLocation");
                  this._geolocateButton.disabled = false, this._geolocateButton.title = e8, this._geolocateButton.setAttribute("aria-label", e8);
                }
                this.options.trackUserLocation && (this._geolocateButton.setAttribute("aria-pressed", "false"), this._watchState = "OFF"), this.options.showUserLocation && (this._dotElement = n5.create("div", "maplibregl-user-location-dot"), this._userLocationDotMarker = new Za({ element: this._dotElement }), this._circleElement = n5.create("div", "maplibregl-user-location-accuracy-circle"), this._accuracyCircleMarker = new Za({ element: this._circleElement, pitchAlignment: "map" }), this.options.trackUserLocation && (this._watchState = "OFF"), this._map.on("zoom", this._onZoom)), this._geolocateButton.addEventListener("click", () => this.trigger()), this._setup = true, this.options.trackUserLocation && this._map.on("movestart", (e8) => {
                  e8.geolocateSource || "ACTIVE_LOCK" !== this._watchState || e8.originalEvent && "resize" === e8.originalEvent.type || (this._watchState = "BACKGROUND", this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this.fire(new t4.l("trackuserlocationend")), this.fire(new t4.l("userlocationlostfocus")));
                });
              }
            }, this.options = t4.e({}, Na, e6);
          }
          onAdd(e6) {
            return this._map = e6, this._container = n5.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._setupUI(), function() {
              return t4._(this, arguments, void 0, function* (e7 = false) {
                if (void 0 !== Fa && !e7) return Fa;
                if (void 0 === window.navigator.permissions) return Fa = !!window.navigator.geolocation, Fa;
                try {
                  const e8 = yield window.navigator.permissions.query({ name: "geolocation" });
                  Fa = "denied" !== e8.state;
                } catch (e8) {
                  Fa = !!window.navigator.geolocation;
                }
                return Fa;
              });
            }().then((e7) => this._finishSetupUI(e7)), this._container;
          }
          onRemove() {
            void 0 !== this._geolocationWatchID && (window.navigator.geolocation.clearWatch(this._geolocationWatchID), this._geolocationWatchID = void 0), this.options.showUserLocation && this._userLocationDotMarker && this._userLocationDotMarker.remove(), this.options.showAccuracyCircle && this._accuracyCircleMarker && this._accuracyCircleMarker.remove(), n5.remove(this._container), this._map.off("zoom", this._onZoom), this._map = void 0, Ga = 0, Ua = false;
          }
          _isOutOfMapMaxBounds(e6) {
            const t5 = this._map.getMaxBounds(), i6 = e6.coords;
            return t5 && (i6.longitude < t5.getWest() || i6.longitude > t5.getEast() || i6.latitude < t5.getSouth() || i6.latitude > t5.getNorth());
          }
          _setErrorState() {
            switch (this._watchState) {
              case "WAITING_ACTIVE":
                this._watchState = "ACTIVE_ERROR", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active-error");
                break;
              case "ACTIVE_LOCK":
                this._watchState = "ACTIVE_ERROR", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting");
                break;
              case "BACKGROUND":
                this._watchState = "BACKGROUND_ERROR", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-background-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting");
                break;
              case "ACTIVE_ERROR":
                break;
              default:
                throw new Error(`Unexpected watchState ${this._watchState}`);
            }
          }
          _updateCircleRadius() {
            const e6 = this._map.getBounds(), t5 = e6.getSouthEast(), i6 = e6.getNorthEast(), r8 = t5.distanceTo(i6), o6 = Math.ceil(this._accuracy / (r8 / this._map._container.clientHeight) * 2);
            this._circleElement.style.width = `${o6}px`, this._circleElement.style.height = `${o6}px`;
          }
          trigger() {
            if (!this._setup) return t4.w("Geolocate control triggered before added to a map"), false;
            if (this.options.trackUserLocation) {
              switch (this._watchState) {
                case "OFF":
                  this._watchState = "WAITING_ACTIVE", this.fire(new t4.l("trackuserlocationstart"));
                  break;
                case "WAITING_ACTIVE":
                case "ACTIVE_LOCK":
                case "ACTIVE_ERROR":
                case "BACKGROUND_ERROR":
                  Ga--, Ua = false, this._watchState = "OFF", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active-error"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background-error"), this.fire(new t4.l("trackuserlocationend"));
                  break;
                case "BACKGROUND":
                  this._watchState = "ACTIVE_LOCK", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"), this._lastKnownPosition && this._updateCamera(this._lastKnownPosition), this.fire(new t4.l("trackuserlocationstart")), this.fire(new t4.l("userlocationfocus"));
                  break;
                default:
                  throw new Error(`Unexpected watchState ${this._watchState}`);
              }
              switch (this._watchState) {
                case "WAITING_ACTIVE":
                  this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active");
                  break;
                case "ACTIVE_LOCK":
                  this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active");
                  break;
                case "OFF":
                  break;
                default:
                  throw new Error(`Unexpected watchState ${this._watchState}`);
              }
              if ("OFF" === this._watchState && void 0 !== this._geolocationWatchID) this._clearWatch();
              else if (void 0 === this._geolocationWatchID) {
                let e6;
                this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.setAttribute("aria-pressed", "true"), Ga++, Ga > 1 ? (e6 = { maximumAge: 6e5, timeout: 0 }, Ua = true) : (e6 = this.options.positionOptions, Ua = false), this._geolocationWatchID = window.navigator.geolocation.watchPosition(this._onSuccess, this._onError, e6);
              }
            } else window.navigator.geolocation.getCurrentPosition(this._onSuccess, this._onError, this.options.positionOptions), this._timeoutId = setTimeout(this._finish, 1e4);
            return true;
          }
          _clearWatch() {
            window.navigator.geolocation.clearWatch(this._geolocationWatchID), this._geolocationWatchID = void 0, this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.setAttribute("aria-pressed", "false"), this.options.showUserLocation && this._updateMarker(null);
          }
        }, e5.GlobeControl = class {
          constructor() {
            this._toggleProjection = () => {
              var e6;
              const t5 = null === (e6 = this._map.getProjection()) || void 0 === e6 ? void 0 : e6.type;
              this._map.setProjection("mercator" !== t5 && t5 ? { type: "mercator" } : { type: "globe" }), this._updateGlobeIcon();
            }, this._updateGlobeIcon = () => {
              var e6;
              this._globeButton.classList.remove("maplibregl-ctrl-globe"), this._globeButton.classList.remove("maplibregl-ctrl-globe-enabled"), "globe" === (null === (e6 = this._map.getProjection()) || void 0 === e6 ? void 0 : e6.type) ? (this._globeButton.classList.add("maplibregl-ctrl-globe-enabled"), this._globeButton.title = this._map._getUIString("GlobeControl.Disable")) : (this._globeButton.classList.add("maplibregl-ctrl-globe"), this._globeButton.title = this._map._getUIString("GlobeControl.Enable"));
            };
          }
          onAdd(e6) {
            return this._map = e6, this._container = n5.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._globeButton = n5.create("button", "maplibregl-ctrl-globe", this._container), n5.create("span", "maplibregl-ctrl-icon", this._globeButton).setAttribute("aria-hidden", "true"), this._globeButton.type = "button", this._globeButton.addEventListener("click", this._toggleProjection), this._updateGlobeIcon(), this._map.on("styledata", this._updateGlobeIcon), this._container;
          }
          onRemove() {
            n5.remove(this._container), this._map.off("styledata", this._updateGlobeIcon), this._globeButton.removeEventListener("click", this._toggleProjection), this._map = void 0;
          }
        }, e5.Hash = wo, e5.ImageSource = X2, e5.KeyboardHandler = aa, e5.LngLatBounds = V2, e5.LogoControl = Ta, e5.Map = class extends ba {
          constructor(e6) {
            var i6, r8;
            t4.cj.mark(t4.ck.create);
            const o6 = Object.assign(Object.assign(Object.assign({}, Aa), e6), { canvasContextAttributes: Object.assign(Object.assign({}, Aa.canvasContextAttributes), e6.canvasContextAttributes) });
            if (null != o6.minZoom && null != o6.maxZoom && o6.minZoom > o6.maxZoom) throw new Error("maxZoom must be greater than or equal to minZoom");
            if (null != o6.minPitch && null != o6.maxPitch && o6.minPitch > o6.maxPitch) throw new Error("maxPitch must be greater than or equal to minPitch");
            if (null != o6.minPitch && o6.minPitch < 0) throw new Error("minPitch must be greater than or equal to 0");
            if (null != o6.maxPitch && o6.maxPitch > 180) throw new Error("maxPitch must be less than or equal to 180");
            const a4 = new Dt(), s4 = new kt();
            if (void 0 !== o6.minZoom && a4.setMinZoom(o6.minZoom), void 0 !== o6.maxZoom && a4.setMaxZoom(o6.maxZoom), void 0 !== o6.minPitch && a4.setMinPitch(o6.minPitch), void 0 !== o6.maxPitch && a4.setMaxPitch(o6.maxPitch), void 0 !== o6.renderWorldCopies && a4.setRenderWorldCopies(o6.renderWorldCopies), super(a4, s4, { bearingSnap: o6.bearingSnap }), this._idleTriggered = false, this._crossFadingFactor = 1, this._renderTaskQueue = new Pa(), this._controls = [], this._mapId = t4.a4(), this._contextLost = (e7) => {
              e7.preventDefault(), this._frameRequest && (this._frameRequest.abort(), this._frameRequest = null), this.fire(new t4.l("webglcontextlost", { originalEvent: e7 }));
            }, this._contextRestored = (e7) => {
              this._setupPainter(), this.resize(), this._update(), this.fire(new t4.l("webglcontextrestored", { originalEvent: e7 }));
            }, this._onMapScroll = (e7) => {
              if (e7.target === this._container) return this._container.scrollTop = 0, this._container.scrollLeft = 0, false;
            }, this._onWindowOnline = () => {
              this._update();
            }, this._interactive = o6.interactive, this._maxTileCacheSize = o6.maxTileCacheSize, this._maxTileCacheZoomLevels = o6.maxTileCacheZoomLevels, this._canvasContextAttributes = Object.assign({}, o6.canvasContextAttributes), this._trackResize = true === o6.trackResize, this._bearingSnap = o6.bearingSnap, this._centerClampedToGround = o6.centerClampedToGround, this._refreshExpiredTiles = true === o6.refreshExpiredTiles, this._fadeDuration = o6.fadeDuration, this._crossSourceCollisions = true === o6.crossSourceCollisions, this._collectResourceTiming = true === o6.collectResourceTiming, this._locale = Object.assign(Object.assign({}, Da), o6.locale), this._clickTolerance = o6.clickTolerance, this._overridePixelRatio = o6.pixelRatio, this._maxCanvasSize = o6.maxCanvasSize, this.transformCameraUpdate = o6.transformCameraUpdate, this.cancelPendingTileRequestsWhileZooming = true === o6.cancelPendingTileRequestsWhileZooming, this._imageQueueHandle = p3.addThrottleControl(() => this.isMoving()), this._requestManager = new m3(o6.transformRequest), "string" == typeof o6.container) {
              if (this._container = document.getElementById(o6.container), !this._container) throw new Error(`Container '${o6.container}' not found.`);
            } else {
              if (!(o6.container instanceof HTMLElement)) throw new Error("Invalid type: 'container' must be a String or HTMLElement.");
              this._container = o6.container;
            }
            if (o6.maxBounds && this.setMaxBounds(o6.maxBounds), this._setupContainer(), this._setupPainter(), this.on("move", () => this._update(false)), this.on("moveend", () => this._update(false)), this.on("zoom", () => this._update(true)), this.on("terrain", () => {
              this.painter.terrainFacilitator.dirty = true, this._update(true);
            }), this.once("idle", () => {
              this._idleTriggered = true;
            }), "undefined" != typeof window) {
              addEventListener("online", this._onWindowOnline, false);
              let e7 = false;
              const t5 = yo((e8) => {
                this._trackResize && !this._removed && (this.resize(e8), this.redraw());
              }, 50);
              this._resizeObserver = new ResizeObserver((i7) => {
                e7 ? t5(i7) : e7 = true;
              }), this._resizeObserver.observe(this._container);
            }
            this.handlers = new xa(this, o6), this._hash = o6.hash && new wo("string" == typeof o6.hash && o6.hash || void 0).addTo(this), this._hash && this._hash._onHashChange() || (this.jumpTo({ center: o6.center, elevation: o6.elevation, zoom: o6.zoom, bearing: o6.bearing, pitch: o6.pitch, roll: o6.roll }), o6.bounds && (this.resize(), this.fitBounds(o6.bounds, t4.e({}, o6.fitBoundsOptions, { duration: 0 }))));
            const n6 = "string" == typeof o6.style || !("globe" === (null === (r8 = null === (i6 = o6.style) || void 0 === i6 ? void 0 : i6.projection) || void 0 === r8 ? void 0 : r8.type));
            this.resize(null, n6), this._localIdeographFontFamily = o6.localIdeographFontFamily, this._validateStyle = o6.validateStyle, o6.style && this.setStyle(o6.style, { localIdeographFontFamily: o6.localIdeographFontFamily }), o6.attributionControl && this.addControl(new wa("boolean" == typeof o6.attributionControl ? void 0 : o6.attributionControl)), o6.maplibreLogo && this.addControl(new Ta(), o6.logoPosition), this.on("style.load", () => {
              if (n6 || this._resizeTransform(), this.transform.unmodified) {
                const e7 = t4.O(this.style.stylesheet, ["center", "zoom", "bearing", "pitch", "roll"]);
                this.jumpTo(e7);
              }
            }), this.on("data", (e7) => {
              this._update("style" === e7.dataType), this.fire(new t4.l(`${e7.dataType}data`, e7));
            }), this.on("dataloading", (e7) => {
              this.fire(new t4.l(`${e7.dataType}dataloading`, e7));
            }), this.on("dataabort", (e7) => {
              this.fire(new t4.l("sourcedataabort", e7));
            });
          }
          _getMapId() {
            return this._mapId;
          }
          addControl(e6, i6) {
            if (void 0 === i6 && (i6 = e6.getDefaultPosition ? e6.getDefaultPosition() : "top-right"), !e6 || !e6.onAdd) return this.fire(new t4.k(new Error("Invalid argument to map.addControl(). Argument must be a control with onAdd and onRemove methods.")));
            const r8 = e6.onAdd(this);
            this._controls.push(e6);
            const o6 = this._controlPositions[i6];
            return -1 !== i6.indexOf("bottom") ? o6.insertBefore(r8, o6.firstChild) : o6.appendChild(r8), this;
          }
          removeControl(e6) {
            if (!e6 || !e6.onRemove) return this.fire(new t4.k(new Error("Invalid argument to map.removeControl(). Argument must be a control with onAdd and onRemove methods.")));
            const i6 = this._controls.indexOf(e6);
            return i6 > -1 && this._controls.splice(i6, 1), e6.onRemove(this), this;
          }
          hasControl(e6) {
            return this._controls.indexOf(e6) > -1;
          }
          calculateCameraOptionsFromTo(e6, t5, i6, r8) {
            return null == r8 && this.terrain && (r8 = this.terrain.getElevationForLngLatZoom(i6, this.transform.tileZoom)), super.calculateCameraOptionsFromTo(e6, t5, i6, r8);
          }
          resize(e6, i6 = true) {
            const [r8, o6] = this._containerDimensions(), a4 = this._getClampedPixelRatio(r8, o6);
            if (this._resizeCanvas(r8, o6, a4), this.painter.resize(r8, o6, a4), this.painter.overLimit()) {
              const e7 = this.painter.context.gl;
              this._maxCanvasSize = [e7.drawingBufferWidth, e7.drawingBufferHeight];
              const t5 = this._getClampedPixelRatio(r8, o6);
              this._resizeCanvas(r8, o6, t5), this.painter.resize(r8, o6, t5);
            }
            this._resizeTransform(i6);
            const s4 = !this._moving;
            return s4 && (this.stop(), this.fire(new t4.l("movestart", e6)).fire(new t4.l("move", e6))), this.fire(new t4.l("resize", e6)), s4 && this.fire(new t4.l("moveend", e6)), this;
          }
          _resizeTransform(e6 = true) {
            var t5;
            const [i6, r8] = this._containerDimensions();
            this.transform.resize(i6, r8, e6), null === (t5 = this._requestedCameraState) || void 0 === t5 || t5.resize(i6, r8, e6);
          }
          _getClampedPixelRatio(e6, t5) {
            const { 0: i6, 1: r8 } = this._maxCanvasSize, o6 = this.getPixelRatio(), a4 = e6 * o6, s4 = t5 * o6;
            return Math.min(a4 > i6 ? i6 / a4 : 1, s4 > r8 ? r8 / s4 : 1) * o6;
          }
          getPixelRatio() {
            var e6;
            return null !== (e6 = this._overridePixelRatio) && void 0 !== e6 ? e6 : devicePixelRatio;
          }
          setPixelRatio(e6) {
            this._overridePixelRatio = e6, this.resize();
          }
          getBounds() {
            return this.transform.getBounds();
          }
          getMaxBounds() {
            return this.transform.getMaxBounds();
          }
          setMaxBounds(e6) {
            return this.transform.setMaxBounds(V2.convert(e6)), this._update();
          }
          setMinZoom(e6) {
            if ((e6 = null == e6 ? -2 : e6) >= -2 && e6 <= this.transform.maxZoom) return this.transform.setMinZoom(e6), this._update(), this.getZoom() < e6 && this.setZoom(e6), this;
            throw new Error("minZoom must be between -2 and the current maxZoom, inclusive");
          }
          getMinZoom() {
            return this.transform.minZoom;
          }
          setMaxZoom(e6) {
            if ((e6 = null == e6 ? 22 : e6) >= this.transform.minZoom) return this.transform.setMaxZoom(e6), this._update(), this.getZoom() > e6 && this.setZoom(e6), this;
            throw new Error("maxZoom must be greater than the current minZoom");
          }
          getMaxZoom() {
            return this.transform.maxZoom;
          }
          setMinPitch(e6) {
            if ((e6 = null == e6 ? 0 : e6) < 0) throw new Error("minPitch must be greater than or equal to 0");
            if (e6 >= 0 && e6 <= this.transform.maxPitch) return this.transform.setMinPitch(e6), this._update(), this.getPitch() < e6 && this.setPitch(e6), this;
            throw new Error("minPitch must be between 0 and the current maxPitch, inclusive");
          }
          getMinPitch() {
            return this.transform.minPitch;
          }
          setMaxPitch(e6) {
            if ((e6 = null == e6 ? 60 : e6) > 180) throw new Error("maxPitch must be less than or equal to 180");
            if (e6 >= this.transform.minPitch) return this.transform.setMaxPitch(e6), this._update(), this.getPitch() > e6 && this.setPitch(e6), this;
            throw new Error("maxPitch must be greater than the current minPitch");
          }
          getMaxPitch() {
            return this.transform.maxPitch;
          }
          getRenderWorldCopies() {
            return this.transform.renderWorldCopies;
          }
          setRenderWorldCopies(e6) {
            return this.transform.setRenderWorldCopies(e6), this._update();
          }
          project(e6) {
            return this.transform.locationToScreenPoint(t4.Q.convert(e6), this.style && this.terrain);
          }
          unproject(e6) {
            return this.transform.screenPointToLocation(t4.P.convert(e6), this.terrain);
          }
          isMoving() {
            var e6;
            return this._moving || (null === (e6 = this.handlers) || void 0 === e6 ? void 0 : e6.isMoving());
          }
          isZooming() {
            var e6;
            return this._zooming || (null === (e6 = this.handlers) || void 0 === e6 ? void 0 : e6.isZooming());
          }
          isRotating() {
            var e6;
            return this._rotating || (null === (e6 = this.handlers) || void 0 === e6 ? void 0 : e6.isRotating());
          }
          _createDelegatedListener(e6, t5, i6) {
            if ("mouseenter" === e6 || "mouseover" === e6) {
              let r8 = false;
              const o6 = (o7) => {
                const a4 = t5.filter((e7) => this.getLayer(e7)), s4 = 0 !== a4.length ? this.queryRenderedFeatures(o7.point, { layers: a4 }) : [];
                s4.length ? r8 || (r8 = true, i6.call(this, new zo(e6, this, o7.originalEvent, { features: s4 }))) : r8 = false;
              };
              return { layers: t5, listener: i6, delegates: { mousemove: o6, mouseout: () => {
                r8 = false;
              } } };
            }
            if ("mouseleave" === e6 || "mouseout" === e6) {
              let r8 = false;
              const o6 = (o7) => {
                const a5 = t5.filter((e7) => this.getLayer(e7));
                (0 !== a5.length ? this.queryRenderedFeatures(o7.point, { layers: a5 }) : []).length ? r8 = true : r8 && (r8 = false, i6.call(this, new zo(e6, this, o7.originalEvent)));
              }, a4 = (t6) => {
                r8 && (r8 = false, i6.call(this, new zo(e6, this, t6.originalEvent)));
              };
              return { layers: t5, listener: i6, delegates: { mousemove: o6, mouseout: a4 } };
            }
            {
              const r8 = (e7) => {
                const r9 = t5.filter((e8) => this.getLayer(e8)), o6 = 0 !== r9.length ? this.queryRenderedFeatures(e7.point, { layers: r9 }) : [];
                o6.length && (e7.features = o6, i6.call(this, e7), delete e7.features);
              };
              return { layers: t5, listener: i6, delegates: { [e6]: r8 } };
            }
          }
          _saveDelegatedListener(e6, t5) {
            this._delegatedListeners = this._delegatedListeners || {}, this._delegatedListeners[e6] = this._delegatedListeners[e6] || [], this._delegatedListeners[e6].push(t5);
          }
          _removeDelegatedListener(e6, t5, i6) {
            if (!this._delegatedListeners || !this._delegatedListeners[e6]) return;
            const r8 = this._delegatedListeners[e6];
            for (let e7 = 0; e7 < r8.length; e7++) {
              const o6 = r8[e7];
              if (o6.listener === i6 && o6.layers.length === t5.length && o6.layers.every((e8) => t5.includes(e8))) {
                for (const e8 in o6.delegates) this.off(e8, o6.delegates[e8]);
                return void r8.splice(e7, 1);
              }
            }
          }
          on(e6, t5, i6) {
            if (void 0 === i6) return super.on(e6, t5);
            const r8 = "string" == typeof t5 ? [t5] : t5, o6 = this._createDelegatedListener(e6, r8, i6);
            this._saveDelegatedListener(e6, o6);
            for (const e7 in o6.delegates) this.on(e7, o6.delegates[e7]);
            return { unsubscribe: () => {
              this._removeDelegatedListener(e6, r8, i6);
            } };
          }
          once(e6, t5, i6) {
            if (void 0 === i6) return super.once(e6, t5);
            const r8 = "string" == typeof t5 ? [t5] : t5, o6 = this._createDelegatedListener(e6, r8, i6);
            for (const t6 in o6.delegates) {
              const a4 = o6.delegates[t6];
              o6.delegates[t6] = (...t7) => {
                this._removeDelegatedListener(e6, r8, i6), a4(...t7);
              };
            }
            this._saveDelegatedListener(e6, o6);
            for (const e7 in o6.delegates) this.once(e7, o6.delegates[e7]);
            return this;
          }
          off(e6, t5, i6) {
            return void 0 === i6 ? super.off(e6, t5) : (this._removeDelegatedListener(e6, "string" == typeof t5 ? [t5] : t5, i6), this);
          }
          queryRenderedFeatures(e6, i6) {
            if (!this.style) return [];
            let r8;
            const o6 = e6 instanceof t4.P || Array.isArray(e6), a4 = o6 ? e6 : [[0, 0], [this.transform.width, this.transform.height]];
            if (i6 = i6 || (o6 ? {} : e6) || {}, a4 instanceof t4.P || "number" == typeof a4[0]) r8 = [t4.P.convert(a4)];
            else {
              const e7 = t4.P.convert(a4[0]), i7 = t4.P.convert(a4[1]);
              r8 = [e7, new t4.P(i7.x, e7.y), i7, new t4.P(e7.x, i7.y), e7];
            }
            return this.style.queryRenderedFeatures(r8, i6, this.transform);
          }
          querySourceFeatures(e6, t5) {
            return this.style.querySourceFeatures(e6, t5);
          }
          setStyle(e6, i6) {
            return false !== (i6 = t4.e({}, { localIdeographFontFamily: this._localIdeographFontFamily, validate: this._validateStyle }, i6)).diff && i6.localIdeographFontFamily === this._localIdeographFontFamily && this.style && e6 ? (this._diffStyle(e6, i6), this) : (this._localIdeographFontFamily = i6.localIdeographFontFamily, this._updateStyle(e6, i6));
          }
          setTransformRequest(e6) {
            return this._requestManager.setTransformRequest(e6), this;
          }
          _getUIString(e6) {
            const t5 = this._locale[e6];
            if (null == t5) throw new Error(`Missing UI string '${e6}'`);
            return t5;
          }
          _updateStyle(e6, t5) {
            var i6, r8;
            if (t5.transformStyle && this.style && !this.style._loaded) return void this.style.once("style.load", () => this._updateStyle(e6, t5));
            const o6 = this.style && t5.transformStyle ? this.style.serialize() : void 0;
            return this.style && (this.style.setEventedParent(null), this.style._remove(!e6)), e6 ? (this.style = new gi(this, t5 || {}), this.style.setEventedParent(this, { style: this.style }), "string" == typeof e6 ? this.style.loadURL(e6, t5, o6) : this.style.loadJSON(e6, t5, o6), this) : (null === (r8 = null === (i6 = this.style) || void 0 === i6 ? void 0 : i6.projection) || void 0 === r8 || r8.destroy(), delete this.style, this);
          }
          _lazyInitEmptyStyle() {
            this.style || (this.style = new gi(this, {}), this.style.setEventedParent(this, { style: this.style }), this.style.loadEmpty());
          }
          _diffStyle(e6, i6) {
            if ("string" == typeof e6) {
              const r8 = this._requestManager.transformRequest(e6, "Style");
              t4.j(r8, new AbortController()).then((e7) => {
                this._updateDiff(e7.data, i6);
              }).catch((e7) => {
                e7 && this.fire(new t4.k(e7));
              });
            } else "object" == typeof e6 && this._updateDiff(e6, i6);
          }
          _updateDiff(e6, i6) {
            try {
              this.style.setState(e6, i6) && this._update(true);
            } catch (r8) {
              t4.w(`Unable to perform style diff: ${r8.message || r8.error || r8}.  Rebuilding the style from scratch.`), this._updateStyle(e6, i6);
            }
          }
          getStyle() {
            if (this.style) return this.style.serialize();
          }
          isStyleLoaded() {
            return this.style ? this.style.loaded() : t4.w("There is no style added to the map.");
          }
          addSource(e6, t5) {
            return this._lazyInitEmptyStyle(), this.style.addSource(e6, t5), this._update(true);
          }
          isSourceLoaded(e6) {
            const i6 = this.style && this.style.sourceCaches[e6];
            if (void 0 !== i6) return i6.loaded();
            this.fire(new t4.k(new Error(`There is no source with ID '${e6}'`)));
          }
          setTerrain(e6) {
            if (this.style._checkLoaded(), this._terrainDataCallback && this.style.off("data", this._terrainDataCallback), e6) {
              const i6 = this.style.sourceCaches[e6.source];
              if (!i6) throw new Error(`cannot load terrain, because there exists no source with ID: ${e6.source}`);
              null === this.terrain && i6.reload();
              for (const i7 in this.style._layers) {
                const r8 = this.style._layers[i7];
                "hillshade" === r8.type && r8.source === e6.source && t4.w("You are using the same source for a hillshade layer and for 3D terrain. Please consider using two separate sources to improve rendering quality.");
              }
              this.terrain = new Ma(this.painter, i6, e6), this.painter.renderToTexture = new Ra(this.painter, this.terrain), this.transform.setMinElevationForCurrentTile(this.terrain.getMinTileElevationForLngLatZoom(this.transform.center, this.transform.tileZoom)), this.transform.setElevation(this.terrain.getElevationForLngLatZoom(this.transform.center, this.transform.tileZoom)), this._terrainDataCallback = (t5) => {
                var i7;
                "style" === t5.dataType ? this.terrain.sourceCache.freeRtt() : "source" === t5.dataType && t5.tile && (t5.sourceId !== e6.source || this._elevationFreeze || (this.transform.setMinElevationForCurrentTile(this.terrain.getMinTileElevationForLngLatZoom(this.transform.center, this.transform.tileZoom)), this._centerClampedToGround && this.transform.setElevation(this.terrain.getElevationForLngLatZoom(this.transform.center, this.transform.tileZoom))), "image" === (null === (i7 = t5.source) || void 0 === i7 ? void 0 : i7.type) ? this.terrain.sourceCache.freeRtt() : this.terrain.sourceCache.freeRtt(t5.tile.tileID));
              }, this.style.on("data", this._terrainDataCallback);
            } else this.terrain && this.terrain.sourceCache.destruct(), this.terrain = null, this.painter.renderToTexture && this.painter.renderToTexture.destruct(), this.painter.renderToTexture = null, this.transform.setMinElevationForCurrentTile(0), this._centerClampedToGround && this.transform.setElevation(0);
            return this.fire(new t4.l("terrain", { terrain: e6 })), this;
          }
          getTerrain() {
            var e6, t5;
            return null !== (t5 = null === (e6 = this.terrain) || void 0 === e6 ? void 0 : e6.options) && void 0 !== t5 ? t5 : null;
          }
          areTilesLoaded() {
            const e6 = this.style && this.style.sourceCaches;
            for (const t5 in e6) {
              const i6 = e6[t5]._tiles;
              for (const e7 in i6) {
                const t6 = i6[e7];
                if ("loaded" !== t6.state && "errored" !== t6.state) return false;
              }
            }
            return true;
          }
          removeSource(e6) {
            return this.style.removeSource(e6), this._update(true);
          }
          getSource(e6) {
            return this.style.getSource(e6);
          }
          addImage(e6, i6, r8 = {}) {
            const { pixelRatio: o6 = 1, sdf: a4 = false, stretchX: n6, stretchY: l5, content: c5, textFitWidth: h4, textFitHeight: u4 } = r8;
            if (this._lazyInitEmptyStyle(), !(i6 instanceof HTMLImageElement || t4.b(i6))) {
              if (void 0 === i6.width || void 0 === i6.height) return this.fire(new t4.k(new Error("Invalid arguments to map.addImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`")));
              {
                const { width: r9, height: s4, data: d4 } = i6, _4 = i6;
                return this.style.addImage(e6, { data: new t4.R({ width: r9, height: s4 }, new Uint8Array(d4)), pixelRatio: o6, stretchX: n6, stretchY: l5, content: c5, textFitWidth: h4, textFitHeight: u4, sdf: a4, version: 0, userImage: _4 }), _4.onAdd && _4.onAdd(this, e6), this;
              }
            }
            {
              const { width: r9, height: d4, data: _4 } = s3.getImageData(i6);
              this.style.addImage(e6, { data: new t4.R({ width: r9, height: d4 }, _4), pixelRatio: o6, stretchX: n6, stretchY: l5, content: c5, textFitWidth: h4, textFitHeight: u4, sdf: a4, version: 0 });
            }
          }
          updateImage(e6, i6) {
            const r8 = this.style.getImage(e6);
            if (!r8) return this.fire(new t4.k(new Error("The map has no image with that id. If you are adding a new image use `map.addImage(...)` instead.")));
            const o6 = i6 instanceof HTMLImageElement || t4.b(i6) ? s3.getImageData(i6) : i6, { width: a4, height: n6, data: l5 } = o6;
            if (void 0 === a4 || void 0 === n6) return this.fire(new t4.k(new Error("Invalid arguments to map.updateImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`")));
            if (a4 !== r8.data.width || n6 !== r8.data.height) return this.fire(new t4.k(new Error("The width and height of the updated image must be that same as the previous version of the image")));
            const c5 = !(i6 instanceof HTMLImageElement || t4.b(i6));
            return r8.data.replace(l5, c5), this.style.updateImage(e6, r8), this;
          }
          getImage(e6) {
            return this.style.getImage(e6);
          }
          hasImage(e6) {
            return e6 ? !!this.style.getImage(e6) : (this.fire(new t4.k(new Error("Missing required image id"))), false);
          }
          removeImage(e6) {
            this.style.removeImage(e6);
          }
          loadImage(e6) {
            return p3.getImage(this._requestManager.transformRequest(e6, "Image"), new AbortController());
          }
          listImages() {
            return this.style.listImages();
          }
          addLayer(e6, t5) {
            return this._lazyInitEmptyStyle(), this.style.addLayer(e6, t5), this._update(true);
          }
          moveLayer(e6, t5) {
            return this.style.moveLayer(e6, t5), this._update(true);
          }
          removeLayer(e6) {
            return this.style.removeLayer(e6), this._update(true);
          }
          getLayer(e6) {
            return this.style.getLayer(e6);
          }
          getLayersOrder() {
            return this.style.getLayersOrder();
          }
          setLayerZoomRange(e6, t5, i6) {
            return this.style.setLayerZoomRange(e6, t5, i6), this._update(true);
          }
          setFilter(e6, t5, i6 = {}) {
            return this.style.setFilter(e6, t5, i6), this._update(true);
          }
          getFilter(e6) {
            return this.style.getFilter(e6);
          }
          setPaintProperty(e6, t5, i6, r8 = {}) {
            return this.style.setPaintProperty(e6, t5, i6, r8), this._update(true);
          }
          getPaintProperty(e6, t5) {
            return this.style.getPaintProperty(e6, t5);
          }
          setLayoutProperty(e6, t5, i6, r8 = {}) {
            return this.style.setLayoutProperty(e6, t5, i6, r8), this._update(true);
          }
          getLayoutProperty(e6, t5) {
            return this.style.getLayoutProperty(e6, t5);
          }
          setGlyphs(e6, t5 = {}) {
            return this._lazyInitEmptyStyle(), this.style.setGlyphs(e6, t5), this._update(true);
          }
          getGlyphs() {
            return this.style.getGlyphsUrl();
          }
          addSprite(e6, t5, i6 = {}) {
            return this._lazyInitEmptyStyle(), this.style.addSprite(e6, t5, i6, (e7) => {
              e7 || this._update(true);
            }), this;
          }
          removeSprite(e6) {
            return this._lazyInitEmptyStyle(), this.style.removeSprite(e6), this._update(true);
          }
          getSprite() {
            return this.style.getSprite();
          }
          setSprite(e6, t5 = {}) {
            return this._lazyInitEmptyStyle(), this.style.setSprite(e6, t5, (e7) => {
              e7 || this._update(true);
            }), this;
          }
          setLight(e6, t5 = {}) {
            return this._lazyInitEmptyStyle(), this.style.setLight(e6, t5), this._update(true);
          }
          getLight() {
            return this.style.getLight();
          }
          setSky(e6, t5 = {}) {
            return this._lazyInitEmptyStyle(), this.style.setSky(e6, t5), this._update(true);
          }
          getSky() {
            return this.style.getSky();
          }
          setFeatureState(e6, t5) {
            return this.style.setFeatureState(e6, t5), this._update();
          }
          removeFeatureState(e6, t5) {
            return this.style.removeFeatureState(e6, t5), this._update();
          }
          getFeatureState(e6) {
            return this.style.getFeatureState(e6);
          }
          getContainer() {
            return this._container;
          }
          getCanvasContainer() {
            return this._canvasContainer;
          }
          getCanvas() {
            return this._canvas;
          }
          _containerDimensions() {
            let e6 = 0, t5 = 0;
            return this._container && (e6 = this._container.clientWidth || 400, t5 = this._container.clientHeight || 300), [e6, t5];
          }
          _setupContainer() {
            const e6 = this._container;
            e6.classList.add("maplibregl-map");
            const t5 = this._canvasContainer = n5.create("div", "maplibregl-canvas-container", e6);
            this._interactive && t5.classList.add("maplibregl-interactive"), this._canvas = n5.create("canvas", "maplibregl-canvas", t5), this._canvas.addEventListener("webglcontextlost", this._contextLost, false), this._canvas.addEventListener("webglcontextrestored", this._contextRestored, false), this._canvas.setAttribute("tabindex", this._interactive ? "0" : "-1"), this._canvas.setAttribute("aria-label", this._getUIString("Map.Title")), this._canvas.setAttribute("role", "region");
            const i6 = this._containerDimensions(), r8 = this._getClampedPixelRatio(i6[0], i6[1]);
            this._resizeCanvas(i6[0], i6[1], r8);
            const o6 = this._controlContainer = n5.create("div", "maplibregl-control-container", e6), a4 = this._controlPositions = {};
            ["top-left", "top-right", "bottom-left", "bottom-right"].forEach((e7) => {
              a4[e7] = n5.create("div", `maplibregl-ctrl-${e7} `, o6);
            }), this._container.addEventListener("scroll", this._onMapScroll, false);
          }
          _resizeCanvas(e6, t5, i6) {
            this._canvas.width = Math.floor(i6 * e6), this._canvas.height = Math.floor(i6 * t5), this._canvas.style.width = `${e6}px`, this._canvas.style.height = `${t5}px`;
          }
          _setupPainter() {
            const e6 = Object.assign(Object.assign({}, this._canvasContextAttributes), { alpha: true, depth: true, stencil: true, premultipliedAlpha: true });
            let t5 = null;
            this._canvas.addEventListener("webglcontextcreationerror", (i7) => {
              t5 = { requestedAttributes: e6 }, i7 && (t5.statusMessage = i7.statusMessage, t5.type = i7.type);
            }, { once: true });
            let i6 = null;
            if (i6 = this._canvasContextAttributes.contextType ? this._canvas.getContext(this._canvasContextAttributes.contextType, e6) : this._canvas.getContext("webgl2", e6) || this._canvas.getContext("webgl", e6), !i6) {
              const e7 = "Failed to initialize WebGL";
              throw t5 ? (t5.message = e7, new Error(JSON.stringify(t5))) : new Error(e7);
            }
            this.painter = new bo(i6, this.transform), l4.testSupport(i6);
          }
          migrateProjection(e6, i6) {
            super.migrateProjection(e6, i6), this.painter.transform = e6, this.fire(new t4.l("projectiontransition", { newProjection: this.style.projection.name }));
          }
          loaded() {
            return !this._styleDirty && !this._sourcesDirty && !!this.style && this.style.loaded();
          }
          _update(e6) {
            return this.style && this.style._loaded ? (this._styleDirty = this._styleDirty || e6, this._sourcesDirty = true, this.triggerRepaint(), this) : this;
          }
          _requestRenderFrame(e6) {
            return this._update(), this._renderTaskQueue.add(e6);
          }
          _cancelRenderFrame(e6) {
            this._renderTaskQueue.remove(e6);
          }
          _render(e6) {
            var i6, r8, o6, a4, n6;
            const l5 = this._idleTriggered ? this._fadeDuration : 0, c5 = (null === (i6 = this.style.projection) || void 0 === i6 ? void 0 : i6.transitionState) > 0;
            if (this.painter.context.setDirty(), this.painter.setBaseState(), this._renderTaskQueue.run(e6), this._removed) return;
            let h4 = false;
            if (this.style && this._styleDirty) {
              this._styleDirty = false;
              const e7 = this.transform.zoom, i7 = s3.now();
              this.style.zoomHistory.update(e7, i7);
              const r9 = new t4.C(e7, { now: i7, fadeDuration: l5, zoomHistory: this.style.zoomHistory, transition: this.style.getTransition() }), o7 = r9.crossFadingFactor();
              1 === o7 && o7 === this._crossFadingFactor || (h4 = true, this._crossFadingFactor = o7), this.style.update(r9);
            }
            const u4 = (null === (r8 = this.style.projection) || void 0 === r8 ? void 0 : r8.transitionState) > 0 !== c5;
            null === (o6 = this.style.projection) || void 0 === o6 || o6.setErrorQueryLatitudeDegrees(this.transform.center.lat), this.transform.setTransitionState(null === (a4 = this.style.projection) || void 0 === a4 ? void 0 : a4.transitionState, null === (n6 = this.style.projection) || void 0 === n6 ? void 0 : n6.latitudeErrorCorrectionRadians), this.style && (this._sourcesDirty || u4) && (this._sourcesDirty = false, this.style._updateSources(this.transform)), this.terrain ? (this.terrain.sourceCache.update(this.transform, this.terrain), this.transform.setMinElevationForCurrentTile(this.terrain.getMinTileElevationForLngLatZoom(this.transform.center, this.transform.tileZoom)), !this._elevationFreeze && this._centerClampedToGround && this.transform.setElevation(this.terrain.getElevationForLngLatZoom(this.transform.center, this.transform.tileZoom))) : (this.transform.setMinElevationForCurrentTile(0), this._centerClampedToGround && this.transform.setElevation(0)), this._placementDirty = this.style && this.style._updatePlacement(this.transform, this.showCollisionBoxes, l5, this._crossSourceCollisions, u4), this.painter.render(this.style, { showTileBoundaries: this.showTileBoundaries, showOverdrawInspector: this._showOverdrawInspector, rotating: this.isRotating(), zooming: this.isZooming(), moving: this.isMoving(), fadeDuration: l5, showPadding: this.showPadding }), this.fire(new t4.l("render")), this.loaded() && !this._loaded && (this._loaded = true, t4.cj.mark(t4.ck.load), this.fire(new t4.l("load"))), this.style && (this.style.hasTransitions() || h4) && (this._styleDirty = true), this.style && !this._placementDirty && this.style._releaseSymbolFadeTiles();
            const d4 = this._sourcesDirty || this._styleDirty || this._placementDirty;
            return d4 || this._repaint ? this.triggerRepaint() : !this.isMoving() && this.loaded() && this.fire(new t4.l("idle")), !this._loaded || this._fullyLoaded || d4 || (this._fullyLoaded = true, t4.cj.mark(t4.ck.fullLoad)), this;
          }
          redraw() {
            return this.style && (this._frameRequest && (this._frameRequest.abort(), this._frameRequest = null), this._render(0)), this;
          }
          remove() {
            var e6;
            this._hash && this._hash.remove();
            for (const e7 of this._controls) e7.onRemove(this);
            this._controls = [], this._frameRequest && (this._frameRequest.abort(), this._frameRequest = null), this._renderTaskQueue.clear(), this.painter.destroy(), this.handlers.destroy(), delete this.handlers, this.setStyle(null), "undefined" != typeof window && removeEventListener("online", this._onWindowOnline, false), p3.removeThrottleControl(this._imageQueueHandle), null === (e6 = this._resizeObserver) || void 0 === e6 || e6.disconnect();
            const i6 = this.painter.context.gl.getExtension("WEBGL_lose_context");
            (null == i6 ? void 0 : i6.loseContext) && i6.loseContext(), this._canvas.removeEventListener("webglcontextrestored", this._contextRestored, false), this._canvas.removeEventListener("webglcontextlost", this._contextLost, false), n5.remove(this._canvasContainer), n5.remove(this._controlContainer), this._container.removeEventListener("scroll", this._onMapScroll, false), this._container.classList.remove("maplibregl-map"), t4.cj.clearMetrics(), this._removed = true, this.fire(new t4.l("remove"));
          }
          triggerRepaint() {
            this.style && !this._frameRequest && (this._frameRequest = new AbortController(), s3.frame(this._frameRequest, (e6) => {
              t4.cj.frame(e6), this._frameRequest = null;
              try {
                this._render(e6);
              } catch (e7) {
                if (!t4.cl(e7) && !function(e8) {
                  return e8.message === jr;
                }(e7)) throw e7;
              }
            }, () => {
            }));
          }
          get showTileBoundaries() {
            return !!this._showTileBoundaries;
          }
          set showTileBoundaries(e6) {
            this._showTileBoundaries !== e6 && (this._showTileBoundaries = e6, this._update());
          }
          get showPadding() {
            return !!this._showPadding;
          }
          set showPadding(e6) {
            this._showPadding !== e6 && (this._showPadding = e6, this._update());
          }
          get showCollisionBoxes() {
            return !!this._showCollisionBoxes;
          }
          set showCollisionBoxes(e6) {
            this._showCollisionBoxes !== e6 && (this._showCollisionBoxes = e6, e6 ? this.style._generateCollisionBoxes() : this._update());
          }
          get showOverdrawInspector() {
            return !!this._showOverdrawInspector;
          }
          set showOverdrawInspector(e6) {
            this._showOverdrawInspector !== e6 && (this._showOverdrawInspector = e6, this._update());
          }
          get repaint() {
            return !!this._repaint;
          }
          set repaint(e6) {
            this._repaint !== e6 && (this._repaint = e6, this.triggerRepaint());
          }
          get vertices() {
            return !!this._vertices;
          }
          set vertices(e6) {
            this._vertices = e6, this._update();
          }
          get version() {
            return za;
          }
          getCameraTargetElevation() {
            return this.transform.elevation;
          }
          getProjection() {
            return this.style.getProjection();
          }
          setProjection(e6) {
            return this._lazyInitEmptyStyle(), this.style.setProjection(e6), this._update(true);
          }
        }, e5.MapMouseEvent = zo, e5.MapTouchEvent = Ao, e5.MapWheelEvent = Lo, e5.Marker = Za, e5.NavigationControl = class {
          constructor(e6) {
            this._updateZoomButtons = () => {
              const e7 = this._map.getZoom(), t5 = e7 === this._map.getMaxZoom(), i6 = e7 === this._map.getMinZoom();
              this._zoomInButton.disabled = t5, this._zoomOutButton.disabled = i6, this._zoomInButton.setAttribute("aria-disabled", t5.toString()), this._zoomOutButton.setAttribute("aria-disabled", i6.toString());
            }, this._rotateCompassArrow = () => {
              this._compassIcon.style.transform = this.options.visualizePitch && this.options.visualizeRoll ? `scale(${1 / Math.pow(Math.cos(this._map.transform.pitchInRadians), 0.5)}) rotateZ(${-this._map.transform.roll}deg) rotateX(${this._map.transform.pitch}deg) rotateZ(${-this._map.transform.bearing}deg)` : this.options.visualizePitch ? `scale(${1 / Math.pow(Math.cos(this._map.transform.pitchInRadians), 0.5)}) rotateX(${this._map.transform.pitch}deg) rotateZ(${-this._map.transform.bearing}deg)` : this.options.visualizeRoll ? `rotate(${-this._map.transform.bearing - this._map.transform.roll}deg)` : `rotate(${-this._map.transform.bearing}deg)`;
            }, this._setButtonTitle = (e7, t5) => {
              const i6 = this._map._getUIString(`NavigationControl.${t5}`);
              e7.title = i6, e7.setAttribute("aria-label", i6);
            }, this.options = t4.e({}, La, e6), this._container = n5.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._container.addEventListener("contextmenu", (e7) => e7.preventDefault()), this.options.showZoom && (this._zoomInButton = this._createButton("maplibregl-ctrl-zoom-in", (e7) => this._map.zoomIn({}, { originalEvent: e7 })), n5.create("span", "maplibregl-ctrl-icon", this._zoomInButton).setAttribute("aria-hidden", "true"), this._zoomOutButton = this._createButton("maplibregl-ctrl-zoom-out", (e7) => this._map.zoomOut({}, { originalEvent: e7 })), n5.create("span", "maplibregl-ctrl-icon", this._zoomOutButton).setAttribute("aria-hidden", "true")), this.options.showCompass && (this._compass = this._createButton("maplibregl-ctrl-compass", (e7) => {
              this.options.visualizePitch ? this._map.resetNorthPitch({}, { originalEvent: e7 }) : this._map.resetNorth({}, { originalEvent: e7 });
            }), this._compassIcon = n5.create("span", "maplibregl-ctrl-icon", this._compass), this._compassIcon.setAttribute("aria-hidden", "true"));
          }
          onAdd(e6) {
            return this._map = e6, this.options.showZoom && (this._setButtonTitle(this._zoomInButton, "ZoomIn"), this._setButtonTitle(this._zoomOutButton, "ZoomOut"), this._map.on("zoom", this._updateZoomButtons), this._updateZoomButtons()), this.options.showCompass && (this._setButtonTitle(this._compass, "ResetBearing"), this.options.visualizePitch && this._map.on("pitch", this._rotateCompassArrow), this.options.visualizeRoll && this._map.on("roll", this._rotateCompassArrow), this._map.on("rotate", this._rotateCompassArrow), this._rotateCompassArrow(), this._handler = new ka(this._map, this._compass, this.options.visualizePitch)), this._container;
          }
          onRemove() {
            n5.remove(this._container), this.options.showZoom && this._map.off("zoom", this._updateZoomButtons), this.options.showCompass && (this.options.visualizePitch && this._map.off("pitch", this._rotateCompassArrow), this.options.visualizeRoll && this._map.off("roll", this._rotateCompassArrow), this._map.off("rotate", this._rotateCompassArrow), this._handler.off(), delete this._handler), delete this._map;
          }
          _createButton(e6, t5) {
            const i6 = n5.create("button", e6, this._container);
            return i6.type = "button", i6.addEventListener("click", t5), i6;
          }
        }, e5.Popup = class extends t4.E {
          constructor(e6) {
            super(), this._updateOpacity = () => {
              void 0 !== this.options.locationOccludedOpacity && (this._container.style.opacity = this._map.transform.isLocationOccluded(this.getLngLat()) ? `${this.options.locationOccludedOpacity}` : void 0);
            }, this.remove = () => (this._content && n5.remove(this._content), this._container && (n5.remove(this._container), delete this._container), this._closeButton && this._closeButton.removeEventListener("click", this._onClose), this._map && (this._map.off("move", this._update), this._map.off("move", this._onClose), this._map.off("click", this._onClose), this._map.off("remove", this.remove), this._map.off("mousemove", this._onMouseMove), this._map.off("mouseup", this._onMouseUp), this._map.off("drag", this._onDrag), this._map._canvasContainer.classList.remove("maplibregl-track-pointer"), delete this._map, this.fire(new t4.l("close"))), this), this._onMouseUp = (e7) => {
              this._update(e7.point);
            }, this._onMouseMove = (e7) => {
              this._update(e7.point);
            }, this._onDrag = (e7) => {
              this._update(e7.point);
            }, this._update = (e7) => {
              var t5;
              if (!this._map || !this._lngLat && !this._trackPointer || !this._content) return;
              if (!this._container) {
                if (this._container = n5.create("div", "maplibregl-popup", this._map.getContainer()), this._tip = n5.create("div", "maplibregl-popup-tip", this._container), this._container.appendChild(this._content), this.options.className) for (const e8 of this.options.className.split(" ")) this._container.classList.add(e8);
                this._closeButton && this._closeButton.setAttribute("aria-label", this._map._getUIString("Popup.Close")), this._trackPointer && this._container.classList.add("maplibregl-popup-track-pointer");
              }
              if (this.options.maxWidth && this._container.style.maxWidth !== this.options.maxWidth && (this._container.style.maxWidth = this.options.maxWidth), this._lngLat = this._map.transform.renderWorldCopies && !this._trackPointer ? Ba(this._lngLat, this._flatPos, this._map.transform) : null === (t5 = this._lngLat) || void 0 === t5 ? void 0 : t5.wrap(), this._trackPointer && !e7) return;
              const i6 = this._flatPos = this._pos = this._trackPointer && e7 ? e7 : this._map.project(this._lngLat);
              this._map.terrain && (this._flatPos = this._trackPointer && e7 ? e7 : this._map.transform.locationToScreenPoint(this._lngLat));
              let r8 = this.options.anchor;
              const o6 = Ka(this.options.offset);
              if (!r8) {
                const e8 = this._container.offsetWidth, t6 = this._container.offsetHeight;
                let a5;
                a5 = i6.y + o6.bottom.y < t6 ? ["top"] : i6.y > this._map.transform.height - t6 ? ["bottom"] : [], i6.x < e8 / 2 ? a5.push("left") : i6.x > this._map.transform.width - e8 / 2 && a5.push("right"), r8 = 0 === a5.length ? "bottom" : a5.join("-");
              }
              let a4 = i6.add(o6[r8]);
              this.options.subpixelPositioning || (a4 = a4.round()), n5.setTransform(this._container, `${Oa[r8]} translate(${a4.x}px,${a4.y}px)`), ja(this._container, r8, "popup"), this._updateOpacity();
            }, this._onClose = () => {
              this.remove();
            }, this.options = t4.e(Object.create($a), e6);
          }
          addTo(e6) {
            return this._map && this.remove(), this._map = e6, this.options.closeOnClick && this._map.on("click", this._onClose), this.options.closeOnMove && this._map.on("move", this._onClose), this._map.on("remove", this.remove), this._update(), this._focusFirstElement(), this._trackPointer ? (this._map.on("mousemove", this._onMouseMove), this._map.on("mouseup", this._onMouseUp), this._container && this._container.classList.add("maplibregl-popup-track-pointer"), this._map._canvasContainer.classList.add("maplibregl-track-pointer")) : this._map.on("move", this._update), this.fire(new t4.l("open")), this;
          }
          isOpen() {
            return !!this._map;
          }
          getLngLat() {
            return this._lngLat;
          }
          setLngLat(e6) {
            return this._lngLat = t4.Q.convert(e6), this._pos = null, this._flatPos = null, this._trackPointer = false, this._update(), this._map && (this._map.on("move", this._update), this._map.off("mousemove", this._onMouseMove), this._container && this._container.classList.remove("maplibregl-popup-track-pointer"), this._map._canvasContainer.classList.remove("maplibregl-track-pointer")), this;
          }
          trackPointer() {
            return this._trackPointer = true, this._pos = null, this._flatPos = null, this._update(), this._map && (this._map.off("move", this._update), this._map.on("mousemove", this._onMouseMove), this._map.on("drag", this._onDrag), this._container && this._container.classList.add("maplibregl-popup-track-pointer"), this._map._canvasContainer.classList.add("maplibregl-track-pointer")), this;
          }
          getElement() {
            return this._container;
          }
          setText(e6) {
            return this.setDOMContent(document.createTextNode(e6));
          }
          setHTML(e6) {
            const t5 = document.createDocumentFragment(), i6 = document.createElement("body");
            let r8;
            for (i6.innerHTML = e6; r8 = i6.firstChild, r8; ) t5.appendChild(r8);
            return this.setDOMContent(t5);
          }
          getMaxWidth() {
            var e6;
            return null === (e6 = this._container) || void 0 === e6 ? void 0 : e6.style.maxWidth;
          }
          setMaxWidth(e6) {
            return this.options.maxWidth = e6, this._update(), this;
          }
          setDOMContent(e6) {
            if (this._content) for (; this._content.hasChildNodes(); ) this._content.firstChild && this._content.removeChild(this._content.firstChild);
            else this._content = n5.create("div", "maplibregl-popup-content", this._container);
            return this._content.appendChild(e6), this._createCloseButton(), this._update(), this._focusFirstElement(), this;
          }
          addClassName(e6) {
            return this._container && this._container.classList.add(e6), this;
          }
          removeClassName(e6) {
            return this._container && this._container.classList.remove(e6), this;
          }
          setOffset(e6) {
            return this.options.offset = e6, this._update(), this;
          }
          toggleClassName(e6) {
            if (this._container) return this._container.classList.toggle(e6);
          }
          setSubpixelPositioning(e6) {
            this.options.subpixelPositioning = e6;
          }
          _createCloseButton() {
            this.options.closeButton && (this._closeButton = n5.create("button", "maplibregl-popup-close-button", this._content), this._closeButton.type = "button", this._closeButton.innerHTML = "&#215;", this._closeButton.addEventListener("click", this._onClose));
          }
          _focusFirstElement() {
            if (!this.options.focusAfterOpen || !this._container) return;
            const e6 = this._container.querySelector(Ha);
            e6 && e6.focus();
          }
        }, e5.RasterDEMTileSource = H4, e5.RasterTileSource = $2, e5.ScaleControl = class {
          constructor(e6) {
            this._onMove = () => {
              qa(this._map, this._container, this.options);
            }, this.setUnit = (e7) => {
              this.options.unit = e7, qa(this._map, this._container, this.options);
            }, this.options = Object.assign(Object.assign({}, Va), e6);
          }
          getDefaultPosition() {
            return "bottom-left";
          }
          onAdd(e6) {
            return this._map = e6, this._container = n5.create("div", "maplibregl-ctrl maplibregl-ctrl-scale", e6.getContainer()), this._map.on("move", this._onMove), this._onMove(), this._container;
          }
          onRemove() {
            n5.remove(this._container), this._map.off("move", this._onMove), this._map = void 0;
          }
        }, e5.ScrollZoomHandler = la, e5.Style = gi, e5.TerrainControl = class {
          constructor(e6) {
            this._toggleTerrain = () => {
              this._map.getTerrain() ? this._map.setTerrain(null) : this._map.setTerrain(this.options), this._updateTerrainIcon();
            }, this._updateTerrainIcon = () => {
              this._terrainButton.classList.remove("maplibregl-ctrl-terrain"), this._terrainButton.classList.remove("maplibregl-ctrl-terrain-enabled"), this._map.terrain ? (this._terrainButton.classList.add("maplibregl-ctrl-terrain-enabled"), this._terrainButton.title = this._map._getUIString("TerrainControl.Disable")) : (this._terrainButton.classList.add("maplibregl-ctrl-terrain"), this._terrainButton.title = this._map._getUIString("TerrainControl.Enable"));
            }, this.options = e6;
          }
          onAdd(e6) {
            return this._map = e6, this._container = n5.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._terrainButton = n5.create("button", "maplibregl-ctrl-terrain", this._container), n5.create("span", "maplibregl-ctrl-icon", this._terrainButton).setAttribute("aria-hidden", "true"), this._terrainButton.type = "button", this._terrainButton.addEventListener("click", this._toggleTerrain), this._updateTerrainIcon(), this._map.on("terrain", this._updateTerrainIcon), this._container;
          }
          onRemove() {
            n5.remove(this._container), this._map.off("terrain", this._updateTerrainIcon), this._map = void 0;
          }
        }, e5.TwoFingersTouchPitchHandler = ra, e5.TwoFingersTouchRotateHandler = ta, e5.TwoFingersTouchZoomHandler = Jo, e5.TwoFingersTouchZoomRotateHandler = pa, e5.VectorTileSource = W, e5.VideoSource = Q2, e5.addSourceType = (e6, i6) => t4._(void 0, void 0, void 0, function* () {
          if (ee(e6)) throw new Error(`A source type called "${e6}" already exists.`);
          ((e7, t5) => {
            J2[e7] = t5;
          })(e6, i6);
        }), e5.clearPrewarmedResources = function() {
          const e6 = L3;
          e6 && (e6.isPreloaded() && 1 === e6.numActive() ? (e6.release(D2), L3 = null) : console.warn("Could not clear WebWorkers since there are active Map instances that still reference it. The pre-warmed WebWorker pool can only be cleared when all map instances have been removed with map.remove()"));
        }, e5.createTileMesh = Wt, e5.getMaxParallelImageRequests = function() {
          return t4.a.MAX_PARALLEL_IMAGE_REQUESTS;
        }, e5.getRTLTextPluginStatus = function() {
          return oe().getRTLTextPluginStatus();
        }, e5.getVersion = function() {
          return Xa;
        }, e5.getWorkerCount = function() {
          return z3.workerCount;
        }, e5.getWorkerUrl = function() {
          return t4.a.WORKER_URL;
        }, e5.importScriptInWorkers = function(e6) {
          return O2().broadcast("IS", e6);
        }, e5.prewarm = function() {
          F2().acquire(D2);
        }, e5.setMaxParallelImageRequests = function(e6) {
          t4.a.MAX_PARALLEL_IMAGE_REQUESTS = e6;
        }, e5.setRTLTextPlugin = function(e6, t5) {
          return oe().setRTLTextPlugin(e6, t5);
        }, e5.setWorkerCount = function(e6) {
          z3.workerCount = e6;
        }, e5.setWorkerUrl = function(e6) {
          t4.a.WORKER_URL = e6;
        };
      });
      var maplibregl$1 = maplibregl2;
      return maplibregl$1;
    });
  }
});

// node_modules/@lit/reactive-element/css-tag.js
var t = globalThis;
var e = t.ShadowRoot && (void 0 === t.ShadyCSS || t.ShadyCSS.nativeShadow) && "adoptedStyleSheets" in Document.prototype && "replace" in CSSStyleSheet.prototype;
var s = Symbol();
var o = /* @__PURE__ */ new WeakMap();
var n = class {
  constructor(t4, e5, o5) {
    if (this._$cssResult$ = true, o5 !== s) throw Error("CSSResult is not constructable. Use `unsafeCSS` or `css` instead.");
    this.cssText = t4, this.t = e5;
  }
  get styleSheet() {
    let t4 = this.o;
    const s3 = this.t;
    if (e && void 0 === t4) {
      const e5 = void 0 !== s3 && 1 === s3.length;
      e5 && (t4 = o.get(s3)), void 0 === t4 && ((this.o = t4 = new CSSStyleSheet()).replaceSync(this.cssText), e5 && o.set(s3, t4));
    }
    return t4;
  }
  toString() {
    return this.cssText;
  }
};
var r = (t4) => new n("string" == typeof t4 ? t4 : t4 + "", void 0, s);
var i = (t4, ...e5) => {
  const o5 = 1 === t4.length ? t4[0] : e5.reduce((e6, s3, o6) => e6 + ((t5) => {
    if (true === t5._$cssResult$) return t5.cssText;
    if ("number" == typeof t5) return t5;
    throw Error("Value passed to 'css' function must be a 'css' function result: " + t5 + ". Use 'unsafeCSS' to pass non-literal values, but take care to ensure page security.");
  })(s3) + t4[o6 + 1], t4[0]);
  return new n(o5, t4, s);
};
var S = (s3, o5) => {
  if (e) s3.adoptedStyleSheets = o5.map((t4) => t4 instanceof CSSStyleSheet ? t4 : t4.styleSheet);
  else for (const e5 of o5) {
    const o6 = document.createElement("style"), n5 = t.litNonce;
    void 0 !== n5 && o6.setAttribute("nonce", n5), o6.textContent = e5.cssText, s3.appendChild(o6);
  }
};
var c = e ? (t4) => t4 : (t4) => t4 instanceof CSSStyleSheet ? ((t5) => {
  let e5 = "";
  for (const s3 of t5.cssRules) e5 += s3.cssText;
  return r(e5);
})(t4) : t4;

// node_modules/@lit/reactive-element/reactive-element.js
var { is: i2, defineProperty: e2, getOwnPropertyDescriptor: r2, getOwnPropertyNames: h, getOwnPropertySymbols: o2, getPrototypeOf: n2 } = Object;
var a = globalThis;
var c2 = a.trustedTypes;
var l = c2 ? c2.emptyScript : "";
var p = a.reactiveElementPolyfillSupport;
var d = (t4, s3) => t4;
var u = { toAttribute(t4, s3) {
  switch (s3) {
    case Boolean:
      t4 = t4 ? l : null;
      break;
    case Object:
    case Array:
      t4 = null == t4 ? t4 : JSON.stringify(t4);
  }
  return t4;
}, fromAttribute(t4, s3) {
  let i5 = t4;
  switch (s3) {
    case Boolean:
      i5 = null !== t4;
      break;
    case Number:
      i5 = null === t4 ? null : Number(t4);
      break;
    case Object:
    case Array:
      try {
        i5 = JSON.parse(t4);
      } catch (t5) {
        i5 = null;
      }
  }
  return i5;
} };
var f = (t4, s3) => !i2(t4, s3);
var y = { attribute: true, type: String, converter: u, reflect: false, hasChanged: f };
Symbol.metadata ?? (Symbol.metadata = Symbol("metadata")), a.litPropertyMetadata ?? (a.litPropertyMetadata = /* @__PURE__ */ new WeakMap());
var b = class extends HTMLElement {
  static addInitializer(t4) {
    this._$Ei(), (this.l ?? (this.l = [])).push(t4);
  }
  static get observedAttributes() {
    return this.finalize(), this._$Eh && [...this._$Eh.keys()];
  }
  static createProperty(t4, s3 = y) {
    if (s3.state && (s3.attribute = false), this._$Ei(), this.elementProperties.set(t4, s3), !s3.noAccessor) {
      const i5 = Symbol(), r7 = this.getPropertyDescriptor(t4, i5, s3);
      void 0 !== r7 && e2(this.prototype, t4, r7);
    }
  }
  static getPropertyDescriptor(t4, s3, i5) {
    const { get: e5, set: h3 } = r2(this.prototype, t4) ?? { get() {
      return this[s3];
    }, set(t5) {
      this[s3] = t5;
    } };
    return { get() {
      return e5?.call(this);
    }, set(s4) {
      const r7 = e5?.call(this);
      h3.call(this, s4), this.requestUpdate(t4, r7, i5);
    }, configurable: true, enumerable: true };
  }
  static getPropertyOptions(t4) {
    return this.elementProperties.get(t4) ?? y;
  }
  static _$Ei() {
    if (this.hasOwnProperty(d("elementProperties"))) return;
    const t4 = n2(this);
    t4.finalize(), void 0 !== t4.l && (this.l = [...t4.l]), this.elementProperties = new Map(t4.elementProperties);
  }
  static finalize() {
    if (this.hasOwnProperty(d("finalized"))) return;
    if (this.finalized = true, this._$Ei(), this.hasOwnProperty(d("properties"))) {
      const t5 = this.properties, s3 = [...h(t5), ...o2(t5)];
      for (const i5 of s3) this.createProperty(i5, t5[i5]);
    }
    const t4 = this[Symbol.metadata];
    if (null !== t4) {
      const s3 = litPropertyMetadata.get(t4);
      if (void 0 !== s3) for (const [t5, i5] of s3) this.elementProperties.set(t5, i5);
    }
    this._$Eh = /* @__PURE__ */ new Map();
    for (const [t5, s3] of this.elementProperties) {
      const i5 = this._$Eu(t5, s3);
      void 0 !== i5 && this._$Eh.set(i5, t5);
    }
    this.elementStyles = this.finalizeStyles(this.styles);
  }
  static finalizeStyles(s3) {
    const i5 = [];
    if (Array.isArray(s3)) {
      const e5 = new Set(s3.flat(1 / 0).reverse());
      for (const s4 of e5) i5.unshift(c(s4));
    } else void 0 !== s3 && i5.push(c(s3));
    return i5;
  }
  static _$Eu(t4, s3) {
    const i5 = s3.attribute;
    return false === i5 ? void 0 : "string" == typeof i5 ? i5 : "string" == typeof t4 ? t4.toLowerCase() : void 0;
  }
  constructor() {
    super(), this._$Ep = void 0, this.isUpdatePending = false, this.hasUpdated = false, this._$Em = null, this._$Ev();
  }
  _$Ev() {
    this._$ES = new Promise((t4) => this.enableUpdating = t4), this._$AL = /* @__PURE__ */ new Map(), this._$E_(), this.requestUpdate(), this.constructor.l?.forEach((t4) => t4(this));
  }
  addController(t4) {
    (this._$EO ?? (this._$EO = /* @__PURE__ */ new Set())).add(t4), void 0 !== this.renderRoot && this.isConnected && t4.hostConnected?.();
  }
  removeController(t4) {
    this._$EO?.delete(t4);
  }
  _$E_() {
    const t4 = /* @__PURE__ */ new Map(), s3 = this.constructor.elementProperties;
    for (const i5 of s3.keys()) this.hasOwnProperty(i5) && (t4.set(i5, this[i5]), delete this[i5]);
    t4.size > 0 && (this._$Ep = t4);
  }
  createRenderRoot() {
    const t4 = this.shadowRoot ?? this.attachShadow(this.constructor.shadowRootOptions);
    return S(t4, this.constructor.elementStyles), t4;
  }
  connectedCallback() {
    this.renderRoot ?? (this.renderRoot = this.createRenderRoot()), this.enableUpdating(true), this._$EO?.forEach((t4) => t4.hostConnected?.());
  }
  enableUpdating(t4) {
  }
  disconnectedCallback() {
    this._$EO?.forEach((t4) => t4.hostDisconnected?.());
  }
  attributeChangedCallback(t4, s3, i5) {
    this._$AK(t4, i5);
  }
  _$EC(t4, s3) {
    const i5 = this.constructor.elementProperties.get(t4), e5 = this.constructor._$Eu(t4, i5);
    if (void 0 !== e5 && true === i5.reflect) {
      const r7 = (void 0 !== i5.converter?.toAttribute ? i5.converter : u).toAttribute(s3, i5.type);
      this._$Em = t4, null == r7 ? this.removeAttribute(e5) : this.setAttribute(e5, r7), this._$Em = null;
    }
  }
  _$AK(t4, s3) {
    const i5 = this.constructor, e5 = i5._$Eh.get(t4);
    if (void 0 !== e5 && this._$Em !== e5) {
      const t5 = i5.getPropertyOptions(e5), r7 = "function" == typeof t5.converter ? { fromAttribute: t5.converter } : void 0 !== t5.converter?.fromAttribute ? t5.converter : u;
      this._$Em = e5, this[e5] = r7.fromAttribute(s3, t5.type), this._$Em = null;
    }
  }
  requestUpdate(t4, s3, i5) {
    if (void 0 !== t4) {
      if (i5 ?? (i5 = this.constructor.getPropertyOptions(t4)), !(i5.hasChanged ?? f)(this[t4], s3)) return;
      this.P(t4, s3, i5);
    }
    false === this.isUpdatePending && (this._$ES = this._$ET());
  }
  P(t4, s3, i5) {
    this._$AL.has(t4) || this._$AL.set(t4, s3), true === i5.reflect && this._$Em !== t4 && (this._$Ej ?? (this._$Ej = /* @__PURE__ */ new Set())).add(t4);
  }
  async _$ET() {
    this.isUpdatePending = true;
    try {
      await this._$ES;
    } catch (t5) {
      Promise.reject(t5);
    }
    const t4 = this.scheduleUpdate();
    return null != t4 && await t4, !this.isUpdatePending;
  }
  scheduleUpdate() {
    return this.performUpdate();
  }
  performUpdate() {
    if (!this.isUpdatePending) return;
    if (!this.hasUpdated) {
      if (this.renderRoot ?? (this.renderRoot = this.createRenderRoot()), this._$Ep) {
        for (const [t6, s4] of this._$Ep) this[t6] = s4;
        this._$Ep = void 0;
      }
      const t5 = this.constructor.elementProperties;
      if (t5.size > 0) for (const [s4, i5] of t5) true !== i5.wrapped || this._$AL.has(s4) || void 0 === this[s4] || this.P(s4, this[s4], i5);
    }
    let t4 = false;
    const s3 = this._$AL;
    try {
      t4 = this.shouldUpdate(s3), t4 ? (this.willUpdate(s3), this._$EO?.forEach((t5) => t5.hostUpdate?.()), this.update(s3)) : this._$EU();
    } catch (s4) {
      throw t4 = false, this._$EU(), s4;
    }
    t4 && this._$AE(s3);
  }
  willUpdate(t4) {
  }
  _$AE(t4) {
    this._$EO?.forEach((t5) => t5.hostUpdated?.()), this.hasUpdated || (this.hasUpdated = true, this.firstUpdated(t4)), this.updated(t4);
  }
  _$EU() {
    this._$AL = /* @__PURE__ */ new Map(), this.isUpdatePending = false;
  }
  get updateComplete() {
    return this.getUpdateComplete();
  }
  getUpdateComplete() {
    return this._$ES;
  }
  shouldUpdate(t4) {
    return true;
  }
  update(t4) {
    this._$Ej && (this._$Ej = this._$Ej.forEach((t5) => this._$EC(t5, this[t5]))), this._$EU();
  }
  updated(t4) {
  }
  firstUpdated(t4) {
  }
};
b.elementStyles = [], b.shadowRootOptions = { mode: "open" }, b[d("elementProperties")] = /* @__PURE__ */ new Map(), b[d("finalized")] = /* @__PURE__ */ new Map(), p?.({ ReactiveElement: b }), (a.reactiveElementVersions ?? (a.reactiveElementVersions = [])).push("2.0.4");

// node_modules/lit-html/lit-html.js
var t2 = globalThis;
var i3 = t2.trustedTypes;
var s2 = i3 ? i3.createPolicy("lit-html", { createHTML: (t4) => t4 }) : void 0;
var e3 = "$lit$";
var h2 = `lit$${Math.random().toFixed(9).slice(2)}$`;
var o3 = "?" + h2;
var n3 = `<${o3}>`;
var r3 = document;
var l2 = () => r3.createComment("");
var c3 = (t4) => null === t4 || "object" != typeof t4 && "function" != typeof t4;
var a2 = Array.isArray;
var u2 = (t4) => a2(t4) || "function" == typeof t4?.[Symbol.iterator];
var d2 = "[ 	\n\f\r]";
var f2 = /<(?:(!--|\/[^a-zA-Z])|(\/?[a-zA-Z][^>\s]*)|(\/?$))/g;
var v = /-->/g;
var _ = />/g;
var m = RegExp(`>|${d2}(?:([^\\s"'>=/]+)(${d2}*=${d2}*(?:[^ 	
\f\r"'\`<>=]|("|')|))|$)`, "g");
var p2 = /'/g;
var g = /"/g;
var $ = /^(?:script|style|textarea|title)$/i;
var y2 = (t4) => (i5, ...s3) => ({ _$litType$: t4, strings: i5, values: s3 });
var x = y2(1);
var b2 = y2(2);
var w = y2(3);
var T = Symbol.for("lit-noChange");
var E = Symbol.for("lit-nothing");
var A = /* @__PURE__ */ new WeakMap();
var C = r3.createTreeWalker(r3, 129);
function P(t4, i5) {
  if (!a2(t4) || !t4.hasOwnProperty("raw")) throw Error("invalid template strings array");
  return void 0 !== s2 ? s2.createHTML(i5) : i5;
}
var V = (t4, i5) => {
  const s3 = t4.length - 1, o5 = [];
  let r7, l4 = 2 === i5 ? "<svg>" : 3 === i5 ? "<math>" : "", c4 = f2;
  for (let i6 = 0; i6 < s3; i6++) {
    const s4 = t4[i6];
    let a3, u3, d3 = -1, y3 = 0;
    for (; y3 < s4.length && (c4.lastIndex = y3, u3 = c4.exec(s4), null !== u3); ) y3 = c4.lastIndex, c4 === f2 ? "!--" === u3[1] ? c4 = v : void 0 !== u3[1] ? c4 = _ : void 0 !== u3[2] ? ($.test(u3[2]) && (r7 = RegExp("</" + u3[2], "g")), c4 = m) : void 0 !== u3[3] && (c4 = m) : c4 === m ? ">" === u3[0] ? (c4 = r7 ?? f2, d3 = -1) : void 0 === u3[1] ? d3 = -2 : (d3 = c4.lastIndex - u3[2].length, a3 = u3[1], c4 = void 0 === u3[3] ? m : '"' === u3[3] ? g : p2) : c4 === g || c4 === p2 ? c4 = m : c4 === v || c4 === _ ? c4 = f2 : (c4 = m, r7 = void 0);
    const x3 = c4 === m && t4[i6 + 1].startsWith("/>") ? " " : "";
    l4 += c4 === f2 ? s4 + n3 : d3 >= 0 ? (o5.push(a3), s4.slice(0, d3) + e3 + s4.slice(d3) + h2 + x3) : s4 + h2 + (-2 === d3 ? i6 : x3);
  }
  return [P(t4, l4 + (t4[s3] || "<?>") + (2 === i5 ? "</svg>" : 3 === i5 ? "</math>" : "")), o5];
};
var N = class _N {
  constructor({ strings: t4, _$litType$: s3 }, n5) {
    let r7;
    this.parts = [];
    let c4 = 0, a3 = 0;
    const u3 = t4.length - 1, d3 = this.parts, [f3, v3] = V(t4, s3);
    if (this.el = _N.createElement(f3, n5), C.currentNode = this.el.content, 2 === s3 || 3 === s3) {
      const t5 = this.el.content.firstChild;
      t5.replaceWith(...t5.childNodes);
    }
    for (; null !== (r7 = C.nextNode()) && d3.length < u3; ) {
      if (1 === r7.nodeType) {
        if (r7.hasAttributes()) for (const t5 of r7.getAttributeNames()) if (t5.endsWith(e3)) {
          const i5 = v3[a3++], s4 = r7.getAttribute(t5).split(h2), e5 = /([.?@])?(.*)/.exec(i5);
          d3.push({ type: 1, index: c4, name: e5[2], strings: s4, ctor: "." === e5[1] ? H : "?" === e5[1] ? I : "@" === e5[1] ? L2 : k }), r7.removeAttribute(t5);
        } else t5.startsWith(h2) && (d3.push({ type: 6, index: c4 }), r7.removeAttribute(t5));
        if ($.test(r7.tagName)) {
          const t5 = r7.textContent.split(h2), s4 = t5.length - 1;
          if (s4 > 0) {
            r7.textContent = i3 ? i3.emptyScript : "";
            for (let i5 = 0; i5 < s4; i5++) r7.append(t5[i5], l2()), C.nextNode(), d3.push({ type: 2, index: ++c4 });
            r7.append(t5[s4], l2());
          }
        }
      } else if (8 === r7.nodeType) if (r7.data === o3) d3.push({ type: 2, index: c4 });
      else {
        let t5 = -1;
        for (; -1 !== (t5 = r7.data.indexOf(h2, t5 + 1)); ) d3.push({ type: 7, index: c4 }), t5 += h2.length - 1;
      }
      c4++;
    }
  }
  static createElement(t4, i5) {
    const s3 = r3.createElement("template");
    return s3.innerHTML = t4, s3;
  }
};
function S2(t4, i5, s3 = t4, e5) {
  if (i5 === T) return i5;
  let h3 = void 0 !== e5 ? s3._$Co?.[e5] : s3._$Cl;
  const o5 = c3(i5) ? void 0 : i5._$litDirective$;
  return h3?.constructor !== o5 && (h3?._$AO?.(false), void 0 === o5 ? h3 = void 0 : (h3 = new o5(t4), h3._$AT(t4, s3, e5)), void 0 !== e5 ? (s3._$Co ?? (s3._$Co = []))[e5] = h3 : s3._$Cl = h3), void 0 !== h3 && (i5 = S2(t4, h3._$AS(t4, i5.values), h3, e5)), i5;
}
var M = class {
  constructor(t4, i5) {
    this._$AV = [], this._$AN = void 0, this._$AD = t4, this._$AM = i5;
  }
  get parentNode() {
    return this._$AM.parentNode;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  u(t4) {
    const { el: { content: i5 }, parts: s3 } = this._$AD, e5 = (t4?.creationScope ?? r3).importNode(i5, true);
    C.currentNode = e5;
    let h3 = C.nextNode(), o5 = 0, n5 = 0, l4 = s3[0];
    for (; void 0 !== l4; ) {
      if (o5 === l4.index) {
        let i6;
        2 === l4.type ? i6 = new R(h3, h3.nextSibling, this, t4) : 1 === l4.type ? i6 = new l4.ctor(h3, l4.name, l4.strings, this, t4) : 6 === l4.type && (i6 = new z(h3, this, t4)), this._$AV.push(i6), l4 = s3[++n5];
      }
      o5 !== l4?.index && (h3 = C.nextNode(), o5++);
    }
    return C.currentNode = r3, e5;
  }
  p(t4) {
    let i5 = 0;
    for (const s3 of this._$AV) void 0 !== s3 && (void 0 !== s3.strings ? (s3._$AI(t4, s3, i5), i5 += s3.strings.length - 2) : s3._$AI(t4[i5])), i5++;
  }
};
var R = class _R {
  get _$AU() {
    return this._$AM?._$AU ?? this._$Cv;
  }
  constructor(t4, i5, s3, e5) {
    this.type = 2, this._$AH = E, this._$AN = void 0, this._$AA = t4, this._$AB = i5, this._$AM = s3, this.options = e5, this._$Cv = e5?.isConnected ?? true;
  }
  get parentNode() {
    let t4 = this._$AA.parentNode;
    const i5 = this._$AM;
    return void 0 !== i5 && 11 === t4?.nodeType && (t4 = i5.parentNode), t4;
  }
  get startNode() {
    return this._$AA;
  }
  get endNode() {
    return this._$AB;
  }
  _$AI(t4, i5 = this) {
    t4 = S2(this, t4, i5), c3(t4) ? t4 === E || null == t4 || "" === t4 ? (this._$AH !== E && this._$AR(), this._$AH = E) : t4 !== this._$AH && t4 !== T && this._(t4) : void 0 !== t4._$litType$ ? this.$(t4) : void 0 !== t4.nodeType ? this.T(t4) : u2(t4) ? this.k(t4) : this._(t4);
  }
  O(t4) {
    return this._$AA.parentNode.insertBefore(t4, this._$AB);
  }
  T(t4) {
    this._$AH !== t4 && (this._$AR(), this._$AH = this.O(t4));
  }
  _(t4) {
    this._$AH !== E && c3(this._$AH) ? this._$AA.nextSibling.data = t4 : this.T(r3.createTextNode(t4)), this._$AH = t4;
  }
  $(t4) {
    const { values: i5, _$litType$: s3 } = t4, e5 = "number" == typeof s3 ? this._$AC(t4) : (void 0 === s3.el && (s3.el = N.createElement(P(s3.h, s3.h[0]), this.options)), s3);
    if (this._$AH?._$AD === e5) this._$AH.p(i5);
    else {
      const t5 = new M(e5, this), s4 = t5.u(this.options);
      t5.p(i5), this.T(s4), this._$AH = t5;
    }
  }
  _$AC(t4) {
    let i5 = A.get(t4.strings);
    return void 0 === i5 && A.set(t4.strings, i5 = new N(t4)), i5;
  }
  k(t4) {
    a2(this._$AH) || (this._$AH = [], this._$AR());
    const i5 = this._$AH;
    let s3, e5 = 0;
    for (const h3 of t4) e5 === i5.length ? i5.push(s3 = new _R(this.O(l2()), this.O(l2()), this, this.options)) : s3 = i5[e5], s3._$AI(h3), e5++;
    e5 < i5.length && (this._$AR(s3 && s3._$AB.nextSibling, e5), i5.length = e5);
  }
  _$AR(t4 = this._$AA.nextSibling, i5) {
    for (this._$AP?.(false, true, i5); t4 && t4 !== this._$AB; ) {
      const i6 = t4.nextSibling;
      t4.remove(), t4 = i6;
    }
  }
  setConnected(t4) {
    void 0 === this._$AM && (this._$Cv = t4, this._$AP?.(t4));
  }
};
var k = class {
  get tagName() {
    return this.element.tagName;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  constructor(t4, i5, s3, e5, h3) {
    this.type = 1, this._$AH = E, this._$AN = void 0, this.element = t4, this.name = i5, this._$AM = e5, this.options = h3, s3.length > 2 || "" !== s3[0] || "" !== s3[1] ? (this._$AH = Array(s3.length - 1).fill(new String()), this.strings = s3) : this._$AH = E;
  }
  _$AI(t4, i5 = this, s3, e5) {
    const h3 = this.strings;
    let o5 = false;
    if (void 0 === h3) t4 = S2(this, t4, i5, 0), o5 = !c3(t4) || t4 !== this._$AH && t4 !== T, o5 && (this._$AH = t4);
    else {
      const e6 = t4;
      let n5, r7;
      for (t4 = h3[0], n5 = 0; n5 < h3.length - 1; n5++) r7 = S2(this, e6[s3 + n5], i5, n5), r7 === T && (r7 = this._$AH[n5]), o5 || (o5 = !c3(r7) || r7 !== this._$AH[n5]), r7 === E ? t4 = E : t4 !== E && (t4 += (r7 ?? "") + h3[n5 + 1]), this._$AH[n5] = r7;
    }
    o5 && !e5 && this.j(t4);
  }
  j(t4) {
    t4 === E ? this.element.removeAttribute(this.name) : this.element.setAttribute(this.name, t4 ?? "");
  }
};
var H = class extends k {
  constructor() {
    super(...arguments), this.type = 3;
  }
  j(t4) {
    this.element[this.name] = t4 === E ? void 0 : t4;
  }
};
var I = class extends k {
  constructor() {
    super(...arguments), this.type = 4;
  }
  j(t4) {
    this.element.toggleAttribute(this.name, !!t4 && t4 !== E);
  }
};
var L2 = class extends k {
  constructor(t4, i5, s3, e5, h3) {
    super(t4, i5, s3, e5, h3), this.type = 5;
  }
  _$AI(t4, i5 = this) {
    if ((t4 = S2(this, t4, i5, 0) ?? E) === T) return;
    const s3 = this._$AH, e5 = t4 === E && s3 !== E || t4.capture !== s3.capture || t4.once !== s3.once || t4.passive !== s3.passive, h3 = t4 !== E && (s3 === E || e5);
    e5 && this.element.removeEventListener(this.name, this, s3), h3 && this.element.addEventListener(this.name, this, t4), this._$AH = t4;
  }
  handleEvent(t4) {
    "function" == typeof this._$AH ? this._$AH.call(this.options?.host ?? this.element, t4) : this._$AH.handleEvent(t4);
  }
};
var z = class {
  constructor(t4, i5, s3) {
    this.element = t4, this.type = 6, this._$AN = void 0, this._$AM = i5, this.options = s3;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  _$AI(t4) {
    S2(this, t4);
  }
};
var j = t2.litHtmlPolyfillSupport;
j?.(N, R), (t2.litHtmlVersions ?? (t2.litHtmlVersions = [])).push("3.2.1");
var B = (t4, i5, s3) => {
  const e5 = s3?.renderBefore ?? i5;
  let h3 = e5._$litPart$;
  if (void 0 === h3) {
    const t5 = s3?.renderBefore ?? null;
    e5._$litPart$ = h3 = new R(i5.insertBefore(l2(), t5), t5, void 0, s3 ?? {});
  }
  return h3._$AI(t4), h3;
};

// node_modules/lit-element/lit-element.js
var r4 = class extends b {
  constructor() {
    super(...arguments), this.renderOptions = { host: this }, this._$Do = void 0;
  }
  createRenderRoot() {
    var _a6;
    const t4 = super.createRenderRoot();
    return (_a6 = this.renderOptions).renderBefore ?? (_a6.renderBefore = t4.firstChild), t4;
  }
  update(t4) {
    const s3 = this.render();
    this.hasUpdated || (this.renderOptions.isConnected = this.isConnected), super.update(t4), this._$Do = B(s3, this.renderRoot, this.renderOptions);
  }
  connectedCallback() {
    super.connectedCallback(), this._$Do?.setConnected(true);
  }
  disconnectedCallback() {
    super.disconnectedCallback(), this._$Do?.setConnected(false);
  }
  render() {
    return T;
  }
};
r4._$litElement$ = true, r4["finalized"] = true, globalThis.litElementHydrateSupport?.({ LitElement: r4 });
var i4 = globalThis.litElementPolyfillSupport;
i4?.({ LitElement: r4 });
(globalThis.litElementVersions ?? (globalThis.litElementVersions = [])).push("4.1.1");

// node_modules/@lit/reactive-element/decorators/custom-element.js
var t3 = (t4) => (e5, o5) => {
  void 0 !== o5 ? o5.addInitializer(() => {
    customElements.define(t4, e5);
  }) : customElements.define(t4, e5);
};

// node_modules/@lit/reactive-element/decorators/property.js
var o4 = { attribute: true, type: String, converter: u, reflect: false, hasChanged: f };
var r5 = (t4 = o4, e5, r7) => {
  const { kind: n5, metadata: i5 } = r7;
  let s3 = globalThis.litPropertyMetadata.get(i5);
  if (void 0 === s3 && globalThis.litPropertyMetadata.set(i5, s3 = /* @__PURE__ */ new Map()), s3.set(r7.name, t4), "accessor" === n5) {
    const { name: o5 } = r7;
    return { set(r8) {
      const n6 = e5.get.call(this);
      e5.set.call(this, r8), this.requestUpdate(o5, n6, t4);
    }, init(e6) {
      return void 0 !== e6 && this.P(o5, void 0, t4), e6;
    } };
  }
  if ("setter" === n5) {
    const { name: o5 } = r7;
    return function(r8) {
      const n6 = this[o5];
      e5.call(this, r8), this.requestUpdate(o5, n6, t4);
    };
  }
  throw Error("Unsupported decorator location: " + n5);
};
function n4(t4) {
  return (e5, o5) => "object" == typeof o5 ? r5(t4, e5, o5) : ((t5, e6, o6) => {
    const r7 = e6.hasOwnProperty(o6);
    return e6.constructor.createProperty(o6, r7 ? { ...t5, wrapped: true } : t5), r7 ? Object.getOwnPropertyDescriptor(e6, o6) : void 0;
  })(t4, e5, o5);
}

// node_modules/@lit/reactive-element/decorators/state.js
function r6(r7) {
  return n4({ ...r7, state: true, attribute: false });
}

// src/data-loader.ts
async function loadSiteData() {
  const response = await fetch("locatedsitesTS_any.csv");
  const text = await response.text();
  const lines = text.split("\n");
  const headers = lines[0].split(",");
  const ceramicColumns = [
    "TS_any",
    "TS_early",
    "TS_late",
    "TSH",
    "TSHT",
    "TSHTB",
    "TSHTM",
    "TSG",
    "DSP",
    "ARSA",
    "ARSC",
    "ARSD",
    "ARS_325",
    "ARS_400",
    "ARS_450",
    "ARS_525",
    "ARS_600",
    "LRC",
    "LRD",
    "PRCW"
  ];
  const sites = [];
  for (let i5 = 1; i5 < lines.length; i5++) {
    if (!lines[i5].trim()) continue;
    const values = lines[i5].split(",");
    const id = values[0];
    const name = values[1];
    const siteType = values[3];
    const analysisType = values[4];
    const latitude = parseFloat(values[values.length - 2]);
    const longitude = parseFloat(values[values.length - 1]);
    if (isNaN(latitude) || isNaN(longitude)) continue;
    const ceramics = {};
    const periods = [];
    for (const ceramic of ceramicColumns) {
      const index = headers.indexOf(ceramic);
      if (index !== -1) {
        ceramics[ceramic] = parseInt(values[index]) || 0;
      }
    }
    if (ceramics["TS_early"] === 1) periods.push("early-roman");
    if (ceramics["TS_late"] === 1) periods.push("late-roman");
    if (ceramics["ARS_450"] === 1 || ceramics["ARS_525"] === 1 || ceramics["ARS_600"] === 1)
      periods.push("post-roman");
    sites.push({
      id,
      name,
      siteType,
      analysisType,
      location: [longitude, latitude],
      ceramics,
      periods
    });
  }
  return sites;
}
function sitesToGeoJSON(sites, period) {
  const features = sites.filter((site) => !period || site.periods.includes(period)).map((site) => ({
    type: "Feature",
    properties: {
      id: site.id,
      name: site.name,
      siteType: site.siteType,
      analysisType: site.analysisType,
      ...site.ceramics
    },
    geometry: {
      type: "Point",
      coordinates: site.location
    }
  }));
  return {
    type: "FeatureCollection",
    features
  };
}

// src/time-slider.ts
var TIME_PERIODS = [
  { id: "all", label: "\u6240\u6709\u65F6\u671F" },
  { id: "early-roman", label: "\u65E9\u671F\u7F57\u9A6C (1-3\u4E16\u7EAA)" },
  { id: "late-roman", label: "\u665A\u671F\u7F57\u9A6C (4-5\u4E16\u7EAA)" },
  { id: "post-roman", label: "\u540E\u7F57\u9A6C (5-7\u4E16\u7EAA)" }
];
var _selected_dec, _a, _TimeSlider_decorators, _init;
_TimeSlider_decorators = [t3("time-slider")];
var TimeSlider = class extends (_a = r4, _selected_dec = [n4({ type: String })], _a) {
  constructor() {
    super(...arguments);
    __publicField(this, "selected", __runInitializers(_init, 8, this, "all")), __runInitializers(_init, 11, this);
  }
  render() {
    return x`
      <div class="slider-container">
        <div class="time-labels">
          ${TIME_PERIODS.map((period) => x`
            <div 
              class="time-label ${period.id === this.selected ? "selected" : ""}"
              @click=${() => this.handlePeriodClick(period.id)}
            >
              ${period.label}
            </div>
          `)}
        </div>
      </div>
    `;
  }
  handlePeriodClick(periodId) {
    this.selected = periodId;
    this.dispatchEvent(new CustomEvent("period-change", {
      detail: { period: periodId },
      bubbles: true,
      composed: true
    }));
  }
};
_init = __decoratorStart(_a);
__decorateElement(_init, 5, "selected", _selected_dec, TimeSlider);
TimeSlider = __decorateElement(_init, 0, "TimeSlider", _TimeSlider_decorators, TimeSlider);
__publicField(TimeSlider, "styles", i`
    :host {
      display: block;
      width: 100%;
      padding: 1rem;
      background: white;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    
    .slider-container {
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
    }
    
    .time-labels {
      display: flex;
      justify-content: space-between;
    }
    
    .time-label {
      flex: 1;
      text-align: center;
      cursor: pointer;
      padding: 0.25rem;
      border-radius: 4px;
    }
    
    .time-label.selected {
      background: #0078ff;
      color: white;
    }
  `);
__runInitializers(_init, 1, TimeSlider);

// src/ceramic-filter.ts
var CERAMIC_TYPES = [
  { id: "all", label: "\u6240\u6709\u7C7B\u578B" },
  { id: "TSH", label: "\u897F\u73ED\u7259\u4EA7\u8D64\u9676 (TSH)" },
  { id: "TSHT", label: "\u665A\u671F\u897F\u73ED\u7259\u8D64\u9676 (TSHT)" },
  { id: "TSG", label: "\u9AD8\u5362\u4EA7\u8D64\u9676 (TSG)" },
  { id: "ARS", label: "\u975E\u6D32\u4EA7\u8D64\u9676 (ARS)" },
  { id: "LRC", label: "\u4E1C\u65B9\u4EA7\u8D64\u9676 (LRC/LRD)" },
  { id: "PRCW", label: "\u665A\u671F\u5F69\u7ED8\u9676\u5668 (PRCW)" }
];
var _selected_dec2, _a2, _CeramicFilter_decorators, _init2;
_CeramicFilter_decorators = [t3("ceramic-filter")];
var CeramicFilter = class extends (_a2 = r4, _selected_dec2 = [n4({ type: String })], _a2) {
  constructor() {
    super(...arguments);
    __publicField(this, "selected", __runInitializers(_init2, 8, this, "all")), __runInitializers(_init2, 11, this);
  }
  render() {
    return x`
      <div class="filter-container">
        <div class="filter-title">陶瓷类型筛选</div>
        
        ${CERAMIC_TYPES.map((type) => x`
          <label class="ceramic-option">
            <input 
              type="radio" 
              name="ceramic-type" 
              value=${type.id} 
              ?checked=${this.selected === type.id}
              @change=${() => this.handleTypeChange(type.id)}
            />
            ${type.label}
          </label>
        `)}
      </div>
    `;
  }
  handleTypeChange(typeId) {
    this.selected = typeId;
    this.dispatchEvent(new CustomEvent("ceramic-filter-change", {
      detail: { type: typeId },
      bubbles: true,
      composed: true
    }));
  }
};
_init2 = __decoratorStart(_a2);
__decorateElement(_init2, 5, "selected", _selected_dec2, CeramicFilter);
CeramicFilter = __decorateElement(_init2, 0, "CeramicFilter", _CeramicFilter_decorators, CeramicFilter);
__publicField(CeramicFilter, "styles", i`
    :host {
      display: block;
      padding: 1rem;
      background: white;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    
    .filter-container {
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
    }
    
    .filter-title {
      font-weight: bold;
      margin-bottom: 0.5rem;
    }
    
    .ceramic-option {
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }
  `);
__runInitializers(_init2, 1, CeramicFilter);

// src/site-type-filter.ts
var SITE_TYPES = [
  { id: "all", label: "\u6240\u6709\u9057\u5740\u7C7B\u578B" },
  { id: "Villa", label: "\u522B\u5885 (Villa)" },
  { id: "Urban", label: "\u57CE\u5E02 (Urban)" },
  { id: "Rural", label: "\u4E61\u6751\u9057\u5740 (Rural)" },
  { id: "Hillfort", label: "\u5C71\u4E18\u5821\u5792 (Hillfort)" },
  { id: "Cemetery", label: "\u5893\u5730 (Cemetery)" }
];
var _selected_dec3, _a3, _SiteTypeFilter_decorators, _init3;
_SiteTypeFilter_decorators = [t3("site-type-filter")];
var SiteTypeFilter = class extends (_a3 = r4, _selected_dec3 = [n4({ type: String })], _a3) {
  constructor() {
    super(...arguments);
    __publicField(this, "selected", __runInitializers(_init3, 8, this, "all")), __runInitializers(_init3, 11, this);
  }
  render() {
    return x`
      <div class="filter-container">
        <div class="filter-title">遗址类型筛选</div>
        
        ${SITE_TYPES.map((type) => x`
          <label class="site-option">
            <input 
              type="radio" 
              name="site-type" 
              value=${type.id} 
              ?checked=${this.selected === type.id}
              @change=${() => this.handleTypeChange(type.id)}
            />
            ${type.label}
          </label>
        `)}
      </div>
    `;
  }
  handleTypeChange(typeId) {
    this.selected = typeId;
    this.dispatchEvent(new CustomEvent("site-filter-change", {
      detail: { type: typeId },
      bubbles: true,
      composed: true
    }));
  }
};
_init3 = __decoratorStart(_a3);
__decorateElement(_init3, 5, "selected", _selected_dec3, SiteTypeFilter);
SiteTypeFilter = __decorateElement(_init3, 0, "SiteTypeFilter", _SiteTypeFilter_decorators, SiteTypeFilter);
__publicField(SiteTypeFilter, "styles", i`
    :host {
      display: block;
      padding: 1rem;
      background: white;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    
    .filter-container {
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
    }
    
    .filter-title {
      font-weight: bold;
      margin-bottom: 0.5rem;
    }
    
    .site-option {
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }
  `);
__runInitializers(_init3, 1, SiteTypeFilter);

// src/tile-map.ts
var import_maplibre_gl = __toESM(require_maplibre_gl());

// node_modules/@turf/meta/dist/esm/index.js
function coordEach(geojson, callback, excludeWrapCoord) {
  if (geojson === null) return;
  var j3, k3, l4, geometry, stopG, coords, geometryMaybeCollection, wrapShrink = 0, coordIndex = 0, isGeometryCollection, type = geojson.type, isFeatureCollection = type === "FeatureCollection", isFeature = type === "Feature", stop = isFeatureCollection ? geojson.features.length : 1;
  for (var featureIndex = 0; featureIndex < stop; featureIndex++) {
    geometryMaybeCollection = isFeatureCollection ? geojson.features[featureIndex].geometry : isFeature ? geojson.geometry : geojson;
    isGeometryCollection = geometryMaybeCollection ? geometryMaybeCollection.type === "GeometryCollection" : false;
    stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;
    for (var geomIndex = 0; geomIndex < stopG; geomIndex++) {
      var multiFeatureIndex = 0;
      var geometryIndex = 0;
      geometry = isGeometryCollection ? geometryMaybeCollection.geometries[geomIndex] : geometryMaybeCollection;
      if (geometry === null) continue;
      coords = geometry.coordinates;
      var geomType = geometry.type;
      wrapShrink = excludeWrapCoord && (geomType === "Polygon" || geomType === "MultiPolygon") ? 1 : 0;
      switch (geomType) {
        case null:
          break;
        case "Point":
          if (callback(
            coords,
            coordIndex,
            featureIndex,
            multiFeatureIndex,
            geometryIndex
          ) === false)
            return false;
          coordIndex++;
          multiFeatureIndex++;
          break;
        case "LineString":
        case "MultiPoint":
          for (j3 = 0; j3 < coords.length; j3++) {
            if (callback(
              coords[j3],
              coordIndex,
              featureIndex,
              multiFeatureIndex,
              geometryIndex
            ) === false)
              return false;
            coordIndex++;
            if (geomType === "MultiPoint") multiFeatureIndex++;
          }
          if (geomType === "LineString") multiFeatureIndex++;
          break;
        case "Polygon":
        case "MultiLineString":
          for (j3 = 0; j3 < coords.length; j3++) {
            for (k3 = 0; k3 < coords[j3].length - wrapShrink; k3++) {
              if (callback(
                coords[j3][k3],
                coordIndex,
                featureIndex,
                multiFeatureIndex,
                geometryIndex
              ) === false)
                return false;
              coordIndex++;
            }
            if (geomType === "MultiLineString") multiFeatureIndex++;
            if (geomType === "Polygon") geometryIndex++;
          }
          if (geomType === "Polygon") multiFeatureIndex++;
          break;
        case "MultiPolygon":
          for (j3 = 0; j3 < coords.length; j3++) {
            geometryIndex = 0;
            for (k3 = 0; k3 < coords[j3].length; k3++) {
              for (l4 = 0; l4 < coords[j3][k3].length - wrapShrink; l4++) {
                if (callback(
                  coords[j3][k3][l4],
                  coordIndex,
                  featureIndex,
                  multiFeatureIndex,
                  geometryIndex
                ) === false)
                  return false;
                coordIndex++;
              }
              geometryIndex++;
            }
            multiFeatureIndex++;
          }
          break;
        case "GeometryCollection":
          for (j3 = 0; j3 < geometry.geometries.length; j3++)
            if (coordEach(geometry.geometries[j3], callback, excludeWrapCoord) === false)
              return false;
          break;
        default:
          throw new Error("Unknown Geometry Type");
      }
    }
  }
}

// node_modules/@turf/bbox/dist/esm/index.js
function bbox(geojson, options = {}) {
  if (geojson.bbox != null && true !== options.recompute) {
    return geojson.bbox;
  }
  const result = [Infinity, Infinity, -Infinity, -Infinity];
  coordEach(geojson, (coord) => {
    if (result[0] > coord[0]) {
      result[0] = coord[0];
    }
    if (result[1] > coord[1]) {
      result[1] = coord[1];
    }
    if (result[2] < coord[0]) {
      result[2] = coord[0];
    }
    if (result[3] < coord[1]) {
      result[3] = coord[1];
    }
  });
  return result;
}
var turf_bbox_default = bbox;

// node_modules/fflate/esm/browser.js
var u8 = Uint8Array;
var u16 = Uint16Array;
var i32 = Int32Array;
var fleb = new u8([
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  1,
  1,
  1,
  1,
  2,
  2,
  2,
  2,
  3,
  3,
  3,
  3,
  4,
  4,
  4,
  4,
  5,
  5,
  5,
  5,
  0,
  /* unused */
  0,
  0,
  /* impossible */
  0
]);
var fdeb = new u8([
  0,
  0,
  0,
  0,
  1,
  1,
  2,
  2,
  3,
  3,
  4,
  4,
  5,
  5,
  6,
  6,
  7,
  7,
  8,
  8,
  9,
  9,
  10,
  10,
  11,
  11,
  12,
  12,
  13,
  13,
  /* unused */
  0,
  0
]);
var clim = new u8([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
var freb = function(eb, start) {
  var b4 = new u16(31);
  for (var i5 = 0; i5 < 31; ++i5) {
    b4[i5] = start += 1 << eb[i5 - 1];
  }
  var r7 = new i32(b4[30]);
  for (var i5 = 1; i5 < 30; ++i5) {
    for (var j3 = b4[i5]; j3 < b4[i5 + 1]; ++j3) {
      r7[j3] = j3 - b4[i5] << 5 | i5;
    }
  }
  return { b: b4, r: r7 };
};
var _a4 = freb(fleb, 2);
var fl = _a4.b;
var revfl = _a4.r;
fl[28] = 258, revfl[258] = 28;
var _b = freb(fdeb, 0);
var fd = _b.b;
var revfd = _b.r;
var rev = new u16(32768);
for (i5 = 0; i5 < 32768; ++i5) {
  x3 = (i5 & 43690) >> 1 | (i5 & 21845) << 1;
  x3 = (x3 & 52428) >> 2 | (x3 & 13107) << 2;
  x3 = (x3 & 61680) >> 4 | (x3 & 3855) << 4;
  rev[i5] = ((x3 & 65280) >> 8 | (x3 & 255) << 8) >> 1;
}
var x3;
var i5;
var hMap = function(cd, mb, r7) {
  var s3 = cd.length;
  var i5 = 0;
  var l4 = new u16(mb);
  for (; i5 < s3; ++i5) {
    if (cd[i5])
      ++l4[cd[i5] - 1];
  }
  var le = new u16(mb);
  for (i5 = 1; i5 < mb; ++i5) {
    le[i5] = le[i5 - 1] + l4[i5 - 1] << 1;
  }
  var co;
  if (r7) {
    co = new u16(1 << mb);
    var rvb = 15 - mb;
    for (i5 = 0; i5 < s3; ++i5) {
      if (cd[i5]) {
        var sv = i5 << 4 | cd[i5];
        var r_1 = mb - cd[i5];
        var v3 = le[cd[i5] - 1]++ << r_1;
        for (var m3 = v3 | (1 << r_1) - 1; v3 <= m3; ++v3) {
          co[rev[v3] >> rvb] = sv;
        }
      }
    }
  } else {
    co = new u16(s3);
    for (i5 = 0; i5 < s3; ++i5) {
      if (cd[i5]) {
        co[i5] = rev[le[cd[i5] - 1]++] >> 15 - cd[i5];
      }
    }
  }
  return co;
};
var flt = new u8(288);
for (i5 = 0; i5 < 144; ++i5)
  flt[i5] = 8;
var i5;
for (i5 = 144; i5 < 256; ++i5)
  flt[i5] = 9;
var i5;
for (i5 = 256; i5 < 280; ++i5)
  flt[i5] = 7;
var i5;
for (i5 = 280; i5 < 288; ++i5)
  flt[i5] = 8;
var i5;
var fdt = new u8(32);
for (i5 = 0; i5 < 32; ++i5)
  fdt[i5] = 5;
var i5;
var flrm = /* @__PURE__ */ hMap(flt, 9, 1);
var fdrm = /* @__PURE__ */ hMap(fdt, 5, 1);
var max = function(a3) {
  var m3 = a3[0];
  for (var i5 = 1; i5 < a3.length; ++i5) {
    if (a3[i5] > m3)
      m3 = a3[i5];
  }
  return m3;
};
var bits = function(d3, p3, m3) {
  var o5 = p3 / 8 | 0;
  return (d3[o5] | d3[o5 + 1] << 8) >> (p3 & 7) & m3;
};
var bits16 = function(d3, p3) {
  var o5 = p3 / 8 | 0;
  return (d3[o5] | d3[o5 + 1] << 8 | d3[o5 + 2] << 16) >> (p3 & 7);
};
var shft = function(p3) {
  return (p3 + 7) / 8 | 0;
};
var slc = function(v3, s3, e5) {
  if (s3 == null || s3 < 0)
    s3 = 0;
  if (e5 == null || e5 > v3.length)
    e5 = v3.length;
  return new u8(v3.subarray(s3, e5));
};
var ec = [
  "unexpected EOF",
  "invalid block type",
  "invalid length/literal",
  "invalid distance",
  "stream finished",
  "no stream handler",
  ,
  "no callback",
  "invalid UTF-8 data",
  "extra field too long",
  "date not in range 1980-2099",
  "filename too long",
  "stream finishing",
  "invalid zip data"
  // determined by unknown compression method
];
var err = function(ind, msg, nt) {
  var e5 = new Error(msg || ec[ind]);
  e5.code = ind;
  if (Error.captureStackTrace)
    Error.captureStackTrace(e5, err);
  if (!nt)
    throw e5;
  return e5;
};
var inflt = function(dat, st, buf, dict) {
  var sl = dat.length, dl = dict ? dict.length : 0;
  if (!sl || st.f && !st.l)
    return buf || new u8(0);
  var noBuf = !buf;
  var resize = noBuf || st.i != 2;
  var noSt = st.i;
  if (noBuf)
    buf = new u8(sl * 3);
  var cbuf = function(l5) {
    var bl = buf.length;
    if (l5 > bl) {
      var nbuf = new u8(Math.max(bl * 2, l5));
      nbuf.set(buf);
      buf = nbuf;
    }
  };
  var final = st.f || 0, pos = st.p || 0, bt = st.b || 0, lm = st.l, dm = st.d, lbt = st.m, dbt = st.n;
  var tbts = sl * 8;
  do {
    if (!lm) {
      final = bits(dat, pos, 1);
      var type = bits(dat, pos + 1, 3);
      pos += 3;
      if (!type) {
        var s3 = shft(pos) + 4, l4 = dat[s3 - 4] | dat[s3 - 3] << 8, t4 = s3 + l4;
        if (t4 > sl) {
          if (noSt)
            err(0);
          break;
        }
        if (resize)
          cbuf(bt + l4);
        buf.set(dat.subarray(s3, t4), bt);
        st.b = bt += l4, st.p = pos = t4 * 8, st.f = final;
        continue;
      } else if (type == 1)
        lm = flrm, dm = fdrm, lbt = 9, dbt = 5;
      else if (type == 2) {
        var hLit = bits(dat, pos, 31) + 257, hcLen = bits(dat, pos + 10, 15) + 4;
        var tl = hLit + bits(dat, pos + 5, 31) + 1;
        pos += 14;
        var ldt = new u8(tl);
        var clt = new u8(19);
        for (var i5 = 0; i5 < hcLen; ++i5) {
          clt[clim[i5]] = bits(dat, pos + i5 * 3, 7);
        }
        pos += hcLen * 3;
        var clb = max(clt), clbmsk = (1 << clb) - 1;
        var clm = hMap(clt, clb, 1);
        for (var i5 = 0; i5 < tl; ) {
          var r7 = clm[bits(dat, pos, clbmsk)];
          pos += r7 & 15;
          var s3 = r7 >> 4;
          if (s3 < 16) {
            ldt[i5++] = s3;
          } else {
            var c4 = 0, n5 = 0;
            if (s3 == 16)
              n5 = 3 + bits(dat, pos, 3), pos += 2, c4 = ldt[i5 - 1];
            else if (s3 == 17)
              n5 = 3 + bits(dat, pos, 7), pos += 3;
            else if (s3 == 18)
              n5 = 11 + bits(dat, pos, 127), pos += 7;
            while (n5--)
              ldt[i5++] = c4;
          }
        }
        var lt = ldt.subarray(0, hLit), dt = ldt.subarray(hLit);
        lbt = max(lt);
        dbt = max(dt);
        lm = hMap(lt, lbt, 1);
        dm = hMap(dt, dbt, 1);
      } else
        err(1);
      if (pos > tbts) {
        if (noSt)
          err(0);
        break;
      }
    }
    if (resize)
      cbuf(bt + 131072);
    var lms = (1 << lbt) - 1, dms = (1 << dbt) - 1;
    var lpos = pos;
    for (; ; lpos = pos) {
      var c4 = lm[bits16(dat, pos) & lms], sym = c4 >> 4;
      pos += c4 & 15;
      if (pos > tbts) {
        if (noSt)
          err(0);
        break;
      }
      if (!c4)
        err(2);
      if (sym < 256)
        buf[bt++] = sym;
      else if (sym == 256) {
        lpos = pos, lm = null;
        break;
      } else {
        var add = sym - 254;
        if (sym > 264) {
          var i5 = sym - 257, b4 = fleb[i5];
          add = bits(dat, pos, (1 << b4) - 1) + fl[i5];
          pos += b4;
        }
        var d3 = dm[bits16(dat, pos) & dms], dsym = d3 >> 4;
        if (!d3)
          err(3);
        pos += d3 & 15;
        var dt = fd[dsym];
        if (dsym > 3) {
          var b4 = fdeb[dsym];
          dt += bits16(dat, pos) & (1 << b4) - 1, pos += b4;
        }
        if (pos > tbts) {
          if (noSt)
            err(0);
          break;
        }
        if (resize)
          cbuf(bt + 131072);
        var end = bt + add;
        if (bt < dt) {
          var shift = dl - dt, dend = Math.min(dt, end);
          if (shift + bt < 0)
            err(3);
          for (; bt < dend; ++bt)
            buf[bt] = dict[shift + bt];
        }
        for (; bt < end; ++bt)
          buf[bt] = buf[bt - dt];
      }
    }
    st.l = lm, st.p = lpos, st.b = bt, st.f = final;
    if (lm)
      final = 1, st.m = lbt, st.d = dm, st.n = dbt;
  } while (!final);
  return bt != buf.length && noBuf ? slc(buf, 0, bt) : buf.subarray(0, bt);
};
var et = /* @__PURE__ */ new u8(0);
var gzs = function(d3) {
  if (d3[0] != 31 || d3[1] != 139 || d3[2] != 8)
    err(6, "invalid gzip data");
  var flg = d3[3];
  var st = 10;
  if (flg & 4)
    st += (d3[10] | d3[11] << 8) + 2;
  for (var zs = (flg >> 3 & 1) + (flg >> 4 & 1); zs > 0; zs -= !d3[st++])
    ;
  return st + (flg & 2);
};
var gzl = function(d3) {
  var l4 = d3.length;
  return (d3[l4 - 4] | d3[l4 - 3] << 8 | d3[l4 - 2] << 16 | d3[l4 - 1] << 24) >>> 0;
};
var zls = function(d3, dict) {
  if ((d3[0] & 15) != 8 || d3[0] >> 4 > 7 || (d3[0] << 8 | d3[1]) % 31)
    err(6, "invalid zlib data");
  if ((d3[1] >> 5 & 1) == +!dict)
    err(6, "invalid zlib data: " + (d3[1] & 32 ? "need" : "unexpected") + " dictionary");
  return (d3[1] >> 3 & 4) + 2;
};
function inflateSync(data, opts) {
  return inflt(data, { i: 2 }, opts && opts.out, opts && opts.dictionary);
}
function gunzipSync(data, opts) {
  var st = gzs(data);
  if (st + 8 > data.length)
    err(6, "invalid gzip data");
  return inflt(data.subarray(st, -8), { i: 2 }, opts && opts.out || new u8(gzl(data)), opts && opts.dictionary);
}
function unzlibSync(data, opts) {
  return inflt(data.subarray(zls(data, opts && opts.dictionary), -4), { i: 2 }, opts && opts.out, opts && opts.dictionary);
}
function decompressSync(data, opts) {
  return data[0] == 31 && data[1] == 139 && data[2] == 8 ? gunzipSync(data, opts) : (data[0] & 15) != 8 || data[0] >> 4 > 7 || (data[0] << 8 | data[1]) % 31 ? inflateSync(data, opts) : unzlibSync(data, opts);
}
var td = typeof TextDecoder != "undefined" && /* @__PURE__ */ new TextDecoder();
var tds = 0;
try {
  td.decode(et, { stream: true });
  tds = 1;
} catch (e5) {
}

// node_modules/pmtiles/dist/esm/index.js
var z2 = Object.defineProperty;
var b3 = Math.pow;
var l3 = (i5, e5) => z2(i5, "name", { value: e5, configurable: true });
var m2 = (i5, e5, t4) => new Promise((r7, n5) => {
  var s3 = (u3) => {
    try {
      a3(t4.next(u3));
    } catch (c4) {
      n5(c4);
    }
  }, o5 = (u3) => {
    try {
      a3(t4.throw(u3));
    } catch (c4) {
      n5(c4);
    }
  }, a3 = (u3) => u3.done ? r7(u3.value) : Promise.resolve(u3.value).then(s3, o5);
  a3((t4 = t4.apply(i5, e5)).next());
});
var re = l3((i5, e5) => {
  let t4 = false, r7 = "", n5 = L.GridLayer.extend({ createTile: l3((s3, o5) => {
    let a3 = document.createElement("img"), u3 = new AbortController(), c4 = u3.signal;
    return a3.cancel = () => {
      u3.abort();
    }, t4 || (i5.getHeader().then((d3) => {
      d3.tileType === 1 ? console.error("Error: archive contains MVT vector tiles, but leafletRasterLayer is for displaying raster tiles. See https://github.com/protomaps/PMTiles/tree/main/js for details.") : d3.tileType === 2 ? r7 = "image/png" : d3.tileType === 3 ? r7 = "image/jpeg" : d3.tileType === 4 ? r7 = "image/webp" : d3.tileType === 5 && (r7 = "image/avif");
    }), t4 = true), i5.getZxy(s3.z, s3.x, s3.y, c4).then((d3) => {
      if (d3) {
        let h3 = new Blob([d3.data], { type: r7 }), p3 = window.URL.createObjectURL(h3);
        a3.src = p3, a3.cancel = void 0, o5(void 0, a3);
      }
    }).catch((d3) => {
      if (d3.name !== "AbortError") throw d3;
    }), a3;
  }, "createTile"), _removeTile: l3(function(s3) {
    let o5 = this._tiles[s3];
    o5 && (o5.el.cancel && o5.el.cancel(), o5.el.width = 0, o5.el.height = 0, o5.el.deleted = true, L.DomUtil.remove(o5.el), delete this._tiles[s3], this.fire("tileunload", { tile: o5.el, coords: this._keyToTileCoords(s3) }));
  }, "_removeTile") });
  return new n5(e5);
}, "leafletRasterLayer");
var j2 = l3((i5) => (e5, t4) => {
  if (t4 instanceof AbortController) return i5(e5, t4);
  let r7 = new AbortController();
  return i5(e5, r7).then((n5) => t4(void 0, n5.data, n5.cacheControl || "", n5.expires || ""), (n5) => t4(n5)).catch((n5) => t4(n5)), { cancel: l3(() => r7.abort(), "cancel") };
}, "v3compat");
var T2 = class T3 {
  constructor(e5) {
    this.tilev4 = l3((e6, t4) => m2(this, null, function* () {
      if (e6.type === "json") {
        let p3 = e6.url.substr(10), y3 = this.tiles.get(p3);
        if (y3 || (y3 = new x2(p3), this.tiles.set(p3, y3)), this.metadata) return { data: yield y3.getTileJson(e6.url) };
        let f3 = yield y3.getHeader();
        return (f3.minLon >= f3.maxLon || f3.minLat >= f3.maxLat) && console.error(`Bounds of PMTiles archive ${f3.minLon},${f3.minLat},${f3.maxLon},${f3.maxLat} are not valid.`), { data: { tiles: [`${e6.url}/{z}/{x}/{y}`], minzoom: f3.minZoom, maxzoom: f3.maxZoom, bounds: [f3.minLon, f3.minLat, f3.maxLon, f3.maxLat] } };
      }
      let r7 = new RegExp(/pmtiles:\/\/(.+)\/(\d+)\/(\d+)\/(\d+)/), n5 = e6.url.match(r7);
      if (!n5) throw new Error("Invalid PMTiles protocol URL");
      let s3 = n5[1], o5 = this.tiles.get(s3);
      o5 || (o5 = new x2(s3), this.tiles.set(s3, o5));
      let a3 = n5[2], u3 = n5[3], c4 = n5[4], d3 = yield o5.getHeader(), h3 = yield o5 == null ? void 0 : o5.getZxy(+a3, +u3, +c4, t4.signal);
      if (h3) return { data: new Uint8Array(h3.data), cacheControl: h3.cacheControl, expires: h3.expires };
      if (d3.tileType === 1) {
        if (this.errorOnMissingTile) throw new Error("Tile not found.");
        return { data: new Uint8Array() };
      }
      return { data: null };
    }), "tilev4");
    this.tile = j2(this.tilev4);
    this.tiles = /* @__PURE__ */ new Map(), this.metadata = (e5 == null ? void 0 : e5.metadata) || false, this.errorOnMissingTile = (e5 == null ? void 0 : e5.errorOnMissingTile) || false;
  }
  add(e5) {
    this.tiles.set(e5.source.getKey(), e5);
  }
  get(e5) {
    return this.tiles.get(e5);
  }
};
l3(T2, "Protocol");
var S3 = T2;
function w2(i5, e5) {
  return (e5 >>> 0) * 4294967296 + (i5 >>> 0);
}
l3(w2, "toNum");
function F(i5, e5) {
  let t4 = e5.buf, r7 = t4[e5.pos++], n5 = (r7 & 112) >> 4;
  if (r7 < 128 || (r7 = t4[e5.pos++], n5 |= (r7 & 127) << 3, r7 < 128) || (r7 = t4[e5.pos++], n5 |= (r7 & 127) << 10, r7 < 128) || (r7 = t4[e5.pos++], n5 |= (r7 & 127) << 17, r7 < 128) || (r7 = t4[e5.pos++], n5 |= (r7 & 127) << 24, r7 < 128) || (r7 = t4[e5.pos++], n5 |= (r7 & 1) << 31, r7 < 128)) return w2(i5, n5);
  throw new Error("Expected varint not more than 10 bytes");
}
l3(F, "readVarintRemainder");
function v2(i5) {
  let e5 = i5.buf, t4 = e5[i5.pos++], r7 = t4 & 127;
  return t4 < 128 || (t4 = e5[i5.pos++], r7 |= (t4 & 127) << 7, t4 < 128) || (t4 = e5[i5.pos++], r7 |= (t4 & 127) << 14, t4 < 128) || (t4 = e5[i5.pos++], r7 |= (t4 & 127) << 21, t4 < 128) ? r7 : (t4 = e5[i5.pos], r7 |= (t4 & 15) << 28, F(r7, i5));
}
l3(v2, "readVarint");
function k2(i5, e5, t4, r7) {
  if (r7 === 0) {
    t4 === 1 && (e5[0] = i5 - 1 - e5[0], e5[1] = i5 - 1 - e5[1]);
    let n5 = e5[0];
    e5[0] = e5[1], e5[1] = n5;
  }
}
l3(k2, "rotate");
function N2(i5, e5) {
  let t4 = b3(2, i5), r7 = e5, n5 = e5, s3 = e5, o5 = [0, 0], a3 = 1;
  for (; a3 < t4; ) r7 = 1 & s3 / 2, n5 = 1 & (s3 ^ r7), k2(a3, o5, r7, n5), o5[0] += a3 * r7, o5[1] += a3 * n5, s3 = s3 / 4, a3 *= 2;
  return [i5, o5[0], o5[1]];
}
l3(N2, "idOnLevel");
var q = [0, 1, 5, 21, 85, 341, 1365, 5461, 21845, 87381, 349525, 1398101, 5592405, 22369621, 89478485, 357913941, 1431655765, 5726623061, 22906492245, 91625968981, 366503875925, 1466015503701, 5864062014805, 23456248059221, 93824992236885, 375299968947541, 1501199875790165];
function G(i5, e5, t4) {
  if (i5 > 26) throw new Error("Tile zoom level exceeds max safe number limit (26)");
  if (e5 > b3(2, i5) - 1 || t4 > b3(2, i5) - 1) throw new Error("tile x/y outside zoom level bounds");
  let r7 = q[i5], n5 = b3(2, i5), s3 = 0, o5 = 0, a3 = 0, u3 = [e5, t4], c4 = n5 / 2;
  for (; c4 > 0; ) s3 = (u3[0] & c4) > 0 ? 1 : 0, o5 = (u3[1] & c4) > 0 ? 1 : 0, a3 += c4 * c4 * (3 * s3 ^ o5), k2(c4, u3, s3, o5), c4 = c4 / 2;
  return r7 + a3;
}
l3(G, "zxyToTileId");
function ie(i5) {
  let e5 = 0, t4 = 0;
  for (let r7 = 0; r7 < 27; r7++) {
    let n5 = (1 << r7) * (1 << r7);
    if (e5 + n5 > i5) return N2(r7, i5 - e5);
    e5 += n5;
  }
  throw new Error("Tile zoom level exceeds max safe number limit (26)");
}
l3(ie, "tileIdToZxy");
var J = ((s3) => (s3[s3.Unknown = 0] = "Unknown", s3[s3.None = 1] = "None", s3[s3.Gzip = 2] = "Gzip", s3[s3.Brotli = 3] = "Brotli", s3[s3.Zstd = 4] = "Zstd", s3))(J || {});
function D(i5, e5) {
  return m2(this, null, function* () {
    if (e5 === 1 || e5 === 0) return i5;
    if (e5 === 2) {
      if (typeof globalThis.DecompressionStream == "undefined") return decompressSync(new Uint8Array(i5));
      let t4 = new Response(i5).body;
      if (!t4) throw new Error("Failed to read response stream");
      let r7 = t4.pipeThrough(new globalThis.DecompressionStream("gzip"));
      return new Response(r7).arrayBuffer();
    }
    throw new Error("Compression method not supported");
  });
}
l3(D, "defaultDecompress");
var O = ((o5) => (o5[o5.Unknown = 0] = "Unknown", o5[o5.Mvt = 1] = "Mvt", o5[o5.Png = 2] = "Png", o5[o5.Jpeg = 3] = "Jpeg", o5[o5.Webp = 4] = "Webp", o5[o5.Avif = 5] = "Avif", o5))(O || {});
function _2(i5) {
  return i5 === 1 ? ".mvt" : i5 === 2 ? ".png" : i5 === 3 ? ".jpg" : i5 === 4 ? ".webp" : i5 === 5 ? ".avif" : "";
}
l3(_2, "tileTypeExt");
var Y = 127;
function Q(i5, e5) {
  let t4 = 0, r7 = i5.length - 1;
  for (; t4 <= r7; ) {
    let n5 = r7 + t4 >> 1, s3 = e5 - i5[n5].tileId;
    if (s3 > 0) t4 = n5 + 1;
    else if (s3 < 0) r7 = n5 - 1;
    else return i5[n5];
  }
  return r7 >= 0 && (i5[r7].runLength === 0 || e5 - i5[r7].tileId < i5[r7].runLength) ? i5[r7] : null;
}
l3(Q, "findTile");
var A2 = class A3 {
  constructor(e5) {
    this.file = e5;
  }
  getKey() {
    return this.file.name;
  }
  getBytes(e5, t4) {
    return m2(this, null, function* () {
      return { data: yield this.file.slice(e5, e5 + t4).arrayBuffer() };
    });
  }
};
l3(A2, "FileSource");
var U = class U2 {
  constructor(e5, t4 = new Headers()) {
    this.url = e5, this.customHeaders = t4, this.mustReload = false;
    let r7 = "";
    "navigator" in globalThis && (r7 = globalThis.navigator.userAgent || "");
    let n5 = r7.indexOf("Windows") > -1, s3 = /Chrome|Chromium|Edg|OPR|Brave/.test(r7);
    this.chromeWindowsNoCache = false, n5 && s3 && (this.chromeWindowsNoCache = true);
  }
  getKey() {
    return this.url;
  }
  setHeaders(e5) {
    this.customHeaders = e5;
  }
  getBytes(e5, t4, r7, n5) {
    return m2(this, null, function* () {
      let s3, o5;
      r7 ? o5 = r7 : (s3 = new AbortController(), o5 = s3.signal);
      let a3 = new Headers(this.customHeaders);
      a3.set("range", `bytes=${e5}-${e5 + t4 - 1}`);
      let u3;
      this.mustReload ? u3 = "reload" : this.chromeWindowsNoCache && (u3 = "no-store");
      let c4 = yield fetch(this.url, { signal: o5, cache: u3, headers: a3 });
      if (e5 === 0 && c4.status === 416) {
        let y3 = c4.headers.get("Content-Range");
        if (!y3 || !y3.startsWith("bytes */")) throw new Error("Missing content-length on 416 response");
        let f3 = +y3.substr(8);
        c4 = yield fetch(this.url, { signal: o5, cache: "reload", headers: { range: `bytes=0-${f3 - 1}` } });
      }
      let d3 = c4.headers.get("Etag");
      if (d3 != null && d3.startsWith("W/") && (d3 = null), c4.status === 416 || n5 && d3 && d3 !== n5) throw this.mustReload = true, new E2(`Server returned non-matching ETag ${n5} after one retry. Check browser extensions and servers for issues that may affect correct ETag headers.`);
      if (c4.status >= 300) throw new Error(`Bad response code: ${c4.status}`);
      let h3 = c4.headers.get("Content-Length");
      if (c4.status === 200 && (!h3 || +h3 > t4)) throw s3 && s3.abort(), new Error("Server returned no content-length header or content-length exceeding request. Check that your storage backend supports HTTP Byte Serving.");
      return { data: yield c4.arrayBuffer(), etag: d3 || void 0, cacheControl: c4.headers.get("Cache-Control") || void 0, expires: c4.headers.get("Expires") || void 0 };
    });
  }
};
l3(U, "FetchSource");
var C2 = U;
function g2(i5, e5) {
  let t4 = i5.getUint32(e5 + 4, true), r7 = i5.getUint32(e5 + 0, true);
  return t4 * b3(2, 32) + r7;
}
l3(g2, "getUint64");
function X(i5, e5) {
  let t4 = new DataView(i5), r7 = t4.getUint8(7);
  if (r7 > 3) throw new Error(`Archive is spec version ${r7} but this library supports up to spec version 3`);
  return { specVersion: r7, rootDirectoryOffset: g2(t4, 8), rootDirectoryLength: g2(t4, 16), jsonMetadataOffset: g2(t4, 24), jsonMetadataLength: g2(t4, 32), leafDirectoryOffset: g2(t4, 40), leafDirectoryLength: g2(t4, 48), tileDataOffset: g2(t4, 56), tileDataLength: g2(t4, 64), numAddressedTiles: g2(t4, 72), numTileEntries: g2(t4, 80), numTileContents: g2(t4, 88), clustered: t4.getUint8(96) === 1, internalCompression: t4.getUint8(97), tileCompression: t4.getUint8(98), tileType: t4.getUint8(99), minZoom: t4.getUint8(100), maxZoom: t4.getUint8(101), minLon: t4.getInt32(102, true) / 1e7, minLat: t4.getInt32(106, true) / 1e7, maxLon: t4.getInt32(110, true) / 1e7, maxLat: t4.getInt32(114, true) / 1e7, centerZoom: t4.getUint8(118), centerLon: t4.getInt32(119, true) / 1e7, centerLat: t4.getInt32(123, true) / 1e7, etag: e5 };
}
l3(X, "bytesToHeader");
function Z(i5) {
  let e5 = { buf: new Uint8Array(i5), pos: 0 }, t4 = v2(e5), r7 = [], n5 = 0;
  for (let s3 = 0; s3 < t4; s3++) {
    let o5 = v2(e5);
    r7.push({ tileId: n5 + o5, offset: 0, length: 0, runLength: 1 }), n5 += o5;
  }
  for (let s3 = 0; s3 < t4; s3++) r7[s3].runLength = v2(e5);
  for (let s3 = 0; s3 < t4; s3++) r7[s3].length = v2(e5);
  for (let s3 = 0; s3 < t4; s3++) {
    let o5 = v2(e5);
    o5 === 0 && s3 > 0 ? r7[s3].offset = r7[s3 - 1].offset + r7[s3 - 1].length : r7[s3].offset = o5 - 1;
  }
  return r7;
}
l3(Z, "deserializeIndex");
var R2 = class R3 extends Error {
};
l3(R2, "EtagMismatch");
var E2 = R2;
function K(i5, e5) {
  return m2(this, null, function* () {
    let t4 = yield i5.getBytes(0, 16384);
    if (new DataView(t4.data).getUint16(0, true) !== 19792) throw new Error("Wrong magic number for PMTiles archive");
    let n5 = t4.data.slice(0, Y), s3 = X(n5, t4.etag), o5 = t4.data.slice(s3.rootDirectoryOffset, s3.rootDirectoryOffset + s3.rootDirectoryLength), a3 = `${i5.getKey()}|${s3.etag || ""}|${s3.rootDirectoryOffset}|${s3.rootDirectoryLength}`, u3 = Z(yield e5(o5, s3.internalCompression));
    return [s3, [a3, u3.length, u3]];
  });
}
l3(K, "getHeaderAndRoot");
function I2(i5, e5, t4, r7, n5) {
  return m2(this, null, function* () {
    let s3 = yield i5.getBytes(t4, r7, void 0, n5.etag), o5 = yield e5(s3.data, n5.internalCompression), a3 = Z(o5);
    if (a3.length === 0) throw new Error("Empty directory is invalid");
    return a3;
  });
}
l3(I2, "getDirectory");
var H2 = class H3 {
  constructor(e5 = 100, t4 = true, r7 = D) {
    this.cache = /* @__PURE__ */ new Map(), this.maxCacheEntries = e5, this.counter = 1, this.decompress = r7;
  }
  getHeader(e5) {
    return m2(this, null, function* () {
      let t4 = e5.getKey(), r7 = this.cache.get(t4);
      if (r7) return r7.lastUsed = this.counter++, r7.data;
      let n5 = yield K(e5, this.decompress);
      return n5[1] && this.cache.set(n5[1][0], { lastUsed: this.counter++, data: n5[1][2] }), this.cache.set(t4, { lastUsed: this.counter++, data: n5[0] }), this.prune(), n5[0];
    });
  }
  getDirectory(e5, t4, r7, n5) {
    return m2(this, null, function* () {
      let s3 = `${e5.getKey()}|${n5.etag || ""}|${t4}|${r7}`, o5 = this.cache.get(s3);
      if (o5) return o5.lastUsed = this.counter++, o5.data;
      let a3 = yield I2(e5, this.decompress, t4, r7, n5);
      return this.cache.set(s3, { lastUsed: this.counter++, data: a3 }), this.prune(), a3;
    });
  }
  prune() {
    if (this.cache.size > this.maxCacheEntries) {
      let e5 = 1 / 0, t4;
      this.cache.forEach((r7, n5) => {
        r7.lastUsed < e5 && (e5 = r7.lastUsed, t4 = n5);
      }), t4 && this.cache.delete(t4);
    }
  }
  invalidate(e5) {
    return m2(this, null, function* () {
      this.cache.delete(e5.getKey());
    });
  }
};
l3(H2, "ResolvedValueCache");
var M2 = class M3 {
  constructor(e5 = 100, t4 = true, r7 = D) {
    this.cache = /* @__PURE__ */ new Map(), this.invalidations = /* @__PURE__ */ new Map(), this.maxCacheEntries = e5, this.counter = 1, this.decompress = r7;
  }
  getHeader(e5) {
    return m2(this, null, function* () {
      let t4 = e5.getKey(), r7 = this.cache.get(t4);
      if (r7) return r7.lastUsed = this.counter++, yield r7.data;
      let n5 = new Promise((s3, o5) => {
        K(e5, this.decompress).then((a3) => {
          a3[1] && this.cache.set(a3[1][0], { lastUsed: this.counter++, data: Promise.resolve(a3[1][2]) }), s3(a3[0]), this.prune();
        }).catch((a3) => {
          o5(a3);
        });
      });
      return this.cache.set(t4, { lastUsed: this.counter++, data: n5 }), n5;
    });
  }
  getDirectory(e5, t4, r7, n5) {
    return m2(this, null, function* () {
      let s3 = `${e5.getKey()}|${n5.etag || ""}|${t4}|${r7}`, o5 = this.cache.get(s3);
      if (o5) return o5.lastUsed = this.counter++, yield o5.data;
      let a3 = new Promise((u3, c4) => {
        I2(e5, this.decompress, t4, r7, n5).then((d3) => {
          u3(d3), this.prune();
        }).catch((d3) => {
          c4(d3);
        });
      });
      return this.cache.set(s3, { lastUsed: this.counter++, data: a3 }), a3;
    });
  }
  prune() {
    if (this.cache.size >= this.maxCacheEntries) {
      let e5 = 1 / 0, t4;
      this.cache.forEach((r7, n5) => {
        r7.lastUsed < e5 && (e5 = r7.lastUsed, t4 = n5);
      }), t4 && this.cache.delete(t4);
    }
  }
  invalidate(e5) {
    return m2(this, null, function* () {
      let t4 = e5.getKey();
      if (this.invalidations.get(t4)) return yield this.invalidations.get(t4);
      this.cache.delete(e5.getKey());
      let r7 = new Promise((n5, s3) => {
        this.getHeader(e5).then((o5) => {
          n5(), this.invalidations.delete(t4);
        }).catch((o5) => {
          s3(o5);
        });
      });
      this.invalidations.set(t4, r7);
    });
  }
};
l3(M2, "SharedPromiseCache");
var P2 = M2;
var B2 = class B3 {
  constructor(e5, t4, r7) {
    typeof e5 == "string" ? this.source = new C2(e5) : this.source = e5, r7 ? this.decompress = r7 : this.decompress = D, t4 ? this.cache = t4 : this.cache = new P2();
  }
  getHeader() {
    return m2(this, null, function* () {
      return yield this.cache.getHeader(this.source);
    });
  }
  getZxyAttempt(e5, t4, r7, n5) {
    return m2(this, null, function* () {
      let s3 = G(e5, t4, r7), o5 = yield this.cache.getHeader(this.source);
      if (e5 < o5.minZoom || e5 > o5.maxZoom) return;
      let a3 = o5.rootDirectoryOffset, u3 = o5.rootDirectoryLength;
      for (let c4 = 0; c4 <= 3; c4++) {
        let d3 = yield this.cache.getDirectory(this.source, a3, u3, o5), h3 = Q(d3, s3);
        if (h3) {
          if (h3.runLength > 0) {
            let p3 = yield this.source.getBytes(o5.tileDataOffset + h3.offset, h3.length, n5, o5.etag);
            return { data: yield this.decompress(p3.data, o5.tileCompression), cacheControl: p3.cacheControl, expires: p3.expires };
          }
          a3 = o5.leafDirectoryOffset + h3.offset, u3 = h3.length;
        } else return;
      }
      throw new Error("Maximum directory depth exceeded");
    });
  }
  getZxy(e5, t4, r7, n5) {
    return m2(this, null, function* () {
      try {
        return yield this.getZxyAttempt(e5, t4, r7, n5);
      } catch (s3) {
        if (s3 instanceof E2) return this.cache.invalidate(this.source), yield this.getZxyAttempt(e5, t4, r7, n5);
        throw s3;
      }
    });
  }
  getMetadataAttempt() {
    return m2(this, null, function* () {
      let e5 = yield this.cache.getHeader(this.source), t4 = yield this.source.getBytes(e5.jsonMetadataOffset, e5.jsonMetadataLength, void 0, e5.etag), r7 = yield this.decompress(t4.data, e5.internalCompression), n5 = new TextDecoder("utf-8");
      return JSON.parse(n5.decode(r7));
    });
  }
  getMetadata() {
    return m2(this, null, function* () {
      try {
        return yield this.getMetadataAttempt();
      } catch (e5) {
        if (e5 instanceof E2) return this.cache.invalidate(this.source), yield this.getMetadataAttempt();
        throw e5;
      }
    });
  }
  getTileJson(e5) {
    return m2(this, null, function* () {
      let t4 = yield this.getHeader(), r7 = yield this.getMetadata(), n5 = _2(t4.tileType);
      return { tilejson: "3.0.0", scheme: "xyz", tiles: [`${e5}/{z}/{x}/{y}${n5}`], vector_layers: r7.vector_layers, attribution: r7.attribution, description: r7.description, name: r7.name, version: r7.version, bounds: [t4.minLon, t4.minLat, t4.maxLon, t4.maxLat], center: [t4.centerLon, t4.centerLat, t4.centerZoom], minzoom: t4.minZoom, maxzoom: t4.maxZoom };
    });
  }
};
l3(B2, "PMTiles");
var x2 = B2;

// src/tile-map.ts
var DEFAULT_ZOOM = 5.5;
var DEFAULT_CENTER = [-3.7, 40.4];
var PMTILES_URL = "https://fly.storage.tigris.dev/cawm-pmtiles/cawm.pmtiles";
var CERAMIC_COLORS = {
  "all": "#333333",
  "TSH": "#e41a1c",
  "TSHT": "#377eb8",
  "TSG": "#4daf4a",
  "ARS": "#ff7f00",
  "LRC": "#984ea3",
  "PRCW": "#ffff33"
};
var TileMap = class extends HTMLElement {
  constructor() {
    super();
    __publicField(this, "placeTypeLayerNames", []);
    __publicField(this, "map", null);
    __publicField(this, "currentCeramicFilter", "all");
    __publicField(this, "currentPeriodFilter", "all");
    __publicField(this, "currentSiteTypeFilter", "all");
    __publicField(this, "popup", null);
    this.attachShadow({ mode: "open" });
  }
  async connectedCallback() {
    this.render();
    const protocol = new S3();
    import_maplibre_gl.default.addProtocol("pmtiles", protocol.tile);
    const tileserver = new x2(PMTILES_URL);
    protocol.add(tileserver);
    const header = await tileserver.getHeader();
    const container = this.shadowRoot.getElementById(this.id);
    this.map = new import_maplibre_gl.default.Map({
      container,
      minZoom: header.minZoom,
      maxZoom: 9,
      zoom: DEFAULT_ZOOM,
      center: DEFAULT_CENTER,
      style: {
        version: 8,
        sources: {
          cawm: {
            type: "raster",
            url: `pmtiles://${PMTILES_URL}`
          },
          places: {
            type: "geojson",
            data: {
              type: "FeatureCollection",
              features: []
            }
          }
        },
        layers: [
          {
            id: "tiles",
            type: "raster",
            source: "cawm"
          },
          {
            id: "points",
            type: "circle",
            source: "places",
            filter: ["==", ["geometry-type"], "Point"],
            paint: {
              "circle-radius": 5,
              "circle-color": "#333333",
              "circle-stroke-width": 1,
              "circle-stroke-color": "#ffffff"
            }
          }
        ]
      }
    });
    this.map.on("click", "points", this.handleMapClick.bind(this));
    this.map.on("mouseenter", "points", () => {
      if (this.map) this.map.getCanvas().style.cursor = "pointer";
    });
    this.map.on("mouseleave", "points", () => {
      if (this.map) this.map.getCanvas().style.cursor = "";
    });
    this.addEventListener("period-change", (e5) => {
      this.currentPeriodFilter = e5.detail.period;
      this.updateFilters();
    });
    this.addEventListener("ceramic-filter-change", (e5) => {
      this.currentCeramicFilter = e5.detail.type;
      this.updateFilters();
      this.updatePointColors();
    });
    this.addEventListener("site-filter-change", (e5) => {
      this.currentSiteTypeFilter = e5.detail.type;
      this.updateFilters();
    });
  }
  render() {
    this.shadowRoot.innerHTML = `
      <link rel="stylesheet" href="/maplibre-gl.css">
      <style>
        #${this.id} { 
          height: 100%; 
        }
        .maplibregl-popup {
          max-width: 300px;
          font: 12px/20px 'Helvetica Neue', Arial, Helvetica, sans-serif;
        }
      </style>
      <div id="${this.id}"></div>
    `;
  }
  handleMapClick(e5) {
    if (!this.map) return;
    const features = this.map.queryRenderedFeatures(e5.point, { layers: ["points"] });
    if (!features.length) return;
    const feature = features[0];
    const props = feature.properties || {};
    const ceramicTypes = ["TSH", "TSHT", "TSG", "ARSA", "ARSC", "ARSD", "LRC", "LRD", "PRCW"];
    const presentCeramics = ceramicTypes.filter((type) => props[type] === 1).join(", ");
    let html = `
      <h3>${props.name || "\u672A\u547D\u540D\u9057\u5740"}</h3>
      <p>\u7C7B\u578B: ${props.siteType || "\u672A\u77E5"}</p>
      <p>\u5206\u6790\u7C7B\u578B: ${props.analysisType || "\u672A\u77E5"}</p>
      <p>\u9676\u74F7\u7C7B\u578B: ${presentCeramics || "\u65E0\u6570\u636E"}</p>
    `;
    if (this.popup) this.popup.remove();
    this.popup = new import_maplibre_gl.default.Popup().setLngLat(feature.geometry.coordinates).setHTML(html).addTo(this.map);
  }
  updateFilters() {
    if (!this.map) return;
    const filters = [];
    if (this.currentCeramicFilter !== "all") {
      filters.push(["==", ["get", this.currentCeramicFilter], 1]);
    }
    if (this.currentSiteTypeFilter !== "all") {
      filters.push(["==", ["get", "siteType"], this.currentSiteTypeFilter]);
    }
    let finalFilter = ["all", ...filters];
    this.map.setFilter("points", finalFilter);
  }
  updatePointColors() {
    if (!this.map) return;
    const color = CERAMIC_COLORS[this.currentCeramicFilter] || CERAMIC_COLORS.all;
    this.map.setPaintProperty("points", "circle-color", color);
  }
  async getPlacesSource() {
    while (true) {
      if (this.map) {
        const source = this.map.getSource("places");
        if (source !== void 0) {
          return source;
        }
      }
      await new Promise((resolve) => setTimeout(resolve, 100));
    }
  }
  async showFeatures(collection) {
    const source = await this.getPlacesSource();
    source.setData(collection);
    if (this.map) {
      if (collection.features.length > 0) {
        const extent = turf_bbox_default(collection);
        this.map.fitBounds(extent, { padding: 150 });
      } else {
        this.map.flyTo({ center: DEFAULT_CENTER, zoom: DEFAULT_ZOOM });
      }
    }
  }
};
customElements.define("tile-map", TileMap);

// src/ceramic-explorer.ts
var _currentSiteType_dec, _currentCeramicType_dec, _currentPeriod_dec, _loading_dec, _sites_dec, _a5, _CeramicExplorer_decorators, _init4;
_CeramicExplorer_decorators = [t3("ceramic-explorer")];
var CeramicExplorer = class extends (_a5 = r4, _sites_dec = [r6()], _loading_dec = [r6()], _currentPeriod_dec = [r6()], _currentCeramicType_dec = [r6()], _currentSiteType_dec = [r6()], _a5) {
  constructor() {
    super(...arguments);
    __publicField(this, "sites", __runInitializers(_init4, 8, this, [])), __runInitializers(_init4, 11, this);
    __publicField(this, "loading", __runInitializers(_init4, 12, this, true)), __runInitializers(_init4, 15, this);
    __publicField(this, "currentPeriod", __runInitializers(_init4, 16, this, "all")), __runInitializers(_init4, 19, this);
    __publicField(this, "currentCeramicType", __runInitializers(_init4, 20, this, "all")), __runInitializers(_init4, 23, this);
    __publicField(this, "currentSiteType", __runInitializers(_init4, 24, this, "all")), __runInitializers(_init4, 27, this);
  }
  async firstUpdated() {
    try {
      this.sites = await loadSiteData();
      const map = this.shadowRoot?.querySelector("tile-map");
      if (map) {
        const geoJSON = sitesToGeoJSON(this.sites);
        await map.showFeatures(geoJSON);
      }
      this.loading = false;
    } catch (error) {
      console.error("\u52A0\u8F7D\u6570\u636E\u5931\u8D25:", error);
      this.loading = false;
    }
  }
  handlePeriodChange(e5) {
    this.currentPeriod = e5.detail.period;
    this.updateMap();
  }
  handleCeramicFilterChange(e5) {
    this.currentCeramicType = e5.detail.type;
    this.updateMap();
  }
  handleSiteFilterChange(e5) {
    this.currentSiteType = e5.detail.type;
    this.updateMap();
  }
  updateMap() {
    const map = this.shadowRoot?.querySelector("tile-map");
    if (!map) return;
    let filteredSites = this.sites;
    if (this.currentPeriod !== "all") {
      filteredSites = filteredSites.filter(
        (site) => site.periods.includes(this.currentPeriod)
      );
    }
    if (this.currentCeramicType !== "all") {
      filteredSites = filteredSites.filter(
        (site) => site.ceramics[this.currentCeramicType] === 1
      );
    }
    if (this.currentSiteType !== "all") {
      filteredSites = filteredSites.filter(
        (site) => site.siteType === this.currentSiteType || site.analysisType === this.currentSiteType
      );
    }
    const geoJSON = sitesToGeoJSON(filteredSites);
    map.showFeatures(geoJSON);
  }
  render() {
    if (this.loading) {
      return x`<div class="loading">加载数据中...</div>`;
    }
    return x`
      <div class="header">
        <h1>伊比利亚半岛陶瓷分布时间序列可视化</h1>
      </div>
      
      <div class="main-content">
        <div class="sidebar">
          <time-slider 
            @period-change=${this.handlePeriodChange}
          ></time-slider>
          
          <ceramic-filter
            @ceramic-filter-change=${this.handleCeramicFilterChange}
          ></ceramic-filter>
          
          <site-type-filter
            @site-filter-change=${this.handleSiteFilterChange}
          ></site-type-filter>
        </div>
        
        <div class="map-container">
          <tile-map id="main-map"></tile-map>
        </div>
      </div>
    `;
  }
};
_init4 = __decoratorStart(_a5);
__decorateElement(_init4, 5, "sites", _sites_dec, CeramicExplorer);
__decorateElement(_init4, 5, "loading", _loading_dec, CeramicExplorer);
__decorateElement(_init4, 5, "currentPeriod", _currentPeriod_dec, CeramicExplorer);
__decorateElement(_init4, 5, "currentCeramicType", _currentCeramicType_dec, CeramicExplorer);
__decorateElement(_init4, 5, "currentSiteType", _currentSiteType_dec, CeramicExplorer);
CeramicExplorer = __decorateElement(_init4, 0, "CeramicExplorer", _CeramicExplorer_decorators, CeramicExplorer);
__publicField(CeramicExplorer, "styles", i`
    :host {
      display: block;
      height: 100vh;
      width: 100%;
      display: flex;
      flex-direction: column;
    }
    
    .header {
      background: #4b6cb7;
      color: white;
      padding: 1rem;
      display: flex;
      justify-content: center;
      align-items: center;
    }
    
    .main-content {
      flex: 1;
      display: flex;
      overflow: hidden;
    }
    
    .map-container {
      flex: 1;
      height: 100%;
    }
    
    .sidebar {
      width: 300px;
      background: #f5f5f5;
      overflow-y: auto;
      display: flex;
      flex-direction: column;
      gap: 1rem;
      padding: 1rem 0;
    }
    
    .loading {
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100%;
      font-size: 1.2rem;
    }
  `);
__runInitializers(_init4, 1, CeramicExplorer);

// src/index.ts
function main() {
  console.log("\u5E94\u7528\u5DF2\u52A0\u8F7D");
}
main();
/*! Bundled license information:

maplibre-gl/dist/maplibre-gl.js:
  (**
   * MapLibre GL JS
   * @license 3-Clause BSD. Full text of license: https://github.com/maplibre/maplibre-gl-js/blob/v5.3.0/LICENSE.txt
   *)

@lit/reactive-element/css-tag.js:
  (**
   * @license
   * Copyright 2019 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/reactive-element.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

lit-html/lit-html.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

lit-element/lit-element.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

lit-html/is-server.js:
  (**
   * @license
   * Copyright 2022 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/decorators/custom-element.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/decorators/property.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/decorators/state.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/decorators/event-options.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/decorators/base.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/decorators/query.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/decorators/query-all.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/decorators/query-async.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/decorators/query-assigned-elements.js:
  (**
   * @license
   * Copyright 2021 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/decorators/query-assigned-nodes.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)
*/
//# sourceMappingURL=index.js.map
