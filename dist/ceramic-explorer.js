"use strict";
(() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __esm = (fn, res) => function __init() {
    return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
  };
  var __commonJS = (cb, mod) => function __require() {
    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __export = (target, all) => {
    for (var name in all)
      __defProp(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
    // If the importer is in node compatibility mode or this is not an ESM
    // file that has been converted to a CommonJS file using a Babel-
    // compatible transform (i.e. "__esModule" has not been set), then set
    // "default" to the CommonJS "module.exports" for node compatibility.
    isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
    mod
  ));
  var __decorateClass = (decorators, target, key, kind) => {
    var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc(target, key) : target;
    for (var i5 = decorators.length - 1, decorator; i5 >= 0; i5--)
      if (decorator = decorators[i5])
        result = (kind ? decorator(target, key, result) : decorator(result)) || result;
    if (kind && result) __defProp(target, key, result);
    return result;
  };

  // ../node_modules/oxigraph/web.js
  var web_exports = {};
  __export(web_exports, {
    BlankNode: () => BlankNode,
    DefaultGraph: () => DefaultGraph,
    Literal: () => Literal,
    NamedNode: () => NamedNode,
    Quad: () => Quad,
    Store: () => Store,
    Variable: () => Variable,
    blankNode: () => blankNode,
    default: () => web_default,
    defaultGraph: () => defaultGraph,
    fromQuad: () => fromQuad,
    fromTerm: () => fromTerm,
    initSync: () => initSync,
    literal: () => literal,
    main: () => main,
    namedNode: () => namedNode,
    quad: () => quad,
    triple: () => triple,
    variable: () => variable
  });
  function addToExternrefTable0(obj) {
    const idx = wasm.__externref_table_alloc();
    wasm.__wbindgen_export_2.set(idx, obj);
    return idx;
  }
  function handleError(f3, args) {
    try {
      return f3.apply(this, args);
    } catch (e6) {
      const idx = addToExternrefTable0(e6);
      wasm.__wbindgen_exn_store(idx);
    }
  }
  function getUint8ArrayMemory0() {
    if (cachedUint8ArrayMemory0 === null || cachedUint8ArrayMemory0.byteLength === 0) {
      cachedUint8ArrayMemory0 = new Uint8Array(wasm.memory.buffer);
    }
    return cachedUint8ArrayMemory0;
  }
  function getStringFromWasm0(ptr, len) {
    ptr = ptr >>> 0;
    return cachedTextDecoder.decode(getUint8ArrayMemory0().subarray(ptr, ptr + len));
  }
  function passStringToWasm0(arg, malloc, realloc) {
    if (realloc === void 0) {
      const buf = cachedTextEncoder.encode(arg);
      const ptr2 = malloc(buf.length, 1) >>> 0;
      getUint8ArrayMemory0().subarray(ptr2, ptr2 + buf.length).set(buf);
      WASM_VECTOR_LEN = buf.length;
      return ptr2;
    }
    let len = arg.length;
    let ptr = malloc(len, 1) >>> 0;
    const mem = getUint8ArrayMemory0();
    let offset = 0;
    for (; offset < len; offset++) {
      const code = arg.charCodeAt(offset);
      if (code > 127) break;
      mem[ptr + offset] = code;
    }
    if (offset !== len) {
      if (offset !== 0) {
        arg = arg.slice(offset);
      }
      ptr = realloc(ptr, len, len = offset + arg.length * 3, 1) >>> 0;
      const view = getUint8ArrayMemory0().subarray(ptr + offset, ptr + len);
      const ret = encodeString(arg, view);
      offset += ret.written;
      ptr = realloc(ptr, len, offset, 1) >>> 0;
    }
    WASM_VECTOR_LEN = offset;
    return ptr;
  }
  function getDataViewMemory0() {
    if (cachedDataViewMemory0 === null || cachedDataViewMemory0.buffer.detached === true || cachedDataViewMemory0.buffer.detached === void 0 && cachedDataViewMemory0.buffer !== wasm.memory.buffer) {
      cachedDataViewMemory0 = new DataView(wasm.memory.buffer);
    }
    return cachedDataViewMemory0;
  }
  function isLikeNone(x3) {
    return x3 === void 0 || x3 === null;
  }
  function takeFromExternrefTable0(idx) {
    const value = wasm.__wbindgen_export_2.get(idx);
    wasm.__externref_table_dealloc(idx);
    return value;
  }
  function namedNode(value) {
    const ptr0 = passStringToWasm0(value, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
    const len0 = WASM_VECTOR_LEN;
    const ret = wasm.namedNode(ptr0, len0);
    if (ret[2]) {
      throw takeFromExternrefTable0(ret[1]);
    }
    return NamedNode.__wrap(ret[0]);
  }
  function blankNode(value) {
    var ptr0 = isLikeNone(value) ? 0 : passStringToWasm0(value, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
    var len0 = WASM_VECTOR_LEN;
    const ret = wasm.blankNode(ptr0, len0);
    if (ret[2]) {
      throw takeFromExternrefTable0(ret[1]);
    }
    return BlankNode.__wrap(ret[0]);
  }
  function literal(value, language_or_datatype) {
    var ptr0 = isLikeNone(value) ? 0 : passStringToWasm0(value, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
    var len0 = WASM_VECTOR_LEN;
    const ret = wasm.literal(ptr0, len0, language_or_datatype);
    if (ret[2]) {
      throw takeFromExternrefTable0(ret[1]);
    }
    return Literal.__wrap(ret[0]);
  }
  function defaultGraph() {
    const ret = wasm.defaultGraph();
    return DefaultGraph.__wrap(ret);
  }
  function variable(value) {
    const ptr0 = passStringToWasm0(value, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
    const len0 = WASM_VECTOR_LEN;
    const ret = wasm.variable(ptr0, len0);
    if (ret[2]) {
      throw takeFromExternrefTable0(ret[1]);
    }
    return Variable.__wrap(ret[0]);
  }
  function triple(subject, predicate, object) {
    const ret = wasm.triple(subject, predicate, object);
    if (ret[2]) {
      throw takeFromExternrefTable0(ret[1]);
    }
    return Quad.__wrap(ret[0]);
  }
  function quad(subject, predicate, object, graph) {
    const ret = wasm.quad(subject, predicate, object, graph);
    if (ret[2]) {
      throw takeFromExternrefTable0(ret[1]);
    }
    return Quad.__wrap(ret[0]);
  }
  function fromTerm(original) {
    const ret = wasm.fromTerm(original);
    if (ret[2]) {
      throw takeFromExternrefTable0(ret[1]);
    }
    return takeFromExternrefTable0(ret[0]);
  }
  function fromQuad(original) {
    const ret = wasm.fromQuad(original);
    if (ret[2]) {
      throw takeFromExternrefTable0(ret[1]);
    }
    return takeFromExternrefTable0(ret[0]);
  }
  function getArrayJsValueFromWasm0(ptr, len) {
    ptr = ptr >>> 0;
    const mem = getDataViewMemory0();
    const result = [];
    for (let i5 = ptr; i5 < ptr + 4 * len; i5 += 4) {
      result.push(wasm.__wbindgen_export_2.get(mem.getUint32(i5, true)));
    }
    wasm.__externref_drop_slice(ptr, len);
    return result;
  }
  function main() {
    wasm.main();
  }
  async function __wbg_load(module2, imports) {
    if (typeof Response === "function" && module2 instanceof Response) {
      if (typeof WebAssembly.instantiateStreaming === "function") {
        try {
          return await WebAssembly.instantiateStreaming(module2, imports);
        } catch (e6) {
          if (module2.headers.get("Content-Type") != "application/wasm") {
            console.warn("`WebAssembly.instantiateStreaming` failed because your server does not serve Wasm with `application/wasm` MIME type. Falling back to `WebAssembly.instantiate` which is slower. Original error:\n", e6);
          } else {
            throw e6;
          }
        }
      }
      const bytes = await module2.arrayBuffer();
      return await WebAssembly.instantiate(bytes, imports);
    } else {
      const instance = await WebAssembly.instantiate(module2, imports);
      if (instance instanceof WebAssembly.Instance) {
        return { instance, module: module2 };
      } else {
        return instance;
      }
    }
  }
  function __wbg_get_imports() {
    const imports = {};
    imports.wbg = {};
    imports.wbg.__wbg_blanknode_new = function(arg0) {
      const ret = BlankNode.__wrap(arg0);
      return ret;
    };
    imports.wbg.__wbg_buffer_609cc3eee51ed158 = function(arg0) {
      const ret = arg0.buffer;
      return ret;
    };
    imports.wbg.__wbg_call_672a4d21634d4a24 = function() {
      return handleError(function(arg0, arg1) {
        const ret = arg0.call(arg1);
        return ret;
      }, arguments);
    };
    imports.wbg.__wbg_call_7cccdd69e0791ae2 = function() {
      return handleError(function(arg0, arg1, arg2) {
        const ret = arg0.call(arg1, arg2);
        return ret;
      }, arguments);
    };
    imports.wbg.__wbg_crypto_ed58b8e10a292839 = function(arg0) {
      const ret = arg0.crypto;
      return ret;
    };
    imports.wbg.__wbg_defaultgraph_new = function(arg0) {
      const ret = DefaultGraph.__wrap(arg0);
      return ret;
    };
    imports.wbg.__wbg_done_769e5ede4b31c67b = function(arg0) {
      const ret = arg0.done;
      return ret;
    };
    imports.wbg.__wbg_error_7534b8e9a36f1ab4 = function(arg0, arg1) {
      let deferred0_0;
      let deferred0_1;
      try {
        deferred0_0 = arg0;
        deferred0_1 = arg1;
        console.error(getStringFromWasm0(arg0, arg1));
      } finally {
        wasm.__wbindgen_free(deferred0_0, deferred0_1, 1);
      }
    };
    imports.wbg.__wbg_getRandomValues_bcb4912f16000dc4 = function() {
      return handleError(function(arg0, arg1) {
        arg0.getRandomValues(arg1);
      }, arguments);
    };
    imports.wbg.__wbg_get_67b2ba62fc30de12 = function() {
      return handleError(function(arg0, arg1) {
        const ret = Reflect.get(arg0, arg1);
        return ret;
      }, arguments);
    };
    imports.wbg.__wbg_has_a5ea9117f258a0ec = function() {
      return handleError(function(arg0, arg1) {
        const ret = Reflect.has(arg0, arg1);
        return ret;
      }, arguments);
    };
    imports.wbg.__wbg_iterator_9a24c88df860dc65 = function() {
      const ret = Symbol.iterator;
      return ret;
    };
    imports.wbg.__wbg_literal_new = function(arg0) {
      const ret = Literal.__wrap(arg0);
      return ret;
    };
    imports.wbg.__wbg_msCrypto_0a36e2ec3a343d26 = function(arg0) {
      const ret = arg0.msCrypto;
      return ret;
    };
    imports.wbg.__wbg_namednode_new = function(arg0) {
      const ret = NamedNode.__wrap(arg0);
      return ret;
    };
    imports.wbg.__wbg_new_232bf76aa774bea9 = function(arg0, arg1) {
      const ret = new URIError(getStringFromWasm0(arg0, arg1));
      return ret;
    };
    imports.wbg.__wbg_new_5e0be73521bc8c17 = function() {
      const ret = /* @__PURE__ */ new Map();
      return ret;
    };
    imports.wbg.__wbg_new_78feb108b6472713 = function() {
      const ret = new Array();
      return ret;
    };
    imports.wbg.__wbg_new_8a6f238a6ece86ea = function() {
      const ret = new Error();
      return ret;
    };
    imports.wbg.__wbg_new_a12002a7f91c75be = function(arg0) {
      const ret = new Uint8Array(arg0);
      return ret;
    };
    imports.wbg.__wbg_new_c68d7209be747379 = function(arg0, arg1) {
      const ret = new Error(getStringFromWasm0(arg0, arg1));
      return ret;
    };
    imports.wbg.__wbg_newnoargs_105ed471475aaf50 = function(arg0, arg1) {
      const ret = new Function(getStringFromWasm0(arg0, arg1));
      return ret;
    };
    imports.wbg.__wbg_newwithbyteoffsetandlength_d97e637ebe145a9a = function(arg0, arg1, arg2) {
      const ret = new Uint8Array(arg0, arg1 >>> 0, arg2 >>> 0);
      return ret;
    };
    imports.wbg.__wbg_newwithlength_a381634e90c276d4 = function(arg0) {
      const ret = new Uint8Array(arg0 >>> 0);
      return ret;
    };
    imports.wbg.__wbg_next_25feadfc0913fea9 = function(arg0) {
      const ret = arg0.next;
      return ret;
    };
    imports.wbg.__wbg_next_6574e1a8a62d1055 = function() {
      return handleError(function(arg0) {
        const ret = arg0.next();
        return ret;
      }, arguments);
    };
    imports.wbg.__wbg_node_02999533c4ea02e3 = function(arg0) {
      const ret = arg0.node;
      return ret;
    };
    imports.wbg.__wbg_now_807e54c39636c349 = function() {
      const ret = Date.now();
      return ret;
    };
    imports.wbg.__wbg_process_5c1d670bc53614b8 = function(arg0) {
      const ret = arg0.process;
      return ret;
    };
    imports.wbg.__wbg_push_737cfc8c1432c2c6 = function(arg0, arg1) {
      const ret = arg0.push(arg1);
      return ret;
    };
    imports.wbg.__wbg_quad_new = function(arg0) {
      const ret = Quad.__wrap(arg0);
      return ret;
    };
    imports.wbg.__wbg_randomFillSync_ab2cfe79ebbf2740 = function() {
      return handleError(function(arg0, arg1) {
        arg0.randomFillSync(arg1);
      }, arguments);
    };
    imports.wbg.__wbg_require_79b1e9274cde3c87 = function() {
      return handleError(function() {
        const ret = module.require;
        return ret;
      }, arguments);
    };
    imports.wbg.__wbg_set_65595bdd868b3009 = function(arg0, arg1, arg2) {
      arg0.set(arg1, arg2 >>> 0);
    };
    imports.wbg.__wbg_set_8fc6bf8a5b1071d1 = function(arg0, arg1, arg2) {
      const ret = arg0.set(arg1, arg2);
      return ret;
    };
    imports.wbg.__wbg_stack_0ed75d68575b0f3c = function(arg0, arg1) {
      const ret = arg1.stack;
      const ptr1 = passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
      const len1 = WASM_VECTOR_LEN;
      getDataViewMemory0().setInt32(arg0 + 4 * 1, len1, true);
      getDataViewMemory0().setInt32(arg0 + 4 * 0, ptr1, true);
    };
    imports.wbg.__wbg_static_accessor_GLOBAL_88a902d13a557d07 = function() {
      const ret = typeof global === "undefined" ? null : global;
      return isLikeNone(ret) ? 0 : addToExternrefTable0(ret);
    };
    imports.wbg.__wbg_static_accessor_GLOBAL_THIS_56578be7e9f832b0 = function() {
      const ret = typeof globalThis === "undefined" ? null : globalThis;
      return isLikeNone(ret) ? 0 : addToExternrefTable0(ret);
    };
    imports.wbg.__wbg_static_accessor_SELF_37c5d418e4bf5819 = function() {
      const ret = typeof self === "undefined" ? null : self;
      return isLikeNone(ret) ? 0 : addToExternrefTable0(ret);
    };
    imports.wbg.__wbg_static_accessor_WINDOW_5de37043a91a9c40 = function() {
      const ret = typeof window === "undefined" ? null : window;
      return isLikeNone(ret) ? 0 : addToExternrefTable0(ret);
    };
    imports.wbg.__wbg_subarray_aa9065fa9dc5df96 = function(arg0, arg1, arg2) {
      const ret = arg0.subarray(arg1 >>> 0, arg2 >>> 0);
      return ret;
    };
    imports.wbg.__wbg_value_cd1ffa7b1ab794f1 = function(arg0) {
      const ret = arg0.value;
      return ret;
    };
    imports.wbg.__wbg_variable_new = function(arg0) {
      const ret = Variable.__wrap(arg0);
      return ret;
    };
    imports.wbg.__wbg_versions_c71aa1626a93e0a1 = function(arg0) {
      const ret = arg0.versions;
      return ret;
    };
    imports.wbg.__wbg_warn_eb0bc5894227877a = function(arg0, arg1) {
      console.warn(getStringFromWasm0(arg0, arg1));
    };
    imports.wbg.__wbindgen_error_new = function(arg0, arg1) {
      const ret = new Error(getStringFromWasm0(arg0, arg1));
      return ret;
    };
    imports.wbg.__wbindgen_init_externref_table = function() {
      const table = wasm.__wbindgen_export_2;
      const offset = table.grow(4);
      table.set(0, void 0);
      table.set(offset + 0, void 0);
      table.set(offset + 1, null);
      table.set(offset + 2, true);
      table.set(offset + 3, false);
      ;
    };
    imports.wbg.__wbindgen_is_falsy = function(arg0) {
      const ret = !arg0;
      return ret;
    };
    imports.wbg.__wbindgen_is_function = function(arg0) {
      const ret = typeof arg0 === "function";
      return ret;
    };
    imports.wbg.__wbindgen_is_null = function(arg0) {
      const ret = arg0 === null;
      return ret;
    };
    imports.wbg.__wbindgen_is_object = function(arg0) {
      const val = arg0;
      const ret = typeof val === "object" && val !== null;
      return ret;
    };
    imports.wbg.__wbindgen_is_string = function(arg0) {
      const ret = typeof arg0 === "string";
      return ret;
    };
    imports.wbg.__wbindgen_is_undefined = function(arg0) {
      const ret = arg0 === void 0;
      return ret;
    };
    imports.wbg.__wbindgen_memory = function() {
      const ret = wasm.memory;
      return ret;
    };
    imports.wbg.__wbindgen_string_get = function(arg0, arg1) {
      const obj = arg1;
      const ret = typeof obj === "string" ? obj : void 0;
      var ptr1 = isLikeNone(ret) ? 0 : passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
      var len1 = WASM_VECTOR_LEN;
      getDataViewMemory0().setInt32(arg0 + 4 * 1, len1, true);
      getDataViewMemory0().setInt32(arg0 + 4 * 0, ptr1, true);
    };
    imports.wbg.__wbindgen_string_new = function(arg0, arg1) {
      const ret = getStringFromWasm0(arg0, arg1);
      return ret;
    };
    imports.wbg.__wbindgen_throw = function(arg0, arg1) {
      throw new Error(getStringFromWasm0(arg0, arg1));
    };
    return imports;
  }
  function __wbg_init_memory(imports, memory) {
  }
  function __wbg_finalize_init(instance, module2) {
    wasm = instance.exports;
    __wbg_init.__wbindgen_wasm_module = module2;
    cachedDataViewMemory0 = null;
    cachedUint8ArrayMemory0 = null;
    wasm.__wbindgen_start();
    return wasm;
  }
  function initSync(module2) {
    if (wasm !== void 0) return wasm;
    if (typeof module2 !== "undefined") {
      if (Object.getPrototypeOf(module2) === Object.prototype) {
        ({ module: module2 } = module2);
      } else {
        console.warn("using deprecated parameters for `initSync()`; pass a single object instead");
      }
    }
    const imports = __wbg_get_imports();
    __wbg_init_memory(imports);
    if (!(module2 instanceof WebAssembly.Module)) {
      module2 = new WebAssembly.Module(module2);
    }
    const instance = new WebAssembly.Instance(module2, imports);
    return __wbg_finalize_init(instance, module2);
  }
  async function __wbg_init(module_or_path) {
    if (wasm !== void 0) return wasm;
    if (typeof module_or_path !== "undefined") {
      if (Object.getPrototypeOf(module_or_path) === Object.prototype) {
        ({ module_or_path } = module_or_path);
      } else {
        console.warn("using deprecated parameters for the initialization function; pass a single object instead");
      }
    }
    if (typeof module_or_path === "undefined") {
      module_or_path = new URL("web_bg.wasm", import_meta.url);
    }
    const imports = __wbg_get_imports();
    if (typeof module_or_path === "string" || typeof Request === "function" && module_or_path instanceof Request || typeof URL === "function" && module_or_path instanceof URL) {
      module_or_path = fetch(module_or_path);
    }
    __wbg_init_memory(imports);
    const { instance, module: module2 } = await __wbg_load(await module_or_path, imports);
    return __wbg_finalize_init(instance, module2);
  }
  var import_meta, wasm, cachedTextDecoder, cachedUint8ArrayMemory0, WASM_VECTOR_LEN, cachedTextEncoder, encodeString, cachedDataViewMemory0, BlankNodeFinalization, BlankNode, DefaultGraphFinalization, DefaultGraph, LiteralFinalization, Literal, NamedNodeFinalization, NamedNode, QuadFinalization, Quad, StoreFinalization, Store, VariableFinalization, Variable, web_default;
  var init_web = __esm({
    "../node_modules/oxigraph/web.js"() {
      import_meta = {};
      cachedTextDecoder = typeof TextDecoder !== "undefined" ? new TextDecoder("utf-8", { ignoreBOM: true, fatal: true }) : { decode: () => {
        throw Error("TextDecoder not available");
      } };
      if (typeof TextDecoder !== "undefined") {
        cachedTextDecoder.decode();
      }
      cachedUint8ArrayMemory0 = null;
      WASM_VECTOR_LEN = 0;
      cachedTextEncoder = typeof TextEncoder !== "undefined" ? new TextEncoder("utf-8") : { encode: () => {
        throw Error("TextEncoder not available");
      } };
      encodeString = typeof cachedTextEncoder.encodeInto === "function" ? function(arg, view) {
        return cachedTextEncoder.encodeInto(arg, view);
      } : function(arg, view) {
        const buf = cachedTextEncoder.encode(arg);
        view.set(buf);
        return {
          read: arg.length,
          written: buf.length
        };
      };
      cachedDataViewMemory0 = null;
      BlankNodeFinalization = typeof FinalizationRegistry === "undefined" ? { register: () => {
      }, unregister: () => {
      } } : new FinalizationRegistry((ptr) => wasm.__wbg_blanknode_free(ptr >>> 0, 1));
      BlankNode = class _BlankNode {
        static __wrap(ptr) {
          ptr = ptr >>> 0;
          const obj = Object.create(_BlankNode.prototype);
          obj.__wbg_ptr = ptr;
          BlankNodeFinalization.register(obj, obj.__wbg_ptr, obj);
          return obj;
        }
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          BlankNodeFinalization.unregister(this);
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm.__wbg_blanknode_free(ptr, 0);
        }
        /**
         * @returns {string}
         */
        get termType() {
          let deferred1_0;
          let deferred1_1;
          try {
            const ret = wasm.blanknode_term_type(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
          } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
          }
        }
        /**
         * @returns {string}
         */
        get value() {
          let deferred1_0;
          let deferred1_1;
          try {
            const ret = wasm.blanknode_value(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
          } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
          }
        }
        /**
         * @returns {string}
         */
        toString() {
          let deferred1_0;
          let deferred1_1;
          try {
            const ret = wasm.blanknode_toString(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
          } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
          }
        }
        /**
         * @param {any} other
         * @returns {boolean}
         */
        equals(other) {
          const ret = wasm.blanknode_equals(this.__wbg_ptr, other);
          return ret !== 0;
        }
      };
      DefaultGraphFinalization = typeof FinalizationRegistry === "undefined" ? { register: () => {
      }, unregister: () => {
      } } : new FinalizationRegistry((ptr) => wasm.__wbg_defaultgraph_free(ptr >>> 0, 1));
      DefaultGraph = class _DefaultGraph {
        static __wrap(ptr) {
          ptr = ptr >>> 0;
          const obj = Object.create(_DefaultGraph.prototype);
          obj.__wbg_ptr = ptr;
          DefaultGraphFinalization.register(obj, obj.__wbg_ptr, obj);
          return obj;
        }
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          DefaultGraphFinalization.unregister(this);
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm.__wbg_defaultgraph_free(ptr, 0);
        }
        /**
         * @returns {string}
         */
        get termType() {
          let deferred1_0;
          let deferred1_1;
          try {
            const ret = wasm.defaultgraph_term_type(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
          } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
          }
        }
        /**
         * @returns {string}
         */
        get value() {
          let deferred1_0;
          let deferred1_1;
          try {
            const ret = wasm.defaultgraph_value(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
          } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
          }
        }
        /**
         * @returns {string}
         */
        toString() {
          let deferred1_0;
          let deferred1_1;
          try {
            const ret = wasm.defaultgraph_toString(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
          } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
          }
        }
        /**
         * @param {any} other
         * @returns {boolean}
         */
        equals(other) {
          const ret = wasm.defaultgraph_equals(this.__wbg_ptr, other);
          return ret !== 0;
        }
      };
      LiteralFinalization = typeof FinalizationRegistry === "undefined" ? { register: () => {
      }, unregister: () => {
      } } : new FinalizationRegistry((ptr) => wasm.__wbg_literal_free(ptr >>> 0, 1));
      Literal = class _Literal {
        static __wrap(ptr) {
          ptr = ptr >>> 0;
          const obj = Object.create(_Literal.prototype);
          obj.__wbg_ptr = ptr;
          LiteralFinalization.register(obj, obj.__wbg_ptr, obj);
          return obj;
        }
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          LiteralFinalization.unregister(this);
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm.__wbg_literal_free(ptr, 0);
        }
        /**
         * @returns {string}
         */
        get termType() {
          let deferred1_0;
          let deferred1_1;
          try {
            const ret = wasm.literal_term_type(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
          } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
          }
        }
        /**
         * @returns {string}
         */
        get value() {
          let deferred1_0;
          let deferred1_1;
          try {
            const ret = wasm.literal_value(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
          } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
          }
        }
        /**
         * @returns {string}
         */
        get language() {
          let deferred1_0;
          let deferred1_1;
          try {
            const ret = wasm.literal_language(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
          } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
          }
        }
        /**
         * @returns {NamedNode}
         */
        get datatype() {
          const ret = wasm.literal_datatype(this.__wbg_ptr);
          return NamedNode.__wrap(ret);
        }
        /**
         * @returns {string}
         */
        toString() {
          let deferred1_0;
          let deferred1_1;
          try {
            const ret = wasm.literal_toString(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
          } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
          }
        }
        /**
         * @param {any} other
         * @returns {boolean}
         */
        equals(other) {
          const ret = wasm.literal_equals(this.__wbg_ptr, other);
          return ret !== 0;
        }
      };
      NamedNodeFinalization = typeof FinalizationRegistry === "undefined" ? { register: () => {
      }, unregister: () => {
      } } : new FinalizationRegistry((ptr) => wasm.__wbg_namednode_free(ptr >>> 0, 1));
      NamedNode = class _NamedNode {
        static __wrap(ptr) {
          ptr = ptr >>> 0;
          const obj = Object.create(_NamedNode.prototype);
          obj.__wbg_ptr = ptr;
          NamedNodeFinalization.register(obj, obj.__wbg_ptr, obj);
          return obj;
        }
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          NamedNodeFinalization.unregister(this);
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm.__wbg_namednode_free(ptr, 0);
        }
        /**
         * @returns {string}
         */
        get termType() {
          let deferred1_0;
          let deferred1_1;
          try {
            const ret = wasm.namednode_term_type(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
          } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
          }
        }
        /**
         * @returns {string}
         */
        get value() {
          let deferred1_0;
          let deferred1_1;
          try {
            const ret = wasm.namednode_value(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
          } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
          }
        }
        /**
         * @returns {string}
         */
        toString() {
          let deferred1_0;
          let deferred1_1;
          try {
            const ret = wasm.namednode_toString(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
          } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
          }
        }
        /**
         * @param {any} other
         * @returns {boolean}
         */
        equals(other) {
          const ret = wasm.namednode_equals(this.__wbg_ptr, other);
          return ret !== 0;
        }
      };
      QuadFinalization = typeof FinalizationRegistry === "undefined" ? { register: () => {
      }, unregister: () => {
      } } : new FinalizationRegistry((ptr) => wasm.__wbg_quad_free(ptr >>> 0, 1));
      Quad = class _Quad {
        static __wrap(ptr) {
          ptr = ptr >>> 0;
          const obj = Object.create(_Quad.prototype);
          obj.__wbg_ptr = ptr;
          QuadFinalization.register(obj, obj.__wbg_ptr, obj);
          return obj;
        }
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          QuadFinalization.unregister(this);
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm.__wbg_quad_free(ptr, 0);
        }
        /**
         * @returns {string}
         */
        get termType() {
          let deferred1_0;
          let deferred1_1;
          try {
            const ret = wasm.quad_term_type(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
          } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
          }
        }
        /**
         * @returns {string}
         */
        get value() {
          let deferred1_0;
          let deferred1_1;
          try {
            const ret = wasm.quad_value(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
          } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
          }
        }
        /**
         * @returns {any}
         */
        get subject() {
          const ret = wasm.quad_subject(this.__wbg_ptr);
          return ret;
        }
        /**
         * @returns {any}
         */
        get predicate() {
          const ret = wasm.quad_predicate(this.__wbg_ptr);
          return ret;
        }
        /**
         * @returns {any}
         */
        get object() {
          const ret = wasm.quad_object(this.__wbg_ptr);
          return ret;
        }
        /**
         * @returns {any}
         */
        get graph() {
          const ret = wasm.quad_graph(this.__wbg_ptr);
          return ret;
        }
        /**
         * @returns {string}
         */
        toString() {
          let deferred1_0;
          let deferred1_1;
          try {
            const ret = wasm.quad_toString(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
          } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
          }
        }
        /**
         * @param {any} other
         * @returns {boolean}
         */
        equals(other) {
          const ret = wasm.quad_equals(this.__wbg_ptr, other);
          return ret !== 0;
        }
      };
      StoreFinalization = typeof FinalizationRegistry === "undefined" ? { register: () => {
      }, unregister: () => {
      } } : new FinalizationRegistry((ptr) => wasm.__wbg_store_free(ptr >>> 0, 1));
      Store = class {
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          StoreFinalization.unregister(this);
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm.__wbg_store_free(ptr, 0);
        }
        /**
         * @param {any} quads
         */
        constructor(quads) {
          const ret = wasm.store_new(quads);
          if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
          }
          this.__wbg_ptr = ret[0] >>> 0;
          StoreFinalization.register(this, this.__wbg_ptr, this);
          return this;
        }
        /**
         * @param {any} quad
         */
        add(quad2) {
          const ret = wasm.store_add(this.__wbg_ptr, quad2);
          if (ret[1]) {
            throw takeFromExternrefTable0(ret[0]);
          }
        }
        /**
         * @param {any} quad
         */
        delete(quad2) {
          const ret = wasm.store_delete(this.__wbg_ptr, quad2);
          if (ret[1]) {
            throw takeFromExternrefTable0(ret[0]);
          }
        }
        /**
         * @param {any} quad
         * @returns {boolean}
         */
        has(quad2) {
          const ret = wasm.store_has(this.__wbg_ptr, quad2);
          if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
          }
          return ret[0] !== 0;
        }
        /**
         * @returns {number}
         */
        get size() {
          const ret = wasm.store_size(this.__wbg_ptr);
          if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
          }
          return ret[0] >>> 0;
        }
        /**
         * @param {any} subject
         * @param {any} predicate
         * @param {any} object
         * @param {any} graph_name
         * @returns {any[]}
         */
        match(subject, predicate, object, graph_name) {
          const ret = wasm.store_match(this.__wbg_ptr, subject, predicate, object, graph_name);
          if (ret[3]) {
            throw takeFromExternrefTable0(ret[2]);
          }
          var v1 = getArrayJsValueFromWasm0(ret[0], ret[1]).slice();
          wasm.__wbindgen_free(ret[0], ret[1] * 4, 4);
          return v1;
        }
        /**
         * @param {string} query
         * @param {any} options
         * @returns {any}
         */
        query(query, options) {
          const ptr0 = passStringToWasm0(query, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
          const len0 = WASM_VECTOR_LEN;
          const ret = wasm.store_query(this.__wbg_ptr, ptr0, len0, options);
          if (ret[2]) {
            throw takeFromExternrefTable0(ret[1]);
          }
          return takeFromExternrefTable0(ret[0]);
        }
        /**
         * @param {string} update
         * @param {any} options
         */
        update(update, options) {
          const ptr0 = passStringToWasm0(update, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
          const len0 = WASM_VECTOR_LEN;
          const ret = wasm.store_update(this.__wbg_ptr, ptr0, len0, options);
          if (ret[1]) {
            throw takeFromExternrefTable0(ret[0]);
          }
        }
        /**
         * @param {string} data
         * @param {any} options
         * @param {any} base_iri
         * @param {any} to_graph_name
         */
        load(data, options, base_iri, to_graph_name) {
          const ptr0 = passStringToWasm0(data, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
          const len0 = WASM_VECTOR_LEN;
          const ret = wasm.store_load(this.__wbg_ptr, ptr0, len0, options, base_iri, to_graph_name);
          if (ret[1]) {
            throw takeFromExternrefTable0(ret[0]);
          }
        }
        /**
         * @param {any} options
         * @param {any} from_graph_name
         * @returns {string}
         */
        dump(options, from_graph_name) {
          let deferred2_0;
          let deferred2_1;
          try {
            const ret = wasm.store_dump(this.__wbg_ptr, options, from_graph_name);
            var ptr1 = ret[0];
            var len1 = ret[1];
            if (ret[3]) {
              ptr1 = 0;
              len1 = 0;
              throw takeFromExternrefTable0(ret[2]);
            }
            deferred2_0 = ptr1;
            deferred2_1 = len1;
            return getStringFromWasm0(ptr1, len1);
          } finally {
            wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);
          }
        }
      };
      VariableFinalization = typeof FinalizationRegistry === "undefined" ? { register: () => {
      }, unregister: () => {
      } } : new FinalizationRegistry((ptr) => wasm.__wbg_variable_free(ptr >>> 0, 1));
      Variable = class _Variable {
        static __wrap(ptr) {
          ptr = ptr >>> 0;
          const obj = Object.create(_Variable.prototype);
          obj.__wbg_ptr = ptr;
          VariableFinalization.register(obj, obj.__wbg_ptr, obj);
          return obj;
        }
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          VariableFinalization.unregister(this);
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm.__wbg_variable_free(ptr, 0);
        }
        /**
         * @returns {string}
         */
        get termType() {
          let deferred1_0;
          let deferred1_1;
          try {
            const ret = wasm.variable_term_type(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
          } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
          }
        }
        /**
         * @returns {string}
         */
        get value() {
          let deferred1_0;
          let deferred1_1;
          try {
            const ret = wasm.variable_value(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
          } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
          }
        }
        /**
         * @returns {string}
         */
        toString() {
          let deferred1_0;
          let deferred1_1;
          try {
            const ret = wasm.variable_toString(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
          } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
          }
        }
        /**
         * @param {any} other
         * @returns {boolean}
         */
        equals(other) {
          const ret = wasm.variable_equals(this.__wbg_ptr, other);
          return ret !== 0;
        }
      };
      web_default = __wbg_init;
    }
  });

  // ../node_modules/maplibre-gl/dist/maplibre-gl.js
  var require_maplibre_gl = __commonJS({
    "../node_modules/maplibre-gl/dist/maplibre-gl.js"(exports, module2) {
      (function(global2, factory) {
        typeof exports === "object" && typeof module2 !== "undefined" ? module2.exports = factory() : typeof define === "function" && define.amd ? define(factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, global2.maplibregl = factory());
      })(exports, function() {
        "use strict";
        var maplibregl2 = {};
        var modules = {};
        function define2(moduleName, _dependencies, moduleFactory) {
          modules[moduleName] = moduleFactory;
          if (moduleName !== "index") {
            return;
          }
          var workerBundleString = "var sharedModule = {}; (" + modules.shared + ")(sharedModule); (" + modules.worker + ")(sharedModule);";
          var sharedModule = {};
          modules.shared(sharedModule);
          modules.index(maplibregl2, sharedModule);
          if (typeof window !== "undefined") {
            maplibregl2.setWorkerUrl(window.URL.createObjectURL(new Blob([workerBundleString], { type: "text/javascript" })));
          }
          return maplibregl2;
        }
        ;
        define2("shared", ["exports"], function(t4) {
          "use strict";
          function e6(t5, e7, r7, n6) {
            return new (r7 || (r7 = Promise))(function(i6, s5) {
              function a4(t6) {
                try {
                  l5(n6.next(t6));
                } catch (t7) {
                  s5(t7);
                }
              }
              function o7(t6) {
                try {
                  l5(n6.throw(t6));
                } catch (t7) {
                  s5(t7);
                }
              }
              function l5(t6) {
                var e8;
                t6.done ? i6(t6.value) : (e8 = t6.value, e8 instanceof r7 ? e8 : new r7(function(t7) {
                  t7(e8);
                })).then(a4, o7);
              }
              l5((n6 = n6.apply(t5, e7 || [])).next());
            });
          }
          function r6(t5) {
            return t5 && t5.__esModule && Object.prototype.hasOwnProperty.call(t5, "default") ? t5.default : t5;
          }
          var n5, i5;
          function s4() {
            if (i5) return n5;
            function t5(t6, e7) {
              this.x = t6, this.y = e7;
            }
            return i5 = 1, n5 = t5, t5.prototype = { clone: function() {
              return new t5(this.x, this.y);
            }, add: function(t6) {
              return this.clone()._add(t6);
            }, sub: function(t6) {
              return this.clone()._sub(t6);
            }, multByPoint: function(t6) {
              return this.clone()._multByPoint(t6);
            }, divByPoint: function(t6) {
              return this.clone()._divByPoint(t6);
            }, mult: function(t6) {
              return this.clone()._mult(t6);
            }, div: function(t6) {
              return this.clone()._div(t6);
            }, rotate: function(t6) {
              return this.clone()._rotate(t6);
            }, rotateAround: function(t6, e7) {
              return this.clone()._rotateAround(t6, e7);
            }, matMult: function(t6) {
              return this.clone()._matMult(t6);
            }, unit: function() {
              return this.clone()._unit();
            }, perp: function() {
              return this.clone()._perp();
            }, round: function() {
              return this.clone()._round();
            }, mag: function() {
              return Math.sqrt(this.x * this.x + this.y * this.y);
            }, equals: function(t6) {
              return this.x === t6.x && this.y === t6.y;
            }, dist: function(t6) {
              return Math.sqrt(this.distSqr(t6));
            }, distSqr: function(t6) {
              var e7 = t6.x - this.x, r7 = t6.y - this.y;
              return e7 * e7 + r7 * r7;
            }, angle: function() {
              return Math.atan2(this.y, this.x);
            }, angleTo: function(t6) {
              return Math.atan2(this.y - t6.y, this.x - t6.x);
            }, angleWith: function(t6) {
              return this.angleWithSep(t6.x, t6.y);
            }, angleWithSep: function(t6, e7) {
              return Math.atan2(this.x * e7 - this.y * t6, this.x * t6 + this.y * e7);
            }, _matMult: function(t6) {
              var e7 = t6[2] * this.x + t6[3] * this.y;
              return this.x = t6[0] * this.x + t6[1] * this.y, this.y = e7, this;
            }, _add: function(t6) {
              return this.x += t6.x, this.y += t6.y, this;
            }, _sub: function(t6) {
              return this.x -= t6.x, this.y -= t6.y, this;
            }, _mult: function(t6) {
              return this.x *= t6, this.y *= t6, this;
            }, _div: function(t6) {
              return this.x /= t6, this.y /= t6, this;
            }, _multByPoint: function(t6) {
              return this.x *= t6.x, this.y *= t6.y, this;
            }, _divByPoint: function(t6) {
              return this.x /= t6.x, this.y /= t6.y, this;
            }, _unit: function() {
              return this._div(this.mag()), this;
            }, _perp: function() {
              var t6 = this.y;
              return this.y = this.x, this.x = -t6, this;
            }, _rotate: function(t6) {
              var e7 = Math.cos(t6), r7 = Math.sin(t6), n6 = r7 * this.x + e7 * this.y;
              return this.x = e7 * this.x - r7 * this.y, this.y = n6, this;
            }, _rotateAround: function(t6, e7) {
              var r7 = Math.cos(t6), n6 = Math.sin(t6), i6 = e7.y + n6 * (this.x - e7.x) + r7 * (this.y - e7.y);
              return this.x = e7.x + r7 * (this.x - e7.x) - n6 * (this.y - e7.y), this.y = i6, this;
            }, _round: function() {
              return this.x = Math.round(this.x), this.y = Math.round(this.y), this;
            } }, t5.convert = function(e7) {
              return e7 instanceof t5 ? e7 : Array.isArray(e7) ? new t5(e7[0], e7[1]) : e7;
            }, n5;
          }
          "function" == typeof SuppressedError && SuppressedError;
          var a3, o6, l4 = r6(s4()), u3 = function() {
            if (o6) return a3;
            function t5(t6, e7, r7, n6) {
              this.cx = 3 * t6, this.bx = 3 * (r7 - t6) - this.cx, this.ax = 1 - this.cx - this.bx, this.cy = 3 * e7, this.by = 3 * (n6 - e7) - this.cy, this.ay = 1 - this.cy - this.by, this.p1x = t6, this.p1y = e7, this.p2x = r7, this.p2y = n6;
            }
            return o6 = 1, a3 = t5, t5.prototype = { sampleCurveX: function(t6) {
              return ((this.ax * t6 + this.bx) * t6 + this.cx) * t6;
            }, sampleCurveY: function(t6) {
              return ((this.ay * t6 + this.by) * t6 + this.cy) * t6;
            }, sampleCurveDerivativeX: function(t6) {
              return (3 * this.ax * t6 + 2 * this.bx) * t6 + this.cx;
            }, solveCurveX: function(t6, e7) {
              if (void 0 === e7 && (e7 = 1e-6), t6 < 0) return 0;
              if (t6 > 1) return 1;
              for (var r7 = t6, n6 = 0; n6 < 8; n6++) {
                var i6 = this.sampleCurveX(r7) - t6;
                if (Math.abs(i6) < e7) return r7;
                var s5 = this.sampleCurveDerivativeX(r7);
                if (Math.abs(s5) < 1e-6) break;
                r7 -= i6 / s5;
              }
              var a4 = 0, o7 = 1;
              for (r7 = t6, n6 = 0; n6 < 20 && (i6 = this.sampleCurveX(r7), !(Math.abs(i6 - t6) < e7)); n6++) t6 > i6 ? a4 = r7 : o7 = r7, r7 = 0.5 * (o7 - a4) + a4;
              return r7;
            }, solve: function(t6, e7) {
              return this.sampleCurveY(this.solveCurveX(t6, e7));
            } }, a3;
          }(), c4 = r6(u3);
          let h3, p3;
          function f3() {
            return null == h3 && (h3 = "undefined" != typeof OffscreenCanvas && new OffscreenCanvas(1, 1).getContext("2d") && "function" == typeof createImageBitmap), h3;
          }
          function d3() {
            if (null == p3 && (p3 = false, f3())) {
              const t5 = 5, e7 = new OffscreenCanvas(t5, t5).getContext("2d", { willReadFrequently: true });
              if (e7) {
                for (let r8 = 0; r8 < t5 * t5; r8++) {
                  const n6 = 4 * r8;
                  e7.fillStyle = `rgb(${n6},${n6 + 1},${n6 + 2})`, e7.fillRect(r8 % t5, Math.floor(r8 / t5), 1, 1);
                }
                const r7 = e7.getImageData(0, 0, t5, t5).data;
                for (let e8 = 0; e8 < t5 * t5 * 4; e8++) if (e8 % 4 != 3 && r7[e8] !== e8) {
                  p3 = true;
                  break;
                }
              }
            }
            return p3 || false;
          }
          var y3, m3 = 1e-6, g3 = "undefined" != typeof Float32Array ? Float32Array : Array;
          function x3() {
            var t5 = new g3(9);
            return g3 != Float32Array && (t5[1] = 0, t5[2] = 0, t5[3] = 0, t5[5] = 0, t5[6] = 0, t5[7] = 0), t5[0] = 1, t5[4] = 1, t5[8] = 1, t5;
          }
          function v3(t5) {
            return t5[0] = 1, t5[1] = 0, t5[2] = 0, t5[3] = 0, t5[4] = 0, t5[5] = 1, t5[6] = 0, t5[7] = 0, t5[8] = 0, t5[9] = 0, t5[10] = 1, t5[11] = 0, t5[12] = 0, t5[13] = 0, t5[14] = 0, t5[15] = 1, t5;
          }
          function b4() {
            var t5 = new g3(3);
            return g3 != Float32Array && (t5[0] = 0, t5[1] = 0, t5[2] = 0), t5;
          }
          function w3(t5, e7, r7) {
            var n6 = new g3(3);
            return n6[0] = t5, n6[1] = e7, n6[2] = r7, n6;
          }
          function _3(t5, e7, r7) {
            var n6 = e7[0], i6 = e7[1], s5 = e7[2], a4 = e7[3];
            return t5[0] = r7[0] * n6 + r7[4] * i6 + r7[8] * s5 + r7[12] * a4, t5[1] = r7[1] * n6 + r7[5] * i6 + r7[9] * s5 + r7[13] * a4, t5[2] = r7[2] * n6 + r7[6] * i6 + r7[10] * s5 + r7[14] * a4, t5[3] = r7[3] * n6 + r7[7] * i6 + r7[11] * s5 + r7[15] * a4, t5;
          }
          function S4() {
            var t5 = new g3(4);
            return g3 != Float32Array && (t5[0] = 0, t5[1] = 0, t5[2] = 0), t5[3] = 1, t5;
          }
          function A4() {
            var t5 = new g3(2);
            return g3 != Float32Array && (t5[0] = 0, t5[1] = 0), t5;
          }
          function k3(t5, e7) {
            var r7 = new g3(2);
            return r7[0] = t5, r7[1] = e7, r7;
          }
          Math.hypot || (Math.hypot = function() {
            for (var t5 = 0, e7 = arguments.length; e7--; ) t5 += arguments[e7] * arguments[e7];
            return Math.sqrt(t5);
          }), b4(), y3 = new g3(4), g3 != Float32Array && (y3[0] = 0, y3[1] = 0, y3[2] = 0, y3[3] = 0), b4(), w3(1, 0, 0), w3(0, 1, 0), S4(), S4(), x3(), A4();
          const M4 = 8192;
          function I3(t5, e7, r7) {
            return e7 * (M4 / (t5.tileSize * Math.pow(2, r7 - t5.tileID.overscaledZ)));
          }
          function z3(t5, e7) {
            return (t5 % e7 + e7) % e7;
          }
          function P3(t5, e7, r7) {
            return t5 * (1 - r7) + e7 * r7;
          }
          function C3(t5) {
            if (t5 <= 0) return 0;
            if (t5 >= 1) return 1;
            const e7 = t5 * t5, r7 = e7 * t5;
            return 4 * (t5 < 0.5 ? r7 : 3 * (t5 - e7) + r7 - 0.75);
          }
          function B4(t5, e7, r7, n6) {
            const i6 = new c4(t5, e7, r7, n6);
            return (t6) => i6.solve(t6);
          }
          const V2 = B4(0.25, 0.1, 0.25, 1);
          function E3(t5, e7, r7) {
            return Math.min(r7, Math.max(e7, t5));
          }
          function T4(t5, e7, r7) {
            const n6 = r7 - e7, i6 = ((t5 - e7) % n6 + n6) % n6 + e7;
            return i6 === e7 ? r7 : i6;
          }
          function F2(t5, ...e7) {
            for (const r7 of e7) for (const e8 in r7) t5[e8] = r7[e8];
            return t5;
          }
          let $2 = 1;
          function L3(t5, e7, r7) {
            const n6 = {};
            for (const r8 in t5) n6[r8] = e7.call(this, t5[r8], r8, t5);
            return n6;
          }
          function O2(t5, e7, r7) {
            const n6 = {};
            for (const r8 in t5) e7.call(this, t5[r8], r8, t5) && (n6[r8] = t5[r8]);
            return n6;
          }
          function D2(t5) {
            return Array.isArray(t5) ? t5.map(D2) : "object" == typeof t5 && t5 ? L3(t5, D2) : t5;
          }
          const R4 = {};
          function j3(t5) {
            R4[t5] || ("undefined" != typeof console && console.warn(t5), R4[t5] = true);
          }
          function N3(t5, e7, r7) {
            return (r7.y - t5.y) * (e7.x - t5.x) > (e7.y - t5.y) * (r7.x - t5.x);
          }
          function U3(t5) {
            return "undefined" != typeof WorkerGlobalScope && void 0 !== t5 && t5 instanceof WorkerGlobalScope;
          }
          let q2 = null;
          function G2(t5) {
            return "undefined" != typeof ImageBitmap && t5 instanceof ImageBitmap;
          }
          const Z2 = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAC0lEQVQYV2NgAAIAAAUAAarVyFEAAAAASUVORK5CYII=";
          function K2(t5, r7, n6, i6, s5) {
            return e6(this, void 0, void 0, function* () {
              if ("undefined" == typeof VideoFrame) throw new Error("VideoFrame not supported");
              const e7 = new VideoFrame(t5, { timestamp: 0 });
              try {
                const a4 = null == e7 ? void 0 : e7.format;
                if (!a4 || !a4.startsWith("BGR") && !a4.startsWith("RGB")) throw new Error(`Unrecognized format ${a4}`);
                const o7 = a4.startsWith("BGR"), l5 = new Uint8ClampedArray(i6 * s5 * 4);
                if (yield e7.copyTo(l5, function(t6, e8, r8, n7, i7) {
                  const s6 = 4 * Math.max(1, 0), a5 = (Math.max(0, r8) - r8) * n7 * 4 + s6, o8 = 4 * n7, l6 = Math.max(0, e8), u4 = Math.max(0, r8);
                  return { rect: { x: l6, y: u4, width: Math.min(t6.width, e8 + n7) - l6, height: Math.min(t6.height, r8 + i7) - u4 }, layout: [{ offset: a5, stride: o8 }] };
                }(t5, r7, n6, i6, s5)), o7) for (let t6 = 0; t6 < l5.length; t6 += 4) {
                  const e8 = l5[t6];
                  l5[t6] = l5[t6 + 2], l5[t6 + 2] = e8;
                }
                return l5;
              } finally {
                e7.close();
              }
            });
          }
          let X2, H4;
          function Y2(t5, e7, r7, n6) {
            return t5.addEventListener(e7, r7, n6), { unsubscribe: () => {
              t5.removeEventListener(e7, r7, n6);
            } };
          }
          function J2(t5) {
            return t5 / Math.PI * 180;
          }
          const W = { touchstart: true, touchmove: true, touchmoveWindow: true, touchend: true, touchcancel: true }, Q2 = { dblclick: true, click: true, mouseover: true, mouseout: true, mousedown: true, mousemove: true, mousemoveWindow: true, mouseup: true, mouseupWindow: true, contextmenu: true, wheel: true }, tt = "AbortError";
          function et2() {
            return new Error(tt);
          }
          const rt = { MAX_PARALLEL_IMAGE_REQUESTS: 16, MAX_PARALLEL_IMAGE_REQUESTS_PER_FRAME: 8, MAX_TILE_CACHE_ZOOM_LEVELS: 5, REGISTERED_PROTOCOLS: {}, WORKER_URL: "" };
          function nt(t5) {
            return rt.REGISTERED_PROTOCOLS[t5.substring(0, t5.indexOf("://"))];
          }
          const it = "global-dispatcher";
          class st extends Error {
            constructor(t5, e7, r7, n6) {
              super(`AJAXError: ${e7} (${t5}): ${r7}`), this.status = t5, this.statusText = e7, this.url = r7, this.body = n6;
            }
          }
          const at = () => U3(self) ? self.worker && self.worker.referrer : ("blob:" === window.location.protocol ? window.parent : window).location.href, ot = function(t5, r7) {
            if (/:\/\//.test(t5.url) && !/^https?:|^file:/.test(t5.url)) {
              const e7 = nt(t5.url);
              if (e7) return e7(t5, r7);
              if (U3(self) && self.worker && self.worker.actor) return self.worker.actor.sendAsync({ type: "GR", data: t5, targetMapId: it }, r7);
            }
            if (!(/^file:/.test(n6 = t5.url) || /^file:/.test(at()) && !/^\w+:/.test(n6))) {
              if (fetch && Request && AbortController && Object.prototype.hasOwnProperty.call(Request.prototype, "signal")) return function(t6, r8) {
                return e6(this, void 0, void 0, function* () {
                  const e7 = new Request(t6.url, { method: t6.method || "GET", body: t6.body, credentials: t6.credentials, headers: t6.headers, cache: t6.cache, referrer: at(), signal: r8.signal });
                  let n7, i6;
                  "json" !== t6.type || e7.headers.has("Accept") || e7.headers.set("Accept", "application/json");
                  try {
                    n7 = yield fetch(e7);
                  } catch (e8) {
                    throw new st(0, e8.message, t6.url, new Blob());
                  }
                  if (!n7.ok) {
                    const e8 = yield n7.blob();
                    throw new st(n7.status, n7.statusText, t6.url, e8);
                  }
                  i6 = "arrayBuffer" === t6.type || "image" === t6.type ? n7.arrayBuffer() : "json" === t6.type ? n7.json() : n7.text();
                  const s5 = yield i6;
                  if (r8.signal.aborted) throw et2();
                  return { data: s5, cacheControl: n7.headers.get("Cache-Control"), expires: n7.headers.get("Expires") };
                });
              }(t5, r7);
              if (U3(self) && self.worker && self.worker.actor) return self.worker.actor.sendAsync({ type: "GR", data: t5, mustQueue: true, targetMapId: it }, r7);
            }
            var n6;
            return function(t6, e7) {
              return new Promise((r8, n7) => {
                var i6;
                const s5 = new XMLHttpRequest();
                s5.open(t6.method || "GET", t6.url, true), "arrayBuffer" !== t6.type && "image" !== t6.type || (s5.responseType = "arraybuffer");
                for (const e8 in t6.headers) s5.setRequestHeader(e8, t6.headers[e8]);
                "json" === t6.type && (s5.responseType = "text", (null === (i6 = t6.headers) || void 0 === i6 ? void 0 : i6.Accept) || s5.setRequestHeader("Accept", "application/json")), s5.withCredentials = "include" === t6.credentials, s5.onerror = () => {
                  n7(new Error(s5.statusText));
                }, s5.onload = () => {
                  if (!e7.signal.aborted) if ((s5.status >= 200 && s5.status < 300 || 0 === s5.status) && null !== s5.response) {
                    let e8 = s5.response;
                    if ("json" === t6.type) try {
                      e8 = JSON.parse(s5.response);
                    } catch (t7) {
                      return void n7(t7);
                    }
                    r8({ data: e8, cacheControl: s5.getResponseHeader("Cache-Control"), expires: s5.getResponseHeader("Expires") });
                  } else {
                    const e8 = new Blob([s5.response], { type: s5.getResponseHeader("Content-Type") });
                    n7(new st(s5.status, s5.statusText, t6.url, e8));
                  }
                }, e7.signal.addEventListener("abort", () => {
                  s5.abort(), n7(et2());
                }), s5.send(t6.body);
              });
            }(t5, r7);
          };
          function lt(t5) {
            if (!t5 || t5.indexOf("://") <= 0 || 0 === t5.indexOf("data:image/") || 0 === t5.indexOf("blob:")) return true;
            const e7 = new URL(t5), r7 = window.location;
            return e7.protocol === r7.protocol && e7.host === r7.host;
          }
          function ut(t5, e7, r7) {
            r7[t5] && -1 !== r7[t5].indexOf(e7) || (r7[t5] = r7[t5] || [], r7[t5].push(e7));
          }
          function ct(t5, e7, r7) {
            if (r7 && r7[t5]) {
              const n6 = r7[t5].indexOf(e7);
              -1 !== n6 && r7[t5].splice(n6, 1);
            }
          }
          class ht {
            constructor(t5, e7 = {}) {
              F2(this, e7), this.type = t5;
            }
          }
          class pt extends ht {
            constructor(t5, e7 = {}) {
              super("error", F2({ error: t5 }, e7));
            }
          }
          class ft {
            on(t5, e7) {
              return this._listeners = this._listeners || {}, ut(t5, e7, this._listeners), { unsubscribe: () => {
                this.off(t5, e7);
              } };
            }
            off(t5, e7) {
              return ct(t5, e7, this._listeners), ct(t5, e7, this._oneTimeListeners), this;
            }
            once(t5, e7) {
              return e7 ? (this._oneTimeListeners = this._oneTimeListeners || {}, ut(t5, e7, this._oneTimeListeners), this) : new Promise((e8) => this.once(t5, e8));
            }
            fire(t5, e7) {
              "string" == typeof t5 && (t5 = new ht(t5, e7 || {}));
              const r7 = t5.type;
              if (this.listens(r7)) {
                t5.target = this;
                const e8 = this._listeners && this._listeners[r7] ? this._listeners[r7].slice() : [];
                for (const r8 of e8) r8.call(this, t5);
                const n6 = this._oneTimeListeners && this._oneTimeListeners[r7] ? this._oneTimeListeners[r7].slice() : [];
                for (const e9 of n6) ct(r7, e9, this._oneTimeListeners), e9.call(this, t5);
                const i6 = this._eventedParent;
                i6 && (F2(t5, "function" == typeof this._eventedParentData ? this._eventedParentData() : this._eventedParentData), i6.fire(t5));
              } else t5 instanceof pt && console.error(t5.error);
              return this;
            }
            listens(t5) {
              return this._listeners && this._listeners[t5] && this._listeners[t5].length > 0 || this._oneTimeListeners && this._oneTimeListeners[t5] && this._oneTimeListeners[t5].length > 0 || this._eventedParent && this._eventedParent.listens(t5);
            }
            setEventedParent(t5, e7) {
              return this._eventedParent = t5, this._eventedParentData = e7, this;
            }
          }
          var dt = { $version: 8, $root: { version: { required: true, type: "enum", values: [8] }, name: { type: "string" }, metadata: { type: "*" }, center: { type: "array", value: "number" }, centerAltitude: { type: "number" }, zoom: { type: "number" }, bearing: { type: "number", default: 0, period: 360, units: "degrees" }, pitch: { type: "number", default: 0, units: "degrees" }, roll: { type: "number", default: 0, units: "degrees" }, light: { type: "light" }, sky: { type: "sky" }, projection: { type: "projection" }, terrain: { type: "terrain" }, sources: { required: true, type: "sources" }, sprite: { type: "sprite" }, glyphs: { type: "string" }, transition: { type: "transition" }, layers: { required: true, type: "array", value: "layer" } }, sources: { "*": { type: "source" } }, source: ["source_vector", "source_raster", "source_raster_dem", "source_geojson", "source_video", "source_image"], source_vector: { type: { required: true, type: "enum", values: { vector: {} } }, url: { type: "string" }, tiles: { type: "array", value: "string" }, bounds: { type: "array", value: "number", length: 4, default: [-180, -85.051129, 180, 85.051129] }, scheme: { type: "enum", values: { xyz: {}, tms: {} }, default: "xyz" }, minzoom: { type: "number", default: 0 }, maxzoom: { type: "number", default: 22 }, attribution: { type: "string" }, promoteId: { type: "promoteId" }, volatile: { type: "boolean", default: false }, "*": { type: "*" } }, source_raster: { type: { required: true, type: "enum", values: { raster: {} } }, url: { type: "string" }, tiles: { type: "array", value: "string" }, bounds: { type: "array", value: "number", length: 4, default: [-180, -85.051129, 180, 85.051129] }, minzoom: { type: "number", default: 0 }, maxzoom: { type: "number", default: 22 }, tileSize: { type: "number", default: 512, units: "pixels" }, scheme: { type: "enum", values: { xyz: {}, tms: {} }, default: "xyz" }, attribution: { type: "string" }, volatile: { type: "boolean", default: false }, "*": { type: "*" } }, source_raster_dem: { type: { required: true, type: "enum", values: { "raster-dem": {} } }, url: { type: "string" }, tiles: { type: "array", value: "string" }, bounds: { type: "array", value: "number", length: 4, default: [-180, -85.051129, 180, 85.051129] }, minzoom: { type: "number", default: 0 }, maxzoom: { type: "number", default: 22 }, tileSize: { type: "number", default: 512, units: "pixels" }, attribution: { type: "string" }, encoding: { type: "enum", values: { terrarium: {}, mapbox: {}, custom: {} }, default: "mapbox" }, redFactor: { type: "number", default: 1 }, blueFactor: { type: "number", default: 1 }, greenFactor: { type: "number", default: 1 }, baseShift: { type: "number", default: 0 }, volatile: { type: "boolean", default: false }, "*": { type: "*" } }, source_geojson: { type: { required: true, type: "enum", values: { geojson: {} } }, data: { required: true, type: "*" }, maxzoom: { type: "number", default: 18 }, attribution: { type: "string" }, buffer: { type: "number", default: 128, maximum: 512, minimum: 0 }, filter: { type: "*" }, tolerance: { type: "number", default: 0.375 }, cluster: { type: "boolean", default: false }, clusterRadius: { type: "number", default: 50, minimum: 0 }, clusterMaxZoom: { type: "number" }, clusterMinPoints: { type: "number" }, clusterProperties: { type: "*" }, lineMetrics: { type: "boolean", default: false }, generateId: { type: "boolean", default: false }, promoteId: { type: "promoteId" } }, source_video: { type: { required: true, type: "enum", values: { video: {} } }, urls: { required: true, type: "array", value: "string" }, coordinates: { required: true, type: "array", length: 4, value: { type: "array", length: 2, value: "number" } } }, source_image: { type: { required: true, type: "enum", values: { image: {} } }, url: { required: true, type: "string" }, coordinates: { required: true, type: "array", length: 4, value: { type: "array", length: 2, value: "number" } } }, layer: { id: { type: "string", required: true }, type: { type: "enum", values: { fill: {}, line: {}, symbol: {}, circle: {}, heatmap: {}, "fill-extrusion": {}, raster: {}, hillshade: {}, background: {} }, required: true }, metadata: { type: "*" }, source: { type: "string" }, "source-layer": { type: "string" }, minzoom: { type: "number", minimum: 0, maximum: 24 }, maxzoom: { type: "number", minimum: 0, maximum: 24 }, filter: { type: "filter" }, layout: { type: "layout" }, paint: { type: "paint" } }, layout: ["layout_fill", "layout_line", "layout_circle", "layout_heatmap", "layout_fill-extrusion", "layout_symbol", "layout_raster", "layout_hillshade", "layout_background"], layout_background: { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_fill: { "fill-sort-key": { type: "number", expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_circle: { "circle-sort-key": { type: "number", expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_heatmap: { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, "layout_fill-extrusion": { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_line: { "line-cap": { type: "enum", values: { butt: {}, round: {}, square: {} }, default: "butt", expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-join": { type: "enum", values: { bevel: {}, round: {}, miter: {} }, default: "miter", expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "line-miter-limit": { type: "number", default: 2, requires: [{ "line-join": "miter" }], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-round-limit": { type: "number", default: 1.05, requires: [{ "line-join": "round" }], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-sort-key": { type: "number", expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_symbol: { "symbol-placement": { type: "enum", values: { point: {}, line: {}, "line-center": {} }, default: "point", expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "symbol-spacing": { type: "number", default: 250, minimum: 1, units: "pixels", requires: [{ "symbol-placement": "line" }], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "symbol-avoid-edges": { type: "boolean", default: false, expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "symbol-sort-key": { type: "number", expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "symbol-z-order": { type: "enum", values: { auto: {}, "viewport-y": {}, source: {} }, default: "auto", expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-allow-overlap": { type: "boolean", default: false, requires: ["icon-image", { "!": "icon-overlap" }], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-overlap": { type: "enum", values: { never: {}, always: {}, cooperative: {} }, requires: ["icon-image"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-ignore-placement": { type: "boolean", default: false, requires: ["icon-image"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-optional": { type: "boolean", default: false, requires: ["icon-image", "text-field"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-rotation-alignment": { type: "enum", values: { map: {}, viewport: {}, auto: {} }, default: "auto", requires: ["icon-image"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-size": { type: "number", default: 1, minimum: 0, units: "factor of the original icon size", requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-text-fit": { type: "enum", values: { none: {}, width: {}, height: {}, both: {} }, default: "none", requires: ["icon-image", "text-field"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-text-fit-padding": { type: "array", value: "number", length: 4, default: [0, 0, 0, 0], units: "pixels", requires: ["icon-image", "text-field", { "icon-text-fit": ["both", "width", "height"] }], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-image": { type: "resolvedImage", tokens: true, expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-rotate": { type: "number", default: 0, period: 360, units: "degrees", requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-padding": { type: "padding", default: [2], units: "pixels", requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-keep-upright": { type: "boolean", default: false, requires: ["icon-image", { "icon-rotation-alignment": "map" }, { "symbol-placement": ["line", "line-center"] }], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-offset": { type: "array", value: "number", length: 2, default: [0, 0], requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-anchor": { type: "enum", values: { center: {}, left: {}, right: {}, top: {}, bottom: {}, "top-left": {}, "top-right": {}, "bottom-left": {}, "bottom-right": {} }, default: "center", requires: ["icon-image"], expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-pitch-alignment": { type: "enum", values: { map: {}, viewport: {}, auto: {} }, default: "auto", requires: ["icon-image"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-pitch-alignment": { type: "enum", values: { map: {}, viewport: {}, auto: {} }, default: "auto", requires: ["text-field"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-rotation-alignment": { type: "enum", values: { map: {}, viewport: {}, "viewport-glyph": {}, auto: {} }, default: "auto", requires: ["text-field"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-field": { type: "formatted", default: "", tokens: true, expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-font": { type: "array", value: "string", default: ["Open Sans Regular", "Arial Unicode MS Regular"], requires: ["text-field"], expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-size": { type: "number", default: 16, minimum: 0, units: "pixels", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-max-width": { type: "number", default: 10, minimum: 0, units: "ems", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-line-height": { type: "number", default: 1.2, units: "ems", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-letter-spacing": { type: "number", default: 0, units: "ems", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-justify": { type: "enum", values: { auto: {}, left: {}, center: {}, right: {} }, default: "center", requires: ["text-field"], expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-radial-offset": { type: "number", units: "ems", default: 0, requires: ["text-field"], "property-type": "data-driven", expression: { interpolated: true, parameters: ["zoom", "feature"] } }, "text-variable-anchor": { type: "array", value: "enum", values: { center: {}, left: {}, right: {}, top: {}, bottom: {}, "top-left": {}, "top-right": {}, "bottom-left": {}, "bottom-right": {} }, requires: ["text-field", { "symbol-placement": ["point"] }], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-variable-anchor-offset": { type: "variableAnchorOffsetCollection", requires: ["text-field", { "symbol-placement": ["point"] }], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-anchor": { type: "enum", values: { center: {}, left: {}, right: {}, top: {}, bottom: {}, "top-left": {}, "top-right": {}, "bottom-left": {}, "bottom-right": {} }, default: "center", requires: ["text-field", { "!": "text-variable-anchor" }], expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-max-angle": { type: "number", default: 45, units: "degrees", requires: ["text-field", { "symbol-placement": ["line", "line-center"] }], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-writing-mode": { type: "array", value: "enum", values: { horizontal: {}, vertical: {} }, requires: ["text-field", { "symbol-placement": ["point"] }], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-rotate": { type: "number", default: 0, period: 360, units: "degrees", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-padding": { type: "number", default: 2, minimum: 0, units: "pixels", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-keep-upright": { type: "boolean", default: true, requires: ["text-field", { "text-rotation-alignment": "map" }, { "symbol-placement": ["line", "line-center"] }], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-transform": { type: "enum", values: { none: {}, uppercase: {}, lowercase: {} }, default: "none", requires: ["text-field"], expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-offset": { type: "array", value: "number", units: "ems", length: 2, default: [0, 0], requires: ["text-field", { "!": "text-radial-offset" }], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-allow-overlap": { type: "boolean", default: false, requires: ["text-field", { "!": "text-overlap" }], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-overlap": { type: "enum", values: { never: {}, always: {}, cooperative: {} }, requires: ["text-field"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-ignore-placement": { type: "boolean", default: false, requires: ["text-field"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-optional": { type: "boolean", default: false, requires: ["text-field", "icon-image"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_raster: { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_hillshade: { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, filter: { type: "array", value: "*" }, filter_operator: { type: "enum", values: { "==": {}, "!=": {}, ">": {}, ">=": {}, "<": {}, "<=": {}, in: {}, "!in": {}, all: {}, any: {}, none: {}, has: {}, "!has": {} } }, geometry_type: { type: "enum", values: { Point: {}, LineString: {}, Polygon: {} } }, function: { expression: { type: "expression" }, stops: { type: "array", value: "function_stop" }, base: { type: "number", default: 1, minimum: 0 }, property: { type: "string", default: "$zoom" }, type: { type: "enum", values: { identity: {}, exponential: {}, interval: {}, categorical: {} }, default: "exponential" }, colorSpace: { type: "enum", values: { rgb: {}, lab: {}, hcl: {} }, default: "rgb" }, default: { type: "*", required: false } }, function_stop: { type: "array", minimum: 0, maximum: 24, value: ["number", "color"], length: 2 }, expression: { type: "array", value: "*", minimum: 1 }, light: { anchor: { type: "enum", default: "viewport", values: { map: {}, viewport: {} }, "property-type": "data-constant", transition: false, expression: { interpolated: false, parameters: ["zoom"] } }, position: { type: "array", default: [1.15, 210, 30], length: 3, value: "number", "property-type": "data-constant", transition: true, expression: { interpolated: true, parameters: ["zoom"] } }, color: { type: "color", "property-type": "data-constant", default: "#ffffff", expression: { interpolated: true, parameters: ["zoom"] }, transition: true }, intensity: { type: "number", "property-type": "data-constant", default: 0.5, minimum: 0, maximum: 1, expression: { interpolated: true, parameters: ["zoom"] }, transition: true } }, sky: { "sky-color": { type: "color", "property-type": "data-constant", default: "#88C6FC", expression: { interpolated: true, parameters: ["zoom"] }, transition: true }, "horizon-color": { type: "color", "property-type": "data-constant", default: "#ffffff", expression: { interpolated: true, parameters: ["zoom"] }, transition: true }, "fog-color": { type: "color", "property-type": "data-constant", default: "#ffffff", expression: { interpolated: true, parameters: ["zoom"] }, transition: true }, "fog-ground-blend": { type: "number", "property-type": "data-constant", default: 0.5, minimum: 0, maximum: 1, expression: { interpolated: true, parameters: ["zoom"] }, transition: true }, "horizon-fog-blend": { type: "number", "property-type": "data-constant", default: 0.8, minimum: 0, maximum: 1, expression: { interpolated: true, parameters: ["zoom"] }, transition: true }, "sky-horizon-blend": { type: "number", "property-type": "data-constant", default: 0.8, minimum: 0, maximum: 1, expression: { interpolated: true, parameters: ["zoom"] }, transition: true }, "atmosphere-blend": { type: "number", "property-type": "data-constant", default: 0.8, minimum: 0, maximum: 1, expression: { interpolated: true, parameters: ["zoom"] }, transition: true } }, terrain: { source: { type: "string", required: true }, exaggeration: { type: "number", minimum: 0, default: 1 } }, projection: { type: { type: "projectionDefinition", default: "mercator", "property-type": "data-constant", transition: false, expression: { interpolated: true, parameters: ["zoom"] } } }, paint: ["paint_fill", "paint_line", "paint_circle", "paint_heatmap", "paint_fill-extrusion", "paint_symbol", "paint_raster", "paint_hillshade", "paint_background"], paint_fill: { "fill-antialias": { type: "boolean", default: true, expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-color": { type: "color", default: "#000000", transition: true, requires: [{ "!": "fill-pattern" }], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-outline-color": { type: "color", transition: true, requires: [{ "!": "fill-pattern" }, { "fill-antialias": true }], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["fill-translate"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-pattern": { type: "resolvedImage", transition: true, expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "cross-faded-data-driven" } }, "paint_fill-extrusion": { "fill-extrusion-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-extrusion-color": { type: "color", default: "#000000", transition: true, requires: [{ "!": "fill-extrusion-pattern" }], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-extrusion-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-extrusion-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["fill-extrusion-translate"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-extrusion-pattern": { type: "resolvedImage", transition: true, expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "cross-faded-data-driven" }, "fill-extrusion-height": { type: "number", default: 0, minimum: 0, units: "meters", transition: true, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-extrusion-base": { type: "number", default: 0, minimum: 0, units: "meters", transition: true, requires: ["fill-extrusion-height"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-extrusion-vertical-gradient": { type: "boolean", default: true, transition: false, expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_line: { "line-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-color": { type: "color", default: "#000000", transition: true, requires: [{ "!": "line-pattern" }], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["line-translate"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-width": { type: "number", default: 1, minimum: 0, transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-gap-width": { type: "number", default: 0, minimum: 0, transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-offset": { type: "number", default: 0, transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-blur": { type: "number", default: 0, minimum: 0, transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-dasharray": { type: "array", value: "number", minimum: 0, transition: true, units: "line widths", requires: [{ "!": "line-pattern" }], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "cross-faded" }, "line-pattern": { type: "resolvedImage", transition: true, expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "cross-faded-data-driven" }, "line-gradient": { type: "color", transition: false, requires: [{ "!": "line-dasharray" }, { "!": "line-pattern" }, { source: "geojson", has: { lineMetrics: true } }], expression: { interpolated: true, parameters: ["line-progress"] }, "property-type": "color-ramp" } }, paint_circle: { "circle-radius": { type: "number", default: 5, minimum: 0, transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-color": { type: "color", default: "#000000", transition: true, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-blur": { type: "number", default: 0, transition: true, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "circle-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["circle-translate"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "circle-pitch-scale": { type: "enum", values: { map: {}, viewport: {} }, default: "map", expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "circle-pitch-alignment": { type: "enum", values: { map: {}, viewport: {} }, default: "viewport", expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "circle-stroke-width": { type: "number", default: 0, minimum: 0, transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-stroke-color": { type: "color", default: "#000000", transition: true, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-stroke-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" } }, paint_heatmap: { "heatmap-radius": { type: "number", default: 30, minimum: 1, transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "heatmap-weight": { type: "number", default: 1, minimum: 0, transition: false, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "heatmap-intensity": { type: "number", default: 1, minimum: 0, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "heatmap-color": { type: "color", default: ["interpolate", ["linear"], ["heatmap-density"], 0, "rgba(0, 0, 255, 0)", 0.1, "royalblue", 0.3, "cyan", 0.5, "lime", 0.7, "yellow", 1, "red"], transition: false, expression: { interpolated: true, parameters: ["heatmap-density"] }, "property-type": "color-ramp" }, "heatmap-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_symbol: { "icon-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-color": { type: "color", default: "#000000", transition: true, requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-halo-color": { type: "color", default: "rgba(0, 0, 0, 0)", transition: true, requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-halo-width": { type: "number", default: 0, minimum: 0, transition: true, units: "pixels", requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-halo-blur": { type: "number", default: 0, minimum: 0, transition: true, units: "pixels", requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: true, units: "pixels", requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["icon-image", "icon-translate"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-color": { type: "color", default: "#000000", transition: true, overridable: true, requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-halo-color": { type: "color", default: "rgba(0, 0, 0, 0)", transition: true, requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-halo-width": { type: "number", default: 0, minimum: 0, transition: true, units: "pixels", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-halo-blur": { type: "number", default: 0, minimum: 0, transition: true, units: "pixels", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: true, units: "pixels", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["text-field", "text-translate"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_raster: { "raster-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-hue-rotate": { type: "number", default: 0, period: 360, transition: true, units: "degrees", expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-brightness-min": { type: "number", default: 0, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-brightness-max": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-saturation": { type: "number", default: 0, minimum: -1, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-contrast": { type: "number", default: 0, minimum: -1, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-resampling": { type: "enum", values: { linear: {}, nearest: {} }, default: "linear", expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-fade-duration": { type: "number", default: 300, minimum: 0, transition: false, units: "milliseconds", expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_hillshade: { "hillshade-illumination-direction": { type: "number", default: 335, minimum: 0, maximum: 359, transition: false, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-illumination-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "viewport", expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-exaggeration": { type: "number", default: 0.5, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-shadow-color": { type: "color", default: "#000000", transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-highlight-color": { type: "color", default: "#FFFFFF", transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-accent-color": { type: "color", default: "#000000", transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_background: { "background-color": { type: "color", default: "#000000", transition: true, requires: [{ "!": "background-pattern" }], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "background-pattern": { type: "resolvedImage", transition: true, expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "cross-faded" }, "background-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" } }, transition: { duration: { type: "number", default: 300, minimum: 0, units: "milliseconds" }, delay: { type: "number", default: 0, minimum: 0, units: "milliseconds" } }, "property-type": { "data-driven": { type: "property-type" }, "cross-faded": { type: "property-type" }, "cross-faded-data-driven": { type: "property-type" }, "color-ramp": { type: "property-type" }, "data-constant": { type: "property-type" }, constant: { type: "property-type" } }, promoteId: { "*": { type: "string" } } };
          const yt = ["type", "source", "source-layer", "minzoom", "maxzoom", "filter", "layout"];
          function mt(t5, e7) {
            const r7 = {};
            for (const e8 in t5) "ref" !== e8 && (r7[e8] = t5[e8]);
            return yt.forEach((t6) => {
              t6 in e7 && (r7[t6] = e7[t6]);
            }), r7;
          }
          function gt(t5, e7) {
            if (Array.isArray(t5)) {
              if (!Array.isArray(e7) || t5.length !== e7.length) return false;
              for (let r7 = 0; r7 < t5.length; r7++) if (!gt(t5[r7], e7[r7])) return false;
              return true;
            }
            if ("object" == typeof t5 && null !== t5 && null !== e7) {
              if ("object" != typeof e7) return false;
              if (Object.keys(t5).length !== Object.keys(e7).length) return false;
              for (const r7 in t5) if (!gt(t5[r7], e7[r7])) return false;
              return true;
            }
            return t5 === e7;
          }
          function xt(t5, e7) {
            t5.push(e7);
          }
          function vt(t5, e7, r7) {
            xt(r7, { command: "addSource", args: [t5, e7[t5]] });
          }
          function bt(t5, e7, r7) {
            xt(e7, { command: "removeSource", args: [t5] }), r7[t5] = true;
          }
          function wt(t5, e7, r7, n6) {
            bt(t5, r7, n6), vt(t5, e7, r7);
          }
          function _t(t5, e7, r7) {
            let n6;
            for (n6 in t5[r7]) if (Object.prototype.hasOwnProperty.call(t5[r7], n6) && "data" !== n6 && !gt(t5[r7][n6], e7[r7][n6])) return false;
            for (n6 in e7[r7]) if (Object.prototype.hasOwnProperty.call(e7[r7], n6) && "data" !== n6 && !gt(t5[r7][n6], e7[r7][n6])) return false;
            return true;
          }
          function St(t5, e7, r7, n6, i6, s5) {
            t5 = t5 || {}, e7 = e7 || {};
            for (const a4 in t5) Object.prototype.hasOwnProperty.call(t5, a4) && (gt(t5[a4], e7[a4]) || r7.push({ command: s5, args: [n6, a4, e7[a4], i6] }));
            for (const a4 in e7) Object.prototype.hasOwnProperty.call(e7, a4) && !Object.prototype.hasOwnProperty.call(t5, a4) && (gt(t5[a4], e7[a4]) || r7.push({ command: s5, args: [n6, a4, e7[a4], i6] }));
          }
          function At(t5) {
            return t5.id;
          }
          function kt(t5, e7) {
            return t5[e7.id] = e7, t5;
          }
          class Mt {
            constructor(t5, e7, r7, n6) {
              this.message = (t5 ? `${t5}: ` : "") + r7, n6 && (this.identifier = n6), null != e7 && e7.__line__ && (this.line = e7.__line__);
            }
          }
          function It(t5, ...e7) {
            for (const r7 of e7) for (const e8 in r7) t5[e8] = r7[e8];
            return t5;
          }
          class zt extends Error {
            constructor(t5, e7) {
              super(e7), this.message = e7, this.key = t5;
            }
          }
          class Pt {
            constructor(t5, e7 = []) {
              this.parent = t5, this.bindings = {};
              for (const [t6, r7] of e7) this.bindings[t6] = r7;
            }
            concat(t5) {
              return new Pt(this, t5);
            }
            get(t5) {
              if (this.bindings[t5]) return this.bindings[t5];
              if (this.parent) return this.parent.get(t5);
              throw new Error(`${t5} not found in scope.`);
            }
            has(t5) {
              return !!this.bindings[t5] || !!this.parent && this.parent.has(t5);
            }
          }
          const Ct = { kind: "null" }, Bt = { kind: "number" }, Vt = { kind: "string" }, Et = { kind: "boolean" }, Tt = { kind: "color" }, Ft = { kind: "projectionDefinition" }, $t = { kind: "object" }, Lt = { kind: "value" }, Ot = { kind: "collator" }, Dt = { kind: "formatted" }, Rt = { kind: "padding" }, jt = { kind: "resolvedImage" }, Nt = { kind: "variableAnchorOffsetCollection" };
          function Ut(t5, e7) {
            return { kind: "array", itemType: t5, N: e7 };
          }
          function qt(t5) {
            if ("array" === t5.kind) {
              const e7 = qt(t5.itemType);
              return "number" == typeof t5.N ? `array<${e7}, ${t5.N}>` : "value" === t5.itemType.kind ? "array" : `array<${e7}>`;
            }
            return t5.kind;
          }
          const Gt = [Ct, Bt, Vt, Et, Tt, Ft, Dt, $t, Ut(Lt), Rt, jt, Nt];
          function Zt(t5, e7) {
            if ("error" === e7.kind) return null;
            if ("array" === t5.kind) {
              if ("array" === e7.kind && (0 === e7.N && "value" === e7.itemType.kind || !Zt(t5.itemType, e7.itemType)) && ("number" != typeof t5.N || t5.N === e7.N)) return null;
            } else {
              if (t5.kind === e7.kind) return null;
              if ("value" === t5.kind) {
                for (const t6 of Gt) if (!Zt(t6, e7)) return null;
              }
            }
            return `Expected ${qt(t5)} but found ${qt(e7)} instead.`;
          }
          function Kt(t5, e7) {
            return e7.some((e8) => e8.kind === t5.kind);
          }
          function Xt(t5, e7) {
            return e7.some((e8) => "null" === e8 ? null === t5 : "array" === e8 ? Array.isArray(t5) : "object" === e8 ? t5 && !Array.isArray(t5) && "object" == typeof t5 : e8 === typeof t5);
          }
          function Ht(t5, e7) {
            return "array" === t5.kind && "array" === e7.kind ? t5.itemType.kind === e7.itemType.kind && "number" == typeof t5.N : t5.kind === e7.kind;
          }
          const Yt = 0.96422, Jt = 0.82521, Wt = 4 / 29, Qt = 6 / 29, te = 3 * Qt * Qt, ee = Qt * Qt * Qt, re2 = Math.PI / 180, ne = 180 / Math.PI;
          function ie2(t5) {
            return (t5 %= 360) < 0 && (t5 += 360), t5;
          }
          function se([t5, e7, r7, n6]) {
            let i6, s5;
            const a4 = oe((0.2225045 * (t5 = ae(t5)) + 0.7168786 * (e7 = ae(e7)) + 0.0606169 * (r7 = ae(r7))) / 1);
            t5 === e7 && e7 === r7 ? i6 = s5 = a4 : (i6 = oe((0.4360747 * t5 + 0.3850649 * e7 + 0.1430804 * r7) / Yt), s5 = oe((0.0139322 * t5 + 0.0971045 * e7 + 0.7141733 * r7) / Jt));
            const o7 = 116 * a4 - 16;
            return [o7 < 0 ? 0 : o7, 500 * (i6 - a4), 200 * (a4 - s5), n6];
          }
          function ae(t5) {
            return t5 <= 0.04045 ? t5 / 12.92 : Math.pow((t5 + 0.055) / 1.055, 2.4);
          }
          function oe(t5) {
            return t5 > ee ? Math.pow(t5, 1 / 3) : t5 / te + Wt;
          }
          function le([t5, e7, r7, n6]) {
            let i6 = (t5 + 16) / 116, s5 = isNaN(e7) ? i6 : i6 + e7 / 500, a4 = isNaN(r7) ? i6 : i6 - r7 / 200;
            return i6 = 1 * ce(i6), s5 = Yt * ce(s5), a4 = Jt * ce(a4), [ue(3.1338561 * s5 - 1.6168667 * i6 - 0.4906146 * a4), ue(-0.9787684 * s5 + 1.9161415 * i6 + 0.033454 * a4), ue(0.0719453 * s5 - 0.2289914 * i6 + 1.4052427 * a4), n6];
          }
          function ue(t5) {
            return (t5 = t5 <= 304e-5 ? 12.92 * t5 : 1.055 * Math.pow(t5, 1 / 2.4) - 0.055) < 0 ? 0 : t5 > 1 ? 1 : t5;
          }
          function ce(t5) {
            return t5 > Qt ? t5 * t5 * t5 : te * (t5 - Wt);
          }
          function he(t5) {
            return parseInt(t5.padEnd(2, t5), 16) / 255;
          }
          function pe(t5, e7) {
            return fe(e7 ? t5 / 100 : t5, 0, 1);
          }
          function fe(t5, e7, r7) {
            return Math.min(Math.max(e7, t5), r7);
          }
          function de(t5) {
            return !t5.some(Number.isNaN);
          }
          const ye = { aliceblue: [240, 248, 255], antiquewhite: [250, 235, 215], aqua: [0, 255, 255], aquamarine: [127, 255, 212], azure: [240, 255, 255], beige: [245, 245, 220], bisque: [255, 228, 196], black: [0, 0, 0], blanchedalmond: [255, 235, 205], blue: [0, 0, 255], blueviolet: [138, 43, 226], brown: [165, 42, 42], burlywood: [222, 184, 135], cadetblue: [95, 158, 160], chartreuse: [127, 255, 0], chocolate: [210, 105, 30], coral: [255, 127, 80], cornflowerblue: [100, 149, 237], cornsilk: [255, 248, 220], crimson: [220, 20, 60], cyan: [0, 255, 255], darkblue: [0, 0, 139], darkcyan: [0, 139, 139], darkgoldenrod: [184, 134, 11], darkgray: [169, 169, 169], darkgreen: [0, 100, 0], darkgrey: [169, 169, 169], darkkhaki: [189, 183, 107], darkmagenta: [139, 0, 139], darkolivegreen: [85, 107, 47], darkorange: [255, 140, 0], darkorchid: [153, 50, 204], darkred: [139, 0, 0], darksalmon: [233, 150, 122], darkseagreen: [143, 188, 143], darkslateblue: [72, 61, 139], darkslategray: [47, 79, 79], darkslategrey: [47, 79, 79], darkturquoise: [0, 206, 209], darkviolet: [148, 0, 211], deeppink: [255, 20, 147], deepskyblue: [0, 191, 255], dimgray: [105, 105, 105], dimgrey: [105, 105, 105], dodgerblue: [30, 144, 255], firebrick: [178, 34, 34], floralwhite: [255, 250, 240], forestgreen: [34, 139, 34], fuchsia: [255, 0, 255], gainsboro: [220, 220, 220], ghostwhite: [248, 248, 255], gold: [255, 215, 0], goldenrod: [218, 165, 32], gray: [128, 128, 128], green: [0, 128, 0], greenyellow: [173, 255, 47], grey: [128, 128, 128], honeydew: [240, 255, 240], hotpink: [255, 105, 180], indianred: [205, 92, 92], indigo: [75, 0, 130], ivory: [255, 255, 240], khaki: [240, 230, 140], lavender: [230, 230, 250], lavenderblush: [255, 240, 245], lawngreen: [124, 252, 0], lemonchiffon: [255, 250, 205], lightblue: [173, 216, 230], lightcoral: [240, 128, 128], lightcyan: [224, 255, 255], lightgoldenrodyellow: [250, 250, 210], lightgray: [211, 211, 211], lightgreen: [144, 238, 144], lightgrey: [211, 211, 211], lightpink: [255, 182, 193], lightsalmon: [255, 160, 122], lightseagreen: [32, 178, 170], lightskyblue: [135, 206, 250], lightslategray: [119, 136, 153], lightslategrey: [119, 136, 153], lightsteelblue: [176, 196, 222], lightyellow: [255, 255, 224], lime: [0, 255, 0], limegreen: [50, 205, 50], linen: [250, 240, 230], magenta: [255, 0, 255], maroon: [128, 0, 0], mediumaquamarine: [102, 205, 170], mediumblue: [0, 0, 205], mediumorchid: [186, 85, 211], mediumpurple: [147, 112, 219], mediumseagreen: [60, 179, 113], mediumslateblue: [123, 104, 238], mediumspringgreen: [0, 250, 154], mediumturquoise: [72, 209, 204], mediumvioletred: [199, 21, 133], midnightblue: [25, 25, 112], mintcream: [245, 255, 250], mistyrose: [255, 228, 225], moccasin: [255, 228, 181], navajowhite: [255, 222, 173], navy: [0, 0, 128], oldlace: [253, 245, 230], olive: [128, 128, 0], olivedrab: [107, 142, 35], orange: [255, 165, 0], orangered: [255, 69, 0], orchid: [218, 112, 214], palegoldenrod: [238, 232, 170], palegreen: [152, 251, 152], paleturquoise: [175, 238, 238], palevioletred: [219, 112, 147], papayawhip: [255, 239, 213], peachpuff: [255, 218, 185], peru: [205, 133, 63], pink: [255, 192, 203], plum: [221, 160, 221], powderblue: [176, 224, 230], purple: [128, 0, 128], rebeccapurple: [102, 51, 153], red: [255, 0, 0], rosybrown: [188, 143, 143], royalblue: [65, 105, 225], saddlebrown: [139, 69, 19], salmon: [250, 128, 114], sandybrown: [244, 164, 96], seagreen: [46, 139, 87], seashell: [255, 245, 238], sienna: [160, 82, 45], silver: [192, 192, 192], skyblue: [135, 206, 235], slateblue: [106, 90, 205], slategray: [112, 128, 144], slategrey: [112, 128, 144], snow: [255, 250, 250], springgreen: [0, 255, 127], steelblue: [70, 130, 180], tan: [210, 180, 140], teal: [0, 128, 128], thistle: [216, 191, 216], tomato: [255, 99, 71], turquoise: [64, 224, 208], violet: [238, 130, 238], wheat: [245, 222, 179], white: [255, 255, 255], whitesmoke: [245, 245, 245], yellow: [255, 255, 0], yellowgreen: [154, 205, 50] };
          function me(t5, e7, r7) {
            return t5 + r7 * (e7 - t5);
          }
          function ge(t5, e7, r7) {
            return t5.map((t6, n6) => me(t6, e7[n6], r7));
          }
          class xe {
            constructor(t5, e7, r7, n6 = 1, i6 = true) {
              this.r = t5, this.g = e7, this.b = r7, this.a = n6, i6 || (this.r *= n6, this.g *= n6, this.b *= n6, n6 || this.overwriteGetter("rgb", [t5, e7, r7, n6]));
            }
            static parse(t5) {
              if (t5 instanceof xe) return t5;
              if ("string" != typeof t5) return;
              const e7 = function(t6) {
                if ("transparent" === (t6 = t6.toLowerCase().trim())) return [0, 0, 0, 0];
                const e8 = ye[t6];
                if (e8) {
                  const [t7, r8, n6] = e8;
                  return [t7 / 255, r8 / 255, n6 / 255, 1];
                }
                if (t6.startsWith("#") && /^#(?:[0-9a-f]{3,4}|[0-9a-f]{6}|[0-9a-f]{8})$/.test(t6)) {
                  const e9 = t6.length < 6 ? 1 : 2;
                  let r8 = 1;
                  return [he(t6.slice(r8, r8 += e9)), he(t6.slice(r8, r8 += e9)), he(t6.slice(r8, r8 += e9)), he(t6.slice(r8, r8 + e9) || "ff")];
                }
                if (t6.startsWith("rgb")) {
                  const e9 = t6.match(/^rgba?\(\s*([\de.+-]+)(%)?(?:\s+|\s*(,)\s*)([\de.+-]+)(%)?(?:\s+|\s*(,)\s*)([\de.+-]+)(%)?(?:\s*([,\/])\s*([\de.+-]+)(%)?)?\s*\)$/);
                  if (e9) {
                    const [t7, r8, n6, i6, s5, a4, o7, l5, u4, c5, h4, p4] = e9, f4 = [i6 || " ", o7 || " ", c5].join("");
                    if ("  " === f4 || "  /" === f4 || ",," === f4 || ",,," === f4) {
                      const t8 = [n6, a4, u4].join(""), e10 = "%%%" === t8 ? 100 : "" === t8 ? 255 : 0;
                      if (e10) {
                        const t9 = [fe(+r8 / e10, 0, 1), fe(+s5 / e10, 0, 1), fe(+l5 / e10, 0, 1), h4 ? pe(+h4, p4) : 1];
                        if (de(t9)) return t9;
                      }
                    }
                    return;
                  }
                }
                const r7 = t6.match(/^hsla?\(\s*([\de.+-]+)(?:deg)?(?:\s+|\s*(,)\s*)([\de.+-]+)%(?:\s+|\s*(,)\s*)([\de.+-]+)%(?:\s*([,\/])\s*([\de.+-]+)(%)?)?\s*\)$/);
                if (r7) {
                  const [t7, e9, n6, i6, s5, a4, o7, l5, u4] = r7, c5 = [n6 || " ", s5 || " ", o7].join("");
                  if ("  " === c5 || "  /" === c5 || ",," === c5 || ",,," === c5) {
                    const t8 = [+e9, fe(+i6, 0, 100), fe(+a4, 0, 100), l5 ? pe(+l5, u4) : 1];
                    if (de(t8)) return function([t9, e10, r8, n7]) {
                      function i7(n8) {
                        const i8 = (n8 + t9 / 30) % 12, s6 = e10 * Math.min(r8, 1 - r8);
                        return r8 - s6 * Math.max(-1, Math.min(i8 - 3, 9 - i8, 1));
                      }
                      return t9 = ie2(t9), e10 /= 100, r8 /= 100, [i7(0), i7(8), i7(4), n7];
                    }(t8);
                  }
                }
              }(t5);
              return e7 ? new xe(...e7, false) : void 0;
            }
            get rgb() {
              const { r: t5, g: e7, b: r7, a: n6 } = this, i6 = n6 || 1 / 0;
              return this.overwriteGetter("rgb", [t5 / i6, e7 / i6, r7 / i6, n6]);
            }
            get hcl() {
              return this.overwriteGetter("hcl", function(t5) {
                const [e7, r7, n6, i6] = se(t5), s5 = Math.sqrt(r7 * r7 + n6 * n6);
                return [Math.round(1e4 * s5) ? ie2(Math.atan2(n6, r7) * ne) : NaN, s5, e7, i6];
              }(this.rgb));
            }
            get lab() {
              return this.overwriteGetter("lab", se(this.rgb));
            }
            overwriteGetter(t5, e7) {
              return Object.defineProperty(this, t5, { value: e7 }), e7;
            }
            toString() {
              const [t5, e7, r7, n6] = this.rgb;
              return `rgba(${[t5, e7, r7].map((t6) => Math.round(255 * t6)).join(",")},${n6})`;
            }
            static interpolate(t5, e7, r7, n6 = "rgb") {
              switch (n6) {
                case "rgb": {
                  const [n7, i6, s5, a4] = ge(t5.rgb, e7.rgb, r7);
                  return new xe(n7, i6, s5, a4, false);
                }
                case "hcl": {
                  const [n7, i6, s5, a4] = t5.hcl, [o7, l5, u4, c5] = e7.hcl;
                  let h4, p4;
                  if (isNaN(n7) || isNaN(o7)) isNaN(n7) ? isNaN(o7) ? h4 = NaN : (h4 = o7, 1 !== s5 && 0 !== s5 || (p4 = l5)) : (h4 = n7, 1 !== u4 && 0 !== u4 || (p4 = i6));
                  else {
                    let t6 = o7 - n7;
                    o7 > n7 && t6 > 180 ? t6 -= 360 : o7 < n7 && n7 - o7 > 180 && (t6 += 360), h4 = n7 + r7 * t6;
                  }
                  const [f4, d4, y4, m4] = function([t6, e8, r8, n8]) {
                    return t6 = isNaN(t6) ? 0 : t6 * re2, le([r8, Math.cos(t6) * e8, Math.sin(t6) * e8, n8]);
                  }([h4, null != p4 ? p4 : me(i6, l5, r7), me(s5, u4, r7), me(a4, c5, r7)]);
                  return new xe(f4, d4, y4, m4, false);
                }
                case "lab": {
                  const [n7, i6, s5, a4] = le(ge(t5.lab, e7.lab, r7));
                  return new xe(n7, i6, s5, a4, false);
                }
              }
            }
          }
          xe.black = new xe(0, 0, 0, 1), xe.white = new xe(1, 1, 1, 1), xe.transparent = new xe(0, 0, 0, 0), xe.red = new xe(1, 0, 0, 1);
          class ve {
            constructor(t5, e7, r7) {
              this.sensitivity = t5 ? e7 ? "variant" : "case" : e7 ? "accent" : "base", this.locale = r7, this.collator = new Intl.Collator(this.locale ? this.locale : [], { sensitivity: this.sensitivity, usage: "search" });
            }
            compare(t5, e7) {
              return this.collator.compare(t5, e7);
            }
            resolvedLocale() {
              return new Intl.Collator(this.locale ? this.locale : []).resolvedOptions().locale;
            }
          }
          const be = ["bottom", "center", "top"];
          class we {
            constructor(t5, e7, r7, n6, i6, s5) {
              this.text = t5, this.image = e7, this.scale = r7, this.fontStack = n6, this.textColor = i6, this.verticalAlign = s5;
            }
          }
          class _e {
            constructor(t5) {
              this.sections = t5;
            }
            static fromString(t5) {
              return new _e([new we(t5, null, null, null, null, null)]);
            }
            isEmpty() {
              return 0 === this.sections.length || !this.sections.some((t5) => 0 !== t5.text.length || t5.image && 0 !== t5.image.name.length);
            }
            static factory(t5) {
              return t5 instanceof _e ? t5 : _e.fromString(t5);
            }
            toString() {
              return 0 === this.sections.length ? "" : this.sections.map((t5) => t5.text).join("");
            }
          }
          class Se {
            constructor(t5) {
              this.values = t5.slice();
            }
            static parse(t5) {
              if (t5 instanceof Se) return t5;
              if ("number" == typeof t5) return new Se([t5, t5, t5, t5]);
              if (Array.isArray(t5) && !(t5.length < 1 || t5.length > 4)) {
                for (const e7 of t5) if ("number" != typeof e7) return;
                switch (t5.length) {
                  case 1:
                    t5 = [t5[0], t5[0], t5[0], t5[0]];
                    break;
                  case 2:
                    t5 = [t5[0], t5[1], t5[0], t5[1]];
                    break;
                  case 3:
                    t5 = [t5[0], t5[1], t5[2], t5[1]];
                }
                return new Se(t5);
              }
            }
            toString() {
              return JSON.stringify(this.values);
            }
            static interpolate(t5, e7, r7) {
              return new Se(ge(t5.values, e7.values, r7));
            }
          }
          class Ae {
            constructor(t5) {
              this.name = "ExpressionEvaluationError", this.message = t5;
            }
            toJSON() {
              return this.message;
            }
          }
          const ke = /* @__PURE__ */ new Set(["center", "left", "right", "top", "bottom", "top-left", "top-right", "bottom-left", "bottom-right"]);
          class Me {
            constructor(t5) {
              this.values = t5.slice();
            }
            static parse(t5) {
              if (t5 instanceof Me) return t5;
              if (Array.isArray(t5) && !(t5.length < 1) && t5.length % 2 == 0) {
                for (let e7 = 0; e7 < t5.length; e7 += 2) {
                  const r7 = t5[e7], n6 = t5[e7 + 1];
                  if ("string" != typeof r7 || !ke.has(r7)) return;
                  if (!Array.isArray(n6) || 2 !== n6.length || "number" != typeof n6[0] || "number" != typeof n6[1]) return;
                }
                return new Me(t5);
              }
            }
            toString() {
              return JSON.stringify(this.values);
            }
            static interpolate(t5, e7, r7) {
              const n6 = t5.values, i6 = e7.values;
              if (n6.length !== i6.length) throw new Ae(`Cannot interpolate values of different length. from: ${t5.toString()}, to: ${e7.toString()}`);
              const s5 = [];
              for (let t6 = 0; t6 < n6.length; t6 += 2) {
                if (n6[t6] !== i6[t6]) throw new Ae(`Cannot interpolate values containing mismatched anchors. from[${t6}]: ${n6[t6]}, to[${t6}]: ${i6[t6]}`);
                s5.push(n6[t6]);
                const [e8, a4] = n6[t6 + 1], [o7, l5] = i6[t6 + 1];
                s5.push([me(e8, o7, r7), me(a4, l5, r7)]);
              }
              return new Me(s5);
            }
          }
          class Ie {
            constructor(t5) {
              this.name = t5.name, this.available = t5.available;
            }
            toString() {
              return this.name;
            }
            static fromString(t5) {
              return t5 ? new Ie({ name: t5, available: false }) : null;
            }
          }
          class ze {
            constructor(t5, e7, r7) {
              this.from = t5, this.to = e7, this.transition = r7;
            }
            static interpolate(t5, e7, r7) {
              return new ze(t5, e7, r7);
            }
            static parse(t5) {
              return t5 instanceof ze ? t5 : Array.isArray(t5) && 3 === t5.length && "string" == typeof t5[0] && "string" == typeof t5[1] && "number" == typeof t5[2] ? new ze(t5[0], t5[1], t5[2]) : "object" == typeof t5 && "string" == typeof t5.from && "string" == typeof t5.to && "number" == typeof t5.transition ? new ze(t5.from, t5.to, t5.transition) : "string" == typeof t5 ? new ze(t5, t5, 1) : void 0;
            }
          }
          function Pe(t5, e7, r7, n6) {
            return "number" == typeof t5 && t5 >= 0 && t5 <= 255 && "number" == typeof e7 && e7 >= 0 && e7 <= 255 && "number" == typeof r7 && r7 >= 0 && r7 <= 255 ? void 0 === n6 || "number" == typeof n6 && n6 >= 0 && n6 <= 1 ? null : `Invalid rgba value [${[t5, e7, r7, n6].join(", ")}]: 'a' must be between 0 and 1.` : `Invalid rgba value [${("number" == typeof n6 ? [t5, e7, r7, n6] : [t5, e7, r7]).join(", ")}]: 'r', 'g', and 'b' must be between 0 and 255.`;
          }
          function Ce(t5) {
            if (null === t5 || "string" == typeof t5 || "boolean" == typeof t5 || "number" == typeof t5 || t5 instanceof ze || t5 instanceof xe || t5 instanceof ve || t5 instanceof _e || t5 instanceof Se || t5 instanceof Me || t5 instanceof Ie) return true;
            if (Array.isArray(t5)) {
              for (const e7 of t5) if (!Ce(e7)) return false;
              return true;
            }
            if ("object" == typeof t5) {
              for (const e7 in t5) if (!Ce(t5[e7])) return false;
              return true;
            }
            return false;
          }
          function Be(t5) {
            if (null === t5) return Ct;
            if ("string" == typeof t5) return Vt;
            if ("boolean" == typeof t5) return Et;
            if ("number" == typeof t5) return Bt;
            if (t5 instanceof xe) return Tt;
            if (t5 instanceof ze) return Ft;
            if (t5 instanceof ve) return Ot;
            if (t5 instanceof _e) return Dt;
            if (t5 instanceof Se) return Rt;
            if (t5 instanceof Me) return Nt;
            if (t5 instanceof Ie) return jt;
            if (Array.isArray(t5)) {
              const e7 = t5.length;
              let r7;
              for (const e8 of t5) {
                const t6 = Be(e8);
                if (r7) {
                  if (r7 === t6) continue;
                  r7 = Lt;
                  break;
                }
                r7 = t6;
              }
              return Ut(r7 || Lt, e7);
            }
            return $t;
          }
          function Ve(t5) {
            const e7 = typeof t5;
            return null === t5 ? "" : "string" === e7 || "number" === e7 || "boolean" === e7 ? String(t5) : t5 instanceof xe || t5 instanceof ze || t5 instanceof _e || t5 instanceof Se || t5 instanceof Me || t5 instanceof Ie ? t5.toString() : JSON.stringify(t5);
          }
          class Ee {
            constructor(t5, e7) {
              this.type = t5, this.value = e7;
            }
            static parse(t5, e7) {
              if (2 !== t5.length) return e7.error(`'literal' expression requires exactly one argument, but found ${t5.length - 1} instead.`);
              if (!Ce(t5[1])) return e7.error("invalid value");
              const r7 = t5[1];
              let n6 = Be(r7);
              const i6 = e7.expectedType;
              return "array" !== n6.kind || 0 !== n6.N || !i6 || "array" !== i6.kind || "number" == typeof i6.N && 0 !== i6.N || (n6 = i6), new Ee(n6, r7);
            }
            evaluate() {
              return this.value;
            }
            eachChild() {
            }
            outputDefined() {
              return true;
            }
          }
          const Te = { string: Vt, number: Bt, boolean: Et, object: $t };
          class Fe {
            constructor(t5, e7) {
              this.type = t5, this.args = e7;
            }
            static parse(t5, e7) {
              if (t5.length < 2) return e7.error("Expected at least one argument.");
              let r7, n6 = 1;
              const i6 = t5[0];
              if ("array" === i6) {
                let i7, s6;
                if (t5.length > 2) {
                  const r8 = t5[1];
                  if ("string" != typeof r8 || !(r8 in Te) || "object" === r8) return e7.error('The item type argument of "array" must be one of string, number, boolean', 1);
                  i7 = Te[r8], n6++;
                } else i7 = Lt;
                if (t5.length > 3) {
                  if (null !== t5[2] && ("number" != typeof t5[2] || t5[2] < 0 || t5[2] !== Math.floor(t5[2]))) return e7.error('The length argument to "array" must be a positive integer literal', 2);
                  s6 = t5[2], n6++;
                }
                r7 = Ut(i7, s6);
              } else {
                if (!Te[i6]) throw new Error(`Types doesn't contain name = ${i6}`);
                r7 = Te[i6];
              }
              const s5 = [];
              for (; n6 < t5.length; n6++) {
                const r8 = e7.parse(t5[n6], n6, Lt);
                if (!r8) return null;
                s5.push(r8);
              }
              return new Fe(r7, s5);
            }
            evaluate(t5) {
              for (let e7 = 0; e7 < this.args.length; e7++) {
                const r7 = this.args[e7].evaluate(t5);
                if (!Zt(this.type, Be(r7))) return r7;
                if (e7 === this.args.length - 1) throw new Ae(`Expected value to be of type ${qt(this.type)}, but found ${qt(Be(r7))} instead.`);
              }
              throw new Error();
            }
            eachChild(t5) {
              this.args.forEach(t5);
            }
            outputDefined() {
              return this.args.every((t5) => t5.outputDefined());
            }
          }
          const $e = { "to-boolean": Et, "to-color": Tt, "to-number": Bt, "to-string": Vt };
          class Le {
            constructor(t5, e7) {
              this.type = t5, this.args = e7;
            }
            static parse(t5, e7) {
              if (t5.length < 2) return e7.error("Expected at least one argument.");
              const r7 = t5[0];
              if (!$e[r7]) throw new Error(`Can't parse ${r7} as it is not part of the known types`);
              if (("to-boolean" === r7 || "to-string" === r7) && 2 !== t5.length) return e7.error("Expected one argument.");
              const n6 = $e[r7], i6 = [];
              for (let r8 = 1; r8 < t5.length; r8++) {
                const n7 = e7.parse(t5[r8], r8, Lt);
                if (!n7) return null;
                i6.push(n7);
              }
              return new Le(n6, i6);
            }
            evaluate(t5) {
              switch (this.type.kind) {
                case "boolean":
                  return Boolean(this.args[0].evaluate(t5));
                case "color": {
                  let e7, r7;
                  for (const n6 of this.args) {
                    if (e7 = n6.evaluate(t5), r7 = null, e7 instanceof xe) return e7;
                    if ("string" == typeof e7) {
                      const r8 = t5.parseColor(e7);
                      if (r8) return r8;
                    } else if (Array.isArray(e7) && (r7 = e7.length < 3 || e7.length > 4 ? `Invalid rgba value ${JSON.stringify(e7)}: expected an array containing either three or four numeric values.` : Pe(e7[0], e7[1], e7[2], e7[3]), !r7)) return new xe(e7[0] / 255, e7[1] / 255, e7[2] / 255, e7[3]);
                  }
                  throw new Ae(r7 || `Could not parse color from value '${"string" == typeof e7 ? e7 : JSON.stringify(e7)}'`);
                }
                case "padding": {
                  let e7;
                  for (const r7 of this.args) {
                    e7 = r7.evaluate(t5);
                    const n6 = Se.parse(e7);
                    if (n6) return n6;
                  }
                  throw new Ae(`Could not parse padding from value '${"string" == typeof e7 ? e7 : JSON.stringify(e7)}'`);
                }
                case "variableAnchorOffsetCollection": {
                  let e7;
                  for (const r7 of this.args) {
                    e7 = r7.evaluate(t5);
                    const n6 = Me.parse(e7);
                    if (n6) return n6;
                  }
                  throw new Ae(`Could not parse variableAnchorOffsetCollection from value '${"string" == typeof e7 ? e7 : JSON.stringify(e7)}'`);
                }
                case "number": {
                  let e7 = null;
                  for (const r7 of this.args) {
                    if (e7 = r7.evaluate(t5), null === e7) return 0;
                    const n6 = Number(e7);
                    if (!isNaN(n6)) return n6;
                  }
                  throw new Ae(`Could not convert ${JSON.stringify(e7)} to number.`);
                }
                case "formatted":
                  return _e.fromString(Ve(this.args[0].evaluate(t5)));
                case "resolvedImage":
                  return Ie.fromString(Ve(this.args[0].evaluate(t5)));
                case "projectionDefinition":
                  return this.args[0].evaluate(t5);
                default:
                  return Ve(this.args[0].evaluate(t5));
              }
            }
            eachChild(t5) {
              this.args.forEach(t5);
            }
            outputDefined() {
              return this.args.every((t5) => t5.outputDefined());
            }
          }
          const Oe = ["Unknown", "Point", "LineString", "Polygon"];
          class De {
            constructor() {
              this.globals = null, this.feature = null, this.featureState = null, this.formattedSection = null, this._parseColorCache = {}, this.availableImages = null, this.canonical = null;
            }
            id() {
              return this.feature && "id" in this.feature ? this.feature.id : null;
            }
            geometryType() {
              return this.feature ? "number" == typeof this.feature.type ? Oe[this.feature.type] : this.feature.type : null;
            }
            geometry() {
              return this.feature && "geometry" in this.feature ? this.feature.geometry : null;
            }
            canonicalID() {
              return this.canonical;
            }
            properties() {
              return this.feature && this.feature.properties || {};
            }
            parseColor(t5) {
              let e7 = this._parseColorCache[t5];
              return e7 || (e7 = this._parseColorCache[t5] = xe.parse(t5)), e7;
            }
          }
          class Re {
            constructor(t5, e7, r7 = [], n6, i6 = new Pt(), s5 = []) {
              this.registry = t5, this.path = r7, this.key = r7.map((t6) => `[${t6}]`).join(""), this.scope = i6, this.errors = s5, this.expectedType = n6, this._isConstant = e7;
            }
            parse(t5, e7, r7, n6, i6 = {}) {
              return e7 ? this.concat(e7, r7, n6)._parse(t5, i6) : this._parse(t5, i6);
            }
            _parse(t5, e7) {
              function r7(t6, e8, r8) {
                return "assert" === r8 ? new Fe(e8, [t6]) : "coerce" === r8 ? new Le(e8, [t6]) : t6;
              }
              if (null !== t5 && "string" != typeof t5 && "boolean" != typeof t5 && "number" != typeof t5 || (t5 = ["literal", t5]), Array.isArray(t5)) {
                if (0 === t5.length) return this.error('Expected an array with at least one element. If you wanted a literal array, use ["literal", []].');
                const n6 = t5[0];
                if ("string" != typeof n6) return this.error(`Expression name must be a string, but found ${typeof n6} instead. If you wanted a literal array, use ["literal", [...]].`, 0), null;
                const i6 = this.registry[n6];
                if (i6) {
                  let n7 = i6.parse(t5, this);
                  if (!n7) return null;
                  if (this.expectedType) {
                    const t6 = this.expectedType, i7 = n7.type;
                    if ("string" !== t6.kind && "number" !== t6.kind && "boolean" !== t6.kind && "object" !== t6.kind && "array" !== t6.kind || "value" !== i7.kind) if ("projectionDefinition" !== t6.kind || "string" !== i7.kind && "array" !== i7.kind) if ("color" !== t6.kind && "formatted" !== t6.kind && "resolvedImage" !== t6.kind || "value" !== i7.kind && "string" !== i7.kind) if ("padding" !== t6.kind || "value" !== i7.kind && "number" !== i7.kind && "array" !== i7.kind) if ("variableAnchorOffsetCollection" !== t6.kind || "value" !== i7.kind && "array" !== i7.kind) {
                      if (this.checkSubtype(t6, i7)) return null;
                    } else n7 = r7(n7, t6, e7.typeAnnotation || "coerce");
                    else n7 = r7(n7, t6, e7.typeAnnotation || "coerce");
                    else n7 = r7(n7, t6, e7.typeAnnotation || "coerce");
                    else n7 = r7(n7, t6, e7.typeAnnotation || "coerce");
                    else n7 = r7(n7, t6, e7.typeAnnotation || "assert");
                  }
                  if (!(n7 instanceof Ee) && "resolvedImage" !== n7.type.kind && this._isConstant(n7)) {
                    const t6 = new De();
                    try {
                      n7 = new Ee(n7.type, n7.evaluate(t6));
                    } catch (t7) {
                      return this.error(t7.message), null;
                    }
                  }
                  return n7;
                }
                return this.error(`Unknown expression "${n6}". If you wanted a literal array, use ["literal", [...]].`, 0);
              }
              return this.error(void 0 === t5 ? "'undefined' value invalid. Use null instead." : "object" == typeof t5 ? 'Bare objects invalid. Use ["literal", {...}] instead.' : `Expected an array, but found ${typeof t5} instead.`);
            }
            concat(t5, e7, r7) {
              const n6 = "number" == typeof t5 ? this.path.concat(t5) : this.path, i6 = r7 ? this.scope.concat(r7) : this.scope;
              return new Re(this.registry, this._isConstant, n6, e7 || null, i6, this.errors);
            }
            error(t5, ...e7) {
              const r7 = `${this.key}${e7.map((t6) => `[${t6}]`).join("")}`;
              this.errors.push(new zt(r7, t5));
            }
            checkSubtype(t5, e7) {
              const r7 = Zt(t5, e7);
              return r7 && this.error(r7), r7;
            }
          }
          class je {
            constructor(t5, e7) {
              this.type = e7.type, this.bindings = [].concat(t5), this.result = e7;
            }
            evaluate(t5) {
              return this.result.evaluate(t5);
            }
            eachChild(t5) {
              for (const e7 of this.bindings) t5(e7[1]);
              t5(this.result);
            }
            static parse(t5, e7) {
              if (t5.length < 4) return e7.error(`Expected at least 3 arguments, but found ${t5.length - 1} instead.`);
              const r7 = [];
              for (let n7 = 1; n7 < t5.length - 1; n7 += 2) {
                const i6 = t5[n7];
                if ("string" != typeof i6) return e7.error(`Expected string, but found ${typeof i6} instead.`, n7);
                if (/[^a-zA-Z0-9_]/.test(i6)) return e7.error("Variable names must contain only alphanumeric characters or '_'.", n7);
                const s5 = e7.parse(t5[n7 + 1], n7 + 1);
                if (!s5) return null;
                r7.push([i6, s5]);
              }
              const n6 = e7.parse(t5[t5.length - 1], t5.length - 1, e7.expectedType, r7);
              return n6 ? new je(r7, n6) : null;
            }
            outputDefined() {
              return this.result.outputDefined();
            }
          }
          class Ne {
            constructor(t5, e7) {
              this.type = e7.type, this.name = t5, this.boundExpression = e7;
            }
            static parse(t5, e7) {
              if (2 !== t5.length || "string" != typeof t5[1]) return e7.error("'var' expression requires exactly one string literal argument.");
              const r7 = t5[1];
              return e7.scope.has(r7) ? new Ne(r7, e7.scope.get(r7)) : e7.error(`Unknown variable "${r7}". Make sure "${r7}" has been bound in an enclosing "let" expression before using it.`, 1);
            }
            evaluate(t5) {
              return this.boundExpression.evaluate(t5);
            }
            eachChild() {
            }
            outputDefined() {
              return false;
            }
          }
          class Ue {
            constructor(t5, e7, r7) {
              this.type = t5, this.index = e7, this.input = r7;
            }
            static parse(t5, e7) {
              if (3 !== t5.length) return e7.error(`Expected 2 arguments, but found ${t5.length - 1} instead.`);
              const r7 = e7.parse(t5[1], 1, Bt), n6 = e7.parse(t5[2], 2, Ut(e7.expectedType || Lt));
              return r7 && n6 ? new Ue(n6.type.itemType, r7, n6) : null;
            }
            evaluate(t5) {
              const e7 = this.index.evaluate(t5), r7 = this.input.evaluate(t5);
              if (e7 < 0) throw new Ae(`Array index out of bounds: ${e7} < 0.`);
              if (e7 >= r7.length) throw new Ae(`Array index out of bounds: ${e7} > ${r7.length - 1}.`);
              if (e7 !== Math.floor(e7)) throw new Ae(`Array index must be an integer, but found ${e7} instead.`);
              return r7[e7];
            }
            eachChild(t5) {
              t5(this.index), t5(this.input);
            }
            outputDefined() {
              return false;
            }
          }
          class qe {
            constructor(t5, e7) {
              this.type = Et, this.needle = t5, this.haystack = e7;
            }
            static parse(t5, e7) {
              if (3 !== t5.length) return e7.error(`Expected 2 arguments, but found ${t5.length - 1} instead.`);
              const r7 = e7.parse(t5[1], 1, Lt), n6 = e7.parse(t5[2], 2, Lt);
              return r7 && n6 ? Kt(r7.type, [Et, Vt, Bt, Ct, Lt]) ? new qe(r7, n6) : e7.error(`Expected first argument to be of type boolean, string, number or null, but found ${qt(r7.type)} instead`) : null;
            }
            evaluate(t5) {
              const e7 = this.needle.evaluate(t5), r7 = this.haystack.evaluate(t5);
              if (!r7) return false;
              if (!Xt(e7, ["boolean", "string", "number", "null"])) throw new Ae(`Expected first argument to be of type boolean, string, number or null, but found ${qt(Be(e7))} instead.`);
              if (!Xt(r7, ["string", "array"])) throw new Ae(`Expected second argument to be of type array or string, but found ${qt(Be(r7))} instead.`);
              return r7.indexOf(e7) >= 0;
            }
            eachChild(t5) {
              t5(this.needle), t5(this.haystack);
            }
            outputDefined() {
              return true;
            }
          }
          class Ge {
            constructor(t5, e7, r7) {
              this.type = Bt, this.needle = t5, this.haystack = e7, this.fromIndex = r7;
            }
            static parse(t5, e7) {
              if (t5.length <= 2 || t5.length >= 5) return e7.error(`Expected 3 or 4 arguments, but found ${t5.length - 1} instead.`);
              const r7 = e7.parse(t5[1], 1, Lt), n6 = e7.parse(t5[2], 2, Lt);
              if (!r7 || !n6) return null;
              if (!Kt(r7.type, [Et, Vt, Bt, Ct, Lt])) return e7.error(`Expected first argument to be of type boolean, string, number or null, but found ${qt(r7.type)} instead`);
              if (4 === t5.length) {
                const i6 = e7.parse(t5[3], 3, Bt);
                return i6 ? new Ge(r7, n6, i6) : null;
              }
              return new Ge(r7, n6);
            }
            evaluate(t5) {
              const e7 = this.needle.evaluate(t5), r7 = this.haystack.evaluate(t5);
              if (!Xt(e7, ["boolean", "string", "number", "null"])) throw new Ae(`Expected first argument to be of type boolean, string, number or null, but found ${qt(Be(e7))} instead.`);
              let n6;
              if (this.fromIndex && (n6 = this.fromIndex.evaluate(t5)), Xt(r7, ["string"])) {
                const t6 = r7.indexOf(e7, n6);
                return -1 === t6 ? -1 : [...r7.slice(0, t6)].length;
              }
              if (Xt(r7, ["array"])) return r7.indexOf(e7, n6);
              throw new Ae(`Expected second argument to be of type array or string, but found ${qt(Be(r7))} instead.`);
            }
            eachChild(t5) {
              t5(this.needle), t5(this.haystack), this.fromIndex && t5(this.fromIndex);
            }
            outputDefined() {
              return false;
            }
          }
          class Ze {
            constructor(t5, e7, r7, n6, i6, s5) {
              this.inputType = t5, this.type = e7, this.input = r7, this.cases = n6, this.outputs = i6, this.otherwise = s5;
            }
            static parse(t5, e7) {
              if (t5.length < 5) return e7.error(`Expected at least 4 arguments, but found only ${t5.length - 1}.`);
              if (t5.length % 2 != 1) return e7.error("Expected an even number of arguments.");
              let r7, n6;
              e7.expectedType && "value" !== e7.expectedType.kind && (n6 = e7.expectedType);
              const i6 = {}, s5 = [];
              for (let a5 = 2; a5 < t5.length - 1; a5 += 2) {
                let o8 = t5[a5];
                const l5 = t5[a5 + 1];
                Array.isArray(o8) || (o8 = [o8]);
                const u4 = e7.concat(a5);
                if (0 === o8.length) return u4.error("Expected at least one branch label.");
                for (const t6 of o8) {
                  if ("number" != typeof t6 && "string" != typeof t6) return u4.error("Branch labels must be numbers or strings.");
                  if ("number" == typeof t6 && Math.abs(t6) > Number.MAX_SAFE_INTEGER) return u4.error(`Branch labels must be integers no larger than ${Number.MAX_SAFE_INTEGER}.`);
                  if ("number" == typeof t6 && Math.floor(t6) !== t6) return u4.error("Numeric branch labels must be integer values.");
                  if (r7) {
                    if (u4.checkSubtype(r7, Be(t6))) return null;
                  } else r7 = Be(t6);
                  if (void 0 !== i6[String(t6)]) return u4.error("Branch labels must be unique.");
                  i6[String(t6)] = s5.length;
                }
                const c5 = e7.parse(l5, a5, n6);
                if (!c5) return null;
                n6 = n6 || c5.type, s5.push(c5);
              }
              const a4 = e7.parse(t5[1], 1, Lt);
              if (!a4) return null;
              const o7 = e7.parse(t5[t5.length - 1], t5.length - 1, n6);
              return o7 ? "value" !== a4.type.kind && e7.concat(1).checkSubtype(r7, a4.type) ? null : new Ze(r7, n6, a4, i6, s5, o7) : null;
            }
            evaluate(t5) {
              const e7 = this.input.evaluate(t5);
              return (Be(e7) === this.inputType && this.outputs[this.cases[e7]] || this.otherwise).evaluate(t5);
            }
            eachChild(t5) {
              t5(this.input), this.outputs.forEach(t5), t5(this.otherwise);
            }
            outputDefined() {
              return this.outputs.every((t5) => t5.outputDefined()) && this.otherwise.outputDefined();
            }
          }
          class Ke {
            constructor(t5, e7, r7) {
              this.type = t5, this.branches = e7, this.otherwise = r7;
            }
            static parse(t5, e7) {
              if (t5.length < 4) return e7.error(`Expected at least 3 arguments, but found only ${t5.length - 1}.`);
              if (t5.length % 2 != 0) return e7.error("Expected an odd number of arguments.");
              let r7;
              e7.expectedType && "value" !== e7.expectedType.kind && (r7 = e7.expectedType);
              const n6 = [];
              for (let i7 = 1; i7 < t5.length - 1; i7 += 2) {
                const s5 = e7.parse(t5[i7], i7, Et);
                if (!s5) return null;
                const a4 = e7.parse(t5[i7 + 1], i7 + 1, r7);
                if (!a4) return null;
                n6.push([s5, a4]), r7 = r7 || a4.type;
              }
              const i6 = e7.parse(t5[t5.length - 1], t5.length - 1, r7);
              if (!i6) return null;
              if (!r7) throw new Error("Can't infer output type");
              return new Ke(r7, n6, i6);
            }
            evaluate(t5) {
              for (const [e7, r7] of this.branches) if (e7.evaluate(t5)) return r7.evaluate(t5);
              return this.otherwise.evaluate(t5);
            }
            eachChild(t5) {
              for (const [e7, r7] of this.branches) t5(e7), t5(r7);
              t5(this.otherwise);
            }
            outputDefined() {
              return this.branches.every(([t5, e7]) => e7.outputDefined()) && this.otherwise.outputDefined();
            }
          }
          class Xe {
            constructor(t5, e7, r7, n6) {
              this.type = t5, this.input = e7, this.beginIndex = r7, this.endIndex = n6;
            }
            static parse(t5, e7) {
              if (t5.length <= 2 || t5.length >= 5) return e7.error(`Expected 3 or 4 arguments, but found ${t5.length - 1} instead.`);
              const r7 = e7.parse(t5[1], 1, Lt), n6 = e7.parse(t5[2], 2, Bt);
              if (!r7 || !n6) return null;
              if (!Kt(r7.type, [Ut(Lt), Vt, Lt])) return e7.error(`Expected first argument to be of type array or string, but found ${qt(r7.type)} instead`);
              if (4 === t5.length) {
                const i6 = e7.parse(t5[3], 3, Bt);
                return i6 ? new Xe(r7.type, r7, n6, i6) : null;
              }
              return new Xe(r7.type, r7, n6);
            }
            evaluate(t5) {
              const e7 = this.input.evaluate(t5), r7 = this.beginIndex.evaluate(t5);
              let n6;
              if (this.endIndex && (n6 = this.endIndex.evaluate(t5)), Xt(e7, ["string"])) return [...e7].slice(r7, n6).join("");
              if (Xt(e7, ["array"])) return e7.slice(r7, n6);
              throw new Ae(`Expected first argument to be of type array or string, but found ${qt(Be(e7))} instead.`);
            }
            eachChild(t5) {
              t5(this.input), t5(this.beginIndex), this.endIndex && t5(this.endIndex);
            }
            outputDefined() {
              return false;
            }
          }
          function He(t5, e7) {
            const r7 = t5.length - 1;
            let n6, i6, s5 = 0, a4 = r7, o7 = 0;
            for (; s5 <= a4; ) if (o7 = Math.floor((s5 + a4) / 2), n6 = t5[o7], i6 = t5[o7 + 1], n6 <= e7) {
              if (o7 === r7 || e7 < i6) return o7;
              s5 = o7 + 1;
            } else {
              if (!(n6 > e7)) throw new Ae("Input is not a number.");
              a4 = o7 - 1;
            }
            return 0;
          }
          class Ye {
            constructor(t5, e7, r7) {
              this.type = t5, this.input = e7, this.labels = [], this.outputs = [];
              for (const [t6, e8] of r7) this.labels.push(t6), this.outputs.push(e8);
            }
            static parse(t5, e7) {
              if (t5.length - 1 < 4) return e7.error(`Expected at least 4 arguments, but found only ${t5.length - 1}.`);
              if ((t5.length - 1) % 2 != 0) return e7.error("Expected an even number of arguments.");
              const r7 = e7.parse(t5[1], 1, Bt);
              if (!r7) return null;
              const n6 = [];
              let i6 = null;
              e7.expectedType && "value" !== e7.expectedType.kind && (i6 = e7.expectedType);
              for (let r8 = 1; r8 < t5.length; r8 += 2) {
                const s5 = 1 === r8 ? -1 / 0 : t5[r8], a4 = t5[r8 + 1], o7 = r8, l5 = r8 + 1;
                if ("number" != typeof s5) return e7.error('Input/output pairs for "step" expressions must be defined using literal numeric values (not computed expressions) for the input values.', o7);
                if (n6.length && n6[n6.length - 1][0] >= s5) return e7.error('Input/output pairs for "step" expressions must be arranged with input values in strictly ascending order.', o7);
                const u4 = e7.parse(a4, l5, i6);
                if (!u4) return null;
                i6 = i6 || u4.type, n6.push([s5, u4]);
              }
              return new Ye(i6, r7, n6);
            }
            evaluate(t5) {
              const e7 = this.labels, r7 = this.outputs;
              if (1 === e7.length) return r7[0].evaluate(t5);
              const n6 = this.input.evaluate(t5);
              if (n6 <= e7[0]) return r7[0].evaluate(t5);
              const i6 = e7.length;
              return n6 >= e7[i6 - 1] ? r7[i6 - 1].evaluate(t5) : r7[He(e7, n6)].evaluate(t5);
            }
            eachChild(t5) {
              t5(this.input);
              for (const e7 of this.outputs) t5(e7);
            }
            outputDefined() {
              return this.outputs.every((t5) => t5.outputDefined());
            }
          }
          function Je(t5) {
            return t5 && t5.__esModule && Object.prototype.hasOwnProperty.call(t5, "default") ? t5.default : t5;
          }
          var We, Qe, tr = function() {
            if (Qe) return We;
            function t5(t6, e7, r7, n6) {
              this.cx = 3 * t6, this.bx = 3 * (r7 - t6) - this.cx, this.ax = 1 - this.cx - this.bx, this.cy = 3 * e7, this.by = 3 * (n6 - e7) - this.cy, this.ay = 1 - this.cy - this.by, this.p1x = t6, this.p1y = e7, this.p2x = r7, this.p2y = n6;
            }
            return Qe = 1, We = t5, t5.prototype = { sampleCurveX: function(t6) {
              return ((this.ax * t6 + this.bx) * t6 + this.cx) * t6;
            }, sampleCurveY: function(t6) {
              return ((this.ay * t6 + this.by) * t6 + this.cy) * t6;
            }, sampleCurveDerivativeX: function(t6) {
              return (3 * this.ax * t6 + 2 * this.bx) * t6 + this.cx;
            }, solveCurveX: function(t6, e7) {
              if (void 0 === e7 && (e7 = 1e-6), t6 < 0) return 0;
              if (t6 > 1) return 1;
              for (var r7 = t6, n6 = 0; n6 < 8; n6++) {
                var i6 = this.sampleCurveX(r7) - t6;
                if (Math.abs(i6) < e7) return r7;
                var s5 = this.sampleCurveDerivativeX(r7);
                if (Math.abs(s5) < 1e-6) break;
                r7 -= i6 / s5;
              }
              var a4 = 0, o7 = 1;
              for (r7 = t6, n6 = 0; n6 < 20 && (i6 = this.sampleCurveX(r7), !(Math.abs(i6 - t6) < e7)); n6++) t6 > i6 ? a4 = r7 : o7 = r7, r7 = 0.5 * (o7 - a4) + a4;
              return r7;
            }, solve: function(t6, e7) {
              return this.sampleCurveY(this.solveCurveX(t6, e7));
            } }, We;
          }(), er = Je(tr);
          class rr {
            constructor(t5, e7, r7, n6, i6) {
              this.type = t5, this.operator = e7, this.interpolation = r7, this.input = n6, this.labels = [], this.outputs = [];
              for (const [t6, e8] of i6) this.labels.push(t6), this.outputs.push(e8);
            }
            static interpolationFactor(t5, e7, r7, n6) {
              let i6 = 0;
              if ("exponential" === t5.name) i6 = nr(e7, t5.base, r7, n6);
              else if ("linear" === t5.name) i6 = nr(e7, 1, r7, n6);
              else if ("cubic-bezier" === t5.name) {
                const s5 = t5.controlPoints;
                i6 = new er(s5[0], s5[1], s5[2], s5[3]).solve(nr(e7, 1, r7, n6));
              }
              return i6;
            }
            static parse(t5, e7) {
              let [r7, n6, i6, ...s5] = t5;
              if (!Array.isArray(n6) || 0 === n6.length) return e7.error("Expected an interpolation type expression.", 1);
              if ("linear" === n6[0]) n6 = { name: "linear" };
              else if ("exponential" === n6[0]) {
                const t6 = n6[1];
                if ("number" != typeof t6) return e7.error("Exponential interpolation requires a numeric base.", 1, 1);
                n6 = { name: "exponential", base: t6 };
              } else {
                if ("cubic-bezier" !== n6[0]) return e7.error(`Unknown interpolation type ${String(n6[0])}`, 1, 0);
                {
                  const t6 = n6.slice(1);
                  if (4 !== t6.length || t6.some((t7) => "number" != typeof t7 || t7 < 0 || t7 > 1)) return e7.error("Cubic bezier interpolation requires four numeric arguments with values between 0 and 1.", 1);
                  n6 = { name: "cubic-bezier", controlPoints: t6 };
                }
              }
              if (t5.length - 1 < 4) return e7.error(`Expected at least 4 arguments, but found only ${t5.length - 1}.`);
              if ((t5.length - 1) % 2 != 0) return e7.error("Expected an even number of arguments.");
              if (i6 = e7.parse(i6, 2, Bt), !i6) return null;
              const a4 = [];
              let o7 = null;
              "interpolate-hcl" === r7 || "interpolate-lab" === r7 ? o7 = Tt : e7.expectedType && "value" !== e7.expectedType.kind && (o7 = e7.expectedType);
              for (let t6 = 0; t6 < s5.length; t6 += 2) {
                const r8 = s5[t6], n7 = s5[t6 + 1], i7 = t6 + 3, l5 = t6 + 4;
                if ("number" != typeof r8) return e7.error('Input/output pairs for "interpolate" expressions must be defined using literal numeric values (not computed expressions) for the input values.', i7);
                if (a4.length && a4[a4.length - 1][0] >= r8) return e7.error('Input/output pairs for "interpolate" expressions must be arranged with input values in strictly ascending order.', i7);
                const u4 = e7.parse(n7, l5, o7);
                if (!u4) return null;
                o7 = o7 || u4.type, a4.push([r8, u4]);
              }
              return Ht(o7, Bt) || Ht(o7, Ft) || Ht(o7, Tt) || Ht(o7, Rt) || Ht(o7, Nt) || Ht(o7, Ut(Bt)) ? new rr(o7, r7, n6, i6, a4) : e7.error(`Type ${qt(o7)} is not interpolatable.`);
            }
            evaluate(t5) {
              const e7 = this.labels, r7 = this.outputs;
              if (1 === e7.length) return r7[0].evaluate(t5);
              const n6 = this.input.evaluate(t5);
              if (n6 <= e7[0]) return r7[0].evaluate(t5);
              const i6 = e7.length;
              if (n6 >= e7[i6 - 1]) return r7[i6 - 1].evaluate(t5);
              const s5 = He(e7, n6), a4 = rr.interpolationFactor(this.interpolation, n6, e7[s5], e7[s5 + 1]), o7 = r7[s5].evaluate(t5), l5 = r7[s5 + 1].evaluate(t5);
              switch (this.operator) {
                case "interpolate":
                  switch (this.type.kind) {
                    case "number":
                      return me(o7, l5, a4);
                    case "color":
                      return xe.interpolate(o7, l5, a4);
                    case "padding":
                      return Se.interpolate(o7, l5, a4);
                    case "variableAnchorOffsetCollection":
                      return Me.interpolate(o7, l5, a4);
                    case "array":
                      return ge(o7, l5, a4);
                    case "projectionDefinition":
                      return ze.interpolate(o7, l5, a4);
                  }
                case "interpolate-hcl":
                  return xe.interpolate(o7, l5, a4, "hcl");
                case "interpolate-lab":
                  return xe.interpolate(o7, l5, a4, "lab");
              }
            }
            eachChild(t5) {
              t5(this.input);
              for (const e7 of this.outputs) t5(e7);
            }
            outputDefined() {
              return this.outputs.every((t5) => t5.outputDefined());
            }
          }
          function nr(t5, e7, r7, n6) {
            const i6 = n6 - r7, s5 = t5 - r7;
            return 0 === i6 ? 0 : 1 === e7 ? s5 / i6 : (Math.pow(e7, s5) - 1) / (Math.pow(e7, i6) - 1);
          }
          const ir = { color: xe.interpolate, number: me, padding: Se.interpolate, variableAnchorOffsetCollection: Me.interpolate, array: ge };
          class sr {
            constructor(t5, e7) {
              this.type = t5, this.args = e7;
            }
            static parse(t5, e7) {
              if (t5.length < 2) return e7.error("Expected at least one argument.");
              let r7 = null;
              const n6 = e7.expectedType;
              n6 && "value" !== n6.kind && (r7 = n6);
              const i6 = [];
              for (const n7 of t5.slice(1)) {
                const t6 = e7.parse(n7, 1 + i6.length, r7, void 0, { typeAnnotation: "omit" });
                if (!t6) return null;
                r7 = r7 || t6.type, i6.push(t6);
              }
              if (!r7) throw new Error("No output type");
              const s5 = n6 && i6.some((t6) => Zt(n6, t6.type));
              return new sr(s5 ? Lt : r7, i6);
            }
            evaluate(t5) {
              let e7, r7 = null, n6 = 0;
              for (const i6 of this.args) if (n6++, r7 = i6.evaluate(t5), r7 && r7 instanceof Ie && !r7.available && (e7 || (e7 = r7.name), r7 = null, n6 === this.args.length && (r7 = e7)), null !== r7) break;
              return r7;
            }
            eachChild(t5) {
              this.args.forEach(t5);
            }
            outputDefined() {
              return this.args.every((t5) => t5.outputDefined());
            }
          }
          function ar(t5, e7) {
            return "==" === t5 || "!=" === t5 ? "boolean" === e7.kind || "string" === e7.kind || "number" === e7.kind || "null" === e7.kind || "value" === e7.kind : "string" === e7.kind || "number" === e7.kind || "value" === e7.kind;
          }
          function or(t5, e7, r7, n6) {
            return 0 === n6.compare(e7, r7);
          }
          function lr(t5, e7, r7) {
            const n6 = "==" !== t5 && "!=" !== t5;
            return class i6 {
              constructor(t6, e8, r8) {
                this.type = Et, this.lhs = t6, this.rhs = e8, this.collator = r8, this.hasUntypedArgument = "value" === t6.type.kind || "value" === e8.type.kind;
              }
              static parse(t6, e8) {
                if (3 !== t6.length && 4 !== t6.length) return e8.error("Expected two or three arguments.");
                const r8 = t6[0];
                let s5 = e8.parse(t6[1], 1, Lt);
                if (!s5) return null;
                if (!ar(r8, s5.type)) return e8.concat(1).error(`"${r8}" comparisons are not supported for type '${qt(s5.type)}'.`);
                let a4 = e8.parse(t6[2], 2, Lt);
                if (!a4) return null;
                if (!ar(r8, a4.type)) return e8.concat(2).error(`"${r8}" comparisons are not supported for type '${qt(a4.type)}'.`);
                if (s5.type.kind !== a4.type.kind && "value" !== s5.type.kind && "value" !== a4.type.kind) return e8.error(`Cannot compare types '${qt(s5.type)}' and '${qt(a4.type)}'.`);
                n6 && ("value" === s5.type.kind && "value" !== a4.type.kind ? s5 = new Fe(a4.type, [s5]) : "value" !== s5.type.kind && "value" === a4.type.kind && (a4 = new Fe(s5.type, [a4])));
                let o7 = null;
                if (4 === t6.length) {
                  if ("string" !== s5.type.kind && "string" !== a4.type.kind && "value" !== s5.type.kind && "value" !== a4.type.kind) return e8.error("Cannot use collator to compare non-string types.");
                  if (o7 = e8.parse(t6[3], 3, Ot), !o7) return null;
                }
                return new i6(s5, a4, o7);
              }
              evaluate(i7) {
                const s5 = this.lhs.evaluate(i7), a4 = this.rhs.evaluate(i7);
                if (n6 && this.hasUntypedArgument) {
                  const e8 = Be(s5), r8 = Be(a4);
                  if (e8.kind !== r8.kind || "string" !== e8.kind && "number" !== e8.kind) throw new Ae(`Expected arguments for "${t5}" to be (string, string) or (number, number), but found (${e8.kind}, ${r8.kind}) instead.`);
                }
                if (this.collator && !n6 && this.hasUntypedArgument) {
                  const t6 = Be(s5), r8 = Be(a4);
                  if ("string" !== t6.kind || "string" !== r8.kind) return e7(i7, s5, a4);
                }
                return this.collator ? r7(i7, s5, a4, this.collator.evaluate(i7)) : e7(i7, s5, a4);
              }
              eachChild(t6) {
                t6(this.lhs), t6(this.rhs), this.collator && t6(this.collator);
              }
              outputDefined() {
                return true;
              }
            };
          }
          const ur = lr("==", function(t5, e7, r7) {
            return e7 === r7;
          }, or), cr = lr("!=", function(t5, e7, r7) {
            return e7 !== r7;
          }, function(t5, e7, r7, n6) {
            return !or(0, e7, r7, n6);
          }), hr = lr("<", function(t5, e7, r7) {
            return e7 < r7;
          }, function(t5, e7, r7, n6) {
            return n6.compare(e7, r7) < 0;
          }), pr = lr(">", function(t5, e7, r7) {
            return e7 > r7;
          }, function(t5, e7, r7, n6) {
            return n6.compare(e7, r7) > 0;
          }), fr = lr("<=", function(t5, e7, r7) {
            return e7 <= r7;
          }, function(t5, e7, r7, n6) {
            return n6.compare(e7, r7) <= 0;
          }), dr = lr(">=", function(t5, e7, r7) {
            return e7 >= r7;
          }, function(t5, e7, r7, n6) {
            return n6.compare(e7, r7) >= 0;
          });
          class yr {
            constructor(t5, e7, r7) {
              this.type = Ot, this.locale = r7, this.caseSensitive = t5, this.diacriticSensitive = e7;
            }
            static parse(t5, e7) {
              if (2 !== t5.length) return e7.error("Expected one argument.");
              const r7 = t5[1];
              if ("object" != typeof r7 || Array.isArray(r7)) return e7.error("Collator options argument must be an object.");
              const n6 = e7.parse(void 0 !== r7["case-sensitive"] && r7["case-sensitive"], 1, Et);
              if (!n6) return null;
              const i6 = e7.parse(void 0 !== r7["diacritic-sensitive"] && r7["diacritic-sensitive"], 1, Et);
              if (!i6) return null;
              let s5 = null;
              return r7.locale && (s5 = e7.parse(r7.locale, 1, Vt), !s5) ? null : new yr(n6, i6, s5);
            }
            evaluate(t5) {
              return new ve(this.caseSensitive.evaluate(t5), this.diacriticSensitive.evaluate(t5), this.locale ? this.locale.evaluate(t5) : null);
            }
            eachChild(t5) {
              t5(this.caseSensitive), t5(this.diacriticSensitive), this.locale && t5(this.locale);
            }
            outputDefined() {
              return false;
            }
          }
          class mr {
            constructor(t5, e7, r7, n6, i6) {
              this.type = Vt, this.number = t5, this.locale = e7, this.currency = r7, this.minFractionDigits = n6, this.maxFractionDigits = i6;
            }
            static parse(t5, e7) {
              if (3 !== t5.length) return e7.error("Expected two arguments.");
              const r7 = e7.parse(t5[1], 1, Bt);
              if (!r7) return null;
              const n6 = t5[2];
              if ("object" != typeof n6 || Array.isArray(n6)) return e7.error("NumberFormat options argument must be an object.");
              let i6 = null;
              if (n6.locale && (i6 = e7.parse(n6.locale, 1, Vt), !i6)) return null;
              let s5 = null;
              if (n6.currency && (s5 = e7.parse(n6.currency, 1, Vt), !s5)) return null;
              let a4 = null;
              if (n6["min-fraction-digits"] && (a4 = e7.parse(n6["min-fraction-digits"], 1, Bt), !a4)) return null;
              let o7 = null;
              return n6["max-fraction-digits"] && (o7 = e7.parse(n6["max-fraction-digits"], 1, Bt), !o7) ? null : new mr(r7, i6, s5, a4, o7);
            }
            evaluate(t5) {
              return new Intl.NumberFormat(this.locale ? this.locale.evaluate(t5) : [], { style: this.currency ? "currency" : "decimal", currency: this.currency ? this.currency.evaluate(t5) : void 0, minimumFractionDigits: this.minFractionDigits ? this.minFractionDigits.evaluate(t5) : void 0, maximumFractionDigits: this.maxFractionDigits ? this.maxFractionDigits.evaluate(t5) : void 0 }).format(this.number.evaluate(t5));
            }
            eachChild(t5) {
              t5(this.number), this.locale && t5(this.locale), this.currency && t5(this.currency), this.minFractionDigits && t5(this.minFractionDigits), this.maxFractionDigits && t5(this.maxFractionDigits);
            }
            outputDefined() {
              return false;
            }
          }
          class gr {
            constructor(t5) {
              this.type = Dt, this.sections = t5;
            }
            static parse(t5, e7) {
              if (t5.length < 2) return e7.error("Expected at least one argument.");
              const r7 = t5[1];
              if (!Array.isArray(r7) && "object" == typeof r7) return e7.error("First argument must be an image or text section.");
              const n6 = [];
              let i6 = false;
              for (let r8 = 1; r8 <= t5.length - 1; ++r8) {
                const s5 = t5[r8];
                if (i6 && "object" == typeof s5 && !Array.isArray(s5)) {
                  i6 = false;
                  let t6 = null;
                  if (s5["font-scale"] && (t6 = e7.parse(s5["font-scale"], 1, Bt), !t6)) return null;
                  let r9 = null;
                  if (s5["text-font"] && (r9 = e7.parse(s5["text-font"], 1, Ut(Vt)), !r9)) return null;
                  let a4 = null;
                  if (s5["text-color"] && (a4 = e7.parse(s5["text-color"], 1, Tt), !a4)) return null;
                  let o7 = null;
                  if (s5["vertical-align"]) {
                    if ("string" == typeof s5["vertical-align"] && !be.includes(s5["vertical-align"])) return e7.error(`'vertical-align' must be one of: 'bottom', 'center', 'top' but found '${s5["vertical-align"]}' instead.`);
                    if (o7 = e7.parse(s5["vertical-align"], 1, Vt), !o7) return null;
                  }
                  const l5 = n6[n6.length - 1];
                  l5.scale = t6, l5.font = r9, l5.textColor = a4, l5.verticalAlign = o7;
                } else {
                  const s6 = e7.parse(t5[r8], 1, Lt);
                  if (!s6) return null;
                  const a4 = s6.type.kind;
                  if ("string" !== a4 && "value" !== a4 && "null" !== a4 && "resolvedImage" !== a4) return e7.error("Formatted text type must be 'string', 'value', 'image' or 'null'.");
                  i6 = true, n6.push({ content: s6, scale: null, font: null, textColor: null, verticalAlign: null });
                }
              }
              return new gr(n6);
            }
            evaluate(t5) {
              return new _e(this.sections.map((e7) => {
                const r7 = e7.content.evaluate(t5);
                return Be(r7) === jt ? new we("", r7, null, null, null, e7.verticalAlign ? e7.verticalAlign.evaluate(t5) : null) : new we(Ve(r7), null, e7.scale ? e7.scale.evaluate(t5) : null, e7.font ? e7.font.evaluate(t5).join(",") : null, e7.textColor ? e7.textColor.evaluate(t5) : null, e7.verticalAlign ? e7.verticalAlign.evaluate(t5) : null);
              }));
            }
            eachChild(t5) {
              for (const e7 of this.sections) t5(e7.content), e7.scale && t5(e7.scale), e7.font && t5(e7.font), e7.textColor && t5(e7.textColor), e7.verticalAlign && t5(e7.verticalAlign);
            }
            outputDefined() {
              return false;
            }
          }
          class xr {
            constructor(t5) {
              this.type = jt, this.input = t5;
            }
            static parse(t5, e7) {
              if (2 !== t5.length) return e7.error("Expected two arguments.");
              const r7 = e7.parse(t5[1], 1, Vt);
              return r7 ? new xr(r7) : e7.error("No image name provided.");
            }
            evaluate(t5) {
              const e7 = this.input.evaluate(t5), r7 = Ie.fromString(e7);
              return r7 && t5.availableImages && (r7.available = t5.availableImages.indexOf(e7) > -1), r7;
            }
            eachChild(t5) {
              t5(this.input);
            }
            outputDefined() {
              return false;
            }
          }
          class vr {
            constructor(t5) {
              this.type = Bt, this.input = t5;
            }
            static parse(t5, e7) {
              if (2 !== t5.length) return e7.error(`Expected 1 argument, but found ${t5.length - 1} instead.`);
              const r7 = e7.parse(t5[1], 1);
              return r7 ? "array" !== r7.type.kind && "string" !== r7.type.kind && "value" !== r7.type.kind ? e7.error(`Expected argument of type string or array, but found ${qt(r7.type)} instead.`) : new vr(r7) : null;
            }
            evaluate(t5) {
              const e7 = this.input.evaluate(t5);
              if ("string" == typeof e7) return [...e7].length;
              if (Array.isArray(e7)) return e7.length;
              throw new Ae(`Expected value to be of type string or array, but found ${qt(Be(e7))} instead.`);
            }
            eachChild(t5) {
              t5(this.input);
            }
            outputDefined() {
              return false;
            }
          }
          const br = 8192;
          function wr(t5, e7) {
            const r7 = (180 + t5[0]) / 360, n6 = (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + t5[1] * Math.PI / 360))) / 360, i6 = Math.pow(2, e7.z);
            return [Math.round(r7 * i6 * br), Math.round(n6 * i6 * br)];
          }
          function _r(t5, e7) {
            const r7 = Math.pow(2, e7.z);
            return [(i6 = (t5[0] / br + e7.x) / r7, 360 * i6 - 180), (n6 = (t5[1] / br + e7.y) / r7, 360 / Math.PI * Math.atan(Math.exp((180 - 360 * n6) * Math.PI / 180)) - 90)];
            var n6, i6;
          }
          function Sr(t5, e7) {
            t5[0] = Math.min(t5[0], e7[0]), t5[1] = Math.min(t5[1], e7[1]), t5[2] = Math.max(t5[2], e7[0]), t5[3] = Math.max(t5[3], e7[1]);
          }
          function Ar(t5, e7) {
            return !(t5[0] <= e7[0] || t5[2] >= e7[2] || t5[1] <= e7[1] || t5[3] >= e7[3]);
          }
          function kr(t5, e7, r7) {
            const n6 = t5[0] - e7[0], i6 = t5[1] - e7[1], s5 = t5[0] - r7[0], a4 = t5[1] - r7[1];
            return n6 * a4 - s5 * i6 == 0 && n6 * s5 <= 0 && i6 * a4 <= 0;
          }
          function Mr(t5, e7, r7, n6) {
            return 0 != (i6 = [n6[0] - r7[0], n6[1] - r7[1]])[0] * (s5 = [e7[0] - t5[0], e7[1] - t5[1]])[1] - i6[1] * s5[0] && !(!Vr(t5, e7, r7, n6) || !Vr(r7, n6, t5, e7));
            var i6, s5;
          }
          function Ir(t5, e7, r7) {
            for (const n6 of r7) for (let r8 = 0; r8 < n6.length - 1; ++r8) if (Mr(t5, e7, n6[r8], n6[r8 + 1])) return true;
            return false;
          }
          function zr(t5, e7, r7 = false) {
            let n6 = false;
            for (const o7 of e7) for (let e8 = 0; e8 < o7.length - 1; e8++) {
              if (kr(t5, o7[e8], o7[e8 + 1])) return r7;
              (s5 = o7[e8])[1] > (i6 = t5)[1] != (a4 = o7[e8 + 1])[1] > i6[1] && i6[0] < (a4[0] - s5[0]) * (i6[1] - s5[1]) / (a4[1] - s5[1]) + s5[0] && (n6 = !n6);
            }
            var i6, s5, a4;
            return n6;
          }
          function Pr(t5, e7) {
            for (const r7 of e7) if (zr(t5, r7)) return true;
            return false;
          }
          function Cr(t5, e7) {
            for (const r7 of t5) if (!zr(r7, e7)) return false;
            for (let r7 = 0; r7 < t5.length - 1; ++r7) if (Ir(t5[r7], t5[r7 + 1], e7)) return false;
            return true;
          }
          function Br(t5, e7) {
            for (const r7 of e7) if (Cr(t5, r7)) return true;
            return false;
          }
          function Vr(t5, e7, r7, n6) {
            const i6 = n6[0] - r7[0], s5 = n6[1] - r7[1], a4 = (t5[0] - r7[0]) * s5 - i6 * (t5[1] - r7[1]), o7 = (e7[0] - r7[0]) * s5 - i6 * (e7[1] - r7[1]);
            return a4 > 0 && o7 < 0 || a4 < 0 && o7 > 0;
          }
          function Er(t5, e7, r7) {
            const n6 = [];
            for (let i6 = 0; i6 < t5.length; i6++) {
              const s5 = [];
              for (let n7 = 0; n7 < t5[i6].length; n7++) {
                const a4 = wr(t5[i6][n7], r7);
                Sr(e7, a4), s5.push(a4);
              }
              n6.push(s5);
            }
            return n6;
          }
          function Tr(t5, e7, r7) {
            const n6 = [];
            for (let i6 = 0; i6 < t5.length; i6++) {
              const s5 = Er(t5[i6], e7, r7);
              n6.push(s5);
            }
            return n6;
          }
          function Fr(t5, e7, r7, n6) {
            if (t5[0] < r7[0] || t5[0] > r7[2]) {
              const e8 = 0.5 * n6;
              let i6 = t5[0] - r7[0] > e8 ? -n6 : r7[0] - t5[0] > e8 ? n6 : 0;
              0 === i6 && (i6 = t5[0] - r7[2] > e8 ? -n6 : r7[2] - t5[0] > e8 ? n6 : 0), t5[0] += i6;
            }
            Sr(e7, t5);
          }
          function $r(t5, e7, r7, n6) {
            const i6 = Math.pow(2, n6.z) * br, s5 = [n6.x * br, n6.y * br], a4 = [];
            for (const n7 of t5) for (const t6 of n7) {
              const n8 = [t6.x + s5[0], t6.y + s5[1]];
              Fr(n8, e7, r7, i6), a4.push(n8);
            }
            return a4;
          }
          function Lr(t5, e7, r7, n6) {
            const i6 = Math.pow(2, n6.z) * br, s5 = [n6.x * br, n6.y * br], a4 = [];
            for (const r8 of t5) {
              const t6 = [];
              for (const n7 of r8) {
                const r9 = [n7.x + s5[0], n7.y + s5[1]];
                Sr(e7, r9), t6.push(r9);
              }
              a4.push(t6);
            }
            if (e7[2] - e7[0] <= i6 / 2) {
              (o7 = e7)[0] = o7[1] = 1 / 0, o7[2] = o7[3] = -1 / 0;
              for (const t6 of a4) for (const n7 of t6) Fr(n7, e7, r7, i6);
            }
            var o7;
            return a4;
          }
          class Or {
            constructor(t5, e7) {
              this.type = Et, this.geojson = t5, this.geometries = e7;
            }
            static parse(t5, e7) {
              if (2 !== t5.length) return e7.error(`'within' expression requires exactly one argument, but found ${t5.length - 1} instead.`);
              if (Ce(t5[1])) {
                const e8 = t5[1];
                if ("FeatureCollection" === e8.type) {
                  const t6 = [];
                  for (const r7 of e8.features) {
                    const { type: e9, coordinates: n6 } = r7.geometry;
                    "Polygon" === e9 && t6.push(n6), "MultiPolygon" === e9 && t6.push(...n6);
                  }
                  if (t6.length) return new Or(e8, { type: "MultiPolygon", coordinates: t6 });
                } else if ("Feature" === e8.type) {
                  const t6 = e8.geometry.type;
                  if ("Polygon" === t6 || "MultiPolygon" === t6) return new Or(e8, e8.geometry);
                } else if ("Polygon" === e8.type || "MultiPolygon" === e8.type) return new Or(e8, e8);
              }
              return e7.error("'within' expression requires valid geojson object that contains polygon geometry type.");
            }
            evaluate(t5) {
              if (null != t5.geometry() && null != t5.canonicalID()) {
                if ("Point" === t5.geometryType()) return function(t6, e7) {
                  const r7 = [1 / 0, 1 / 0, -1 / 0, -1 / 0], n6 = [1 / 0, 1 / 0, -1 / 0, -1 / 0], i6 = t6.canonicalID();
                  if ("Polygon" === e7.type) {
                    const s5 = Er(e7.coordinates, n6, i6), a4 = $r(t6.geometry(), r7, n6, i6);
                    if (!Ar(r7, n6)) return false;
                    for (const t7 of a4) if (!zr(t7, s5)) return false;
                  }
                  if ("MultiPolygon" === e7.type) {
                    const s5 = Tr(e7.coordinates, n6, i6), a4 = $r(t6.geometry(), r7, n6, i6);
                    if (!Ar(r7, n6)) return false;
                    for (const t7 of a4) if (!Pr(t7, s5)) return false;
                  }
                  return true;
                }(t5, this.geometries);
                if ("LineString" === t5.geometryType()) return function(t6, e7) {
                  const r7 = [1 / 0, 1 / 0, -1 / 0, -1 / 0], n6 = [1 / 0, 1 / 0, -1 / 0, -1 / 0], i6 = t6.canonicalID();
                  if ("Polygon" === e7.type) {
                    const s5 = Er(e7.coordinates, n6, i6), a4 = Lr(t6.geometry(), r7, n6, i6);
                    if (!Ar(r7, n6)) return false;
                    for (const t7 of a4) if (!Cr(t7, s5)) return false;
                  }
                  if ("MultiPolygon" === e7.type) {
                    const s5 = Tr(e7.coordinates, n6, i6), a4 = Lr(t6.geometry(), r7, n6, i6);
                    if (!Ar(r7, n6)) return false;
                    for (const t7 of a4) if (!Br(t7, s5)) return false;
                  }
                  return true;
                }(t5, this.geometries);
              }
              return false;
            }
            eachChild() {
            }
            outputDefined() {
              return true;
            }
          }
          let Dr = class {
            constructor(t5 = [], e7 = (t6, e8) => t6 < e8 ? -1 : t6 > e8 ? 1 : 0) {
              if (this.data = t5, this.length = this.data.length, this.compare = e7, this.length > 0) for (let t6 = (this.length >> 1) - 1; t6 >= 0; t6--) this._down(t6);
            }
            push(t5) {
              this.data.push(t5), this._up(this.length++);
            }
            pop() {
              if (0 === this.length) return;
              const t5 = this.data[0], e7 = this.data.pop();
              return --this.length > 0 && (this.data[0] = e7, this._down(0)), t5;
            }
            peek() {
              return this.data[0];
            }
            _up(t5) {
              const { data: e7, compare: r7 } = this, n6 = e7[t5];
              for (; t5 > 0; ) {
                const i6 = t5 - 1 >> 1, s5 = e7[i6];
                if (r7(n6, s5) >= 0) break;
                e7[t5] = s5, t5 = i6;
              }
              e7[t5] = n6;
            }
            _down(t5) {
              const { data: e7, compare: r7 } = this, n6 = this.length >> 1, i6 = e7[t5];
              for (; t5 < n6; ) {
                let n7 = 1 + (t5 << 1);
                const s5 = n7 + 1;
                if (s5 < this.length && r7(e7[s5], e7[n7]) < 0 && (n7 = s5), r7(e7[n7], i6) >= 0) break;
                e7[t5] = e7[n7], t5 = n7;
              }
              e7[t5] = i6;
            }
          };
          function Rr(t5, e7, r7 = 0, n6 = t5.length - 1, i6 = Nr) {
            for (; n6 > r7; ) {
              if (n6 - r7 > 600) {
                const s6 = n6 - r7 + 1, a5 = e7 - r7 + 1, o8 = Math.log(s6), l5 = 0.5 * Math.exp(2 * o8 / 3), u4 = 0.5 * Math.sqrt(o8 * l5 * (s6 - l5) / s6) * (a5 - s6 / 2 < 0 ? -1 : 1);
                Rr(t5, e7, Math.max(r7, Math.floor(e7 - a5 * l5 / s6 + u4)), Math.min(n6, Math.floor(e7 + (s6 - a5) * l5 / s6 + u4)), i6);
              }
              const s5 = t5[e7];
              let a4 = r7, o7 = n6;
              for (jr(t5, r7, e7), i6(t5[n6], s5) > 0 && jr(t5, r7, n6); a4 < o7; ) {
                for (jr(t5, a4, o7), a4++, o7--; i6(t5[a4], s5) < 0; ) a4++;
                for (; i6(t5[o7], s5) > 0; ) o7--;
              }
              0 === i6(t5[r7], s5) ? jr(t5, r7, o7) : (o7++, jr(t5, o7, n6)), o7 <= e7 && (r7 = o7 + 1), e7 <= o7 && (n6 = o7 - 1);
            }
          }
          function jr(t5, e7, r7) {
            const n6 = t5[e7];
            t5[e7] = t5[r7], t5[r7] = n6;
          }
          function Nr(t5, e7) {
            return t5 < e7 ? -1 : t5 > e7 ? 1 : 0;
          }
          function Ur(t5, e7) {
            if (t5.length <= 1) return [t5];
            const r7 = [];
            let n6, i6;
            for (const e8 of t5) {
              const t6 = Gr(e8);
              0 !== t6 && (e8.area = Math.abs(t6), void 0 === i6 && (i6 = t6 < 0), i6 === t6 < 0 ? (n6 && r7.push(n6), n6 = [e8]) : n6.push(e8));
            }
            if (n6 && r7.push(n6), e7 > 1) for (let t6 = 0; t6 < r7.length; t6++) r7[t6].length <= e7 || (Rr(r7[t6], e7, 1, r7[t6].length - 1, qr), r7[t6] = r7[t6].slice(0, e7));
            return r7;
          }
          function qr(t5, e7) {
            return e7.area - t5.area;
          }
          function Gr(t5) {
            let e7 = 0;
            for (let r7, n6, i6 = 0, s5 = t5.length, a4 = s5 - 1; i6 < s5; a4 = i6++) r7 = t5[i6], n6 = t5[a4], e7 += (n6.x - r7.x) * (r7.y + n6.y);
            return e7;
          }
          const Zr = 1 / 298.257223563, Kr = Zr * (2 - Zr), Xr = Math.PI / 180;
          class Hr {
            constructor(t5) {
              const e7 = 6378.137 * Xr * 1e3, r7 = Math.cos(t5 * Xr), n6 = 1 / (1 - Kr * (1 - r7 * r7)), i6 = Math.sqrt(n6);
              this.kx = e7 * i6 * r7, this.ky = e7 * i6 * n6 * (1 - Kr);
            }
            distance(t5, e7) {
              const r7 = this.wrap(t5[0] - e7[0]) * this.kx, n6 = (t5[1] - e7[1]) * this.ky;
              return Math.sqrt(r7 * r7 + n6 * n6);
            }
            pointOnLine(t5, e7) {
              let r7, n6, i6, s5, a4 = 1 / 0;
              for (let o7 = 0; o7 < t5.length - 1; o7++) {
                let l5 = t5[o7][0], u4 = t5[o7][1], c5 = this.wrap(t5[o7 + 1][0] - l5) * this.kx, h4 = (t5[o7 + 1][1] - u4) * this.ky, p4 = 0;
                0 === c5 && 0 === h4 || (p4 = (this.wrap(e7[0] - l5) * this.kx * c5 + (e7[1] - u4) * this.ky * h4) / (c5 * c5 + h4 * h4), p4 > 1 ? (l5 = t5[o7 + 1][0], u4 = t5[o7 + 1][1]) : p4 > 0 && (l5 += c5 / this.kx * p4, u4 += h4 / this.ky * p4)), c5 = this.wrap(e7[0] - l5) * this.kx, h4 = (e7[1] - u4) * this.ky;
                const f4 = c5 * c5 + h4 * h4;
                f4 < a4 && (a4 = f4, r7 = l5, n6 = u4, i6 = o7, s5 = p4);
              }
              return { point: [r7, n6], index: i6, t: Math.max(0, Math.min(1, s5)) };
            }
            wrap(t5) {
              for (; t5 < -180; ) t5 += 360;
              for (; t5 > 180; ) t5 -= 360;
              return t5;
            }
          }
          function Yr(t5, e7) {
            return e7[0] - t5[0];
          }
          function Jr(t5) {
            return t5[1] - t5[0] + 1;
          }
          function Wr(t5, e7) {
            return t5[1] >= t5[0] && t5[1] < e7;
          }
          function Qr(t5, e7) {
            if (t5[0] > t5[1]) return [null, null];
            const r7 = Jr(t5);
            if (e7) {
              if (2 === r7) return [t5, null];
              const e8 = Math.floor(r7 / 2);
              return [[t5[0], t5[0] + e8], [t5[0] + e8, t5[1]]];
            }
            if (1 === r7) return [t5, null];
            const n6 = Math.floor(r7 / 2) - 1;
            return [[t5[0], t5[0] + n6], [t5[0] + n6 + 1, t5[1]]];
          }
          function tn(t5, e7) {
            if (!Wr(e7, t5.length)) return [1 / 0, 1 / 0, -1 / 0, -1 / 0];
            const r7 = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
            for (let n6 = e7[0]; n6 <= e7[1]; ++n6) Sr(r7, t5[n6]);
            return r7;
          }
          function en(t5) {
            const e7 = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
            for (const r7 of t5) for (const t6 of r7) Sr(e7, t6);
            return e7;
          }
          function rn(t5) {
            return t5[0] !== -1 / 0 && t5[1] !== -1 / 0 && t5[2] !== 1 / 0 && t5[3] !== 1 / 0;
          }
          function nn(t5, e7, r7) {
            if (!rn(t5) || !rn(e7)) return NaN;
            let n6 = 0, i6 = 0;
            return t5[2] < e7[0] && (n6 = e7[0] - t5[2]), t5[0] > e7[2] && (n6 = t5[0] - e7[2]), t5[1] > e7[3] && (i6 = t5[1] - e7[3]), t5[3] < e7[1] && (i6 = e7[1] - t5[3]), r7.distance([0, 0], [n6, i6]);
          }
          function sn(t5, e7, r7) {
            const n6 = r7.pointOnLine(e7, t5);
            return r7.distance(t5, n6.point);
          }
          function an(t5, e7, r7, n6, i6) {
            const s5 = Math.min(sn(t5, [r7, n6], i6), sn(e7, [r7, n6], i6)), a4 = Math.min(sn(r7, [t5, e7], i6), sn(n6, [t5, e7], i6));
            return Math.min(s5, a4);
          }
          function on(t5, e7, r7, n6, i6) {
            if (!Wr(e7, t5.length) || !Wr(n6, r7.length)) return 1 / 0;
            let s5 = 1 / 0;
            for (let a4 = e7[0]; a4 < e7[1]; ++a4) {
              const e8 = t5[a4], o7 = t5[a4 + 1];
              for (let t6 = n6[0]; t6 < n6[1]; ++t6) {
                const n7 = r7[t6], a5 = r7[t6 + 1];
                if (Mr(e8, o7, n7, a5)) return 0;
                s5 = Math.min(s5, an(e8, o7, n7, a5, i6));
              }
            }
            return s5;
          }
          function ln(t5, e7, r7, n6, i6) {
            if (!Wr(e7, t5.length) || !Wr(n6, r7.length)) return NaN;
            let s5 = 1 / 0;
            for (let a4 = e7[0]; a4 <= e7[1]; ++a4) for (let e8 = n6[0]; e8 <= n6[1]; ++e8) if (s5 = Math.min(s5, i6.distance(t5[a4], r7[e8])), 0 === s5) return s5;
            return s5;
          }
          function un(t5, e7, r7) {
            if (zr(t5, e7, true)) return 0;
            let n6 = 1 / 0;
            for (const i6 of e7) {
              const e8 = i6[0], s5 = i6[i6.length - 1];
              if (e8 !== s5 && (n6 = Math.min(n6, sn(t5, [s5, e8], r7)), 0 === n6)) return n6;
              const a4 = r7.pointOnLine(i6, t5);
              if (n6 = Math.min(n6, r7.distance(t5, a4.point)), 0 === n6) return n6;
            }
            return n6;
          }
          function cn(t5, e7, r7, n6) {
            if (!Wr(e7, t5.length)) return NaN;
            for (let n7 = e7[0]; n7 <= e7[1]; ++n7) if (zr(t5[n7], r7, true)) return 0;
            let i6 = 1 / 0;
            for (let s5 = e7[0]; s5 < e7[1]; ++s5) {
              const e8 = t5[s5], a4 = t5[s5 + 1];
              for (const t6 of r7) for (let r8 = 0, s6 = t6.length, o7 = s6 - 1; r8 < s6; o7 = r8++) {
                const s7 = t6[o7], l5 = t6[r8];
                if (Mr(e8, a4, s7, l5)) return 0;
                i6 = Math.min(i6, an(e8, a4, s7, l5, n6));
              }
            }
            return i6;
          }
          function hn(t5, e7) {
            for (const r7 of t5) for (const t6 of r7) if (zr(t6, e7, true)) return true;
            return false;
          }
          function pn(t5, e7, r7, n6 = 1 / 0) {
            const i6 = en(t5), s5 = en(e7);
            if (n6 !== 1 / 0 && nn(i6, s5, r7) >= n6) return n6;
            if (Ar(i6, s5)) {
              if (hn(t5, e7)) return 0;
            } else if (hn(e7, t5)) return 0;
            let a4 = 1 / 0;
            for (const n7 of t5) for (let t6 = 0, i7 = n7.length, s6 = i7 - 1; t6 < i7; s6 = t6++) {
              const i8 = n7[s6], o7 = n7[t6];
              for (const t7 of e7) for (let e8 = 0, n8 = t7.length, s7 = n8 - 1; e8 < n8; s7 = e8++) {
                const n9 = t7[s7], l5 = t7[e8];
                if (Mr(i8, o7, n9, l5)) return 0;
                a4 = Math.min(a4, an(i8, o7, n9, l5, r7));
              }
            }
            return a4;
          }
          function fn(t5, e7, r7, n6, i6, s5) {
            if (!s5) return;
            const a4 = nn(tn(n6, s5), i6, r7);
            a4 < e7 && t5.push([a4, s5, [0, 0]]);
          }
          function dn(t5, e7, r7, n6, i6, s5, a4) {
            if (!s5 || !a4) return;
            const o7 = nn(tn(n6, s5), tn(i6, a4), r7);
            o7 < e7 && t5.push([o7, s5, a4]);
          }
          function yn(t5, e7, r7, n6, i6 = 1 / 0) {
            let s5 = Math.min(n6.distance(t5[0], r7[0][0]), i6);
            if (0 === s5) return s5;
            const a4 = new Dr([[0, [0, t5.length - 1], [0, 0]]], Yr), o7 = en(r7);
            for (; a4.length > 0; ) {
              const i7 = a4.pop();
              if (i7[0] >= s5) continue;
              const l5 = i7[1], u4 = e7 ? 50 : 100;
              if (Jr(l5) <= u4) {
                if (!Wr(l5, t5.length)) return NaN;
                if (e7) {
                  const e8 = cn(t5, l5, r7, n6);
                  if (isNaN(e8) || 0 === e8) return e8;
                  s5 = Math.min(s5, e8);
                } else for (let e8 = l5[0]; e8 <= l5[1]; ++e8) {
                  const i8 = un(t5[e8], r7, n6);
                  if (s5 = Math.min(s5, i8), 0 === s5) return 0;
                }
              } else {
                const r8 = Qr(l5, e7);
                fn(a4, s5, n6, t5, o7, r8[0]), fn(a4, s5, n6, t5, o7, r8[1]);
              }
            }
            return s5;
          }
          function mn(t5, e7, r7, n6, i6, s5 = 1 / 0) {
            let a4 = Math.min(s5, i6.distance(t5[0], r7[0]));
            if (0 === a4) return a4;
            const o7 = new Dr([[0, [0, t5.length - 1], [0, r7.length - 1]]], Yr);
            for (; o7.length > 0; ) {
              const s6 = o7.pop();
              if (s6[0] >= a4) continue;
              const l5 = s6[1], u4 = s6[2], c5 = e7 ? 50 : 100, h4 = n6 ? 50 : 100;
              if (Jr(l5) <= c5 && Jr(u4) <= h4) {
                if (!Wr(l5, t5.length) && Wr(u4, r7.length)) return NaN;
                let s7;
                if (e7 && n6) s7 = on(t5, l5, r7, u4, i6), a4 = Math.min(a4, s7);
                else if (e7 && !n6) {
                  const e8 = t5.slice(l5[0], l5[1] + 1);
                  for (let t6 = u4[0]; t6 <= u4[1]; ++t6) if (s7 = sn(r7[t6], e8, i6), a4 = Math.min(a4, s7), 0 === a4) return a4;
                } else if (!e7 && n6) {
                  const e8 = r7.slice(u4[0], u4[1] + 1);
                  for (let r8 = l5[0]; r8 <= l5[1]; ++r8) if (s7 = sn(t5[r8], e8, i6), a4 = Math.min(a4, s7), 0 === a4) return a4;
                } else s7 = ln(t5, l5, r7, u4, i6), a4 = Math.min(a4, s7);
              } else {
                const s7 = Qr(l5, e7), c6 = Qr(u4, n6);
                dn(o7, a4, i6, t5, r7, s7[0], c6[0]), dn(o7, a4, i6, t5, r7, s7[0], c6[1]), dn(o7, a4, i6, t5, r7, s7[1], c6[0]), dn(o7, a4, i6, t5, r7, s7[1], c6[1]);
              }
            }
            return a4;
          }
          function gn(t5) {
            return "MultiPolygon" === t5.type ? t5.coordinates.map((t6) => ({ type: "Polygon", coordinates: t6 })) : "MultiLineString" === t5.type ? t5.coordinates.map((t6) => ({ type: "LineString", coordinates: t6 })) : "MultiPoint" === t5.type ? t5.coordinates.map((t6) => ({ type: "Point", coordinates: t6 })) : [t5];
          }
          class xn {
            constructor(t5, e7) {
              this.type = Bt, this.geojson = t5, this.geometries = e7;
            }
            static parse(t5, e7) {
              if (2 !== t5.length) return e7.error(`'distance' expression requires exactly one argument, but found ${t5.length - 1} instead.`);
              if (Ce(t5[1])) {
                const e8 = t5[1];
                if ("FeatureCollection" === e8.type) return new xn(e8, e8.features.map((t6) => gn(t6.geometry)).flat());
                if ("Feature" === e8.type) return new xn(e8, gn(e8.geometry));
                if ("type" in e8 && "coordinates" in e8) return new xn(e8, gn(e8));
              }
              return e7.error("'distance' expression requires valid geojson object that contains polygon geometry type.");
            }
            evaluate(t5) {
              if (null != t5.geometry() && null != t5.canonicalID()) {
                if ("Point" === t5.geometryType()) return function(t6, e7) {
                  const r7 = t6.geometry(), n6 = r7.flat().map((e8) => _r([e8.x, e8.y], t6.canonical));
                  if (0 === r7.length) return NaN;
                  const i6 = new Hr(n6[0][1]);
                  let s5 = 1 / 0;
                  for (const t7 of e7) {
                    switch (t7.type) {
                      case "Point":
                        s5 = Math.min(s5, mn(n6, false, [t7.coordinates], false, i6, s5));
                        break;
                      case "LineString":
                        s5 = Math.min(s5, mn(n6, false, t7.coordinates, true, i6, s5));
                        break;
                      case "Polygon":
                        s5 = Math.min(s5, yn(n6, false, t7.coordinates, i6, s5));
                    }
                    if (0 === s5) return s5;
                  }
                  return s5;
                }(t5, this.geometries);
                if ("LineString" === t5.geometryType()) return function(t6, e7) {
                  const r7 = t6.geometry(), n6 = r7.flat().map((e8) => _r([e8.x, e8.y], t6.canonical));
                  if (0 === r7.length) return NaN;
                  const i6 = new Hr(n6[0][1]);
                  let s5 = 1 / 0;
                  for (const t7 of e7) {
                    switch (t7.type) {
                      case "Point":
                        s5 = Math.min(s5, mn(n6, true, [t7.coordinates], false, i6, s5));
                        break;
                      case "LineString":
                        s5 = Math.min(s5, mn(n6, true, t7.coordinates, true, i6, s5));
                        break;
                      case "Polygon":
                        s5 = Math.min(s5, yn(n6, true, t7.coordinates, i6, s5));
                    }
                    if (0 === s5) return s5;
                  }
                  return s5;
                }(t5, this.geometries);
                if ("Polygon" === t5.geometryType()) return function(t6, e7) {
                  const r7 = t6.geometry();
                  if (0 === r7.length || 0 === r7[0].length) return NaN;
                  const n6 = Ur(r7, 0).map((e8) => e8.map((e9) => e9.map((e10) => _r([e10.x, e10.y], t6.canonical)))), i6 = new Hr(n6[0][0][0][1]);
                  let s5 = 1 / 0;
                  for (const t7 of e7) for (const e8 of n6) {
                    switch (t7.type) {
                      case "Point":
                        s5 = Math.min(s5, yn([t7.coordinates], false, e8, i6, s5));
                        break;
                      case "LineString":
                        s5 = Math.min(s5, yn(t7.coordinates, true, e8, i6, s5));
                        break;
                      case "Polygon":
                        s5 = Math.min(s5, pn(e8, t7.coordinates, i6, s5));
                    }
                    if (0 === s5) return s5;
                  }
                  return s5;
                }(t5, this.geometries);
              }
              return NaN;
            }
            eachChild() {
            }
            outputDefined() {
              return true;
            }
          }
          const vn = { "==": ur, "!=": cr, ">": pr, "<": hr, ">=": dr, "<=": fr, array: Fe, at: Ue, boolean: Fe, case: Ke, coalesce: sr, collator: yr, format: gr, image: xr, in: qe, "index-of": Ge, interpolate: rr, "interpolate-hcl": rr, "interpolate-lab": rr, length: vr, let: je, literal: Ee, match: Ze, number: Fe, "number-format": mr, object: Fe, slice: Xe, step: Ye, string: Fe, "to-boolean": Le, "to-color": Le, "to-number": Le, "to-string": Le, var: Ne, within: Or, distance: xn };
          class bn {
            constructor(t5, e7, r7, n6) {
              this.name = t5, this.type = e7, this._evaluate = r7, this.args = n6;
            }
            evaluate(t5) {
              return this._evaluate(t5, this.args);
            }
            eachChild(t5) {
              this.args.forEach(t5);
            }
            outputDefined() {
              return false;
            }
            static parse(t5, e7) {
              const r7 = t5[0], n6 = bn.definitions[r7];
              if (!n6) return e7.error(`Unknown expression "${r7}". If you wanted a literal array, use ["literal", [...]].`, 0);
              const i6 = Array.isArray(n6) ? n6[0] : n6.type, s5 = Array.isArray(n6) ? [[n6[1], n6[2]]] : n6.overloads, a4 = s5.filter(([e8]) => !Array.isArray(e8) || e8.length === t5.length - 1);
              let o7 = null;
              for (const [n7, s6] of a4) {
                o7 = new Re(e7.registry, kn, e7.path, null, e7.scope);
                const a5 = [];
                let l5 = false;
                for (let e8 = 1; e8 < t5.length; e8++) {
                  const r8 = t5[e8], i7 = Array.isArray(n7) ? n7[e8 - 1] : n7.type, s7 = o7.parse(r8, 1 + a5.length, i7);
                  if (!s7) {
                    l5 = true;
                    break;
                  }
                  a5.push(s7);
                }
                if (!l5) if (Array.isArray(n7) && n7.length !== a5.length) o7.error(`Expected ${n7.length} arguments, but found ${a5.length} instead.`);
                else {
                  for (let t6 = 0; t6 < a5.length; t6++) {
                    const e8 = Array.isArray(n7) ? n7[t6] : n7.type, r8 = a5[t6];
                    o7.concat(t6 + 1).checkSubtype(e8, r8.type);
                  }
                  if (0 === o7.errors.length) return new bn(r7, i6, s6, a5);
                }
              }
              if (1 === a4.length) e7.errors.push(...o7.errors);
              else {
                const r8 = (a4.length ? a4 : s5).map(([t6]) => {
                  return e8 = t6, Array.isArray(e8) ? `(${e8.map(qt).join(", ")})` : `(${qt(e8.type)}...)`;
                  var e8;
                }).join(" | "), n7 = [];
                for (let r9 = 1; r9 < t5.length; r9++) {
                  const i7 = e7.parse(t5[r9], 1 + n7.length);
                  if (!i7) return null;
                  n7.push(qt(i7.type));
                }
                e7.error(`Expected arguments of type ${r8}, but found (${n7.join(", ")}) instead.`);
              }
              return null;
            }
            static register(t5, e7) {
              bn.definitions = e7;
              for (const r7 in e7) t5[r7] = bn;
            }
          }
          function wn(t5, [e7, r7, n6, i6]) {
            e7 = e7.evaluate(t5), r7 = r7.evaluate(t5), n6 = n6.evaluate(t5);
            const s5 = i6 ? i6.evaluate(t5) : 1, a4 = Pe(e7, r7, n6, s5);
            if (a4) throw new Ae(a4);
            return new xe(e7 / 255, r7 / 255, n6 / 255, s5, false);
          }
          function _n(t5, e7) {
            return t5 in e7;
          }
          function Sn(t5, e7) {
            const r7 = e7[t5];
            return void 0 === r7 ? null : r7;
          }
          function An(t5) {
            return { type: t5 };
          }
          function kn(t5) {
            if (t5 instanceof Ne) return kn(t5.boundExpression);
            if (t5 instanceof bn && "error" === t5.name) return false;
            if (t5 instanceof yr) return false;
            if (t5 instanceof Or) return false;
            if (t5 instanceof xn) return false;
            const e7 = t5 instanceof Le || t5 instanceof Fe;
            let r7 = true;
            return t5.eachChild((t6) => {
              r7 = e7 ? r7 && kn(t6) : r7 && t6 instanceof Ee;
            }), !!r7 && Mn(t5) && zn(t5, ["zoom", "heatmap-density", "line-progress", "accumulated", "is-supported-script"]);
          }
          function Mn(t5) {
            if (t5 instanceof bn) {
              if ("get" === t5.name && 1 === t5.args.length) return false;
              if ("feature-state" === t5.name) return false;
              if ("has" === t5.name && 1 === t5.args.length) return false;
              if ("properties" === t5.name || "geometry-type" === t5.name || "id" === t5.name) return false;
              if (/^filter-/.test(t5.name)) return false;
            }
            if (t5 instanceof Or) return false;
            if (t5 instanceof xn) return false;
            let e7 = true;
            return t5.eachChild((t6) => {
              e7 && !Mn(t6) && (e7 = false);
            }), e7;
          }
          function In(t5) {
            if (t5 instanceof bn && "feature-state" === t5.name) return false;
            let e7 = true;
            return t5.eachChild((t6) => {
              e7 && !In(t6) && (e7 = false);
            }), e7;
          }
          function zn(t5, e7) {
            if (t5 instanceof bn && e7.indexOf(t5.name) >= 0) return false;
            let r7 = true;
            return t5.eachChild((t6) => {
              r7 && !zn(t6, e7) && (r7 = false);
            }), r7;
          }
          function Pn(t5) {
            return { result: "success", value: t5 };
          }
          function Cn(t5) {
            return { result: "error", value: t5 };
          }
          function Bn(t5) {
            return "data-driven" === t5["property-type"] || "cross-faded-data-driven" === t5["property-type"];
          }
          function Vn(t5) {
            return !!t5.expression && t5.expression.parameters.indexOf("zoom") > -1;
          }
          function En(t5) {
            return !!t5.expression && t5.expression.interpolated;
          }
          function Tn(t5) {
            return t5 instanceof Number ? "number" : t5 instanceof String ? "string" : t5 instanceof Boolean ? "boolean" : Array.isArray(t5) ? "array" : null === t5 ? "null" : typeof t5;
          }
          function Fn(t5) {
            return "object" == typeof t5 && null !== t5 && !Array.isArray(t5);
          }
          function $n(t5) {
            return t5;
          }
          function Ln(t5, e7) {
            const r7 = "color" === e7.type, n6 = t5.stops && "object" == typeof t5.stops[0][0], i6 = n6 || !(n6 || void 0 !== t5.property), s5 = t5.type || (En(e7) ? "exponential" : "interval");
            if (r7 || "padding" === e7.type) {
              const n7 = r7 ? xe.parse : Se.parse;
              (t5 = It({}, t5)).stops && (t5.stops = t5.stops.map((t6) => [t6[0], n7(t6[1])])), t5.default = n7(t5.default ? t5.default : e7.default);
            }
            if (t5.colorSpace && "rgb" !== (a4 = t5.colorSpace) && "hcl" !== a4 && "lab" !== a4) throw new Error(`Unknown color space: "${t5.colorSpace}"`);
            var a4;
            let o7, l5, u4;
            if ("exponential" === s5) o7 = jn;
            else if ("interval" === s5) o7 = Rn;
            else if ("categorical" === s5) {
              o7 = Dn, l5 = /* @__PURE__ */ Object.create(null);
              for (const e8 of t5.stops) l5[e8[0]] = e8[1];
              u4 = typeof t5.stops[0][0];
            } else {
              if ("identity" !== s5) throw new Error(`Unknown function type "${s5}"`);
              o7 = Nn;
            }
            if (n6) {
              const r8 = {}, n7 = [];
              for (let e8 = 0; e8 < t5.stops.length; e8++) {
                const i8 = t5.stops[e8], s7 = i8[0].zoom;
                void 0 === r8[s7] && (r8[s7] = { zoom: s7, type: t5.type, property: t5.property, default: t5.default, stops: [] }, n7.push(s7)), r8[s7].stops.push([i8[0].value, i8[1]]);
              }
              const i7 = [];
              for (const t6 of n7) i7.push([r8[t6].zoom, Ln(r8[t6], e7)]);
              const s6 = { name: "linear" };
              return { kind: "composite", interpolationType: s6, interpolationFactor: rr.interpolationFactor.bind(void 0, s6), zoomStops: i7.map((t6) => t6[0]), evaluate: ({ zoom: r9 }, n8) => jn({ stops: i7, base: t5.base }, e7, r9).evaluate(r9, n8) };
            }
            if (i6) {
              const r8 = "exponential" === s5 ? { name: "exponential", base: void 0 !== t5.base ? t5.base : 1 } : null;
              return { kind: "camera", interpolationType: r8, interpolationFactor: rr.interpolationFactor.bind(void 0, r8), zoomStops: t5.stops.map((t6) => t6[0]), evaluate: ({ zoom: r9 }) => o7(t5, e7, r9, l5, u4) };
            }
            return { kind: "source", evaluate(r8, n7) {
              const i7 = n7 && n7.properties ? n7.properties[t5.property] : void 0;
              return void 0 === i7 ? On(t5.default, e7.default) : o7(t5, e7, i7, l5, u4);
            } };
          }
          function On(t5, e7, r7) {
            return void 0 !== t5 ? t5 : void 0 !== e7 ? e7 : void 0 !== r7 ? r7 : void 0;
          }
          function Dn(t5, e7, r7, n6, i6) {
            return On(typeof r7 === i6 ? n6[r7] : void 0, t5.default, e7.default);
          }
          function Rn(t5, e7, r7) {
            if ("number" !== Tn(r7)) return On(t5.default, e7.default);
            const n6 = t5.stops.length;
            if (1 === n6) return t5.stops[0][1];
            if (r7 <= t5.stops[0][0]) return t5.stops[0][1];
            if (r7 >= t5.stops[n6 - 1][0]) return t5.stops[n6 - 1][1];
            const i6 = He(t5.stops.map((t6) => t6[0]), r7);
            return t5.stops[i6][1];
          }
          function jn(t5, e7, r7) {
            const n6 = void 0 !== t5.base ? t5.base : 1;
            if ("number" !== Tn(r7)) return On(t5.default, e7.default);
            const i6 = t5.stops.length;
            if (1 === i6) return t5.stops[0][1];
            if (r7 <= t5.stops[0][0]) return t5.stops[0][1];
            if (r7 >= t5.stops[i6 - 1][0]) return t5.stops[i6 - 1][1];
            const s5 = He(t5.stops.map((t6) => t6[0]), r7), a4 = function(t6, e8, r8, n7) {
              const i7 = n7 - r8, s6 = t6 - r8;
              return 0 === i7 ? 0 : 1 === e8 ? s6 / i7 : (Math.pow(e8, s6) - 1) / (Math.pow(e8, i7) - 1);
            }(r7, n6, t5.stops[s5][0], t5.stops[s5 + 1][0]), o7 = t5.stops[s5][1], l5 = t5.stops[s5 + 1][1], u4 = ir[e7.type] || $n;
            return "function" == typeof o7.evaluate ? { evaluate(...e8) {
              const r8 = o7.evaluate.apply(void 0, e8), n7 = l5.evaluate.apply(void 0, e8);
              if (void 0 !== r8 && void 0 !== n7) return u4(r8, n7, a4, t5.colorSpace);
            } } : u4(o7, l5, a4, t5.colorSpace);
          }
          function Nn(t5, e7, r7) {
            switch (e7.type) {
              case "color":
                r7 = xe.parse(r7);
                break;
              case "formatted":
                r7 = _e.fromString(r7.toString());
                break;
              case "resolvedImage":
                r7 = Ie.fromString(r7.toString());
                break;
              case "padding":
                r7 = Se.parse(r7);
                break;
              default:
                Tn(r7) === e7.type || "enum" === e7.type && e7.values[r7] || (r7 = void 0);
            }
            return On(r7, t5.default, e7.default);
          }
          bn.register(vn, { error: [{ kind: "error" }, [Vt], (t5, [e7]) => {
            throw new Ae(e7.evaluate(t5));
          }], typeof: [Vt, [Lt], (t5, [e7]) => qt(Be(e7.evaluate(t5)))], "to-rgba": [Ut(Bt, 4), [Tt], (t5, [e7]) => {
            const [r7, n6, i6, s5] = e7.evaluate(t5).rgb;
            return [255 * r7, 255 * n6, 255 * i6, s5];
          }], rgb: [Tt, [Bt, Bt, Bt], wn], rgba: [Tt, [Bt, Bt, Bt, Bt], wn], has: { type: Et, overloads: [[[Vt], (t5, [e7]) => _n(e7.evaluate(t5), t5.properties())], [[Vt, $t], (t5, [e7, r7]) => _n(e7.evaluate(t5), r7.evaluate(t5))]] }, get: { type: Lt, overloads: [[[Vt], (t5, [e7]) => Sn(e7.evaluate(t5), t5.properties())], [[Vt, $t], (t5, [e7, r7]) => Sn(e7.evaluate(t5), r7.evaluate(t5))]] }, "feature-state": [Lt, [Vt], (t5, [e7]) => Sn(e7.evaluate(t5), t5.featureState || {})], properties: [$t, [], (t5) => t5.properties()], "geometry-type": [Vt, [], (t5) => t5.geometryType()], id: [Lt, [], (t5) => t5.id()], zoom: [Bt, [], (t5) => t5.globals.zoom], "heatmap-density": [Bt, [], (t5) => t5.globals.heatmapDensity || 0], "line-progress": [Bt, [], (t5) => t5.globals.lineProgress || 0], accumulated: [Lt, [], (t5) => void 0 === t5.globals.accumulated ? null : t5.globals.accumulated], "+": [Bt, An(Bt), (t5, e7) => {
            let r7 = 0;
            for (const n6 of e7) r7 += n6.evaluate(t5);
            return r7;
          }], "*": [Bt, An(Bt), (t5, e7) => {
            let r7 = 1;
            for (const n6 of e7) r7 *= n6.evaluate(t5);
            return r7;
          }], "-": { type: Bt, overloads: [[[Bt, Bt], (t5, [e7, r7]) => e7.evaluate(t5) - r7.evaluate(t5)], [[Bt], (t5, [e7]) => -e7.evaluate(t5)]] }, "/": [Bt, [Bt, Bt], (t5, [e7, r7]) => e7.evaluate(t5) / r7.evaluate(t5)], "%": [Bt, [Bt, Bt], (t5, [e7, r7]) => e7.evaluate(t5) % r7.evaluate(t5)], ln2: [Bt, [], () => Math.LN2], pi: [Bt, [], () => Math.PI], e: [Bt, [], () => Math.E], "^": [Bt, [Bt, Bt], (t5, [e7, r7]) => Math.pow(e7.evaluate(t5), r7.evaluate(t5))], sqrt: [Bt, [Bt], (t5, [e7]) => Math.sqrt(e7.evaluate(t5))], log10: [Bt, [Bt], (t5, [e7]) => Math.log(e7.evaluate(t5)) / Math.LN10], ln: [Bt, [Bt], (t5, [e7]) => Math.log(e7.evaluate(t5))], log2: [Bt, [Bt], (t5, [e7]) => Math.log(e7.evaluate(t5)) / Math.LN2], sin: [Bt, [Bt], (t5, [e7]) => Math.sin(e7.evaluate(t5))], cos: [Bt, [Bt], (t5, [e7]) => Math.cos(e7.evaluate(t5))], tan: [Bt, [Bt], (t5, [e7]) => Math.tan(e7.evaluate(t5))], asin: [Bt, [Bt], (t5, [e7]) => Math.asin(e7.evaluate(t5))], acos: [Bt, [Bt], (t5, [e7]) => Math.acos(e7.evaluate(t5))], atan: [Bt, [Bt], (t5, [e7]) => Math.atan(e7.evaluate(t5))], min: [Bt, An(Bt), (t5, e7) => Math.min(...e7.map((e8) => e8.evaluate(t5)))], max: [Bt, An(Bt), (t5, e7) => Math.max(...e7.map((e8) => e8.evaluate(t5)))], abs: [Bt, [Bt], (t5, [e7]) => Math.abs(e7.evaluate(t5))], round: [Bt, [Bt], (t5, [e7]) => {
            const r7 = e7.evaluate(t5);
            return r7 < 0 ? -Math.round(-r7) : Math.round(r7);
          }], floor: [Bt, [Bt], (t5, [e7]) => Math.floor(e7.evaluate(t5))], ceil: [Bt, [Bt], (t5, [e7]) => Math.ceil(e7.evaluate(t5))], "filter-==": [Et, [Vt, Lt], (t5, [e7, r7]) => t5.properties()[e7.value] === r7.value], "filter-id-==": [Et, [Lt], (t5, [e7]) => t5.id() === e7.value], "filter-type-==": [Et, [Vt], (t5, [e7]) => t5.geometryType() === e7.value], "filter-<": [Et, [Vt, Lt], (t5, [e7, r7]) => {
            const n6 = t5.properties()[e7.value], i6 = r7.value;
            return typeof n6 == typeof i6 && n6 < i6;
          }], "filter-id-<": [Et, [Lt], (t5, [e7]) => {
            const r7 = t5.id(), n6 = e7.value;
            return typeof r7 == typeof n6 && r7 < n6;
          }], "filter->": [Et, [Vt, Lt], (t5, [e7, r7]) => {
            const n6 = t5.properties()[e7.value], i6 = r7.value;
            return typeof n6 == typeof i6 && n6 > i6;
          }], "filter-id->": [Et, [Lt], (t5, [e7]) => {
            const r7 = t5.id(), n6 = e7.value;
            return typeof r7 == typeof n6 && r7 > n6;
          }], "filter-<=": [Et, [Vt, Lt], (t5, [e7, r7]) => {
            const n6 = t5.properties()[e7.value], i6 = r7.value;
            return typeof n6 == typeof i6 && n6 <= i6;
          }], "filter-id-<=": [Et, [Lt], (t5, [e7]) => {
            const r7 = t5.id(), n6 = e7.value;
            return typeof r7 == typeof n6 && r7 <= n6;
          }], "filter->=": [Et, [Vt, Lt], (t5, [e7, r7]) => {
            const n6 = t5.properties()[e7.value], i6 = r7.value;
            return typeof n6 == typeof i6 && n6 >= i6;
          }], "filter-id->=": [Et, [Lt], (t5, [e7]) => {
            const r7 = t5.id(), n6 = e7.value;
            return typeof r7 == typeof n6 && r7 >= n6;
          }], "filter-has": [Et, [Lt], (t5, [e7]) => e7.value in t5.properties()], "filter-has-id": [Et, [], (t5) => null !== t5.id() && void 0 !== t5.id()], "filter-type-in": [Et, [Ut(Vt)], (t5, [e7]) => e7.value.indexOf(t5.geometryType()) >= 0], "filter-id-in": [Et, [Ut(Lt)], (t5, [e7]) => e7.value.indexOf(t5.id()) >= 0], "filter-in-small": [Et, [Vt, Ut(Lt)], (t5, [e7, r7]) => r7.value.indexOf(t5.properties()[e7.value]) >= 0], "filter-in-large": [Et, [Vt, Ut(Lt)], (t5, [e7, r7]) => function(t6, e8, r8, n6) {
            for (; r8 <= n6; ) {
              const i6 = r8 + n6 >> 1;
              if (e8[i6] === t6) return true;
              e8[i6] > t6 ? n6 = i6 - 1 : r8 = i6 + 1;
            }
            return false;
          }(t5.properties()[e7.value], r7.value, 0, r7.value.length - 1)], all: { type: Et, overloads: [[[Et, Et], (t5, [e7, r7]) => e7.evaluate(t5) && r7.evaluate(t5)], [An(Et), (t5, e7) => {
            for (const r7 of e7) if (!r7.evaluate(t5)) return false;
            return true;
          }]] }, any: { type: Et, overloads: [[[Et, Et], (t5, [e7, r7]) => e7.evaluate(t5) || r7.evaluate(t5)], [An(Et), (t5, e7) => {
            for (const r7 of e7) if (r7.evaluate(t5)) return true;
            return false;
          }]] }, "!": [Et, [Et], (t5, [e7]) => !e7.evaluate(t5)], "is-supported-script": [Et, [Vt], (t5, [e7]) => {
            const r7 = t5.globals && t5.globals.isSupportedScript;
            return !r7 || r7(e7.evaluate(t5));
          }], upcase: [Vt, [Vt], (t5, [e7]) => e7.evaluate(t5).toUpperCase()], downcase: [Vt, [Vt], (t5, [e7]) => e7.evaluate(t5).toLowerCase()], concat: [Vt, An(Lt), (t5, e7) => e7.map((e8) => Ve(e8.evaluate(t5))).join("")], "resolved-locale": [Vt, [Ot], (t5, [e7]) => e7.evaluate(t5).resolvedLocale()] });
          class Un {
            constructor(t5, e7) {
              var r7;
              this.expression = t5, this._warningHistory = {}, this._evaluator = new De(), this._defaultValue = e7 ? "color" === (r7 = e7).type && Fn(r7.default) ? new xe(0, 0, 0, 0) : "color" === r7.type ? xe.parse(r7.default) || null : "padding" === r7.type ? Se.parse(r7.default) || null : "variableAnchorOffsetCollection" === r7.type ? Me.parse(r7.default) || null : "projectionDefinition" === r7.type ? ze.parse(r7.default) || null : void 0 === r7.default ? null : r7.default : null, this._enumValues = e7 && "enum" === e7.type ? e7.values : null;
            }
            evaluateWithoutErrorHandling(t5, e7, r7, n6, i6, s5) {
              return this._evaluator.globals = t5, this._evaluator.feature = e7, this._evaluator.featureState = r7, this._evaluator.canonical = n6, this._evaluator.availableImages = i6 || null, this._evaluator.formattedSection = s5, this.expression.evaluate(this._evaluator);
            }
            evaluate(t5, e7, r7, n6, i6, s5) {
              this._evaluator.globals = t5, this._evaluator.feature = e7 || null, this._evaluator.featureState = r7 || null, this._evaluator.canonical = n6, this._evaluator.availableImages = i6 || null, this._evaluator.formattedSection = s5 || null;
              try {
                const t6 = this.expression.evaluate(this._evaluator);
                if (null == t6 || "number" == typeof t6 && t6 != t6) return this._defaultValue;
                if (this._enumValues && !(t6 in this._enumValues)) throw new Ae(`Expected value to be one of ${Object.keys(this._enumValues).map((t7) => JSON.stringify(t7)).join(", ")}, but found ${JSON.stringify(t6)} instead.`);
                return t6;
              } catch (t6) {
                return this._warningHistory[t6.message] || (this._warningHistory[t6.message] = true, "undefined" != typeof console && console.warn(t6.message)), this._defaultValue;
              }
            }
          }
          function qn(t5) {
            return Array.isArray(t5) && t5.length > 0 && "string" == typeof t5[0] && t5[0] in vn;
          }
          function Gn(t5, e7) {
            const r7 = new Re(vn, kn, [], e7 ? function(t6) {
              const e8 = { color: Tt, string: Vt, number: Bt, enum: Vt, boolean: Et, formatted: Dt, padding: Rt, projectionDefinition: Ft, resolvedImage: jt, variableAnchorOffsetCollection: Nt };
              return "array" === t6.type ? Ut(e8[t6.value] || Lt, t6.length) : e8[t6.type];
            }(e7) : void 0), n6 = r7.parse(t5, void 0, void 0, void 0, e7 && "string" === e7.type ? { typeAnnotation: "coerce" } : void 0);
            return n6 ? Pn(new Un(n6, e7)) : Cn(r7.errors);
          }
          class Zn {
            constructor(t5, e7) {
              this.kind = t5, this._styleExpression = e7, this.isStateDependent = "constant" !== t5 && !In(e7.expression);
            }
            evaluateWithoutErrorHandling(t5, e7, r7, n6, i6, s5) {
              return this._styleExpression.evaluateWithoutErrorHandling(t5, e7, r7, n6, i6, s5);
            }
            evaluate(t5, e7, r7, n6, i6, s5) {
              return this._styleExpression.evaluate(t5, e7, r7, n6, i6, s5);
            }
          }
          class Kn {
            constructor(t5, e7, r7, n6) {
              this.kind = t5, this.zoomStops = r7, this._styleExpression = e7, this.isStateDependent = "camera" !== t5 && !In(e7.expression), this.interpolationType = n6;
            }
            evaluateWithoutErrorHandling(t5, e7, r7, n6, i6, s5) {
              return this._styleExpression.evaluateWithoutErrorHandling(t5, e7, r7, n6, i6, s5);
            }
            evaluate(t5, e7, r7, n6, i6, s5) {
              return this._styleExpression.evaluate(t5, e7, r7, n6, i6, s5);
            }
            interpolationFactor(t5, e7, r7) {
              return this.interpolationType ? rr.interpolationFactor(this.interpolationType, t5, e7, r7) : 0;
            }
          }
          function Xn(t5, e7) {
            const r7 = Gn(t5, e7);
            if ("error" === r7.result) return r7;
            const n6 = r7.value.expression, i6 = Mn(n6);
            if (!i6 && !Bn(e7)) return Cn([new zt("", "data expressions not supported")]);
            const s5 = zn(n6, ["zoom"]);
            if (!s5 && !Vn(e7)) return Cn([new zt("", "zoom expressions not supported")]);
            const a4 = Yn(n6);
            return a4 || s5 ? a4 instanceof zt ? Cn([a4]) : a4 instanceof rr && !En(e7) ? Cn([new zt("", '"interpolate" expressions cannot be used with this property')]) : Pn(a4 ? new Kn(i6 ? "camera" : "composite", r7.value, a4.labels, a4 instanceof rr ? a4.interpolation : void 0) : new Zn(i6 ? "constant" : "source", r7.value)) : Cn([new zt("", '"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.')]);
          }
          class Hn {
            constructor(t5, e7) {
              this._parameters = t5, this._specification = e7, It(this, Ln(this._parameters, this._specification));
            }
            static deserialize(t5) {
              return new Hn(t5._parameters, t5._specification);
            }
            static serialize(t5) {
              return { _parameters: t5._parameters, _specification: t5._specification };
            }
          }
          function Yn(t5) {
            let e7 = null;
            if (t5 instanceof je) e7 = Yn(t5.result);
            else if (t5 instanceof sr) {
              for (const r7 of t5.args) if (e7 = Yn(r7), e7) break;
            } else (t5 instanceof Ye || t5 instanceof rr) && t5.input instanceof bn && "zoom" === t5.input.name && (e7 = t5);
            return e7 instanceof zt || t5.eachChild((t6) => {
              const r7 = Yn(t6);
              r7 instanceof zt ? e7 = r7 : !e7 && r7 ? e7 = new zt("", '"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.') : e7 && r7 && e7 !== r7 && (e7 = new zt("", 'Only one zoom-based "step" or "interpolate" subexpression may be used in an expression.'));
            }), e7;
          }
          function Jn(t5) {
            if (true === t5 || false === t5) return true;
            if (!Array.isArray(t5) || 0 === t5.length) return false;
            switch (t5[0]) {
              case "has":
                return t5.length >= 2 && "$id" !== t5[1] && "$type" !== t5[1];
              case "in":
                return t5.length >= 3 && ("string" != typeof t5[1] || Array.isArray(t5[2]));
              case "!in":
              case "!has":
              case "none":
                return false;
              case "==":
              case "!=":
              case ">":
              case ">=":
              case "<":
              case "<=":
                return 3 !== t5.length || Array.isArray(t5[1]) || Array.isArray(t5[2]);
              case "any":
              case "all":
                for (const e7 of t5.slice(1)) if (!Jn(e7) && "boolean" != typeof e7) return false;
                return true;
              default:
                return true;
            }
          }
          const Wn = { type: "boolean", default: false, transition: false, "property-type": "data-driven", expression: { interpolated: false, parameters: ["zoom", "feature"] } };
          function Qn(t5) {
            if (null == t5) return { filter: () => true, needGeometry: false };
            Jn(t5) || (t5 = ri(t5));
            const e7 = Gn(t5, Wn);
            if ("error" === e7.result) throw new Error(e7.value.map((t6) => `${t6.key}: ${t6.message}`).join(", "));
            return { filter: (t6, r7, n6) => e7.value.evaluate(t6, r7, {}, n6), needGeometry: ei(t5) };
          }
          function ti(t5, e7) {
            return t5 < e7 ? -1 : t5 > e7 ? 1 : 0;
          }
          function ei(t5) {
            if (!Array.isArray(t5)) return false;
            if ("within" === t5[0] || "distance" === t5[0]) return true;
            for (let e7 = 1; e7 < t5.length; e7++) if (ei(t5[e7])) return true;
            return false;
          }
          function ri(t5) {
            if (!t5) return true;
            const e7 = t5[0];
            return t5.length <= 1 ? "any" !== e7 : "==" === e7 ? ni(t5[1], t5[2], "==") : "!=" === e7 ? ai(ni(t5[1], t5[2], "==")) : "<" === e7 || ">" === e7 || "<=" === e7 || ">=" === e7 ? ni(t5[1], t5[2], e7) : "any" === e7 ? (r7 = t5.slice(1), ["any"].concat(r7.map(ri))) : "all" === e7 ? ["all"].concat(t5.slice(1).map(ri)) : "none" === e7 ? ["all"].concat(t5.slice(1).map(ri).map(ai)) : "in" === e7 ? ii(t5[1], t5.slice(2)) : "!in" === e7 ? ai(ii(t5[1], t5.slice(2))) : "has" === e7 ? si(t5[1]) : "!has" !== e7 || ai(si(t5[1]));
            var r7;
          }
          function ni(t5, e7, r7) {
            switch (t5) {
              case "$type":
                return [`filter-type-${r7}`, e7];
              case "$id":
                return [`filter-id-${r7}`, e7];
              default:
                return [`filter-${r7}`, t5, e7];
            }
          }
          function ii(t5, e7) {
            if (0 === e7.length) return false;
            switch (t5) {
              case "$type":
                return ["filter-type-in", ["literal", e7]];
              case "$id":
                return ["filter-id-in", ["literal", e7]];
              default:
                return e7.length > 200 && !e7.some((t6) => typeof t6 != typeof e7[0]) ? ["filter-in-large", t5, ["literal", e7.sort(ti)]] : ["filter-in-small", t5, ["literal", e7]];
            }
          }
          function si(t5) {
            switch (t5) {
              case "$type":
                return true;
              case "$id":
                return ["filter-has-id"];
              default:
                return ["filter-has", t5];
            }
          }
          function ai(t5) {
            return ["!", t5];
          }
          function oi(t5) {
            const e7 = typeof t5;
            if ("number" === e7 || "boolean" === e7 || "string" === e7 || null == t5) return JSON.stringify(t5);
            if (Array.isArray(t5)) {
              let e8 = "[";
              for (const r8 of t5) e8 += `${oi(r8)},`;
              return `${e8}]`;
            }
            const r7 = Object.keys(t5).sort();
            let n6 = "{";
            for (let e8 = 0; e8 < r7.length; e8++) n6 += `${JSON.stringify(r7[e8])}:${oi(t5[r7[e8]])},`;
            return `${n6}}`;
          }
          function li(t5) {
            let e7 = "";
            for (const r7 of yt) e7 += `/${oi(t5[r7])}`;
            return e7;
          }
          function ui(t5) {
            const e7 = t5.value;
            return e7 ? [new Mt(t5.key, e7, "constants have been deprecated as of v8")] : [];
          }
          function ci(t5) {
            return t5 instanceof Number || t5 instanceof String || t5 instanceof Boolean ? t5.valueOf() : t5;
          }
          function hi(t5) {
            if (Array.isArray(t5)) return t5.map(hi);
            if (t5 instanceof Object && !(t5 instanceof Number || t5 instanceof String || t5 instanceof Boolean)) {
              const e7 = {};
              for (const r7 in t5) e7[r7] = hi(t5[r7]);
              return e7;
            }
            return ci(t5);
          }
          function pi(t5) {
            const e7 = t5.key, r7 = t5.value, n6 = t5.valueSpec || {}, i6 = t5.objectElementValidators || {}, s5 = t5.style, a4 = t5.styleSpec, o7 = t5.validateSpec;
            let l5 = [];
            const u4 = Tn(r7);
            if ("object" !== u4) return [new Mt(e7, r7, `object expected, ${u4} found`)];
            for (const t6 in r7) {
              const u5 = t6.split(".")[0], c5 = n6[u5] || n6["*"];
              let h4;
              if (i6[u5]) h4 = i6[u5];
              else if (n6[u5]) h4 = o7;
              else if (i6["*"]) h4 = i6["*"];
              else {
                if (!n6["*"]) {
                  l5.push(new Mt(e7, r7[t6], `unknown property "${t6}"`));
                  continue;
                }
                h4 = o7;
              }
              l5 = l5.concat(h4({ key: (e7 ? `${e7}.` : e7) + t6, value: r7[t6], valueSpec: c5, style: s5, styleSpec: a4, object: r7, objectKey: t6, validateSpec: o7 }, r7));
            }
            for (const t6 in n6) i6[t6] || n6[t6].required && void 0 === n6[t6].default && void 0 === r7[t6] && l5.push(new Mt(e7, r7, `missing required property "${t6}"`));
            return l5;
          }
          function fi(t5) {
            const e7 = t5.value, r7 = t5.valueSpec, n6 = t5.style, i6 = t5.styleSpec, s5 = t5.key, a4 = t5.arrayElementValidator || t5.validateSpec;
            if ("array" !== Tn(e7)) return [new Mt(s5, e7, `array expected, ${Tn(e7)} found`)];
            if (r7.length && e7.length !== r7.length) return [new Mt(s5, e7, `array length ${r7.length} expected, length ${e7.length} found`)];
            if (r7["min-length"] && e7.length < r7["min-length"]) return [new Mt(s5, e7, `array length at least ${r7["min-length"]} expected, length ${e7.length} found`)];
            let o7 = { type: r7.value, values: r7.values };
            i6.$version < 7 && (o7.function = r7.function), "object" === Tn(r7.value) && (o7 = r7.value);
            let l5 = [];
            for (let r8 = 0; r8 < e7.length; r8++) l5 = l5.concat(a4({ array: e7, arrayIndex: r8, value: e7[r8], valueSpec: o7, validateSpec: t5.validateSpec, style: n6, styleSpec: i6, key: `${s5}[${r8}]` }));
            return l5;
          }
          function di(t5) {
            const e7 = t5.key, r7 = t5.value, n6 = t5.valueSpec;
            let i6 = Tn(r7);
            return "number" === i6 && r7 != r7 && (i6 = "NaN"), "number" !== i6 ? [new Mt(e7, r7, `number expected, ${i6} found`)] : "minimum" in n6 && r7 < n6.minimum ? [new Mt(e7, r7, `${r7} is less than the minimum value ${n6.minimum}`)] : "maximum" in n6 && r7 > n6.maximum ? [new Mt(e7, r7, `${r7} is greater than the maximum value ${n6.maximum}`)] : [];
          }
          function yi(t5) {
            const e7 = t5.valueSpec, r7 = ci(t5.value.type);
            let n6, i6, s5, a4 = {};
            const o7 = "categorical" !== r7 && void 0 === t5.value.property, l5 = !o7, u4 = "array" === Tn(t5.value.stops) && "array" === Tn(t5.value.stops[0]) && "object" === Tn(t5.value.stops[0][0]), c5 = pi({ key: t5.key, value: t5.value, valueSpec: t5.styleSpec.function, validateSpec: t5.validateSpec, style: t5.style, styleSpec: t5.styleSpec, objectElementValidators: { stops: function(t6) {
              if ("identity" === r7) return [new Mt(t6.key, t6.value, 'identity function may not have a "stops" property')];
              let e8 = [];
              const n7 = t6.value;
              return e8 = e8.concat(fi({ key: t6.key, value: n7, valueSpec: t6.valueSpec, validateSpec: t6.validateSpec, style: t6.style, styleSpec: t6.styleSpec, arrayElementValidator: h4 })), "array" === Tn(n7) && 0 === n7.length && e8.push(new Mt(t6.key, n7, "array must have at least one stop")), e8;
            }, default: function(t6) {
              return t6.validateSpec({ key: t6.key, value: t6.value, valueSpec: e7, validateSpec: t6.validateSpec, style: t6.style, styleSpec: t6.styleSpec });
            } } });
            return "identity" === r7 && o7 && c5.push(new Mt(t5.key, t5.value, 'missing required property "property"')), "identity" === r7 || t5.value.stops || c5.push(new Mt(t5.key, t5.value, 'missing required property "stops"')), "exponential" === r7 && t5.valueSpec.expression && !En(t5.valueSpec) && c5.push(new Mt(t5.key, t5.value, "exponential functions not supported")), t5.styleSpec.$version >= 8 && (l5 && !Bn(t5.valueSpec) ? c5.push(new Mt(t5.key, t5.value, "property functions not supported")) : o7 && !Vn(t5.valueSpec) && c5.push(new Mt(t5.key, t5.value, "zoom functions not supported"))), "categorical" !== r7 && !u4 || void 0 !== t5.value.property || c5.push(new Mt(t5.key, t5.value, '"property" property is required')), c5;
            function h4(t6) {
              let r8 = [];
              const n7 = t6.value, o8 = t6.key;
              if ("array" !== Tn(n7)) return [new Mt(o8, n7, `array expected, ${Tn(n7)} found`)];
              if (2 !== n7.length) return [new Mt(o8, n7, `array length 2 expected, length ${n7.length} found`)];
              if (u4) {
                if ("object" !== Tn(n7[0])) return [new Mt(o8, n7, `object expected, ${Tn(n7[0])} found`)];
                if (void 0 === n7[0].zoom) return [new Mt(o8, n7, "object stop key must have zoom")];
                if (void 0 === n7[0].value) return [new Mt(o8, n7, "object stop key must have value")];
                if (s5 && s5 > ci(n7[0].zoom)) return [new Mt(o8, n7[0].zoom, "stop zoom values must appear in ascending order")];
                ci(n7[0].zoom) !== s5 && (s5 = ci(n7[0].zoom), i6 = void 0, a4 = {}), r8 = r8.concat(pi({ key: `${o8}[0]`, value: n7[0], valueSpec: { zoom: {} }, validateSpec: t6.validateSpec, style: t6.style, styleSpec: t6.styleSpec, objectElementValidators: { zoom: di, value: p4 } }));
              } else r8 = r8.concat(p4({ key: `${o8}[0]`, value: n7[0], validateSpec: t6.validateSpec, style: t6.style, styleSpec: t6.styleSpec }, n7));
              return qn(hi(n7[1])) ? r8.concat([new Mt(`${o8}[1]`, n7[1], "expressions are not allowed in function stops.")]) : r8.concat(t6.validateSpec({ key: `${o8}[1]`, value: n7[1], valueSpec: e7, validateSpec: t6.validateSpec, style: t6.style, styleSpec: t6.styleSpec }));
            }
            function p4(t6, s6) {
              const o8 = Tn(t6.value), l6 = ci(t6.value), u5 = null !== t6.value ? t6.value : s6;
              if (n6) {
                if (o8 !== n6) return [new Mt(t6.key, u5, `${o8} stop domain type must match previous stop domain type ${n6}`)];
              } else n6 = o8;
              if ("number" !== o8 && "string" !== o8 && "boolean" !== o8) return [new Mt(t6.key, u5, "stop domain value must be a number, string, or boolean")];
              if ("number" !== o8 && "categorical" !== r7) {
                let n7 = `number expected, ${o8} found`;
                return Bn(e7) && void 0 === r7 && (n7 += '\nIf you intended to use a categorical function, specify `"type": "categorical"`.'), [new Mt(t6.key, u5, n7)];
              }
              return "categorical" !== r7 || "number" !== o8 || isFinite(l6) && Math.floor(l6) === l6 ? "categorical" !== r7 && "number" === o8 && void 0 !== i6 && l6 < i6 ? [new Mt(t6.key, u5, "stop domain values must appear in ascending order")] : (i6 = l6, "categorical" === r7 && l6 in a4 ? [new Mt(t6.key, u5, "stop domain values must be unique")] : (a4[l6] = true, [])) : [new Mt(t6.key, u5, `integer expected, found ${l6}`)];
            }
          }
          function mi(t5) {
            const e7 = ("property" === t5.expressionContext ? Xn : Gn)(hi(t5.value), t5.valueSpec);
            if ("error" === e7.result) return e7.value.map((e8) => new Mt(`${t5.key}${e8.key}`, t5.value, e8.message));
            const r7 = e7.value.expression || e7.value._styleExpression.expression;
            if ("property" === t5.expressionContext && "text-font" === t5.propertyKey && !r7.outputDefined()) return [new Mt(t5.key, t5.value, `Invalid data expression for "${t5.propertyKey}". Output values must be contained as literals within the expression.`)];
            if ("property" === t5.expressionContext && "layout" === t5.propertyType && !In(r7)) return [new Mt(t5.key, t5.value, '"feature-state" data expressions are not supported with layout properties.')];
            if ("filter" === t5.expressionContext && !In(r7)) return [new Mt(t5.key, t5.value, '"feature-state" data expressions are not supported with filters.')];
            if (t5.expressionContext && 0 === t5.expressionContext.indexOf("cluster")) {
              if (!zn(r7, ["zoom", "feature-state"])) return [new Mt(t5.key, t5.value, '"zoom" and "feature-state" expressions are not supported with cluster properties.')];
              if ("cluster-initial" === t5.expressionContext && !Mn(r7)) return [new Mt(t5.key, t5.value, "Feature data expressions are not supported with initial expression part of cluster properties.")];
            }
            return [];
          }
          function gi(t5) {
            const e7 = t5.key, r7 = t5.value, n6 = t5.valueSpec, i6 = [];
            return Array.isArray(n6.values) ? -1 === n6.values.indexOf(ci(r7)) && i6.push(new Mt(e7, r7, `expected one of [${n6.values.join(", ")}], ${JSON.stringify(r7)} found`)) : -1 === Object.keys(n6.values).indexOf(ci(r7)) && i6.push(new Mt(e7, r7, `expected one of [${Object.keys(n6.values).join(", ")}], ${JSON.stringify(r7)} found`)), i6;
          }
          function xi(t5) {
            return Jn(hi(t5.value)) ? mi(It({}, t5, { expressionContext: "filter", valueSpec: { value: "boolean" } })) : vi(t5);
          }
          function vi(t5) {
            const e7 = t5.value, r7 = t5.key;
            if ("array" !== Tn(e7)) return [new Mt(r7, e7, `array expected, ${Tn(e7)} found`)];
            const n6 = t5.styleSpec;
            let i6, s5 = [];
            if (e7.length < 1) return [new Mt(r7, e7, "filter array must have at least 1 element")];
            switch (s5 = s5.concat(gi({ key: `${r7}[0]`, value: e7[0], valueSpec: n6.filter_operator, style: t5.style, styleSpec: t5.styleSpec })), ci(e7[0])) {
              case "<":
              case "<=":
              case ">":
              case ">=":
                e7.length >= 2 && "$type" === ci(e7[1]) && s5.push(new Mt(r7, e7, `"$type" cannot be use with operator "${e7[0]}"`));
              case "==":
              case "!=":
                3 !== e7.length && s5.push(new Mt(r7, e7, `filter array for operator "${e7[0]}" must have 3 elements`));
              case "in":
              case "!in":
                e7.length >= 2 && (i6 = Tn(e7[1]), "string" !== i6 && s5.push(new Mt(`${r7}[1]`, e7[1], `string expected, ${i6} found`)));
                for (let a4 = 2; a4 < e7.length; a4++) i6 = Tn(e7[a4]), "$type" === ci(e7[1]) ? s5 = s5.concat(gi({ key: `${r7}[${a4}]`, value: e7[a4], valueSpec: n6.geometry_type, style: t5.style, styleSpec: t5.styleSpec })) : "string" !== i6 && "number" !== i6 && "boolean" !== i6 && s5.push(new Mt(`${r7}[${a4}]`, e7[a4], `string, number, or boolean expected, ${i6} found`));
                break;
              case "any":
              case "all":
              case "none":
                for (let n7 = 1; n7 < e7.length; n7++) s5 = s5.concat(vi({ key: `${r7}[${n7}]`, value: e7[n7], style: t5.style, styleSpec: t5.styleSpec }));
                break;
              case "has":
              case "!has":
                i6 = Tn(e7[1]), 2 !== e7.length ? s5.push(new Mt(r7, e7, `filter array for "${e7[0]}" operator must have 2 elements`)) : "string" !== i6 && s5.push(new Mt(`${r7}[1]`, e7[1], `string expected, ${i6} found`));
            }
            return s5;
          }
          function bi(t5, e7) {
            const r7 = t5.key, n6 = t5.validateSpec, i6 = t5.style, s5 = t5.styleSpec, a4 = t5.value, o7 = t5.objectKey, l5 = s5[`${e7}_${t5.layerType}`];
            if (!l5) return [];
            const u4 = o7.match(/^(.*)-transition$/);
            if ("paint" === e7 && u4 && l5[u4[1]] && l5[u4[1]].transition) return n6({ key: r7, value: a4, valueSpec: s5.transition, style: i6, styleSpec: s5 });
            const c5 = t5.valueSpec || l5[o7];
            if (!c5) return [new Mt(r7, a4, `unknown property "${o7}"`)];
            let h4;
            if ("string" === Tn(a4) && Bn(c5) && !c5.tokens && (h4 = /^{([^}]+)}$/.exec(a4))) return [new Mt(r7, a4, `"${o7}" does not support interpolation syntax
Use an identity property function instead: \`{ "type": "identity", "property": ${JSON.stringify(h4[1])} }\`.`)];
            const p4 = [];
            return "symbol" === t5.layerType && ("text-field" === o7 && i6 && !i6.glyphs && p4.push(new Mt(r7, a4, 'use of "text-field" requires a style "glyphs" property')), "text-font" === o7 && Fn(hi(a4)) && "identity" === ci(a4.type) && p4.push(new Mt(r7, a4, '"text-font" does not support identity functions'))), p4.concat(n6({ key: t5.key, value: a4, valueSpec: c5, style: i6, styleSpec: s5, expressionContext: "property", propertyType: e7, propertyKey: o7 }));
          }
          function wi(t5) {
            return bi(t5, "paint");
          }
          function _i(t5) {
            return bi(t5, "layout");
          }
          function Si(t5) {
            let e7 = [];
            const r7 = t5.value, n6 = t5.key, i6 = t5.style, s5 = t5.styleSpec;
            r7.type || r7.ref || e7.push(new Mt(n6, r7, 'either "type" or "ref" is required'));
            let a4 = ci(r7.type);
            const o7 = ci(r7.ref);
            if (r7.id) {
              const s6 = ci(r7.id);
              for (let a5 = 0; a5 < t5.arrayIndex; a5++) {
                const t6 = i6.layers[a5];
                ci(t6.id) === s6 && e7.push(new Mt(n6, r7.id, `duplicate layer id "${r7.id}", previously used at line ${t6.id.__line__}`));
              }
            }
            if ("ref" in r7) {
              let t6;
              ["type", "source", "source-layer", "filter", "layout"].forEach((t7) => {
                t7 in r7 && e7.push(new Mt(n6, r7[t7], `"${t7}" is prohibited for ref layers`));
              }), i6.layers.forEach((e8) => {
                ci(e8.id) === o7 && (t6 = e8);
              }), t6 ? t6.ref ? e7.push(new Mt(n6, r7.ref, "ref cannot reference another ref layer")) : a4 = ci(t6.type) : e7.push(new Mt(n6, r7.ref, `ref layer "${o7}" not found`));
            } else if ("background" !== a4) if (r7.source) {
              const t6 = i6.sources && i6.sources[r7.source], s6 = t6 && ci(t6.type);
              t6 ? "vector" === s6 && "raster" === a4 ? e7.push(new Mt(n6, r7.source, `layer "${r7.id}" requires a raster source`)) : "raster-dem" !== s6 && "hillshade" === a4 ? e7.push(new Mt(n6, r7.source, `layer "${r7.id}" requires a raster-dem source`)) : "raster" === s6 && "raster" !== a4 ? e7.push(new Mt(n6, r7.source, `layer "${r7.id}" requires a vector source`)) : "vector" !== s6 || r7["source-layer"] ? "raster-dem" === s6 && "hillshade" !== a4 ? e7.push(new Mt(n6, r7.source, "raster-dem source can only be used with layer type 'hillshade'.")) : "line" !== a4 || !r7.paint || !r7.paint["line-gradient"] || "geojson" === s6 && t6.lineMetrics || e7.push(new Mt(n6, r7, `layer "${r7.id}" specifies a line-gradient, which requires a GeoJSON source with \`lineMetrics\` enabled.`)) : e7.push(new Mt(n6, r7, `layer "${r7.id}" must specify a "source-layer"`)) : e7.push(new Mt(n6, r7.source, `source "${r7.source}" not found`));
            } else e7.push(new Mt(n6, r7, 'missing required property "source"'));
            return e7 = e7.concat(pi({ key: n6, value: r7, valueSpec: s5.layer, style: t5.style, styleSpec: t5.styleSpec, validateSpec: t5.validateSpec, objectElementValidators: { "*": () => [], type: () => t5.validateSpec({ key: `${n6}.type`, value: r7.type, valueSpec: s5.layer.type, style: t5.style, styleSpec: t5.styleSpec, validateSpec: t5.validateSpec, object: r7, objectKey: "type" }), filter: xi, layout: (t6) => pi({ layer: r7, key: t6.key, value: t6.value, style: t6.style, styleSpec: t6.styleSpec, validateSpec: t6.validateSpec, objectElementValidators: { "*": (t7) => _i(It({ layerType: a4 }, t7)) } }), paint: (t6) => pi({ layer: r7, key: t6.key, value: t6.value, style: t6.style, styleSpec: t6.styleSpec, validateSpec: t6.validateSpec, objectElementValidators: { "*": (t7) => wi(It({ layerType: a4 }, t7)) } }) } })), e7;
          }
          function Ai(t5) {
            const e7 = t5.value, r7 = t5.key, n6 = Tn(e7);
            return "string" !== n6 ? [new Mt(r7, e7, `string expected, ${n6} found`)] : [];
          }
          const ki = { promoteId: function({ key: t5, value: e7 }) {
            if ("string" === Tn(e7)) return Ai({ key: t5, value: e7 });
            {
              const r7 = [];
              for (const n6 in e7) r7.push(...Ai({ key: `${t5}.${n6}`, value: e7[n6] }));
              return r7;
            }
          } };
          function Mi(t5) {
            const e7 = t5.value, r7 = t5.key, n6 = t5.styleSpec, i6 = t5.style, s5 = t5.validateSpec;
            if (!e7.type) return [new Mt(r7, e7, '"type" is required')];
            const a4 = ci(e7.type);
            let o7;
            switch (a4) {
              case "vector":
              case "raster":
                return o7 = pi({ key: r7, value: e7, valueSpec: n6[`source_${a4.replace("-", "_")}`], style: t5.style, styleSpec: n6, objectElementValidators: ki, validateSpec: s5 }), o7;
              case "raster-dem":
                return o7 = function(t6) {
                  var e8;
                  const r8 = null !== (e8 = t6.sourceName) && void 0 !== e8 ? e8 : "", n7 = t6.value, i7 = t6.styleSpec, s6 = i7.source_raster_dem, a5 = t6.style;
                  let o8 = [];
                  const l5 = Tn(n7);
                  if (void 0 === n7) return o8;
                  if ("object" !== l5) return o8.push(new Mt("source_raster_dem", n7, `object expected, ${l5} found`)), o8;
                  const u4 = "custom" === ci(n7.encoding), c5 = ["redFactor", "greenFactor", "blueFactor", "baseShift"], h4 = t6.value.encoding ? `"${t6.value.encoding}"` : "Default";
                  for (const e9 in n7) !u4 && c5.includes(e9) ? o8.push(new Mt(e9, n7[e9], `In "${r8}": "${e9}" is only valid when "encoding" is set to "custom". ${h4} encoding found`)) : s6[e9] ? o8 = o8.concat(t6.validateSpec({ key: e9, value: n7[e9], valueSpec: s6[e9], validateSpec: t6.validateSpec, style: a5, styleSpec: i7 })) : o8.push(new Mt(e9, n7[e9], `unknown property "${e9}"`));
                  return o8;
                }({ sourceName: r7, value: e7, style: t5.style, styleSpec: n6, validateSpec: s5 }), o7;
              case "geojson":
                if (o7 = pi({ key: r7, value: e7, valueSpec: n6.source_geojson, style: i6, styleSpec: n6, validateSpec: s5, objectElementValidators: ki }), e7.cluster) for (const t6 in e7.clusterProperties) {
                  const [n7, i7] = e7.clusterProperties[t6], s6 = "string" == typeof n7 ? [n7, ["accumulated"], ["get", t6]] : n7;
                  o7.push(...mi({ key: `${r7}.${t6}.map`, value: i7, expressionContext: "cluster-map" })), o7.push(...mi({ key: `${r7}.${t6}.reduce`, value: s6, expressionContext: "cluster-reduce" }));
                }
                return o7;
              case "video":
                return pi({ key: r7, value: e7, valueSpec: n6.source_video, style: i6, validateSpec: s5, styleSpec: n6 });
              case "image":
                return pi({ key: r7, value: e7, valueSpec: n6.source_image, style: i6, validateSpec: s5, styleSpec: n6 });
              case "canvas":
                return [new Mt(r7, null, "Please use runtime APIs to add canvas sources, rather than including them in stylesheets.", "source.canvas")];
              default:
                return gi({ key: `${r7}.type`, value: e7.type, valueSpec: { values: ["vector", "raster", "raster-dem", "geojson", "video", "image"] } });
            }
          }
          function Ii(t5) {
            const e7 = t5.value, r7 = t5.styleSpec, n6 = r7.light, i6 = t5.style;
            let s5 = [];
            const a4 = Tn(e7);
            if (void 0 === e7) return s5;
            if ("object" !== a4) return s5 = s5.concat([new Mt("light", e7, `object expected, ${a4} found`)]), s5;
            for (const a5 in e7) {
              const o7 = a5.match(/^(.*)-transition$/);
              s5 = s5.concat(o7 && n6[o7[1]] && n6[o7[1]].transition ? t5.validateSpec({ key: a5, value: e7[a5], valueSpec: r7.transition, validateSpec: t5.validateSpec, style: i6, styleSpec: r7 }) : n6[a5] ? t5.validateSpec({ key: a5, value: e7[a5], valueSpec: n6[a5], validateSpec: t5.validateSpec, style: i6, styleSpec: r7 }) : [new Mt(a5, e7[a5], `unknown property "${a5}"`)]);
            }
            return s5;
          }
          function zi(t5) {
            const e7 = t5.value, r7 = t5.styleSpec, n6 = r7.sky, i6 = t5.style, s5 = Tn(e7);
            if (void 0 === e7) return [];
            if ("object" !== s5) return [new Mt("sky", e7, `object expected, ${s5} found`)];
            let a4 = [];
            for (const s6 in e7) a4 = a4.concat(n6[s6] ? t5.validateSpec({ key: s6, value: e7[s6], valueSpec: n6[s6], style: i6, styleSpec: r7 }) : [new Mt(s6, e7[s6], `unknown property "${s6}"`)]);
            return a4;
          }
          function Pi(t5) {
            const e7 = t5.value, r7 = t5.styleSpec, n6 = r7.terrain, i6 = t5.style;
            let s5 = [];
            const a4 = Tn(e7);
            if (void 0 === e7) return s5;
            if ("object" !== a4) return s5 = s5.concat([new Mt("terrain", e7, `object expected, ${a4} found`)]), s5;
            for (const a5 in e7) s5 = s5.concat(n6[a5] ? t5.validateSpec({ key: a5, value: e7[a5], valueSpec: n6[a5], validateSpec: t5.validateSpec, style: i6, styleSpec: r7 }) : [new Mt(a5, e7[a5], `unknown property "${a5}"`)]);
            return s5;
          }
          function Ci(t5) {
            let e7 = [];
            const r7 = t5.value, n6 = t5.key;
            if (Array.isArray(r7)) {
              const i6 = [], s5 = [];
              for (const a4 in r7) r7[a4].id && i6.includes(r7[a4].id) && e7.push(new Mt(n6, r7, `all the sprites' ids must be unique, but ${r7[a4].id} is duplicated`)), i6.push(r7[a4].id), r7[a4].url && s5.includes(r7[a4].url) && e7.push(new Mt(n6, r7, `all the sprites' URLs must be unique, but ${r7[a4].url} is duplicated`)), s5.push(r7[a4].url), e7 = e7.concat(pi({ key: `${n6}[${a4}]`, value: r7[a4], valueSpec: { id: { type: "string", required: true }, url: { type: "string", required: true } }, validateSpec: t5.validateSpec }));
              return e7;
            }
            return Ai({ key: n6, value: r7 });
          }
          const Bi = { "*": () => [], array: fi, boolean: function(t5) {
            const e7 = t5.value, r7 = t5.key, n6 = Tn(e7);
            return "boolean" !== n6 ? [new Mt(r7, e7, `boolean expected, ${n6} found`)] : [];
          }, number: di, color: function(t5) {
            const e7 = t5.key, r7 = t5.value, n6 = Tn(r7);
            return "string" !== n6 ? [new Mt(e7, r7, `color expected, ${n6} found`)] : xe.parse(String(r7)) ? [] : [new Mt(e7, r7, `color expected, "${r7}" found`)];
          }, constants: ui, enum: gi, filter: xi, function: yi, layer: Si, object: pi, source: Mi, light: Ii, sky: zi, terrain: Pi, projection: function(t5) {
            const e7 = t5.value, r7 = t5.styleSpec, n6 = r7.projection, i6 = t5.style, s5 = Tn(e7);
            if (void 0 === e7) return [];
            if ("object" !== s5) return [new Mt("projection", e7, `object expected, ${s5} found`)];
            let a4 = [];
            for (const s6 in e7) a4 = a4.concat(n6[s6] ? t5.validateSpec({ key: s6, value: e7[s6], valueSpec: n6[s6], style: i6, styleSpec: r7 }) : [new Mt(s6, e7[s6], `unknown property "${s6}"`)]);
            return a4;
          }, projectionDefinition: function(t5) {
            const e7 = t5.key;
            let r7 = t5.value;
            r7 = r7 instanceof String ? r7.valueOf() : r7;
            const n6 = Tn(r7);
            return "array" !== n6 || function(t6) {
              return Array.isArray(t6) && 3 === t6.length && "string" == typeof t6[0] && "string" == typeof t6[1] && "number" == typeof t6[2];
            }(r7) || function(t6) {
              return !!["interpolate", "step", "literal"].includes(t6[0]);
            }(r7) ? ["array", "string"].includes(n6) ? [] : [new Mt(e7, r7, `projection expected, invalid type "${n6}" found`)] : [new Mt(e7, r7, `projection expected, invalid array ${JSON.stringify(r7)} found`)];
          }, string: Ai, formatted: function(t5) {
            return 0 === Ai(t5).length ? [] : mi(t5);
          }, resolvedImage: function(t5) {
            return 0 === Ai(t5).length ? [] : mi(t5);
          }, padding: function(t5) {
            const e7 = t5.key, r7 = t5.value;
            if ("array" === Tn(r7)) {
              if (r7.length < 1 || r7.length > 4) return [new Mt(e7, r7, `padding requires 1 to 4 values; ${r7.length} values found`)];
              const n6 = { type: "number" };
              let i6 = [];
              for (let s5 = 0; s5 < r7.length; s5++) i6 = i6.concat(t5.validateSpec({ key: `${e7}[${s5}]`, value: r7[s5], validateSpec: t5.validateSpec, valueSpec: n6 }));
              return i6;
            }
            return di({ key: e7, value: r7, valueSpec: {} });
          }, variableAnchorOffsetCollection: function(t5) {
            const e7 = t5.key, r7 = t5.value, n6 = Tn(r7), i6 = t5.styleSpec;
            if ("array" !== n6 || r7.length < 1 || r7.length % 2 != 0) return [new Mt(e7, r7, "variableAnchorOffsetCollection requires a non-empty array of even length")];
            let s5 = [];
            for (let n7 = 0; n7 < r7.length; n7 += 2) s5 = s5.concat(gi({ key: `${e7}[${n7}]`, value: r7[n7], valueSpec: i6.layout_symbol["text-anchor"] })), s5 = s5.concat(fi({ key: `${e7}[${n7 + 1}]`, value: r7[n7 + 1], valueSpec: { length: 2, value: "number" }, validateSpec: t5.validateSpec, style: t5.style, styleSpec: i6 }));
            return s5;
          }, sprite: Ci };
          function Vi(t5) {
            const e7 = t5.value, r7 = t5.valueSpec, n6 = t5.styleSpec;
            return t5.validateSpec = Vi, r7.expression && Fn(ci(e7)) ? yi(t5) : r7.expression && qn(hi(e7)) ? mi(t5) : r7.type && Bi[r7.type] ? Bi[r7.type](t5) : pi(It({}, t5, { valueSpec: r7.type ? n6[r7.type] : r7 }));
          }
          function Ei(t5) {
            const e7 = t5.value, r7 = t5.key, n6 = Ai(t5);
            return n6.length || (-1 === e7.indexOf("{fontstack}") && n6.push(new Mt(r7, e7, '"glyphs" url must include a "{fontstack}" token')), -1 === e7.indexOf("{range}") && n6.push(new Mt(r7, e7, '"glyphs" url must include a "{range}" token'))), n6;
          }
          function Ti(t5, e7 = dt) {
            let r7 = [];
            return r7 = r7.concat(Vi({ key: "", value: t5, valueSpec: e7.$root, styleSpec: e7, style: t5, validateSpec: Vi, objectElementValidators: { glyphs: Ei, "*": () => [] } })), t5.constants && (r7 = r7.concat(ui({ key: "constants", value: t5.constants }))), $i(r7);
          }
          function Fi(t5) {
            return function(e7) {
              return t5({ ...e7, validateSpec: Vi });
            };
          }
          function $i(t5) {
            return [].concat(t5).sort((t6, e7) => t6.line - e7.line);
          }
          function Li(t5) {
            return function(...e7) {
              return $i(t5.apply(this, e7));
            };
          }
          Ti.source = Li(Fi(Mi)), Ti.sprite = Li(Fi(Ci)), Ti.glyphs = Li(Fi(Ei)), Ti.light = Li(Fi(Ii)), Ti.sky = Li(Fi(zi)), Ti.terrain = Li(Fi(Pi)), Ti.layer = Li(Fi(Si)), Ti.filter = Li(Fi(xi)), Ti.paintProperty = Li(Fi(wi)), Ti.layoutProperty = Li(Fi(_i));
          const Oi = Ti, Di = Oi.light, Ri = Oi.sky, ji = Oi.paintProperty, Ni = Oi.layoutProperty;
          function Ui(t5, e7) {
            let r7 = false;
            if (e7 && e7.length) for (const n6 of e7) t5.fire(new pt(new Error(n6.message))), r7 = true;
            return r7;
          }
          class qi {
            constructor(t5, e7, r7) {
              const n6 = this.cells = [];
              if (t5 instanceof ArrayBuffer) {
                this.arrayBuffer = t5;
                const i7 = new Int32Array(this.arrayBuffer);
                t5 = i7[0], this.d = (e7 = i7[1]) + 2 * (r7 = i7[2]);
                for (let t6 = 0; t6 < this.d * this.d; t6++) {
                  const e8 = i7[3 + t6], r8 = i7[3 + t6 + 1];
                  n6.push(e8 === r8 ? null : i7.subarray(e8, r8));
                }
                const s5 = i7[3 + n6.length + 1];
                this.keys = i7.subarray(i7[3 + n6.length], s5), this.bboxes = i7.subarray(s5), this.insert = this._insertReadonly;
              } else {
                this.d = e7 + 2 * r7;
                for (let t6 = 0; t6 < this.d * this.d; t6++) n6.push([]);
                this.keys = [], this.bboxes = [];
              }
              this.n = e7, this.extent = t5, this.padding = r7, this.scale = e7 / t5, this.uid = 0;
              const i6 = r7 / e7 * t5;
              this.min = -i6, this.max = t5 + i6;
            }
            insert(t5, e7, r7, n6, i6) {
              this._forEachCell(e7, r7, n6, i6, this._insertCell, this.uid++, void 0, void 0), this.keys.push(t5), this.bboxes.push(e7), this.bboxes.push(r7), this.bboxes.push(n6), this.bboxes.push(i6);
            }
            _insertReadonly() {
              throw new Error("Cannot insert into a GridIndex created from an ArrayBuffer.");
            }
            _insertCell(t5, e7, r7, n6, i6, s5) {
              this.cells[i6].push(s5);
            }
            query(t5, e7, r7, n6, i6) {
              const s5 = this.min, a4 = this.max;
              if (t5 <= s5 && e7 <= s5 && a4 <= r7 && a4 <= n6 && !i6) return Array.prototype.slice.call(this.keys);
              {
                const s6 = [];
                return this._forEachCell(t5, e7, r7, n6, this._queryCell, s6, {}, i6), s6;
              }
            }
            _queryCell(t5, e7, r7, n6, i6, s5, a4, o7) {
              const l5 = this.cells[i6];
              if (null !== l5) {
                const i7 = this.keys, u4 = this.bboxes;
                for (let c5 = 0; c5 < l5.length; c5++) {
                  const h4 = l5[c5];
                  if (void 0 === a4[h4]) {
                    const l6 = 4 * h4;
                    (o7 ? o7(u4[l6 + 0], u4[l6 + 1], u4[l6 + 2], u4[l6 + 3]) : t5 <= u4[l6 + 2] && e7 <= u4[l6 + 3] && r7 >= u4[l6 + 0] && n6 >= u4[l6 + 1]) ? (a4[h4] = true, s5.push(i7[h4])) : a4[h4] = false;
                  }
                }
              }
            }
            _forEachCell(t5, e7, r7, n6, i6, s5, a4, o7) {
              const l5 = this._convertToCellCoord(t5), u4 = this._convertToCellCoord(e7), c5 = this._convertToCellCoord(r7), h4 = this._convertToCellCoord(n6);
              for (let p4 = l5; p4 <= c5; p4++) for (let l6 = u4; l6 <= h4; l6++) {
                const u5 = this.d * l6 + p4;
                if ((!o7 || o7(this._convertFromCellCoord(p4), this._convertFromCellCoord(l6), this._convertFromCellCoord(p4 + 1), this._convertFromCellCoord(l6 + 1))) && i6.call(this, t5, e7, r7, n6, u5, s5, a4, o7)) return;
              }
            }
            _convertFromCellCoord(t5) {
              return (t5 - this.padding) / this.scale;
            }
            _convertToCellCoord(t5) {
              return Math.max(0, Math.min(this.d - 1, Math.floor(t5 * this.scale) + this.padding));
            }
            toArrayBuffer() {
              if (this.arrayBuffer) return this.arrayBuffer;
              const t5 = this.cells, e7 = 3 + this.cells.length + 1 + 1;
              let r7 = 0;
              for (let t6 = 0; t6 < this.cells.length; t6++) r7 += this.cells[t6].length;
              const n6 = new Int32Array(e7 + r7 + this.keys.length + this.bboxes.length);
              n6[0] = this.extent, n6[1] = this.n, n6[2] = this.padding;
              let i6 = e7;
              for (let e8 = 0; e8 < t5.length; e8++) {
                const r8 = t5[e8];
                n6[3 + e8] = i6, n6.set(r8, i6), i6 += r8.length;
              }
              return n6[3 + t5.length] = i6, n6.set(this.keys, i6), i6 += this.keys.length, n6[3 + t5.length + 1] = i6, n6.set(this.bboxes, i6), i6 += this.bboxes.length, n6.buffer;
            }
            static serialize(t5, e7) {
              const r7 = t5.toArrayBuffer();
              return e7 && e7.push(r7), { buffer: r7 };
            }
            static deserialize(t5) {
              return new qi(t5.buffer);
            }
          }
          const Gi = {};
          function Zi(t5, e7, r7 = {}) {
            if (Gi[t5]) throw new Error(`${t5} is already registered.`);
            Object.defineProperty(e7, "_classRegistryKey", { value: t5, writeable: false }), Gi[t5] = { klass: e7, omit: r7.omit || [], shallow: r7.shallow || [] };
          }
          Zi("Object", Object), Zi("TransferableGridIndex", qi), Zi("Color", xe), Zi("Error", Error), Zi("AJAXError", st), Zi("ResolvedImage", Ie), Zi("StylePropertyFunction", Hn), Zi("StyleExpression", Un, { omit: ["_evaluator"] }), Zi("ZoomDependentExpression", Kn), Zi("ZoomConstantExpression", Zn), Zi("CompoundExpression", bn, { omit: ["_evaluate"] });
          for (const t5 in vn) vn[t5]._classRegistryKey || Zi(`Expression_${t5}`, vn[t5]);
          function Ki(t5) {
            return t5 && "undefined" != typeof ArrayBuffer && (t5 instanceof ArrayBuffer || t5.constructor && "ArrayBuffer" === t5.constructor.name);
          }
          function Xi(t5) {
            return t5.$name || t5.constructor._classRegistryKey;
          }
          function Hi(t5) {
            return !function(t6) {
              if (null === t6 || "object" != typeof t6) return false;
              const e7 = Xi(t6);
              return !(!e7 || "Object" === e7);
            }(t5) && (null == t5 || "boolean" == typeof t5 || "number" == typeof t5 || "string" == typeof t5 || t5 instanceof Boolean || t5 instanceof Number || t5 instanceof String || t5 instanceof Date || t5 instanceof RegExp || t5 instanceof Blob || t5 instanceof Error || Ki(t5) || G2(t5) || ArrayBuffer.isView(t5) || t5 instanceof ImageData);
          }
          function Yi(t5, e7) {
            if (Hi(t5)) return (Ki(t5) || G2(t5)) && e7 && e7.push(t5), ArrayBuffer.isView(t5) && e7 && e7.push(t5.buffer), t5 instanceof ImageData && e7 && e7.push(t5.data.buffer), t5;
            if (Array.isArray(t5)) {
              const r8 = [];
              for (const n7 of t5) r8.push(Yi(n7, e7));
              return r8;
            }
            if ("object" != typeof t5) throw new Error("can't serialize object of type " + typeof t5);
            const r7 = Xi(t5);
            if (!r7) throw new Error(`can't serialize object of unregistered class ${t5.constructor.name}`);
            if (!Gi[r7]) throw new Error(`${r7} is not registered.`);
            const { klass: n6 } = Gi[r7], i6 = n6.serialize ? n6.serialize(t5, e7) : {};
            if (n6.serialize) {
              if (e7 && i6 === e7[e7.length - 1]) throw new Error("statically serialized object won't survive transfer of $name property");
            } else {
              for (const n7 in t5) {
                if (!t5.hasOwnProperty(n7)) continue;
                if (Gi[r7].omit.indexOf(n7) >= 0) continue;
                const s5 = t5[n7];
                i6[n7] = Gi[r7].shallow.indexOf(n7) >= 0 ? s5 : Yi(s5, e7);
              }
              t5 instanceof Error && (i6.message = t5.message);
            }
            if (i6.$name) throw new Error("$name property is reserved for worker serialization logic.");
            return "Object" !== r7 && (i6.$name = r7), i6;
          }
          function Ji(t5) {
            if (Hi(t5)) return t5;
            if (Array.isArray(t5)) return t5.map(Ji);
            if ("object" != typeof t5) throw new Error("can't deserialize object of type " + typeof t5);
            const e7 = Xi(t5) || "Object";
            if (!Gi[e7]) throw new Error(`can't deserialize unregistered class ${e7}`);
            const { klass: r7 } = Gi[e7];
            if (!r7) throw new Error(`can't deserialize unregistered class ${e7}`);
            if (r7.deserialize) return r7.deserialize(t5);
            const n6 = Object.create(r7.prototype);
            for (const r8 of Object.keys(t5)) {
              if ("$name" === r8) continue;
              const i6 = t5[r8];
              n6[r8] = Gi[e7].shallow.indexOf(r8) >= 0 ? i6 : Ji(i6);
            }
            return n6;
          }
          class Wi {
            constructor() {
              this.first = true;
            }
            update(t5, e7) {
              const r7 = Math.floor(t5);
              return this.first ? (this.first = false, this.lastIntegerZoom = r7, this.lastIntegerZoomTime = 0, this.lastZoom = t5, this.lastFloorZoom = r7, true) : (this.lastFloorZoom > r7 ? (this.lastIntegerZoom = r7 + 1, this.lastIntegerZoomTime = e7) : this.lastFloorZoom < r7 && (this.lastIntegerZoom = r7, this.lastIntegerZoomTime = e7), t5 !== this.lastZoom && (this.lastZoom = t5, this.lastFloorZoom = r7, true));
            }
          }
          const Qi = { "Latin-1 Supplement": (t5) => t5 >= 128 && t5 <= 255, "Hangul Jamo": (t5) => t5 >= 4352 && t5 <= 4607, Khmer: (t5) => t5 >= 6016 && t5 <= 6143, "General Punctuation": (t5) => t5 >= 8192 && t5 <= 8303, "Letterlike Symbols": (t5) => t5 >= 8448 && t5 <= 8527, "Number Forms": (t5) => t5 >= 8528 && t5 <= 8591, "Miscellaneous Technical": (t5) => t5 >= 8960 && t5 <= 9215, "Control Pictures": (t5) => t5 >= 9216 && t5 <= 9279, "Optical Character Recognition": (t5) => t5 >= 9280 && t5 <= 9311, "Enclosed Alphanumerics": (t5) => t5 >= 9312 && t5 <= 9471, "Geometric Shapes": (t5) => t5 >= 9632 && t5 <= 9727, "Miscellaneous Symbols": (t5) => t5 >= 9728 && t5 <= 9983, "Miscellaneous Symbols and Arrows": (t5) => t5 >= 11008 && t5 <= 11263, "Ideographic Description Characters": (t5) => t5 >= 12272 && t5 <= 12287, "CJK Symbols and Punctuation": (t5) => t5 >= 12288 && t5 <= 12351, Hiragana: (t5) => t5 >= 12352 && t5 <= 12447, Katakana: (t5) => t5 >= 12448 && t5 <= 12543, Kanbun: (t5) => t5 >= 12688 && t5 <= 12703, "CJK Strokes": (t5) => t5 >= 12736 && t5 <= 12783, "Enclosed CJK Letters and Months": (t5) => t5 >= 12800 && t5 <= 13055, "CJK Compatibility": (t5) => t5 >= 13056 && t5 <= 13311, "Yijing Hexagram Symbols": (t5) => t5 >= 19904 && t5 <= 19967, "CJK Unified Ideographs": (t5) => t5 >= 19968 && t5 <= 40959, "Hangul Syllables": (t5) => t5 >= 44032 && t5 <= 55215, "Private Use Area": (t5) => t5 >= 57344 && t5 <= 63743, "Vertical Forms": (t5) => t5 >= 65040 && t5 <= 65055, "CJK Compatibility Forms": (t5) => t5 >= 65072 && t5 <= 65103, "Small Form Variants": (t5) => t5 >= 65104 && t5 <= 65135, "Halfwidth and Fullwidth Forms": (t5) => t5 >= 65280 && t5 <= 65519 };
          function ts(t5) {
            for (const e7 of t5) if (as(e7.charCodeAt(0))) return true;
            return false;
          }
          function es(t5) {
            for (const e7 of t5) if (!is(e7.charCodeAt(0))) return false;
            return true;
          }
          function rs(t5) {
            const e7 = t5.map((t6) => {
              try {
                return new RegExp(`\\p{sc=${t6}}`, "u").source;
              } catch (t7) {
                return null;
              }
            }).filter((t6) => t6);
            return new RegExp(e7.join("|"), "u");
          }
          const ns = rs(["Arab", "Dupl", "Mong", "Ougr", "Syrc"]);
          function is(t5) {
            return !ns.test(String.fromCodePoint(t5));
          }
          const ss = rs(["Bopo", "Hani", "Hira", "Kana", "Kits", "Nshu", "Tang", "Yiii"]);
          function as(t5) {
            return !(746 !== t5 && 747 !== t5 && (t5 < 4352 || !(Qi["CJK Compatibility Forms"](t5) && !(t5 >= 65097 && t5 <= 65103) || Qi["CJK Compatibility"](t5) || Qi["CJK Strokes"](t5) || !(!Qi["CJK Symbols and Punctuation"](t5) || t5 >= 12296 && t5 <= 12305 || t5 >= 12308 && t5 <= 12319 || 12336 === t5) || Qi["Enclosed CJK Letters and Months"](t5) || Qi["Ideographic Description Characters"](t5) || Qi.Kanbun(t5) || Qi.Katakana(t5) && 12540 !== t5 || !(!Qi["Halfwidth and Fullwidth Forms"](t5) || 65288 === t5 || 65289 === t5 || 65293 === t5 || t5 >= 65306 && t5 <= 65310 || 65339 === t5 || 65341 === t5 || 65343 === t5 || t5 >= 65371 && t5 <= 65503 || 65507 === t5 || t5 >= 65512 && t5 <= 65519) || !(!Qi["Small Form Variants"](t5) || t5 >= 65112 && t5 <= 65118 || t5 >= 65123 && t5 <= 65126) || Qi["Vertical Forms"](t5) || Qi["Yijing Hexagram Symbols"](t5) || /\p{sc=Cans}/u.test(String.fromCodePoint(t5)) || /\p{sc=Hang}/u.test(String.fromCodePoint(t5)) || ss.test(String.fromCodePoint(t5)))));
          }
          function os(t5) {
            return !(as(t5) || function(t6) {
              return !!(Qi["Latin-1 Supplement"](t6) && (167 === t6 || 169 === t6 || 174 === t6 || 177 === t6 || 188 === t6 || 189 === t6 || 190 === t6 || 215 === t6 || 247 === t6) || Qi["General Punctuation"](t6) && (8214 === t6 || 8224 === t6 || 8225 === t6 || 8240 === t6 || 8241 === t6 || 8251 === t6 || 8252 === t6 || 8258 === t6 || 8263 === t6 || 8264 === t6 || 8265 === t6 || 8273 === t6) || Qi["Letterlike Symbols"](t6) || Qi["Number Forms"](t6) || Qi["Miscellaneous Technical"](t6) && (t6 >= 8960 && t6 <= 8967 || t6 >= 8972 && t6 <= 8991 || t6 >= 8996 && t6 <= 9e3 || 9003 === t6 || t6 >= 9085 && t6 <= 9114 || t6 >= 9150 && t6 <= 9165 || 9167 === t6 || t6 >= 9169 && t6 <= 9179 || t6 >= 9186 && t6 <= 9215) || Qi["Control Pictures"](t6) && 9251 !== t6 || Qi["Optical Character Recognition"](t6) || Qi["Enclosed Alphanumerics"](t6) || Qi["Geometric Shapes"](t6) || Qi["Miscellaneous Symbols"](t6) && !(t6 >= 9754 && t6 <= 9759) || Qi["Miscellaneous Symbols and Arrows"](t6) && (t6 >= 11026 && t6 <= 11055 || t6 >= 11088 && t6 <= 11097 || t6 >= 11192 && t6 <= 11243) || Qi["CJK Symbols and Punctuation"](t6) || Qi.Katakana(t6) || Qi["Private Use Area"](t6) || Qi["CJK Compatibility Forms"](t6) || Qi["Small Form Variants"](t6) || Qi["Halfwidth and Fullwidth Forms"](t6) || 8734 === t6 || 8756 === t6 || 8757 === t6 || t6 >= 9984 && t6 <= 10087 || t6 >= 10102 && t6 <= 10131 || 65532 === t6 || 65533 === t6);
            }(t5));
          }
          const ls = rs(["Adlm", "Arab", "Armi", "Avst", "Chrs", "Cprt", "Egyp", "Elym", "Gara", "Hatr", "Hebr", "Hung", "Khar", "Lydi", "Mand", "Mani", "Mend", "Merc", "Mero", "Narb", "Nbat", "Nkoo", "Orkh", "Palm", "Phli", "Phlp", "Phnx", "Prti", "Rohg", "Samr", "Sarb", "Sogo", "Syrc", "Thaa", "Todr", "Yezi"]);
          function us(t5) {
            return ls.test(String.fromCodePoint(t5));
          }
          function cs(t5, e7) {
            return !(!e7 && us(t5) || t5 >= 2304 && t5 <= 3583 || t5 >= 3840 && t5 <= 4255 || Qi.Khmer(t5));
          }
          function hs(t5) {
            for (const e7 of t5) if (us(e7.charCodeAt(0))) return true;
            return false;
          }
          const ps = new class {
            constructor() {
              this.TIMEOUT = 5e3, this.applyArabicShaping = null, this.processBidirectionalText = null, this.processStyledBidirectionalText = null, this.pluginStatus = "unavailable", this.pluginURL = null, this.loadScriptResolve = () => {
              };
            }
            setState(t5) {
              this.pluginStatus = t5.pluginStatus, this.pluginURL = t5.pluginURL;
            }
            getState() {
              return { pluginStatus: this.pluginStatus, pluginURL: this.pluginURL };
            }
            setMethods(t5) {
              if (ps.isParsed()) throw new Error("RTL text plugin already registered.");
              this.applyArabicShaping = t5.applyArabicShaping, this.processBidirectionalText = t5.processBidirectionalText, this.processStyledBidirectionalText = t5.processStyledBidirectionalText, this.loadScriptResolve();
            }
            isParsed() {
              return null != this.applyArabicShaping && null != this.processBidirectionalText && null != this.processStyledBidirectionalText;
            }
            getRTLTextPluginStatus() {
              return this.pluginStatus;
            }
            syncState(t5, r7) {
              return e6(this, void 0, void 0, function* () {
                if (this.isParsed()) return this.getState();
                if ("loading" !== t5.pluginStatus) return this.setState(t5), t5;
                const e7 = t5.pluginURL, n6 = new Promise((t6) => {
                  this.loadScriptResolve = t6;
                });
                r7(e7);
                const i6 = new Promise((t6) => setTimeout(() => t6(), this.TIMEOUT));
                if (yield Promise.race([n6, i6]), this.isParsed()) {
                  const t6 = { pluginStatus: "loaded", pluginURL: e7 };
                  return this.setState(t6), t6;
                }
                throw this.setState({ pluginStatus: "error", pluginURL: "" }), new Error(`RTL Text Plugin failed to import scripts from ${e7}`);
              });
            }
          }();
          class fs {
            constructor(t5, e7) {
              this.zoom = t5, e7 ? (this.now = e7.now, this.fadeDuration = e7.fadeDuration, this.zoomHistory = e7.zoomHistory, this.transition = e7.transition) : (this.now = 0, this.fadeDuration = 0, this.zoomHistory = new Wi(), this.transition = {});
            }
            isSupportedScript(t5) {
              return function(t6, e7) {
                for (const r7 of t6) if (!cs(r7.charCodeAt(0), e7)) return false;
                return true;
              }(t5, "loaded" === ps.getRTLTextPluginStatus());
            }
            crossFadingFactor() {
              return 0 === this.fadeDuration ? 1 : Math.min((this.now - this.zoomHistory.lastIntegerZoomTime) / this.fadeDuration, 1);
            }
            getCrossfadeParameters() {
              const t5 = this.zoom, e7 = t5 - Math.floor(t5), r7 = this.crossFadingFactor();
              return t5 > this.zoomHistory.lastIntegerZoom ? { fromScale: 2, toScale: 1, t: e7 + (1 - e7) * r7 } : { fromScale: 0.5, toScale: 1, t: 1 - (1 - r7) * e7 };
            }
          }
          class ds {
            constructor(t5, e7) {
              this.property = t5, this.value = e7, this.expression = function(t6, e8) {
                if (Fn(t6)) return new Hn(t6, e8);
                if (qn(t6)) {
                  const r7 = Xn(t6, e8);
                  if ("error" === r7.result) throw new Error(r7.value.map((t7) => `${t7.key}: ${t7.message}`).join(", "));
                  return r7.value;
                }
                {
                  let r7 = t6;
                  return "color" === e8.type && "string" == typeof t6 ? r7 = xe.parse(t6) : "padding" !== e8.type || "number" != typeof t6 && !Array.isArray(t6) ? "variableAnchorOffsetCollection" === e8.type && Array.isArray(t6) ? r7 = Me.parse(t6) : "projectionDefinition" === e8.type && "string" == typeof t6 && (r7 = ze.parse(t6)) : r7 = Se.parse(t6), { kind: "constant", evaluate: () => r7 };
                }
              }(void 0 === e7 ? t5.specification.default : e7, t5.specification);
            }
            isDataDriven() {
              return "source" === this.expression.kind || "composite" === this.expression.kind;
            }
            possiblyEvaluate(t5, e7, r7) {
              return this.property.possiblyEvaluate(this, t5, e7, r7);
            }
          }
          class ys {
            constructor(t5) {
              this.property = t5, this.value = new ds(t5, void 0);
            }
            transitioned(t5, e7) {
              return new gs(this.property, this.value, e7, F2({}, t5.transition, this.transition), t5.now);
            }
            untransitioned() {
              return new gs(this.property, this.value, null, {}, 0);
            }
          }
          class ms {
            constructor(t5) {
              this._properties = t5, this._values = Object.create(t5.defaultTransitionablePropertyValues);
            }
            getValue(t5) {
              return D2(this._values[t5].value.value);
            }
            setValue(t5, e7) {
              Object.prototype.hasOwnProperty.call(this._values, t5) || (this._values[t5] = new ys(this._values[t5].property)), this._values[t5].value = new ds(this._values[t5].property, null === e7 ? void 0 : D2(e7));
            }
            getTransition(t5) {
              return D2(this._values[t5].transition);
            }
            setTransition(t5, e7) {
              Object.prototype.hasOwnProperty.call(this._values, t5) || (this._values[t5] = new ys(this._values[t5].property)), this._values[t5].transition = D2(e7) || void 0;
            }
            serialize() {
              const t5 = {};
              for (const e7 of Object.keys(this._values)) {
                const r7 = this.getValue(e7);
                void 0 !== r7 && (t5[e7] = r7);
                const n6 = this.getTransition(e7);
                void 0 !== n6 && (t5[`${e7}-transition`] = n6);
              }
              return t5;
            }
            transitioned(t5, e7) {
              const r7 = new xs(this._properties);
              for (const n6 of Object.keys(this._values)) r7._values[n6] = this._values[n6].transitioned(t5, e7._values[n6]);
              return r7;
            }
            untransitioned() {
              const t5 = new xs(this._properties);
              for (const e7 of Object.keys(this._values)) t5._values[e7] = this._values[e7].untransitioned();
              return t5;
            }
          }
          class gs {
            constructor(t5, e7, r7, n6, i6) {
              this.property = t5, this.value = e7, this.begin = i6 + n6.delay || 0, this.end = this.begin + n6.duration || 0, t5.specification.transition && (n6.delay || n6.duration) && (this.prior = r7);
            }
            possiblyEvaluate(t5, e7, r7) {
              const n6 = t5.now || 0, i6 = this.value.possiblyEvaluate(t5, e7, r7), s5 = this.prior;
              if (s5) {
                if (n6 > this.end) return this.prior = null, i6;
                if (this.value.isDataDriven()) return this.prior = null, i6;
                if (n6 < this.begin) return s5.possiblyEvaluate(t5, e7, r7);
                {
                  const a4 = (n6 - this.begin) / (this.end - this.begin);
                  return this.property.interpolate(s5.possiblyEvaluate(t5, e7, r7), i6, C3(a4));
                }
              }
              return i6;
            }
          }
          class xs {
            constructor(t5) {
              this._properties = t5, this._values = Object.create(t5.defaultTransitioningPropertyValues);
            }
            possiblyEvaluate(t5, e7, r7) {
              const n6 = new ws(this._properties);
              for (const i6 of Object.keys(this._values)) n6._values[i6] = this._values[i6].possiblyEvaluate(t5, e7, r7);
              return n6;
            }
            hasTransition() {
              for (const t5 of Object.keys(this._values)) if (this._values[t5].prior) return true;
              return false;
            }
          }
          class vs {
            constructor(t5) {
              this._properties = t5, this._values = Object.create(t5.defaultPropertyValues);
            }
            hasValue(t5) {
              return void 0 !== this._values[t5].value;
            }
            getValue(t5) {
              return D2(this._values[t5].value);
            }
            setValue(t5, e7) {
              this._values[t5] = new ds(this._values[t5].property, null === e7 ? void 0 : D2(e7));
            }
            serialize() {
              const t5 = {};
              for (const e7 of Object.keys(this._values)) {
                const r7 = this.getValue(e7);
                void 0 !== r7 && (t5[e7] = r7);
              }
              return t5;
            }
            possiblyEvaluate(t5, e7, r7) {
              const n6 = new ws(this._properties);
              for (const i6 of Object.keys(this._values)) n6._values[i6] = this._values[i6].possiblyEvaluate(t5, e7, r7);
              return n6;
            }
          }
          class bs {
            constructor(t5, e7, r7) {
              this.property = t5, this.value = e7, this.parameters = r7;
            }
            isConstant() {
              return "constant" === this.value.kind;
            }
            constantOr(t5) {
              return "constant" === this.value.kind ? this.value.value : t5;
            }
            evaluate(t5, e7, r7, n6) {
              return this.property.evaluate(this.value, this.parameters, t5, e7, r7, n6);
            }
          }
          class ws {
            constructor(t5) {
              this._properties = t5, this._values = Object.create(t5.defaultPossiblyEvaluatedValues);
            }
            get(t5) {
              return this._values[t5];
            }
          }
          class _s {
            constructor(t5) {
              this.specification = t5;
            }
            possiblyEvaluate(t5, e7) {
              if (t5.isDataDriven()) throw new Error("Value should not be data driven");
              return t5.expression.evaluate(e7);
            }
            interpolate(t5, e7, r7) {
              const n6 = ir[this.specification.type];
              return n6 ? n6(t5, e7, r7) : t5;
            }
          }
          class Ss {
            constructor(t5, e7) {
              this.specification = t5, this.overrides = e7;
            }
            possiblyEvaluate(t5, e7, r7, n6) {
              return new bs(this, "constant" === t5.expression.kind || "camera" === t5.expression.kind ? { kind: "constant", value: t5.expression.evaluate(e7, null, {}, r7, n6) } : t5.expression, e7);
            }
            interpolate(t5, e7, r7) {
              if ("constant" !== t5.value.kind || "constant" !== e7.value.kind) return t5;
              if (void 0 === t5.value.value || void 0 === e7.value.value) return new bs(this, { kind: "constant", value: void 0 }, t5.parameters);
              const n6 = ir[this.specification.type];
              if (n6) {
                const i6 = n6(t5.value.value, e7.value.value, r7);
                return new bs(this, { kind: "constant", value: i6 }, t5.parameters);
              }
              return t5;
            }
            evaluate(t5, e7, r7, n6, i6, s5) {
              return "constant" === t5.kind ? t5.value : t5.evaluate(e7, r7, n6, i6, s5);
            }
          }
          class As extends Ss {
            possiblyEvaluate(t5, e7, r7, n6) {
              if (void 0 === t5.value) return new bs(this, { kind: "constant", value: void 0 }, e7);
              if ("constant" === t5.expression.kind) {
                const i6 = t5.expression.evaluate(e7, null, {}, r7, n6), s5 = "resolvedImage" === t5.property.specification.type && "string" != typeof i6 ? i6.name : i6, a4 = this._calculate(s5, s5, s5, e7);
                return new bs(this, { kind: "constant", value: a4 }, e7);
              }
              if ("camera" === t5.expression.kind) {
                const r8 = this._calculate(t5.expression.evaluate({ zoom: e7.zoom - 1 }), t5.expression.evaluate({ zoom: e7.zoom }), t5.expression.evaluate({ zoom: e7.zoom + 1 }), e7);
                return new bs(this, { kind: "constant", value: r8 }, e7);
              }
              return new bs(this, t5.expression, e7);
            }
            evaluate(t5, e7, r7, n6, i6, s5) {
              if ("source" === t5.kind) {
                const a4 = t5.evaluate(e7, r7, n6, i6, s5);
                return this._calculate(a4, a4, a4, e7);
              }
              return "composite" === t5.kind ? this._calculate(t5.evaluate({ zoom: Math.floor(e7.zoom) - 1 }, r7, n6), t5.evaluate({ zoom: Math.floor(e7.zoom) }, r7, n6), t5.evaluate({ zoom: Math.floor(e7.zoom) + 1 }, r7, n6), e7) : t5.value;
            }
            _calculate(t5, e7, r7, n6) {
              return n6.zoom > n6.zoomHistory.lastIntegerZoom ? { from: t5, to: e7 } : { from: r7, to: e7 };
            }
            interpolate(t5) {
              return t5;
            }
          }
          class ks {
            constructor(t5) {
              this.specification = t5;
            }
            possiblyEvaluate(t5, e7, r7, n6) {
              if (void 0 !== t5.value) {
                if ("constant" === t5.expression.kind) {
                  const i6 = t5.expression.evaluate(e7, null, {}, r7, n6);
                  return this._calculate(i6, i6, i6, e7);
                }
                return this._calculate(t5.expression.evaluate(new fs(Math.floor(e7.zoom - 1), e7)), t5.expression.evaluate(new fs(Math.floor(e7.zoom), e7)), t5.expression.evaluate(new fs(Math.floor(e7.zoom + 1), e7)), e7);
              }
            }
            _calculate(t5, e7, r7, n6) {
              return n6.zoom > n6.zoomHistory.lastIntegerZoom ? { from: t5, to: e7 } : { from: r7, to: e7 };
            }
            interpolate(t5) {
              return t5;
            }
          }
          class Ms {
            constructor(t5) {
              this.specification = t5;
            }
            possiblyEvaluate(t5, e7, r7, n6) {
              return !!t5.expression.evaluate(e7, null, {}, r7, n6);
            }
            interpolate() {
              return false;
            }
          }
          class Is {
            constructor(t5) {
              this.properties = t5, this.defaultPropertyValues = {}, this.defaultTransitionablePropertyValues = {}, this.defaultTransitioningPropertyValues = {}, this.defaultPossiblyEvaluatedValues = {}, this.overridableProperties = [];
              for (const e7 in t5) {
                const r7 = t5[e7];
                r7.specification.overridable && this.overridableProperties.push(e7);
                const n6 = this.defaultPropertyValues[e7] = new ds(r7, void 0), i6 = this.defaultTransitionablePropertyValues[e7] = new ys(r7);
                this.defaultTransitioningPropertyValues[e7] = i6.untransitioned(), this.defaultPossiblyEvaluatedValues[e7] = n6.possiblyEvaluate({});
              }
            }
          }
          Zi("DataDrivenProperty", Ss), Zi("DataConstantProperty", _s), Zi("CrossFadedDataDrivenProperty", As), Zi("CrossFadedProperty", ks), Zi("ColorRampProperty", Ms);
          const zs = "-transition";
          class Ps extends ft {
            constructor(t5, e7) {
              if (super(), this.id = t5.id, this.type = t5.type, this._featureFilter = { filter: () => true, needGeometry: false }, "custom" !== t5.type && (this.metadata = t5.metadata, this.minzoom = t5.minzoom, this.maxzoom = t5.maxzoom, "background" !== t5.type && (this.source = t5.source, this.sourceLayer = t5["source-layer"], this.filter = t5.filter), e7.layout && (this._unevaluatedLayout = new vs(e7.layout)), e7.paint)) {
                this._transitionablePaint = new ms(e7.paint);
                for (const e8 in t5.paint) this.setPaintProperty(e8, t5.paint[e8], { validate: false });
                for (const e8 in t5.layout) this.setLayoutProperty(e8, t5.layout[e8], { validate: false });
                this._transitioningPaint = this._transitionablePaint.untransitioned(), this.paint = new ws(e7.paint);
              }
            }
            getCrossfadeParameters() {
              return this._crossfadeParameters;
            }
            getLayoutProperty(t5) {
              return "visibility" === t5 ? this.visibility : this._unevaluatedLayout.getValue(t5);
            }
            setLayoutProperty(t5, e7, r7 = {}) {
              null != e7 && this._validate(Ni, `layers.${this.id}.layout.${t5}`, t5, e7, r7) || ("visibility" !== t5 ? this._unevaluatedLayout.setValue(t5, e7) : this.visibility = e7);
            }
            getPaintProperty(t5) {
              return t5.endsWith(zs) ? this._transitionablePaint.getTransition(t5.slice(0, -11)) : this._transitionablePaint.getValue(t5);
            }
            setPaintProperty(t5, e7, r7 = {}) {
              if (null != e7 && this._validate(ji, `layers.${this.id}.paint.${t5}`, t5, e7, r7)) return false;
              if (t5.endsWith(zs)) return this._transitionablePaint.setTransition(t5.slice(0, -11), e7 || void 0), false;
              {
                const r8 = this._transitionablePaint._values[t5], n6 = "cross-faded-data-driven" === r8.property.specification["property-type"], i6 = r8.value.isDataDriven(), s5 = r8.value;
                this._transitionablePaint.setValue(t5, e7), this._handleSpecialPaintPropertyUpdate(t5);
                const a4 = this._transitionablePaint._values[t5].value;
                return a4.isDataDriven() || i6 || n6 || this._handleOverridablePaintPropertyUpdate(t5, s5, a4);
              }
            }
            _handleSpecialPaintPropertyUpdate(t5) {
            }
            _handleOverridablePaintPropertyUpdate(t5, e7, r7) {
              return false;
            }
            isHidden(t5) {
              return !!(this.minzoom && t5 < this.minzoom) || !!(this.maxzoom && t5 >= this.maxzoom) || "none" === this.visibility;
            }
            updateTransitions(t5) {
              this._transitioningPaint = this._transitionablePaint.transitioned(t5, this._transitioningPaint);
            }
            hasTransition() {
              return this._transitioningPaint.hasTransition();
            }
            recalculate(t5, e7) {
              t5.getCrossfadeParameters && (this._crossfadeParameters = t5.getCrossfadeParameters()), this._unevaluatedLayout && (this.layout = this._unevaluatedLayout.possiblyEvaluate(t5, void 0, e7)), this.paint = this._transitioningPaint.possiblyEvaluate(t5, void 0, e7);
            }
            serialize() {
              const t5 = { id: this.id, type: this.type, source: this.source, "source-layer": this.sourceLayer, metadata: this.metadata, minzoom: this.minzoom, maxzoom: this.maxzoom, filter: this.filter, layout: this._unevaluatedLayout && this._unevaluatedLayout.serialize(), paint: this._transitionablePaint && this._transitionablePaint.serialize() };
              return this.visibility && (t5.layout = t5.layout || {}, t5.layout.visibility = this.visibility), O2(t5, (t6, e7) => !(void 0 === t6 || "layout" === e7 && !Object.keys(t6).length || "paint" === e7 && !Object.keys(t6).length));
            }
            _validate(t5, e7, r7, n6, i6 = {}) {
              return (!i6 || false !== i6.validate) && Ui(this, t5.call(Oi, { key: e7, layerType: this.type, objectKey: r7, value: n6, styleSpec: dt, style: { glyphs: true, sprite: true } }));
            }
            is3D() {
              return false;
            }
            isTileClipped() {
              return false;
            }
            hasOffscreenPass() {
              return false;
            }
            resize() {
            }
            isStateDependent() {
              for (const t5 in this.paint._values) {
                const e7 = this.paint.get(t5);
                if (e7 instanceof bs && Bn(e7.property.specification) && ("source" === e7.value.kind || "composite" === e7.value.kind) && e7.value.isStateDependent) return true;
              }
              return false;
            }
          }
          const Cs = { Int8: Int8Array, Uint8: Uint8Array, Int16: Int16Array, Uint16: Uint16Array, Int32: Int32Array, Uint32: Uint32Array, Float32: Float32Array };
          class Bs {
            constructor(t5, e7) {
              this._structArray = t5, this._pos1 = e7 * this.size, this._pos2 = this._pos1 / 2, this._pos4 = this._pos1 / 4, this._pos8 = this._pos1 / 8;
            }
          }
          class Vs {
            constructor() {
              this.isTransferred = false, this.capacity = -1, this.resize(0);
            }
            static serialize(t5, e7) {
              return t5._trim(), e7 && (t5.isTransferred = true, e7.push(t5.arrayBuffer)), { length: t5.length, arrayBuffer: t5.arrayBuffer };
            }
            static deserialize(t5) {
              const e7 = Object.create(this.prototype);
              return e7.arrayBuffer = t5.arrayBuffer, e7.length = t5.length, e7.capacity = t5.arrayBuffer.byteLength / e7.bytesPerElement, e7._refreshViews(), e7;
            }
            _trim() {
              this.length !== this.capacity && (this.capacity = this.length, this.arrayBuffer = this.arrayBuffer.slice(0, this.length * this.bytesPerElement), this._refreshViews());
            }
            clear() {
              this.length = 0;
            }
            resize(t5) {
              this.reserve(t5), this.length = t5;
            }
            reserve(t5) {
              if (t5 > this.capacity) {
                this.capacity = Math.max(t5, Math.floor(5 * this.capacity), 128), this.arrayBuffer = new ArrayBuffer(this.capacity * this.bytesPerElement);
                const e7 = this.uint8;
                this._refreshViews(), e7 && this.uint8.set(e7);
              }
            }
            _refreshViews() {
              throw new Error("_refreshViews() must be implemented by each concrete StructArray layout");
            }
          }
          function Es(t5, e7 = 1) {
            let r7 = 0, n6 = 0;
            return { members: t5.map((t6) => {
              const i6 = Cs[t6.type].BYTES_PER_ELEMENT, s5 = r7 = Ts(r7, Math.max(e7, i6)), a4 = t6.components || 1;
              return n6 = Math.max(n6, i6), r7 += i6 * a4, { name: t6.name, type: t6.type, components: a4, offset: s5 };
            }), size: Ts(r7, Math.max(n6, e7)), alignment: e7 };
          }
          function Ts(t5, e7) {
            return Math.ceil(t5 / e7) * e7;
          }
          class Fs extends Vs {
            _refreshViews() {
              this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
            }
            emplaceBack(t5, e7) {
              const r7 = this.length;
              return this.resize(r7 + 1), this.emplace(r7, t5, e7);
            }
            emplace(t5, e7, r7) {
              const n6 = 2 * t5;
              return this.int16[n6 + 0] = e7, this.int16[n6 + 1] = r7, t5;
            }
          }
          Fs.prototype.bytesPerElement = 4, Zi("StructArrayLayout2i4", Fs);
          class $s extends Vs {
            _refreshViews() {
              this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
            }
            emplaceBack(t5, e7, r7) {
              const n6 = this.length;
              return this.resize(n6 + 1), this.emplace(n6, t5, e7, r7);
            }
            emplace(t5, e7, r7, n6) {
              const i6 = 3 * t5;
              return this.int16[i6 + 0] = e7, this.int16[i6 + 1] = r7, this.int16[i6 + 2] = n6, t5;
            }
          }
          $s.prototype.bytesPerElement = 6, Zi("StructArrayLayout3i6", $s);
          class Ls extends Vs {
            _refreshViews() {
              this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
            }
            emplaceBack(t5, e7, r7, n6) {
              const i6 = this.length;
              return this.resize(i6 + 1), this.emplace(i6, t5, e7, r7, n6);
            }
            emplace(t5, e7, r7, n6, i6) {
              const s5 = 4 * t5;
              return this.int16[s5 + 0] = e7, this.int16[s5 + 1] = r7, this.int16[s5 + 2] = n6, this.int16[s5 + 3] = i6, t5;
            }
          }
          Ls.prototype.bytesPerElement = 8, Zi("StructArrayLayout4i8", Ls);
          class Os extends Vs {
            _refreshViews() {
              this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
            }
            emplaceBack(t5, e7, r7, n6, i6, s5) {
              const a4 = this.length;
              return this.resize(a4 + 1), this.emplace(a4, t5, e7, r7, n6, i6, s5);
            }
            emplace(t5, e7, r7, n6, i6, s5, a4) {
              const o7 = 6 * t5;
              return this.int16[o7 + 0] = e7, this.int16[o7 + 1] = r7, this.int16[o7 + 2] = n6, this.int16[o7 + 3] = i6, this.int16[o7 + 4] = s5, this.int16[o7 + 5] = a4, t5;
            }
          }
          Os.prototype.bytesPerElement = 12, Zi("StructArrayLayout2i4i12", Os);
          class Ds extends Vs {
            _refreshViews() {
              this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
            }
            emplaceBack(t5, e7, r7, n6, i6, s5) {
              const a4 = this.length;
              return this.resize(a4 + 1), this.emplace(a4, t5, e7, r7, n6, i6, s5);
            }
            emplace(t5, e7, r7, n6, i6, s5, a4) {
              const o7 = 4 * t5, l5 = 8 * t5;
              return this.int16[o7 + 0] = e7, this.int16[o7 + 1] = r7, this.uint8[l5 + 4] = n6, this.uint8[l5 + 5] = i6, this.uint8[l5 + 6] = s5, this.uint8[l5 + 7] = a4, t5;
            }
          }
          Ds.prototype.bytesPerElement = 8, Zi("StructArrayLayout2i4ub8", Ds);
          class Rs extends Vs {
            _refreshViews() {
              this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
            }
            emplaceBack(t5, e7) {
              const r7 = this.length;
              return this.resize(r7 + 1), this.emplace(r7, t5, e7);
            }
            emplace(t5, e7, r7) {
              const n6 = 2 * t5;
              return this.float32[n6 + 0] = e7, this.float32[n6 + 1] = r7, t5;
            }
          }
          Rs.prototype.bytesPerElement = 8, Zi("StructArrayLayout2f8", Rs);
          class js extends Vs {
            _refreshViews() {
              this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
            }
            emplaceBack(t5, e7, r7, n6, i6, s5, a4, o7, l5, u4) {
              const c5 = this.length;
              return this.resize(c5 + 1), this.emplace(c5, t5, e7, r7, n6, i6, s5, a4, o7, l5, u4);
            }
            emplace(t5, e7, r7, n6, i6, s5, a4, o7, l5, u4, c5) {
              const h4 = 10 * t5;
              return this.uint16[h4 + 0] = e7, this.uint16[h4 + 1] = r7, this.uint16[h4 + 2] = n6, this.uint16[h4 + 3] = i6, this.uint16[h4 + 4] = s5, this.uint16[h4 + 5] = a4, this.uint16[h4 + 6] = o7, this.uint16[h4 + 7] = l5, this.uint16[h4 + 8] = u4, this.uint16[h4 + 9] = c5, t5;
            }
          }
          js.prototype.bytesPerElement = 20, Zi("StructArrayLayout10ui20", js);
          class Ns extends Vs {
            _refreshViews() {
              this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
            }
            emplaceBack(t5, e7, r7, n6, i6, s5, a4, o7, l5, u4, c5, h4) {
              const p4 = this.length;
              return this.resize(p4 + 1), this.emplace(p4, t5, e7, r7, n6, i6, s5, a4, o7, l5, u4, c5, h4);
            }
            emplace(t5, e7, r7, n6, i6, s5, a4, o7, l5, u4, c5, h4, p4) {
              const f4 = 12 * t5;
              return this.int16[f4 + 0] = e7, this.int16[f4 + 1] = r7, this.int16[f4 + 2] = n6, this.int16[f4 + 3] = i6, this.uint16[f4 + 4] = s5, this.uint16[f4 + 5] = a4, this.uint16[f4 + 6] = o7, this.uint16[f4 + 7] = l5, this.int16[f4 + 8] = u4, this.int16[f4 + 9] = c5, this.int16[f4 + 10] = h4, this.int16[f4 + 11] = p4, t5;
            }
          }
          Ns.prototype.bytesPerElement = 24, Zi("StructArrayLayout4i4ui4i24", Ns);
          class Us extends Vs {
            _refreshViews() {
              this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
            }
            emplaceBack(t5, e7, r7) {
              const n6 = this.length;
              return this.resize(n6 + 1), this.emplace(n6, t5, e7, r7);
            }
            emplace(t5, e7, r7, n6) {
              const i6 = 3 * t5;
              return this.float32[i6 + 0] = e7, this.float32[i6 + 1] = r7, this.float32[i6 + 2] = n6, t5;
            }
          }
          Us.prototype.bytesPerElement = 12, Zi("StructArrayLayout3f12", Us);
          class qs extends Vs {
            _refreshViews() {
              this.uint8 = new Uint8Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer);
            }
            emplaceBack(t5) {
              const e7 = this.length;
              return this.resize(e7 + 1), this.emplace(e7, t5);
            }
            emplace(t5, e7) {
              return this.uint32[1 * t5 + 0] = e7, t5;
            }
          }
          qs.prototype.bytesPerElement = 4, Zi("StructArrayLayout1ul4", qs);
          class Gs extends Vs {
            _refreshViews() {
              this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
            }
            emplaceBack(t5, e7, r7, n6, i6, s5, a4, o7, l5) {
              const u4 = this.length;
              return this.resize(u4 + 1), this.emplace(u4, t5, e7, r7, n6, i6, s5, a4, o7, l5);
            }
            emplace(t5, e7, r7, n6, i6, s5, a4, o7, l5, u4) {
              const c5 = 10 * t5, h4 = 5 * t5;
              return this.int16[c5 + 0] = e7, this.int16[c5 + 1] = r7, this.int16[c5 + 2] = n6, this.int16[c5 + 3] = i6, this.int16[c5 + 4] = s5, this.int16[c5 + 5] = a4, this.uint32[h4 + 3] = o7, this.uint16[c5 + 8] = l5, this.uint16[c5 + 9] = u4, t5;
            }
          }
          Gs.prototype.bytesPerElement = 20, Zi("StructArrayLayout6i1ul2ui20", Gs);
          class Zs extends Vs {
            _refreshViews() {
              this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
            }
            emplaceBack(t5, e7, r7, n6, i6, s5) {
              const a4 = this.length;
              return this.resize(a4 + 1), this.emplace(a4, t5, e7, r7, n6, i6, s5);
            }
            emplace(t5, e7, r7, n6, i6, s5, a4) {
              const o7 = 6 * t5;
              return this.int16[o7 + 0] = e7, this.int16[o7 + 1] = r7, this.int16[o7 + 2] = n6, this.int16[o7 + 3] = i6, this.int16[o7 + 4] = s5, this.int16[o7 + 5] = a4, t5;
            }
          }
          Zs.prototype.bytesPerElement = 12, Zi("StructArrayLayout2i2i2i12", Zs);
          class Ks extends Vs {
            _refreshViews() {
              this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
            }
            emplaceBack(t5, e7, r7, n6, i6) {
              const s5 = this.length;
              return this.resize(s5 + 1), this.emplace(s5, t5, e7, r7, n6, i6);
            }
            emplace(t5, e7, r7, n6, i6, s5) {
              const a4 = 4 * t5, o7 = 8 * t5;
              return this.float32[a4 + 0] = e7, this.float32[a4 + 1] = r7, this.float32[a4 + 2] = n6, this.int16[o7 + 6] = i6, this.int16[o7 + 7] = s5, t5;
            }
          }
          Ks.prototype.bytesPerElement = 16, Zi("StructArrayLayout2f1f2i16", Ks);
          class Xs extends Vs {
            _refreshViews() {
              this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
            }
            emplaceBack(t5, e7, r7, n6, i6, s5) {
              const a4 = this.length;
              return this.resize(a4 + 1), this.emplace(a4, t5, e7, r7, n6, i6, s5);
            }
            emplace(t5, e7, r7, n6, i6, s5, a4) {
              const o7 = 16 * t5, l5 = 4 * t5, u4 = 8 * t5;
              return this.uint8[o7 + 0] = e7, this.uint8[o7 + 1] = r7, this.float32[l5 + 1] = n6, this.float32[l5 + 2] = i6, this.int16[u4 + 6] = s5, this.int16[u4 + 7] = a4, t5;
            }
          }
          Xs.prototype.bytesPerElement = 16, Zi("StructArrayLayout2ub2f2i16", Xs);
          class Hs extends Vs {
            _refreshViews() {
              this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
            }
            emplaceBack(t5, e7, r7) {
              const n6 = this.length;
              return this.resize(n6 + 1), this.emplace(n6, t5, e7, r7);
            }
            emplace(t5, e7, r7, n6) {
              const i6 = 3 * t5;
              return this.uint16[i6 + 0] = e7, this.uint16[i6 + 1] = r7, this.uint16[i6 + 2] = n6, t5;
            }
          }
          Hs.prototype.bytesPerElement = 6, Zi("StructArrayLayout3ui6", Hs);
          class Ys extends Vs {
            _refreshViews() {
              this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
            }
            emplaceBack(t5, e7, r7, n6, i6, s5, a4, o7, l5, u4, c5, h4, p4, f4, d4, y4, m4) {
              const g4 = this.length;
              return this.resize(g4 + 1), this.emplace(g4, t5, e7, r7, n6, i6, s5, a4, o7, l5, u4, c5, h4, p4, f4, d4, y4, m4);
            }
            emplace(t5, e7, r7, n6, i6, s5, a4, o7, l5, u4, c5, h4, p4, f4, d4, y4, m4, g4) {
              const x4 = 24 * t5, v4 = 12 * t5, b5 = 48 * t5;
              return this.int16[x4 + 0] = e7, this.int16[x4 + 1] = r7, this.uint16[x4 + 2] = n6, this.uint16[x4 + 3] = i6, this.uint32[v4 + 2] = s5, this.uint32[v4 + 3] = a4, this.uint32[v4 + 4] = o7, this.uint16[x4 + 10] = l5, this.uint16[x4 + 11] = u4, this.uint16[x4 + 12] = c5, this.float32[v4 + 7] = h4, this.float32[v4 + 8] = p4, this.uint8[b5 + 36] = f4, this.uint8[b5 + 37] = d4, this.uint8[b5 + 38] = y4, this.uint32[v4 + 10] = m4, this.int16[x4 + 22] = g4, t5;
            }
          }
          Ys.prototype.bytesPerElement = 48, Zi("StructArrayLayout2i2ui3ul3ui2f3ub1ul1i48", Ys);
          class Js extends Vs {
            _refreshViews() {
              this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
            }
            emplaceBack(t5, e7, r7, n6, i6, s5, a4, o7, l5, u4, c5, h4, p4, f4, d4, y4, m4, g4, x4, v4, b5, w4, _4, S5, A5, k4, M5, I4) {
              const z4 = this.length;
              return this.resize(z4 + 1), this.emplace(z4, t5, e7, r7, n6, i6, s5, a4, o7, l5, u4, c5, h4, p4, f4, d4, y4, m4, g4, x4, v4, b5, w4, _4, S5, A5, k4, M5, I4);
            }
            emplace(t5, e7, r7, n6, i6, s5, a4, o7, l5, u4, c5, h4, p4, f4, d4, y4, m4, g4, x4, v4, b5, w4, _4, S5, A5, k4, M5, I4, z4) {
              const P4 = 32 * t5, C4 = 16 * t5;
              return this.int16[P4 + 0] = e7, this.int16[P4 + 1] = r7, this.int16[P4 + 2] = n6, this.int16[P4 + 3] = i6, this.int16[P4 + 4] = s5, this.int16[P4 + 5] = a4, this.int16[P4 + 6] = o7, this.int16[P4 + 7] = l5, this.uint16[P4 + 8] = u4, this.uint16[P4 + 9] = c5, this.uint16[P4 + 10] = h4, this.uint16[P4 + 11] = p4, this.uint16[P4 + 12] = f4, this.uint16[P4 + 13] = d4, this.uint16[P4 + 14] = y4, this.uint16[P4 + 15] = m4, this.uint16[P4 + 16] = g4, this.uint16[P4 + 17] = x4, this.uint16[P4 + 18] = v4, this.uint16[P4 + 19] = b5, this.uint16[P4 + 20] = w4, this.uint16[P4 + 21] = _4, this.uint16[P4 + 22] = S5, this.uint32[C4 + 12] = A5, this.float32[C4 + 13] = k4, this.float32[C4 + 14] = M5, this.uint16[P4 + 30] = I4, this.uint16[P4 + 31] = z4, t5;
            }
          }
          Js.prototype.bytesPerElement = 64, Zi("StructArrayLayout8i15ui1ul2f2ui64", Js);
          class Ws extends Vs {
            _refreshViews() {
              this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
            }
            emplaceBack(t5) {
              const e7 = this.length;
              return this.resize(e7 + 1), this.emplace(e7, t5);
            }
            emplace(t5, e7) {
              return this.float32[1 * t5 + 0] = e7, t5;
            }
          }
          Ws.prototype.bytesPerElement = 4, Zi("StructArrayLayout1f4", Ws);
          class Qs extends Vs {
            _refreshViews() {
              this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
            }
            emplaceBack(t5, e7, r7) {
              const n6 = this.length;
              return this.resize(n6 + 1), this.emplace(n6, t5, e7, r7);
            }
            emplace(t5, e7, r7, n6) {
              const i6 = 3 * t5;
              return this.uint16[6 * t5 + 0] = e7, this.float32[i6 + 1] = r7, this.float32[i6 + 2] = n6, t5;
            }
          }
          Qs.prototype.bytesPerElement = 12, Zi("StructArrayLayout1ui2f12", Qs);
          class ta extends Vs {
            _refreshViews() {
              this.uint8 = new Uint8Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
            }
            emplaceBack(t5, e7, r7) {
              const n6 = this.length;
              return this.resize(n6 + 1), this.emplace(n6, t5, e7, r7);
            }
            emplace(t5, e7, r7, n6) {
              const i6 = 4 * t5;
              return this.uint32[2 * t5 + 0] = e7, this.uint16[i6 + 2] = r7, this.uint16[i6 + 3] = n6, t5;
            }
          }
          ta.prototype.bytesPerElement = 8, Zi("StructArrayLayout1ul2ui8", ta);
          class ea extends Vs {
            _refreshViews() {
              this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
            }
            emplaceBack(t5, e7) {
              const r7 = this.length;
              return this.resize(r7 + 1), this.emplace(r7, t5, e7);
            }
            emplace(t5, e7, r7) {
              const n6 = 2 * t5;
              return this.uint16[n6 + 0] = e7, this.uint16[n6 + 1] = r7, t5;
            }
          }
          ea.prototype.bytesPerElement = 4, Zi("StructArrayLayout2ui4", ea);
          class ra extends Vs {
            _refreshViews() {
              this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
            }
            emplaceBack(t5) {
              const e7 = this.length;
              return this.resize(e7 + 1), this.emplace(e7, t5);
            }
            emplace(t5, e7) {
              return this.uint16[1 * t5 + 0] = e7, t5;
            }
          }
          ra.prototype.bytesPerElement = 2, Zi("StructArrayLayout1ui2", ra);
          class na extends Vs {
            _refreshViews() {
              this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
            }
            emplaceBack(t5, e7, r7, n6) {
              const i6 = this.length;
              return this.resize(i6 + 1), this.emplace(i6, t5, e7, r7, n6);
            }
            emplace(t5, e7, r7, n6, i6) {
              const s5 = 4 * t5;
              return this.float32[s5 + 0] = e7, this.float32[s5 + 1] = r7, this.float32[s5 + 2] = n6, this.float32[s5 + 3] = i6, t5;
            }
          }
          na.prototype.bytesPerElement = 16, Zi("StructArrayLayout4f16", na);
          class ia extends Bs {
            get anchorPointX() {
              return this._structArray.int16[this._pos2 + 0];
            }
            get anchorPointY() {
              return this._structArray.int16[this._pos2 + 1];
            }
            get x1() {
              return this._structArray.int16[this._pos2 + 2];
            }
            get y1() {
              return this._structArray.int16[this._pos2 + 3];
            }
            get x2() {
              return this._structArray.int16[this._pos2 + 4];
            }
            get y2() {
              return this._structArray.int16[this._pos2 + 5];
            }
            get featureIndex() {
              return this._structArray.uint32[this._pos4 + 3];
            }
            get sourceLayerIndex() {
              return this._structArray.uint16[this._pos2 + 8];
            }
            get bucketIndex() {
              return this._structArray.uint16[this._pos2 + 9];
            }
            get anchorPoint() {
              return new l4(this.anchorPointX, this.anchorPointY);
            }
          }
          ia.prototype.size = 20;
          class sa extends Gs {
            get(t5) {
              return new ia(this, t5);
            }
          }
          Zi("CollisionBoxArray", sa);
          class aa extends Bs {
            get anchorX() {
              return this._structArray.int16[this._pos2 + 0];
            }
            get anchorY() {
              return this._structArray.int16[this._pos2 + 1];
            }
            get glyphStartIndex() {
              return this._structArray.uint16[this._pos2 + 2];
            }
            get numGlyphs() {
              return this._structArray.uint16[this._pos2 + 3];
            }
            get vertexStartIndex() {
              return this._structArray.uint32[this._pos4 + 2];
            }
            get lineStartIndex() {
              return this._structArray.uint32[this._pos4 + 3];
            }
            get lineLength() {
              return this._structArray.uint32[this._pos4 + 4];
            }
            get segment() {
              return this._structArray.uint16[this._pos2 + 10];
            }
            get lowerSize() {
              return this._structArray.uint16[this._pos2 + 11];
            }
            get upperSize() {
              return this._structArray.uint16[this._pos2 + 12];
            }
            get lineOffsetX() {
              return this._structArray.float32[this._pos4 + 7];
            }
            get lineOffsetY() {
              return this._structArray.float32[this._pos4 + 8];
            }
            get writingMode() {
              return this._structArray.uint8[this._pos1 + 36];
            }
            get placedOrientation() {
              return this._structArray.uint8[this._pos1 + 37];
            }
            set placedOrientation(t5) {
              this._structArray.uint8[this._pos1 + 37] = t5;
            }
            get hidden() {
              return this._structArray.uint8[this._pos1 + 38];
            }
            set hidden(t5) {
              this._structArray.uint8[this._pos1 + 38] = t5;
            }
            get crossTileID() {
              return this._structArray.uint32[this._pos4 + 10];
            }
            set crossTileID(t5) {
              this._structArray.uint32[this._pos4 + 10] = t5;
            }
            get associatedIconIndex() {
              return this._structArray.int16[this._pos2 + 22];
            }
          }
          aa.prototype.size = 48;
          class oa extends Ys {
            get(t5) {
              return new aa(this, t5);
            }
          }
          Zi("PlacedSymbolArray", oa);
          class la extends Bs {
            get anchorX() {
              return this._structArray.int16[this._pos2 + 0];
            }
            get anchorY() {
              return this._structArray.int16[this._pos2 + 1];
            }
            get rightJustifiedTextSymbolIndex() {
              return this._structArray.int16[this._pos2 + 2];
            }
            get centerJustifiedTextSymbolIndex() {
              return this._structArray.int16[this._pos2 + 3];
            }
            get leftJustifiedTextSymbolIndex() {
              return this._structArray.int16[this._pos2 + 4];
            }
            get verticalPlacedTextSymbolIndex() {
              return this._structArray.int16[this._pos2 + 5];
            }
            get placedIconSymbolIndex() {
              return this._structArray.int16[this._pos2 + 6];
            }
            get verticalPlacedIconSymbolIndex() {
              return this._structArray.int16[this._pos2 + 7];
            }
            get key() {
              return this._structArray.uint16[this._pos2 + 8];
            }
            get textBoxStartIndex() {
              return this._structArray.uint16[this._pos2 + 9];
            }
            get textBoxEndIndex() {
              return this._structArray.uint16[this._pos2 + 10];
            }
            get verticalTextBoxStartIndex() {
              return this._structArray.uint16[this._pos2 + 11];
            }
            get verticalTextBoxEndIndex() {
              return this._structArray.uint16[this._pos2 + 12];
            }
            get iconBoxStartIndex() {
              return this._structArray.uint16[this._pos2 + 13];
            }
            get iconBoxEndIndex() {
              return this._structArray.uint16[this._pos2 + 14];
            }
            get verticalIconBoxStartIndex() {
              return this._structArray.uint16[this._pos2 + 15];
            }
            get verticalIconBoxEndIndex() {
              return this._structArray.uint16[this._pos2 + 16];
            }
            get featureIndex() {
              return this._structArray.uint16[this._pos2 + 17];
            }
            get numHorizontalGlyphVertices() {
              return this._structArray.uint16[this._pos2 + 18];
            }
            get numVerticalGlyphVertices() {
              return this._structArray.uint16[this._pos2 + 19];
            }
            get numIconVertices() {
              return this._structArray.uint16[this._pos2 + 20];
            }
            get numVerticalIconVertices() {
              return this._structArray.uint16[this._pos2 + 21];
            }
            get useRuntimeCollisionCircles() {
              return this._structArray.uint16[this._pos2 + 22];
            }
            get crossTileID() {
              return this._structArray.uint32[this._pos4 + 12];
            }
            set crossTileID(t5) {
              this._structArray.uint32[this._pos4 + 12] = t5;
            }
            get textBoxScale() {
              return this._structArray.float32[this._pos4 + 13];
            }
            get collisionCircleDiameter() {
              return this._structArray.float32[this._pos4 + 14];
            }
            get textAnchorOffsetStartIndex() {
              return this._structArray.uint16[this._pos2 + 30];
            }
            get textAnchorOffsetEndIndex() {
              return this._structArray.uint16[this._pos2 + 31];
            }
          }
          la.prototype.size = 64;
          class ua extends Js {
            get(t5) {
              return new la(this, t5);
            }
          }
          Zi("SymbolInstanceArray", ua);
          class ca extends Ws {
            getoffsetX(t5) {
              return this.float32[1 * t5 + 0];
            }
          }
          Zi("GlyphOffsetArray", ca);
          class ha extends $s {
            getx(t5) {
              return this.int16[3 * t5 + 0];
            }
            gety(t5) {
              return this.int16[3 * t5 + 1];
            }
            gettileUnitDistanceFromAnchor(t5) {
              return this.int16[3 * t5 + 2];
            }
          }
          Zi("SymbolLineVertexArray", ha);
          class pa extends Bs {
            get textAnchor() {
              return this._structArray.uint16[this._pos2 + 0];
            }
            get textOffset0() {
              return this._structArray.float32[this._pos4 + 1];
            }
            get textOffset1() {
              return this._structArray.float32[this._pos4 + 2];
            }
          }
          pa.prototype.size = 12;
          class fa extends Qs {
            get(t5) {
              return new pa(this, t5);
            }
          }
          Zi("TextAnchorOffsetArray", fa);
          class da extends Bs {
            get featureIndex() {
              return this._structArray.uint32[this._pos4 + 0];
            }
            get sourceLayerIndex() {
              return this._structArray.uint16[this._pos2 + 2];
            }
            get bucketIndex() {
              return this._structArray.uint16[this._pos2 + 3];
            }
          }
          da.prototype.size = 8;
          class ya extends ta {
            get(t5) {
              return new da(this, t5);
            }
          }
          Zi("FeatureIndexArray", ya);
          class ma extends Fs {
          }
          class ga extends Fs {
          }
          class xa extends Fs {
          }
          class va extends Os {
          }
          class ba extends Ds {
          }
          class wa extends Rs {
          }
          class _a2 extends js {
          }
          class Sa extends Ns {
          }
          class Aa extends Us {
          }
          class ka extends qs {
          }
          class Ma extends Zs {
          }
          class Ia extends Xs {
          }
          class za extends Hs {
          }
          class Pa extends ea {
          }
          const Ca = Es([{ name: "a_pos", components: 2, type: "Int16" }], 4), { members: Ba } = Ca;
          class Va {
            constructor(t5 = []) {
              this._forceNewSegmentOnNextPrepare = false, this.segments = t5;
            }
            prepareSegment(t5, e7, r7, n6) {
              const i6 = this.segments[this.segments.length - 1];
              return t5 > Va.MAX_VERTEX_ARRAY_LENGTH && j3(`Max vertices per segment is ${Va.MAX_VERTEX_ARRAY_LENGTH}: bucket requested ${t5}. Consider using the \`fillLargeMeshArrays\` function if you require meshes with more than ${Va.MAX_VERTEX_ARRAY_LENGTH} vertices.`), this._forceNewSegmentOnNextPrepare || !i6 || i6.vertexLength + t5 > Va.MAX_VERTEX_ARRAY_LENGTH || i6.sortKey !== n6 ? this.createNewSegment(e7, r7, n6) : i6;
            }
            createNewSegment(t5, e7, r7) {
              const n6 = { vertexOffset: t5.length, primitiveOffset: e7.length, vertexLength: 0, primitiveLength: 0, vaos: {} };
              return void 0 !== r7 && (n6.sortKey = r7), this._forceNewSegmentOnNextPrepare = false, this.segments.push(n6), n6;
            }
            getOrCreateLatestSegment(t5, e7, r7) {
              return this.prepareSegment(0, t5, e7, r7);
            }
            forceNewSegmentOnNextPrepare() {
              this._forceNewSegmentOnNextPrepare = true;
            }
            get() {
              return this.segments;
            }
            destroy() {
              for (const t5 of this.segments) for (const e7 in t5.vaos) t5.vaos[e7].destroy();
            }
            static simpleSegment(t5, e7, r7, n6) {
              return new Va([{ vertexOffset: t5, primitiveOffset: e7, vertexLength: r7, primitiveLength: n6, vaos: {}, sortKey: 0 }]);
            }
          }
          function Ea(t5, e7) {
            return 256 * (t5 = E3(Math.floor(t5), 0, 255)) + E3(Math.floor(e7), 0, 255);
          }
          Va.MAX_VERTEX_ARRAY_LENGTH = Math.pow(2, 16) - 1, Zi("SegmentVector", Va);
          const Ta = Es([{ name: "a_pattern_from", components: 4, type: "Uint16" }, { name: "a_pattern_to", components: 4, type: "Uint16" }, { name: "a_pixel_ratio_from", components: 1, type: "Uint16" }, { name: "a_pixel_ratio_to", components: 1, type: "Uint16" }]);
          var Fa, $a, La, Oa = { exports: {} }, Da = { exports: {} }, Ra = { exports: {} }, ja = function() {
            if (La) return Oa.exports;
            La = 1;
            var t5 = (Fa || (Fa = 1, Da.exports = function(t6, e8) {
              var r7, n6, i6, s5, a4, o7, l5, u4;
              for (n6 = t6.length - (r7 = 3 & t6.length), i6 = e8, a4 = 3432918353, o7 = 461845907, u4 = 0; u4 < n6; ) l5 = 255 & t6.charCodeAt(u4) | (255 & t6.charCodeAt(++u4)) << 8 | (255 & t6.charCodeAt(++u4)) << 16 | (255 & t6.charCodeAt(++u4)) << 24, ++u4, i6 = 27492 + (65535 & (s5 = 5 * (65535 & (i6 = (i6 ^= l5 = (65535 & (l5 = (l5 = (65535 & l5) * a4 + (((l5 >>> 16) * a4 & 65535) << 16) & 4294967295) << 15 | l5 >>> 17)) * o7 + (((l5 >>> 16) * o7 & 65535) << 16) & 4294967295) << 13 | i6 >>> 19)) + ((5 * (i6 >>> 16) & 65535) << 16) & 4294967295)) + ((58964 + (s5 >>> 16) & 65535) << 16);
              switch (l5 = 0, r7) {
                case 3:
                  l5 ^= (255 & t6.charCodeAt(u4 + 2)) << 16;
                case 2:
                  l5 ^= (255 & t6.charCodeAt(u4 + 1)) << 8;
                case 1:
                  i6 ^= l5 = (65535 & (l5 = (l5 = (65535 & (l5 ^= 255 & t6.charCodeAt(u4))) * a4 + (((l5 >>> 16) * a4 & 65535) << 16) & 4294967295) << 15 | l5 >>> 17)) * o7 + (((l5 >>> 16) * o7 & 65535) << 16) & 4294967295;
              }
              return i6 ^= t6.length, i6 = 2246822507 * (65535 & (i6 ^= i6 >>> 16)) + ((2246822507 * (i6 >>> 16) & 65535) << 16) & 4294967295, i6 = 3266489909 * (65535 & (i6 ^= i6 >>> 13)) + ((3266489909 * (i6 >>> 16) & 65535) << 16) & 4294967295, (i6 ^= i6 >>> 16) >>> 0;
            }), Da.exports), e7 = ($a || ($a = 1, Ra.exports = function(t6, e8) {
              for (var r7, n6 = t6.length, i6 = e8 ^ n6, s5 = 0; n6 >= 4; ) r7 = 1540483477 * (65535 & (r7 = 255 & t6.charCodeAt(s5) | (255 & t6.charCodeAt(++s5)) << 8 | (255 & t6.charCodeAt(++s5)) << 16 | (255 & t6.charCodeAt(++s5)) << 24)) + ((1540483477 * (r7 >>> 16) & 65535) << 16), i6 = 1540483477 * (65535 & i6) + ((1540483477 * (i6 >>> 16) & 65535) << 16) ^ (r7 = 1540483477 * (65535 & (r7 ^= r7 >>> 24)) + ((1540483477 * (r7 >>> 16) & 65535) << 16)), n6 -= 4, ++s5;
              switch (n6) {
                case 3:
                  i6 ^= (255 & t6.charCodeAt(s5 + 2)) << 16;
                case 2:
                  i6 ^= (255 & t6.charCodeAt(s5 + 1)) << 8;
                case 1:
                  i6 = 1540483477 * (65535 & (i6 ^= 255 & t6.charCodeAt(s5))) + ((1540483477 * (i6 >>> 16) & 65535) << 16);
              }
              return i6 = 1540483477 * (65535 & (i6 ^= i6 >>> 13)) + ((1540483477 * (i6 >>> 16) & 65535) << 16), (i6 ^= i6 >>> 15) >>> 0;
            }), Ra.exports);
            return Oa.exports = t5, Oa.exports.murmur3 = t5, Oa.exports.murmur2 = e7, Oa.exports;
          }(), Na = r6(ja);
          class Ua {
            constructor() {
              this.ids = [], this.positions = [], this.indexed = false;
            }
            add(t5, e7, r7, n6) {
              this.ids.push(qa(t5)), this.positions.push(e7, r7, n6);
            }
            getPositions(t5) {
              if (!this.indexed) throw new Error("Trying to get index, but feature positions are not indexed");
              const e7 = qa(t5);
              let r7 = 0, n6 = this.ids.length - 1;
              for (; r7 < n6; ) {
                const t6 = r7 + n6 >> 1;
                this.ids[t6] >= e7 ? n6 = t6 : r7 = t6 + 1;
              }
              const i6 = [];
              for (; this.ids[r7] === e7; ) i6.push({ index: this.positions[3 * r7], start: this.positions[3 * r7 + 1], end: this.positions[3 * r7 + 2] }), r7++;
              return i6;
            }
            static serialize(t5, e7) {
              const r7 = new Float64Array(t5.ids), n6 = new Uint32Array(t5.positions);
              return Ga(r7, n6, 0, r7.length - 1), e7 && e7.push(r7.buffer, n6.buffer), { ids: r7, positions: n6 };
            }
            static deserialize(t5) {
              const e7 = new Ua();
              return e7.ids = t5.ids, e7.positions = t5.positions, e7.indexed = true, e7;
            }
          }
          function qa(t5) {
            const e7 = +t5;
            return !isNaN(e7) && e7 <= Number.MAX_SAFE_INTEGER ? e7 : Na(String(t5));
          }
          function Ga(t5, e7, r7, n6) {
            for (; r7 < n6; ) {
              const i6 = t5[r7 + n6 >> 1];
              let s5 = r7 - 1, a4 = n6 + 1;
              for (; ; ) {
                do {
                  s5++;
                } while (t5[s5] < i6);
                do {
                  a4--;
                } while (t5[a4] > i6);
                if (s5 >= a4) break;
                Za(t5, s5, a4), Za(e7, 3 * s5, 3 * a4), Za(e7, 3 * s5 + 1, 3 * a4 + 1), Za(e7, 3 * s5 + 2, 3 * a4 + 2);
              }
              a4 - r7 < n6 - a4 ? (Ga(t5, e7, r7, a4), r7 = a4 + 1) : (Ga(t5, e7, a4 + 1, n6), n6 = a4);
            }
          }
          function Za(t5, e7, r7) {
            const n6 = t5[e7];
            t5[e7] = t5[r7], t5[r7] = n6;
          }
          Zi("FeaturePositionMap", Ua);
          class Ka {
            constructor(t5, e7) {
              this.gl = t5.gl, this.location = e7;
            }
          }
          class Xa extends Ka {
            constructor(t5, e7) {
              super(t5, e7), this.current = 0;
            }
            set(t5) {
              this.current !== t5 && (this.current = t5, this.gl.uniform1f(this.location, t5));
            }
          }
          class Ha extends Ka {
            constructor(t5, e7) {
              super(t5, e7), this.current = [0, 0, 0, 0];
            }
            set(t5) {
              t5[0] === this.current[0] && t5[1] === this.current[1] && t5[2] === this.current[2] && t5[3] === this.current[3] || (this.current = t5, this.gl.uniform4f(this.location, t5[0], t5[1], t5[2], t5[3]));
            }
          }
          class Ya extends Ka {
            constructor(t5, e7) {
              super(t5, e7), this.current = xe.transparent;
            }
            set(t5) {
              t5.r === this.current.r && t5.g === this.current.g && t5.b === this.current.b && t5.a === this.current.a || (this.current = t5, this.gl.uniform4f(this.location, t5.r, t5.g, t5.b, t5.a));
            }
          }
          const Ja = new Float32Array(16);
          function Wa(t5) {
            return [Ea(255 * t5.r, 255 * t5.g), Ea(255 * t5.b, 255 * t5.a)];
          }
          class Qa {
            constructor(t5, e7, r7) {
              this.value = t5, this.uniformNames = e7.map((t6) => `u_${t6}`), this.type = r7;
            }
            setUniform(t5, e7, r7) {
              t5.set(r7.constantOr(this.value));
            }
            getBinding(t5, e7, r7) {
              return "color" === this.type ? new Ya(t5, e7) : new Xa(t5, e7);
            }
          }
          class to {
            constructor(t5, e7) {
              this.uniformNames = e7.map((t6) => `u_${t6}`), this.patternFrom = null, this.patternTo = null, this.pixelRatioFrom = 1, this.pixelRatioTo = 1;
            }
            setConstantPatternPositions(t5, e7) {
              this.pixelRatioFrom = e7.pixelRatio, this.pixelRatioTo = t5.pixelRatio, this.patternFrom = e7.tlbr, this.patternTo = t5.tlbr;
            }
            setUniform(t5, e7, r7, n6) {
              const i6 = "u_pattern_to" === n6 ? this.patternTo : "u_pattern_from" === n6 ? this.patternFrom : "u_pixel_ratio_to" === n6 ? this.pixelRatioTo : "u_pixel_ratio_from" === n6 ? this.pixelRatioFrom : null;
              i6 && t5.set(i6);
            }
            getBinding(t5, e7, r7) {
              return "u_pattern" === r7.substr(0, 9) ? new Ha(t5, e7) : new Xa(t5, e7);
            }
          }
          class eo {
            constructor(t5, e7, r7, n6) {
              this.expression = t5, this.type = r7, this.maxValue = 0, this.paintVertexAttributes = e7.map((t6) => ({ name: `a_${t6}`, type: "Float32", components: "color" === r7 ? 2 : 1, offset: 0 })), this.paintVertexArray = new n6();
            }
            populatePaintArray(t5, e7, r7, n6, i6) {
              const s5 = this.paintVertexArray.length, a4 = this.expression.evaluate(new fs(0), e7, {}, n6, [], i6);
              this.paintVertexArray.resize(t5), this._setPaintValue(s5, t5, a4);
            }
            updatePaintArray(t5, e7, r7, n6) {
              const i6 = this.expression.evaluate({ zoom: 0 }, r7, n6);
              this._setPaintValue(t5, e7, i6);
            }
            _setPaintValue(t5, e7, r7) {
              if ("color" === this.type) {
                const n6 = Wa(r7);
                for (let r8 = t5; r8 < e7; r8++) this.paintVertexArray.emplace(r8, n6[0], n6[1]);
              } else {
                for (let n6 = t5; n6 < e7; n6++) this.paintVertexArray.emplace(n6, r7);
                this.maxValue = Math.max(this.maxValue, Math.abs(r7));
              }
            }
            upload(t5) {
              this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer && this.paintVertexBuffer.buffer ? this.paintVertexBuffer.updateData(this.paintVertexArray) : this.paintVertexBuffer = t5.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent));
            }
            destroy() {
              this.paintVertexBuffer && this.paintVertexBuffer.destroy();
            }
          }
          class ro {
            constructor(t5, e7, r7, n6, i6, s5) {
              this.expression = t5, this.uniformNames = e7.map((t6) => `u_${t6}_t`), this.type = r7, this.useIntegerZoom = n6, this.zoom = i6, this.maxValue = 0, this.paintVertexAttributes = e7.map((t6) => ({ name: `a_${t6}`, type: "Float32", components: "color" === r7 ? 4 : 2, offset: 0 })), this.paintVertexArray = new s5();
            }
            populatePaintArray(t5, e7, r7, n6, i6) {
              const s5 = this.expression.evaluate(new fs(this.zoom), e7, {}, n6, [], i6), a4 = this.expression.evaluate(new fs(this.zoom + 1), e7, {}, n6, [], i6), o7 = this.paintVertexArray.length;
              this.paintVertexArray.resize(t5), this._setPaintValue(o7, t5, s5, a4);
            }
            updatePaintArray(t5, e7, r7, n6) {
              const i6 = this.expression.evaluate({ zoom: this.zoom }, r7, n6), s5 = this.expression.evaluate({ zoom: this.zoom + 1 }, r7, n6);
              this._setPaintValue(t5, e7, i6, s5);
            }
            _setPaintValue(t5, e7, r7, n6) {
              if ("color" === this.type) {
                const i6 = Wa(r7), s5 = Wa(n6);
                for (let r8 = t5; r8 < e7; r8++) this.paintVertexArray.emplace(r8, i6[0], i6[1], s5[0], s5[1]);
              } else {
                for (let i6 = t5; i6 < e7; i6++) this.paintVertexArray.emplace(i6, r7, n6);
                this.maxValue = Math.max(this.maxValue, Math.abs(r7), Math.abs(n6));
              }
            }
            upload(t5) {
              this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer && this.paintVertexBuffer.buffer ? this.paintVertexBuffer.updateData(this.paintVertexArray) : this.paintVertexBuffer = t5.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent));
            }
            destroy() {
              this.paintVertexBuffer && this.paintVertexBuffer.destroy();
            }
            setUniform(t5, e7) {
              const r7 = this.useIntegerZoom ? Math.floor(e7.zoom) : e7.zoom, n6 = E3(this.expression.interpolationFactor(r7, this.zoom, this.zoom + 1), 0, 1);
              t5.set(n6);
            }
            getBinding(t5, e7, r7) {
              return new Xa(t5, e7);
            }
          }
          class no {
            constructor(t5, e7, r7, n6, i6, s5) {
              this.expression = t5, this.type = e7, this.useIntegerZoom = r7, this.zoom = n6, this.layerId = s5, this.zoomInPaintVertexArray = new i6(), this.zoomOutPaintVertexArray = new i6();
            }
            populatePaintArray(t5, e7, r7) {
              const n6 = this.zoomInPaintVertexArray.length;
              this.zoomInPaintVertexArray.resize(t5), this.zoomOutPaintVertexArray.resize(t5), this._setPaintValues(n6, t5, e7.patterns && e7.patterns[this.layerId], r7);
            }
            updatePaintArray(t5, e7, r7, n6, i6) {
              this._setPaintValues(t5, e7, r7.patterns && r7.patterns[this.layerId], i6);
            }
            _setPaintValues(t5, e7, r7, n6) {
              if (!n6 || !r7) return;
              const { min: i6, mid: s5, max: a4 } = r7, o7 = n6[i6], l5 = n6[s5], u4 = n6[a4];
              if (o7 && l5 && u4) for (let r8 = t5; r8 < e7; r8++) this.zoomInPaintVertexArray.emplace(r8, l5.tl[0], l5.tl[1], l5.br[0], l5.br[1], o7.tl[0], o7.tl[1], o7.br[0], o7.br[1], l5.pixelRatio, o7.pixelRatio), this.zoomOutPaintVertexArray.emplace(r8, l5.tl[0], l5.tl[1], l5.br[0], l5.br[1], u4.tl[0], u4.tl[1], u4.br[0], u4.br[1], l5.pixelRatio, u4.pixelRatio);
            }
            upload(t5) {
              this.zoomInPaintVertexArray && this.zoomInPaintVertexArray.arrayBuffer && this.zoomOutPaintVertexArray && this.zoomOutPaintVertexArray.arrayBuffer && (this.zoomInPaintVertexBuffer = t5.createVertexBuffer(this.zoomInPaintVertexArray, Ta.members, this.expression.isStateDependent), this.zoomOutPaintVertexBuffer = t5.createVertexBuffer(this.zoomOutPaintVertexArray, Ta.members, this.expression.isStateDependent));
            }
            destroy() {
              this.zoomOutPaintVertexBuffer && this.zoomOutPaintVertexBuffer.destroy(), this.zoomInPaintVertexBuffer && this.zoomInPaintVertexBuffer.destroy();
            }
          }
          class io {
            constructor(t5, e7, r7) {
              this.binders = {}, this._buffers = [];
              const n6 = [];
              for (const i6 in t5.paint._values) {
                if (!r7(i6)) continue;
                const s5 = t5.paint.get(i6);
                if (!(s5 instanceof bs && Bn(s5.property.specification))) continue;
                const a4 = ao(i6, t5.type), o7 = s5.value, l5 = s5.property.specification.type, u4 = s5.property.useIntegerZoom, c5 = s5.property.specification["property-type"], h4 = "cross-faded" === c5 || "cross-faded-data-driven" === c5;
                if ("constant" === o7.kind) this.binders[i6] = h4 ? new to(o7.value, a4) : new Qa(o7.value, a4, l5), n6.push(`/u_${i6}`);
                else if ("source" === o7.kind || h4) {
                  const r8 = oo(i6, l5, "source");
                  this.binders[i6] = h4 ? new no(o7, l5, u4, e7, r8, t5.id) : new eo(o7, a4, l5, r8), n6.push(`/a_${i6}`);
                } else {
                  const t6 = oo(i6, l5, "composite");
                  this.binders[i6] = new ro(o7, a4, l5, u4, e7, t6), n6.push(`/z_${i6}`);
                }
              }
              this.cacheKey = n6.sort().join("");
            }
            getMaxValue(t5) {
              const e7 = this.binders[t5];
              return e7 instanceof eo || e7 instanceof ro ? e7.maxValue : 0;
            }
            populatePaintArrays(t5, e7, r7, n6, i6) {
              for (const s5 in this.binders) {
                const a4 = this.binders[s5];
                (a4 instanceof eo || a4 instanceof ro || a4 instanceof no) && a4.populatePaintArray(t5, e7, r7, n6, i6);
              }
            }
            setConstantPatternPositions(t5, e7) {
              for (const r7 in this.binders) {
                const n6 = this.binders[r7];
                n6 instanceof to && n6.setConstantPatternPositions(t5, e7);
              }
            }
            updatePaintArrays(t5, e7, r7, n6, i6) {
              let s5 = false;
              for (const a4 in t5) {
                const o7 = e7.getPositions(a4);
                for (const e8 of o7) {
                  const o8 = r7.feature(e8.index);
                  for (const r8 in this.binders) {
                    const l5 = this.binders[r8];
                    if ((l5 instanceof eo || l5 instanceof ro || l5 instanceof no) && true === l5.expression.isStateDependent) {
                      const u4 = n6.paint.get(r8);
                      l5.expression = u4.value, l5.updatePaintArray(e8.start, e8.end, o8, t5[a4], i6), s5 = true;
                    }
                  }
                }
              }
              return s5;
            }
            defines() {
              const t5 = [];
              for (const e7 in this.binders) {
                const r7 = this.binders[e7];
                (r7 instanceof Qa || r7 instanceof to) && t5.push(...r7.uniformNames.map((t6) => `#define HAS_UNIFORM_${t6}`));
              }
              return t5;
            }
            getBinderAttributes() {
              const t5 = [];
              for (const e7 in this.binders) {
                const r7 = this.binders[e7];
                if (r7 instanceof eo || r7 instanceof ro) for (let e8 = 0; e8 < r7.paintVertexAttributes.length; e8++) t5.push(r7.paintVertexAttributes[e8].name);
                else if (r7 instanceof no) for (let e8 = 0; e8 < Ta.members.length; e8++) t5.push(Ta.members[e8].name);
              }
              return t5;
            }
            getBinderUniforms() {
              const t5 = [];
              for (const e7 in this.binders) {
                const r7 = this.binders[e7];
                if (r7 instanceof Qa || r7 instanceof to || r7 instanceof ro) for (const e8 of r7.uniformNames) t5.push(e8);
              }
              return t5;
            }
            getPaintVertexBuffers() {
              return this._buffers;
            }
            getUniforms(t5, e7) {
              const r7 = [];
              for (const n6 in this.binders) {
                const i6 = this.binders[n6];
                if (i6 instanceof Qa || i6 instanceof to || i6 instanceof ro) {
                  for (const s5 of i6.uniformNames) if (e7[s5]) {
                    const a4 = i6.getBinding(t5, e7[s5], s5);
                    r7.push({ name: s5, property: n6, binding: a4 });
                  }
                }
              }
              return r7;
            }
            setUniforms(t5, e7, r7, n6) {
              for (const { name: t6, property: i6, binding: s5 } of e7) this.binders[i6].setUniform(s5, n6, r7.get(i6), t6);
            }
            updatePaintBuffers(t5) {
              this._buffers = [];
              for (const e7 in this.binders) {
                const r7 = this.binders[e7];
                if (t5 && r7 instanceof no) {
                  const e8 = 2 === t5.fromScale ? r7.zoomInPaintVertexBuffer : r7.zoomOutPaintVertexBuffer;
                  e8 && this._buffers.push(e8);
                } else (r7 instanceof eo || r7 instanceof ro) && r7.paintVertexBuffer && this._buffers.push(r7.paintVertexBuffer);
              }
            }
            upload(t5) {
              for (const e7 in this.binders) {
                const r7 = this.binders[e7];
                (r7 instanceof eo || r7 instanceof ro || r7 instanceof no) && r7.upload(t5);
              }
              this.updatePaintBuffers();
            }
            destroy() {
              for (const t5 in this.binders) {
                const e7 = this.binders[t5];
                (e7 instanceof eo || e7 instanceof ro || e7 instanceof no) && e7.destroy();
              }
            }
          }
          class so {
            constructor(t5, e7, r7 = () => true) {
              this.programConfigurations = {};
              for (const n6 of t5) this.programConfigurations[n6.id] = new io(n6, e7, r7);
              this.needsUpload = false, this._featureMap = new Ua(), this._bufferOffset = 0;
            }
            populatePaintArrays(t5, e7, r7, n6, i6, s5) {
              for (const r8 in this.programConfigurations) this.programConfigurations[r8].populatePaintArrays(t5, e7, n6, i6, s5);
              void 0 !== e7.id && this._featureMap.add(e7.id, r7, this._bufferOffset, t5), this._bufferOffset = t5, this.needsUpload = true;
            }
            updatePaintArrays(t5, e7, r7, n6) {
              for (const i6 of r7) this.needsUpload = this.programConfigurations[i6.id].updatePaintArrays(t5, this._featureMap, e7, i6, n6) || this.needsUpload;
            }
            get(t5) {
              return this.programConfigurations[t5];
            }
            upload(t5) {
              if (this.needsUpload) {
                for (const e7 in this.programConfigurations) this.programConfigurations[e7].upload(t5);
                this.needsUpload = false;
              }
            }
            destroy() {
              for (const t5 in this.programConfigurations) this.programConfigurations[t5].destroy();
            }
          }
          function ao(t5, e7) {
            return { "text-opacity": ["opacity"], "icon-opacity": ["opacity"], "text-color": ["fill_color"], "icon-color": ["fill_color"], "text-halo-color": ["halo_color"], "icon-halo-color": ["halo_color"], "text-halo-blur": ["halo_blur"], "icon-halo-blur": ["halo_blur"], "text-halo-width": ["halo_width"], "icon-halo-width": ["halo_width"], "line-gap-width": ["gapwidth"], "line-pattern": ["pattern_to", "pattern_from", "pixel_ratio_to", "pixel_ratio_from"], "fill-pattern": ["pattern_to", "pattern_from", "pixel_ratio_to", "pixel_ratio_from"], "fill-extrusion-pattern": ["pattern_to", "pattern_from", "pixel_ratio_to", "pixel_ratio_from"] }[t5] || [t5.replace(`${e7}-`, "").replace(/-/g, "_")];
          }
          function oo(t5, e7, r7) {
            const n6 = { color: { source: Rs, composite: na }, number: { source: Ws, composite: Rs } }, i6 = function(t6) {
              return { "line-pattern": { source: _a2, composite: _a2 }, "fill-pattern": { source: _a2, composite: _a2 }, "fill-extrusion-pattern": { source: _a2, composite: _a2 } }[t6];
            }(t5);
            return i6 && i6[r7] || n6[e7][r7];
          }
          Zi("ConstantBinder", Qa), Zi("CrossFadedConstantBinder", to), Zi("SourceExpressionBinder", eo), Zi("CrossFadedCompositeBinder", no), Zi("CompositeExpressionBinder", ro), Zi("ProgramConfiguration", io, { omit: ["_buffers"] }), Zi("ProgramConfigurationSet", so);
          const lo = Math.pow(2, 14) - 1, uo = -lo - 1;
          function co(t5) {
            const e7 = M4 / t5.extent, r7 = t5.loadGeometry();
            for (let t6 = 0; t6 < r7.length; t6++) {
              const n6 = r7[t6];
              for (let t7 = 0; t7 < n6.length; t7++) {
                const r8 = n6[t7], i6 = Math.round(r8.x * e7), s5 = Math.round(r8.y * e7);
                r8.x = E3(i6, uo, lo), r8.y = E3(s5, uo, lo), (i6 < r8.x || i6 > r8.x + 1 || s5 < r8.y || s5 > r8.y + 1) && j3("Geometry exceeds allowed extent, reduce your vector tile buffer size");
              }
            }
            return r7;
          }
          function ho(t5, e7) {
            return { type: t5.type, id: t5.id, properties: t5.properties, geometry: e7 ? co(t5) : [] };
          }
          const po = -32768;
          function fo(t5, e7, r7, n6, i6) {
            t5.emplaceBack(po + 8 * e7 + n6, po + 8 * r7 + i6);
          }
          class yo {
            constructor(t5) {
              this.zoom = t5.zoom, this.overscaling = t5.overscaling, this.layers = t5.layers, this.layerIds = this.layers.map((t6) => t6.id), this.index = t5.index, this.hasPattern = false, this.layoutVertexArray = new ga(), this.indexArray = new za(), this.segments = new Va(), this.programConfigurations = new so(t5.layers, t5.zoom), this.stateDependentLayerIds = this.layers.filter((t6) => t6.isStateDependent()).map((t6) => t6.id);
            }
            populate(t5, e7, r7) {
              const n6 = this.layers[0], i6 = [];
              let s5 = null, a4 = false, o7 = "heatmap" === n6.type;
              if ("circle" === n6.type) {
                const t6 = n6;
                s5 = t6.layout.get("circle-sort-key"), a4 = !s5.isConstant(), o7 = o7 || "map" === t6.paint.get("circle-pitch-alignment");
              }
              const l5 = o7 ? e7.subdivisionGranularity.circle : 1;
              for (const { feature: e8, id: n7, index: o8, sourceLayerIndex: l6 } of t5) {
                const t6 = this.layers[0]._featureFilter.needGeometry, u4 = ho(e8, t6);
                if (!this.layers[0]._featureFilter.filter(new fs(this.zoom), u4, r7)) continue;
                const c5 = a4 ? s5.evaluate(u4, {}, r7) : void 0, h4 = { id: n7, properties: e8.properties, type: e8.type, sourceLayerIndex: l6, index: o8, geometry: t6 ? u4.geometry : co(e8), patterns: {}, sortKey: c5 };
                i6.push(h4);
              }
              a4 && i6.sort((t6, e8) => t6.sortKey - e8.sortKey);
              for (const n7 of i6) {
                const { geometry: i7, index: s6, sourceLayerIndex: a5 } = n7, o8 = t5[s6].feature;
                this.addFeature(n7, i7, s6, r7, l5), e7.featureIndex.insert(o8, i7, s6, a5, this.index);
              }
            }
            update(t5, e7, r7) {
              this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t5, e7, this.stateDependentLayers, r7);
            }
            isEmpty() {
              return 0 === this.layoutVertexArray.length;
            }
            uploadPending() {
              return !this.uploaded || this.programConfigurations.needsUpload;
            }
            upload(t5) {
              this.uploaded || (this.layoutVertexBuffer = t5.createVertexBuffer(this.layoutVertexArray, Ba), this.indexBuffer = t5.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(t5), this.uploaded = true;
            }
            destroy() {
              this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy());
            }
            addFeature(t5, e7, r7, n6, i6 = 1) {
              let s5;
              switch (i6) {
                case 1:
                  s5 = [0, 7];
                  break;
                case 3:
                  s5 = [0, 2, 5, 7];
                  break;
                case 5:
                  s5 = [0, 1, 3, 4, 6, 7];
                  break;
                case 7:
                  s5 = [0, 1, 2, 3, 4, 5, 6, 7];
                  break;
                default:
                  throw new Error(`Invalid circle bucket granularity: ${i6}; valid values are 1, 3, 5, 7.`);
              }
              const a4 = s5.length;
              for (const r8 of e7) for (const e8 of r8) {
                const r9 = e8.x, n7 = e8.y;
                if (r9 < 0 || r9 >= M4 || n7 < 0 || n7 >= M4) continue;
                const i7 = this.segments.prepareSegment(a4 * a4, this.layoutVertexArray, this.indexArray, t5.sortKey), o7 = i7.vertexLength;
                for (let t6 = 0; t6 < a4; t6++) for (let e9 = 0; e9 < a4; e9++) fo(this.layoutVertexArray, r9, n7, s5[e9], s5[t6]);
                for (let t6 = 0; t6 < a4 - 1; t6++) for (let e9 = 0; e9 < a4 - 1; e9++) {
                  const r10 = o7 + t6 * a4 + e9, n8 = o7 + (t6 + 1) * a4 + e9;
                  this.indexArray.emplaceBack(r10, n8 + 1, r10 + 1), this.indexArray.emplaceBack(r10, n8, n8 + 1);
                }
                i7.vertexLength += a4 * a4, i7.primitiveLength += (a4 - 1) * (a4 - 1) * 2;
              }
              this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t5, r7, {}, n6);
            }
          }
          function mo(t5, e7) {
            for (let r7 = 0; r7 < t5.length; r7++) if (ko(e7, t5[r7])) return true;
            for (let r7 = 0; r7 < e7.length; r7++) if (ko(t5, e7[r7])) return true;
            return !!bo(t5, e7);
          }
          function go(t5, e7, r7) {
            return !!ko(t5, e7) || !!_o(e7, t5, r7);
          }
          function xo(t5, e7) {
            if (1 === t5.length) return Ao(e7, t5[0]);
            for (let r7 = 0; r7 < e7.length; r7++) {
              const n6 = e7[r7];
              for (let e8 = 0; e8 < n6.length; e8++) if (ko(t5, n6[e8])) return true;
            }
            for (let r7 = 0; r7 < t5.length; r7++) if (Ao(e7, t5[r7])) return true;
            for (let r7 = 0; r7 < e7.length; r7++) if (bo(t5, e7[r7])) return true;
            return false;
          }
          function vo(t5, e7, r7) {
            if (t5.length > 1) {
              if (bo(t5, e7)) return true;
              for (let n6 = 0; n6 < e7.length; n6++) if (_o(e7[n6], t5, r7)) return true;
            }
            for (let n6 = 0; n6 < t5.length; n6++) if (_o(t5[n6], e7, r7)) return true;
            return false;
          }
          function bo(t5, e7) {
            if (0 === t5.length || 0 === e7.length) return false;
            for (let r7 = 0; r7 < t5.length - 1; r7++) {
              const n6 = t5[r7], i6 = t5[r7 + 1];
              for (let t6 = 0; t6 < e7.length - 1; t6++) if (wo(n6, i6, e7[t6], e7[t6 + 1])) return true;
            }
            return false;
          }
          function wo(t5, e7, r7, n6) {
            return N3(t5, r7, n6) !== N3(e7, r7, n6) && N3(t5, e7, r7) !== N3(t5, e7, n6);
          }
          function _o(t5, e7, r7) {
            const n6 = r7 * r7;
            if (1 === e7.length) return t5.distSqr(e7[0]) < n6;
            for (let r8 = 1; r8 < e7.length; r8++) if (So(t5, e7[r8 - 1], e7[r8]) < n6) return true;
            return false;
          }
          function So(t5, e7, r7) {
            const n6 = e7.distSqr(r7);
            if (0 === n6) return t5.distSqr(e7);
            const i6 = ((t5.x - e7.x) * (r7.x - e7.x) + (t5.y - e7.y) * (r7.y - e7.y)) / n6;
            return t5.distSqr(i6 < 0 ? e7 : i6 > 1 ? r7 : r7.sub(e7)._mult(i6)._add(e7));
          }
          function Ao(t5, e7) {
            for (let r7 = 0; r7 < t5.length; r7++) if (ko(t5[r7], e7)) return true;
            return false;
          }
          function ko(t5, e7) {
            let r7 = false;
            for (let n6 = 0, i6 = t5.length - 1; n6 < t5.length; i6 = n6++) {
              const s5 = t5[n6], a4 = t5[i6];
              s5.y > e7.y != a4.y > e7.y && e7.x < (a4.x - s5.x) * (e7.y - s5.y) / (a4.y - s5.y) + s5.x && (r7 = !r7);
            }
            return r7;
          }
          function Mo(t5, e7, r7) {
            const n6 = r7[0], i6 = r7[2];
            if (t5.x < n6.x && e7.x < n6.x || t5.x > i6.x && e7.x > i6.x || t5.y < n6.y && e7.y < n6.y || t5.y > i6.y && e7.y > i6.y) return false;
            const s5 = N3(t5, e7, r7[0]);
            return s5 !== N3(t5, e7, r7[1]) || s5 !== N3(t5, e7, r7[2]) || s5 !== N3(t5, e7, r7[3]);
          }
          function Io(t5, e7, r7) {
            const n6 = e7.paint.get(t5).value;
            return "constant" === n6.kind ? n6.value : r7.programConfigurations.get(e7.id).getMaxValue(t5);
          }
          function zo(t5) {
            return Math.sqrt(t5[0] * t5[0] + t5[1] * t5[1]);
          }
          function Po(t5, e7, r7, n6, i6) {
            if (!e7[0] && !e7[1]) return t5;
            const s5 = l4.convert(e7)._mult(i6);
            "viewport" === r7 && s5._rotate(-n6);
            const a4 = [];
            for (let e8 = 0; e8 < t5.length; e8++) a4.push(t5[e8].sub(s5));
            return a4;
          }
          let Co, Bo;
          Zi("CircleBucket", yo, { omit: ["layers"] });
          var Vo = { get paint() {
            return Bo = Bo || new Is({ "circle-radius": new Ss(dt.paint_circle["circle-radius"]), "circle-color": new Ss(dt.paint_circle["circle-color"]), "circle-blur": new Ss(dt.paint_circle["circle-blur"]), "circle-opacity": new Ss(dt.paint_circle["circle-opacity"]), "circle-translate": new _s(dt.paint_circle["circle-translate"]), "circle-translate-anchor": new _s(dt.paint_circle["circle-translate-anchor"]), "circle-pitch-scale": new _s(dt.paint_circle["circle-pitch-scale"]), "circle-pitch-alignment": new _s(dt.paint_circle["circle-pitch-alignment"]), "circle-stroke-width": new Ss(dt.paint_circle["circle-stroke-width"]), "circle-stroke-color": new Ss(dt.paint_circle["circle-stroke-color"]), "circle-stroke-opacity": new Ss(dt.paint_circle["circle-stroke-opacity"]) });
          }, get layout() {
            return Co = Co || new Is({ "circle-sort-key": new Ss(dt.layout_circle["circle-sort-key"]) });
          } };
          class Eo extends Ps {
            constructor(t5) {
              super(t5, Vo);
            }
            createBucket(t5) {
              return new yo(t5);
            }
            queryRadius(t5) {
              const e7 = t5;
              return Io("circle-radius", this, e7) + Io("circle-stroke-width", this, e7) + zo(this.paint.get("circle-translate"));
            }
            queryIntersectsFeature({ queryGeometry: t5, feature: e7, featureState: r7, geometry: n6, transform: i6, pixelsToTileUnits: s5, unwrappedTileID: a4, getElevation: o7 }) {
              const l5 = Po(t5, this.paint.get("circle-translate"), this.paint.get("circle-translate-anchor"), -i6.bearingInRadians, s5), u4 = this.paint.get("circle-radius").evaluate(e7, r7) + this.paint.get("circle-stroke-width").evaluate(e7, r7), c5 = "map" === this.paint.get("circle-pitch-alignment"), h4 = c5 ? l5 : function(t6, e8, r8, n7) {
                return t6.map((t7) => To(t7, e8, r8, n7));
              }(l5, i6, a4, o7), p4 = c5 ? u4 * s5 : u4;
              for (const t6 of n6) for (const e8 of t6) {
                const t7 = c5 ? e8 : To(e8, i6, a4, o7);
                let r8 = p4;
                const n7 = i6.projectTileCoordinates(e8.x, e8.y, a4, o7).signedDistanceFromCamera;
                if ("viewport" === this.paint.get("circle-pitch-scale") && "map" === this.paint.get("circle-pitch-alignment") ? r8 *= n7 / i6.cameraToCenterDistance : "map" === this.paint.get("circle-pitch-scale") && "viewport" === this.paint.get("circle-pitch-alignment") && (r8 *= i6.cameraToCenterDistance / n7), go(h4, t7, r8)) return true;
              }
              return false;
            }
          }
          function To(t5, e7, r7, n6) {
            const i6 = e7.projectTileCoordinates(t5.x, t5.y, r7, n6).point;
            return new l4((0.5 * i6.x + 0.5) * e7.width, (0.5 * -i6.y + 0.5) * e7.height);
          }
          class Fo extends yo {
          }
          let $o;
          Zi("HeatmapBucket", Fo, { omit: ["layers"] });
          var Lo = { get paint() {
            return $o = $o || new Is({ "heatmap-radius": new Ss(dt.paint_heatmap["heatmap-radius"]), "heatmap-weight": new Ss(dt.paint_heatmap["heatmap-weight"]), "heatmap-intensity": new _s(dt.paint_heatmap["heatmap-intensity"]), "heatmap-color": new Ms(dt.paint_heatmap["heatmap-color"]), "heatmap-opacity": new _s(dt.paint_heatmap["heatmap-opacity"]) });
          } };
          function Oo(t5, { width: e7, height: r7 }, n6, i6) {
            if (i6) {
              if (i6 instanceof Uint8ClampedArray) i6 = new Uint8Array(i6.buffer);
              else if (i6.length !== e7 * r7 * n6) throw new RangeError(`mismatched image size. expected: ${i6.length} but got: ${e7 * r7 * n6}`);
            } else i6 = new Uint8Array(e7 * r7 * n6);
            return t5.width = e7, t5.height = r7, t5.data = i6, t5;
          }
          function Do(t5, { width: e7, height: r7 }, n6) {
            if (e7 === t5.width && r7 === t5.height) return;
            const i6 = Oo({}, { width: e7, height: r7 }, n6);
            Ro(t5, i6, { x: 0, y: 0 }, { x: 0, y: 0 }, { width: Math.min(t5.width, e7), height: Math.min(t5.height, r7) }, n6), t5.width = e7, t5.height = r7, t5.data = i6.data;
          }
          function Ro(t5, e7, r7, n6, i6, s5) {
            if (0 === i6.width || 0 === i6.height) return e7;
            if (i6.width > t5.width || i6.height > t5.height || r7.x > t5.width - i6.width || r7.y > t5.height - i6.height) throw new RangeError("out of range source coordinates for image copy");
            if (i6.width > e7.width || i6.height > e7.height || n6.x > e7.width - i6.width || n6.y > e7.height - i6.height) throw new RangeError("out of range destination coordinates for image copy");
            const a4 = t5.data, o7 = e7.data;
            if (a4 === o7) throw new Error("srcData equals dstData, so image is already copied");
            for (let l5 = 0; l5 < i6.height; l5++) {
              const u4 = ((r7.y + l5) * t5.width + r7.x) * s5, c5 = ((n6.y + l5) * e7.width + n6.x) * s5;
              for (let t6 = 0; t6 < i6.width * s5; t6++) o7[c5 + t6] = a4[u4 + t6];
            }
            return e7;
          }
          class jo {
            constructor(t5, e7) {
              Oo(this, t5, 1, e7);
            }
            resize(t5) {
              Do(this, t5, 1);
            }
            clone() {
              return new jo({ width: this.width, height: this.height }, new Uint8Array(this.data));
            }
            static copy(t5, e7, r7, n6, i6) {
              Ro(t5, e7, r7, n6, i6, 1);
            }
          }
          class No {
            constructor(t5, e7) {
              Oo(this, t5, 4, e7);
            }
            resize(t5) {
              Do(this, t5, 4);
            }
            replace(t5, e7) {
              e7 ? this.data.set(t5) : this.data = t5 instanceof Uint8ClampedArray ? new Uint8Array(t5.buffer) : t5;
            }
            clone() {
              return new No({ width: this.width, height: this.height }, new Uint8Array(this.data));
            }
            static copy(t5, e7, r7, n6, i6) {
              Ro(t5, e7, r7, n6, i6, 4);
            }
          }
          function Uo(t5) {
            const e7 = {}, r7 = t5.resolution || 256, n6 = t5.clips ? t5.clips.length : 1, i6 = t5.image || new No({ width: r7, height: n6 });
            if (Math.log(r7) / Math.LN2 % 1 != 0) throw new Error(`width is not a power of 2 - ${r7}`);
            const s5 = (r8, n7, s6) => {
              e7[t5.evaluationKey] = s6;
              const a4 = t5.expression.evaluate(e7);
              i6.data[r8 + n7 + 0] = Math.floor(255 * a4.r / a4.a), i6.data[r8 + n7 + 1] = Math.floor(255 * a4.g / a4.a), i6.data[r8 + n7 + 2] = Math.floor(255 * a4.b / a4.a), i6.data[r8 + n7 + 3] = Math.floor(255 * a4.a);
            };
            if (t5.clips) for (let e8 = 0, i7 = 0; e8 < n6; ++e8, i7 += 4 * r7) for (let n7 = 0, a4 = 0; n7 < r7; n7++, a4 += 4) {
              const o7 = n7 / (r7 - 1), { start: l5, end: u4 } = t5.clips[e8];
              s5(i7, a4, l5 * (1 - o7) + u4 * o7);
            }
            else for (let t6 = 0, e8 = 0; t6 < r7; t6++, e8 += 4) s5(0, e8, t6 / (r7 - 1));
            return i6;
          }
          Zi("AlphaImage", jo), Zi("RGBAImage", No);
          const qo = "big-fb";
          class Go extends Ps {
            createBucket(t5) {
              return new Fo(t5);
            }
            constructor(t5) {
              super(t5, Lo), this.heatmapFbos = /* @__PURE__ */ new Map(), this._updateColorRamp();
            }
            _handleSpecialPaintPropertyUpdate(t5) {
              "heatmap-color" === t5 && this._updateColorRamp();
            }
            _updateColorRamp() {
              this.colorRamp = Uo({ expression: this._transitionablePaint._values["heatmap-color"].value.expression, evaluationKey: "heatmapDensity", image: this.colorRamp }), this.colorRampTexture = null;
            }
            resize() {
              this.heatmapFbos.has(qo) && this.heatmapFbos.delete(qo);
            }
            queryRadius() {
              return 0;
            }
            queryIntersectsFeature() {
              return false;
            }
            hasOffscreenPass() {
              return 0 !== this.paint.get("heatmap-opacity") && "none" !== this.visibility;
            }
          }
          let Zo;
          var Ko = { get paint() {
            return Zo = Zo || new Is({ "hillshade-illumination-direction": new _s(dt.paint_hillshade["hillshade-illumination-direction"]), "hillshade-illumination-anchor": new _s(dt.paint_hillshade["hillshade-illumination-anchor"]), "hillshade-exaggeration": new _s(dt.paint_hillshade["hillshade-exaggeration"]), "hillshade-shadow-color": new _s(dt.paint_hillshade["hillshade-shadow-color"]), "hillshade-highlight-color": new _s(dt.paint_hillshade["hillshade-highlight-color"]), "hillshade-accent-color": new _s(dt.paint_hillshade["hillshade-accent-color"]) });
          } };
          class Xo extends Ps {
            constructor(t5) {
              super(t5, Ko);
            }
            hasOffscreenPass() {
              return 0 !== this.paint.get("hillshade-exaggeration") && "none" !== this.visibility;
            }
          }
          const Ho = Es([{ name: "a_pos", components: 2, type: "Int16" }], 4), { members: Yo } = Ho;
          function Jo(t5, e7, r7) {
            const n6 = r7.patternDependencies;
            let i6 = false;
            for (const r8 of e7) {
              const e8 = r8.paint.get(`${t5}-pattern`);
              e8.isConstant() || (i6 = true);
              const s5 = e8.constantOr(null);
              s5 && (i6 = true, n6[s5.to] = true, n6[s5.from] = true);
            }
            return i6;
          }
          function Wo(t5, e7, r7, n6, i6) {
            const s5 = i6.patternDependencies;
            for (const a4 of e7) {
              const e8 = a4.paint.get(`${t5}-pattern`).value;
              if ("constant" !== e8.kind) {
                let t6 = e8.evaluate({ zoom: n6 - 1 }, r7, {}, i6.availableImages), o7 = e8.evaluate({ zoom: n6 }, r7, {}, i6.availableImages), l5 = e8.evaluate({ zoom: n6 + 1 }, r7, {}, i6.availableImages);
                t6 = t6 && t6.name ? t6.name : t6, o7 = o7 && o7.name ? o7.name : o7, l5 = l5 && l5.name ? l5.name : l5, s5[t6] = true, s5[o7] = true, s5[l5] = true, r7.patterns[a4.id] = { min: t6, mid: o7, max: l5 };
              }
            }
            return r7;
          }
          function Qo(t5, e7, r7, n6, i6) {
            let s5;
            if (i6 === function(t6, e8, r8, n7) {
              let i7 = 0;
              for (let s6 = e8, a4 = r8 - n7; s6 < r8; s6 += n7) i7 += (t6[a4] - t6[s6]) * (t6[s6 + 1] + t6[a4 + 1]), a4 = s6;
              return i7;
            }(t5, e7, r7, n6) > 0) for (let i7 = e7; i7 < r7; i7 += n6) s5 = wl(i7 / n6 | 0, t5[i7], t5[i7 + 1], s5);
            else for (let i7 = r7 - n6; i7 >= e7; i7 -= n6) s5 = wl(i7 / n6 | 0, t5[i7], t5[i7 + 1], s5);
            return s5 && yl(s5, s5.next) && (_l(s5), s5 = s5.next), s5;
          }
          function tl(t5, e7) {
            if (!t5) return t5;
            e7 || (e7 = t5);
            let r7, n6 = t5;
            do {
              if (r7 = false, n6.steiner || !yl(n6, n6.next) && 0 !== dl(n6.prev, n6, n6.next)) n6 = n6.next;
              else {
                if (_l(n6), n6 = e7 = n6.prev, n6 === n6.next) break;
                r7 = true;
              }
            } while (r7 || n6 !== e7);
            return e7;
          }
          function el(t5, e7, r7, n6, i6, s5, a4) {
            if (!t5) return;
            !a4 && s5 && function(t6, e8, r8, n7) {
              let i7 = t6;
              do {
                0 === i7.z && (i7.z = ul(i7.x, i7.y, e8, r8, n7)), i7.prevZ = i7.prev, i7.nextZ = i7.next, i7 = i7.next;
              } while (i7 !== t6);
              i7.prevZ.nextZ = null, i7.prevZ = null, function(t7) {
                let e9, r9 = 1;
                do {
                  let n8, i8 = t7;
                  t7 = null;
                  let s6 = null;
                  for (e9 = 0; i8; ) {
                    e9++;
                    let a5 = i8, o8 = 0;
                    for (let t8 = 0; t8 < r9 && (o8++, a5 = a5.nextZ, a5); t8++) ;
                    let l5 = r9;
                    for (; o8 > 0 || l5 > 0 && a5; ) 0 !== o8 && (0 === l5 || !a5 || i8.z <= a5.z) ? (n8 = i8, i8 = i8.nextZ, o8--) : (n8 = a5, a5 = a5.nextZ, l5--), s6 ? s6.nextZ = n8 : t7 = n8, n8.prevZ = s6, s6 = n8;
                    i8 = a5;
                  }
                  s6.nextZ = null, r9 *= 2;
                } while (e9 > 1);
              }(i7);
            }(t5, n6, i6, s5);
            let o7 = t5;
            for (; t5.prev !== t5.next; ) {
              const l5 = t5.prev, u4 = t5.next;
              if (s5 ? nl(t5, n6, i6, s5) : rl(t5)) e7.push(l5.i, t5.i, u4.i), _l(t5), t5 = u4.next, o7 = u4.next;
              else if ((t5 = u4) === o7) {
                a4 ? 1 === a4 ? el(t5 = il(tl(t5), e7), e7, r7, n6, i6, s5, 2) : 2 === a4 && sl(t5, e7, r7, n6, i6, s5) : el(tl(t5), e7, r7, n6, i6, s5, 1);
                break;
              }
            }
          }
          function rl(t5) {
            const e7 = t5.prev, r7 = t5, n6 = t5.next;
            if (dl(e7, r7, n6) >= 0) return false;
            const i6 = e7.x, s5 = r7.x, a4 = n6.x, o7 = e7.y, l5 = r7.y, u4 = n6.y, c5 = Math.min(i6, s5, a4), h4 = Math.min(o7, l5, u4), p4 = Math.max(i6, s5, a4), f4 = Math.max(o7, l5, u4);
            let d4 = n6.next;
            for (; d4 !== e7; ) {
              if (d4.x >= c5 && d4.x <= p4 && d4.y >= h4 && d4.y <= f4 && pl(i6, o7, s5, l5, a4, u4, d4.x, d4.y) && dl(d4.prev, d4, d4.next) >= 0) return false;
              d4 = d4.next;
            }
            return true;
          }
          function nl(t5, e7, r7, n6) {
            const i6 = t5.prev, s5 = t5, a4 = t5.next;
            if (dl(i6, s5, a4) >= 0) return false;
            const o7 = i6.x, l5 = s5.x, u4 = a4.x, c5 = i6.y, h4 = s5.y, p4 = a4.y, f4 = Math.min(o7, l5, u4), d4 = Math.min(c5, h4, p4), y4 = Math.max(o7, l5, u4), m4 = Math.max(c5, h4, p4), g4 = ul(f4, d4, e7, r7, n6), x4 = ul(y4, m4, e7, r7, n6);
            let v4 = t5.prevZ, b5 = t5.nextZ;
            for (; v4 && v4.z >= g4 && b5 && b5.z <= x4; ) {
              if (v4.x >= f4 && v4.x <= y4 && v4.y >= d4 && v4.y <= m4 && v4 !== i6 && v4 !== a4 && pl(o7, c5, l5, h4, u4, p4, v4.x, v4.y) && dl(v4.prev, v4, v4.next) >= 0) return false;
              if (v4 = v4.prevZ, b5.x >= f4 && b5.x <= y4 && b5.y >= d4 && b5.y <= m4 && b5 !== i6 && b5 !== a4 && pl(o7, c5, l5, h4, u4, p4, b5.x, b5.y) && dl(b5.prev, b5, b5.next) >= 0) return false;
              b5 = b5.nextZ;
            }
            for (; v4 && v4.z >= g4; ) {
              if (v4.x >= f4 && v4.x <= y4 && v4.y >= d4 && v4.y <= m4 && v4 !== i6 && v4 !== a4 && pl(o7, c5, l5, h4, u4, p4, v4.x, v4.y) && dl(v4.prev, v4, v4.next) >= 0) return false;
              v4 = v4.prevZ;
            }
            for (; b5 && b5.z <= x4; ) {
              if (b5.x >= f4 && b5.x <= y4 && b5.y >= d4 && b5.y <= m4 && b5 !== i6 && b5 !== a4 && pl(o7, c5, l5, h4, u4, p4, b5.x, b5.y) && dl(b5.prev, b5, b5.next) >= 0) return false;
              b5 = b5.nextZ;
            }
            return true;
          }
          function il(t5, e7) {
            let r7 = t5;
            do {
              const n6 = r7.prev, i6 = r7.next.next;
              !yl(n6, i6) && ml(n6, r7, r7.next, i6) && vl(n6, i6) && vl(i6, n6) && (e7.push(n6.i, r7.i, i6.i), _l(r7), _l(r7.next), r7 = t5 = i6), r7 = r7.next;
            } while (r7 !== t5);
            return tl(r7);
          }
          function sl(t5, e7, r7, n6, i6, s5) {
            let a4 = t5;
            do {
              let t6 = a4.next.next;
              for (; t6 !== a4.prev; ) {
                if (a4.i !== t6.i && fl2(a4, t6)) {
                  let o7 = bl(a4, t6);
                  return a4 = tl(a4, a4.next), o7 = tl(o7, o7.next), el(a4, e7, r7, n6, i6, s5, 0), void el(o7, e7, r7, n6, i6, s5, 0);
                }
                t6 = t6.next;
              }
              a4 = a4.next;
            } while (a4 !== t5);
          }
          function al(t5, e7) {
            let r7 = t5.x - e7.x;
            return 0 === r7 && (r7 = t5.y - e7.y, 0 === r7) && (r7 = (t5.next.y - t5.y) / (t5.next.x - t5.x) - (e7.next.y - e7.y) / (e7.next.x - e7.x)), r7;
          }
          function ol(t5, e7) {
            const r7 = function(t6, e8) {
              let r8 = e8;
              const n7 = t6.x, i6 = t6.y;
              let s5, a4 = -1 / 0;
              if (yl(t6, r8)) return r8;
              do {
                if (yl(t6, r8.next)) return r8.next;
                if (i6 <= r8.y && i6 >= r8.next.y && r8.next.y !== r8.y) {
                  const t7 = r8.x + (i6 - r8.y) * (r8.next.x - r8.x) / (r8.next.y - r8.y);
                  if (t7 <= n7 && t7 > a4 && (a4 = t7, s5 = r8.x < r8.next.x ? r8 : r8.next, t7 === n7)) return s5;
                }
                r8 = r8.next;
              } while (r8 !== e8);
              if (!s5) return null;
              const o7 = s5, l5 = s5.x, u4 = s5.y;
              let c5 = 1 / 0;
              r8 = s5;
              do {
                if (n7 >= r8.x && r8.x >= l5 && n7 !== r8.x && hl(i6 < u4 ? n7 : a4, i6, l5, u4, i6 < u4 ? a4 : n7, i6, r8.x, r8.y)) {
                  const e9 = Math.abs(i6 - r8.y) / (n7 - r8.x);
                  vl(r8, t6) && (e9 < c5 || e9 === c5 && (r8.x > s5.x || r8.x === s5.x && ll(s5, r8))) && (s5 = r8, c5 = e9);
                }
                r8 = r8.next;
              } while (r8 !== o7);
              return s5;
            }(t5, e7);
            if (!r7) return e7;
            const n6 = bl(r7, t5);
            return tl(n6, n6.next), tl(r7, r7.next);
          }
          function ll(t5, e7) {
            return dl(t5.prev, t5, e7.prev) < 0 && dl(e7.next, t5, t5.next) < 0;
          }
          function ul(t5, e7, r7, n6, i6) {
            return (t5 = 1431655765 & ((t5 = 858993459 & ((t5 = 252645135 & ((t5 = 16711935 & ((t5 = (t5 - r7) * i6 | 0) | t5 << 8)) | t5 << 4)) | t5 << 2)) | t5 << 1)) | (e7 = 1431655765 & ((e7 = 858993459 & ((e7 = 252645135 & ((e7 = 16711935 & ((e7 = (e7 - n6) * i6 | 0) | e7 << 8)) | e7 << 4)) | e7 << 2)) | e7 << 1)) << 1;
          }
          function cl(t5) {
            let e7 = t5, r7 = t5;
            do {
              (e7.x < r7.x || e7.x === r7.x && e7.y < r7.y) && (r7 = e7), e7 = e7.next;
            } while (e7 !== t5);
            return r7;
          }
          function hl(t5, e7, r7, n6, i6, s5, a4, o7) {
            return (i6 - a4) * (e7 - o7) >= (t5 - a4) * (s5 - o7) && (t5 - a4) * (n6 - o7) >= (r7 - a4) * (e7 - o7) && (r7 - a4) * (s5 - o7) >= (i6 - a4) * (n6 - o7);
          }
          function pl(t5, e7, r7, n6, i6, s5, a4, o7) {
            return !(t5 === a4 && e7 === o7) && hl(t5, e7, r7, n6, i6, s5, a4, o7);
          }
          function fl2(t5, e7) {
            return t5.next.i !== e7.i && t5.prev.i !== e7.i && !function(t6, e8) {
              let r7 = t6;
              do {
                if (r7.i !== t6.i && r7.next.i !== t6.i && r7.i !== e8.i && r7.next.i !== e8.i && ml(r7, r7.next, t6, e8)) return true;
                r7 = r7.next;
              } while (r7 !== t6);
              return false;
            }(t5, e7) && (vl(t5, e7) && vl(e7, t5) && function(t6, e8) {
              let r7 = t6, n6 = false;
              const i6 = (t6.x + e8.x) / 2, s5 = (t6.y + e8.y) / 2;
              do {
                r7.y > s5 != r7.next.y > s5 && r7.next.y !== r7.y && i6 < (r7.next.x - r7.x) * (s5 - r7.y) / (r7.next.y - r7.y) + r7.x && (n6 = !n6), r7 = r7.next;
              } while (r7 !== t6);
              return n6;
            }(t5, e7) && (dl(t5.prev, t5, e7.prev) || dl(t5, e7.prev, e7)) || yl(t5, e7) && dl(t5.prev, t5, t5.next) > 0 && dl(e7.prev, e7, e7.next) > 0);
          }
          function dl(t5, e7, r7) {
            return (e7.y - t5.y) * (r7.x - e7.x) - (e7.x - t5.x) * (r7.y - e7.y);
          }
          function yl(t5, e7) {
            return t5.x === e7.x && t5.y === e7.y;
          }
          function ml(t5, e7, r7, n6) {
            const i6 = xl(dl(t5, e7, r7)), s5 = xl(dl(t5, e7, n6)), a4 = xl(dl(r7, n6, t5)), o7 = xl(dl(r7, n6, e7));
            return i6 !== s5 && a4 !== o7 || !(0 !== i6 || !gl(t5, r7, e7)) || !(0 !== s5 || !gl(t5, n6, e7)) || !(0 !== a4 || !gl(r7, t5, n6)) || !(0 !== o7 || !gl(r7, e7, n6));
          }
          function gl(t5, e7, r7) {
            return e7.x <= Math.max(t5.x, r7.x) && e7.x >= Math.min(t5.x, r7.x) && e7.y <= Math.max(t5.y, r7.y) && e7.y >= Math.min(t5.y, r7.y);
          }
          function xl(t5) {
            return t5 > 0 ? 1 : t5 < 0 ? -1 : 0;
          }
          function vl(t5, e7) {
            return dl(t5.prev, t5, t5.next) < 0 ? dl(t5, e7, t5.next) >= 0 && dl(t5, t5.prev, e7) >= 0 : dl(t5, e7, t5.prev) < 0 || dl(t5, t5.next, e7) < 0;
          }
          function bl(t5, e7) {
            const r7 = Sl(t5.i, t5.x, t5.y), n6 = Sl(e7.i, e7.x, e7.y), i6 = t5.next, s5 = e7.prev;
            return t5.next = e7, e7.prev = t5, r7.next = i6, i6.prev = r7, n6.next = r7, r7.prev = n6, s5.next = n6, n6.prev = s5, n6;
          }
          function wl(t5, e7, r7, n6) {
            const i6 = Sl(t5, e7, r7);
            return n6 ? (i6.next = n6.next, i6.prev = n6, n6.next.prev = i6, n6.next = i6) : (i6.prev = i6, i6.next = i6), i6;
          }
          function _l(t5) {
            t5.next.prev = t5.prev, t5.prev.next = t5.next, t5.prevZ && (t5.prevZ.nextZ = t5.nextZ), t5.nextZ && (t5.nextZ.prevZ = t5.prevZ);
          }
          function Sl(t5, e7, r7) {
            return { i: t5, x: e7, y: r7, prev: null, next: null, z: 0, prevZ: null, nextZ: null, steiner: false };
          }
          class Al {
            constructor(t5, e7) {
              if (e7 > t5) throw new Error("Min granularity must not be greater than base granularity.");
              this._baseZoomGranularity = t5, this._minGranularity = e7;
            }
            getGranularityForZoomLevel(t5) {
              return Math.max(Math.floor(this._baseZoomGranularity / (1 << t5)), this._minGranularity, 1);
            }
          }
          class kl {
            constructor(t5) {
              this.fill = t5.fill, this.line = t5.line, this.tile = t5.tile, this.stencil = t5.stencil, this.circle = t5.circle;
            }
          }
          kl.noSubdivision = new kl({ fill: new Al(0, 0), line: new Al(0, 0), tile: new Al(0, 0), stencil: new Al(0, 0), circle: 1 }), Zi("SubdivisionGranularityExpression", Al), Zi("SubdivisionGranularitySetting", kl);
          const Ml = -32768, Il = 32767;
          class zl {
            constructor(t5, e7) {
              this._vertexBuffer = [], this._vertexDictionary = /* @__PURE__ */ new Map(), this._used = false, this._granularity = t5, this._granularityCellSize = M4 / t5, this._canonical = e7;
            }
            _getKey(t5, e7) {
              return (t5 += 32768) << 16 | (e7 += 32768) << 0;
            }
            _vertexToIndex(t5, e7) {
              if (t5 < -32768 || e7 < -32768 || t5 > 32767 || e7 > 32767) throw new Error("Vertex coordinates are out of signed 16 bit integer range.");
              const r7 = 0 | Math.round(t5), n6 = 0 | Math.round(e7), i6 = this._getKey(r7, n6);
              if (this._vertexDictionary.has(i6)) return this._vertexDictionary.get(i6);
              const s5 = this._vertexBuffer.length / 2;
              return this._vertexDictionary.set(i6, s5), this._vertexBuffer.push(r7, n6), s5;
            }
            _subdivideTrianglesScanline(t5) {
              if (this._granularity < 2) return function(t6, e8) {
                const r8 = [];
                for (let n6 = 0; n6 < e8.length; n6 += 3) {
                  const i6 = e8[n6], s5 = e8[n6 + 1], a4 = e8[n6 + 2], o7 = t6[2 * i6], l5 = t6[2 * i6 + 1];
                  (t6[2 * s5] - o7) * (t6[2 * a4 + 1] - l5) - (t6[2 * s5 + 1] - l5) * (t6[2 * a4] - o7) > 0 ? (r8.push(i6), r8.push(a4), r8.push(s5)) : (r8.push(i6), r8.push(s5), r8.push(a4));
                }
                return r8;
              }(this._vertexBuffer, t5);
              const e7 = [], r7 = t5.length;
              for (let n6 = 0; n6 < r7; n6 += 3) {
                const r8 = [t5[n6 + 0], t5[n6 + 1], t5[n6 + 2]], i6 = [this._vertexBuffer[2 * t5[n6 + 0] + 0], this._vertexBuffer[2 * t5[n6 + 0] + 1], this._vertexBuffer[2 * t5[n6 + 1] + 0], this._vertexBuffer[2 * t5[n6 + 1] + 1], this._vertexBuffer[2 * t5[n6 + 2] + 0], this._vertexBuffer[2 * t5[n6 + 2] + 1]];
                let s5 = 1 / 0, a4 = 1 / 0, o7 = -1 / 0, l5 = -1 / 0;
                for (let t6 = 0; t6 < 3; t6++) {
                  const e8 = i6[2 * t6], r9 = i6[2 * t6 + 1];
                  s5 = Math.min(s5, e8), o7 = Math.max(o7, e8), a4 = Math.min(a4, r9), l5 = Math.max(l5, r9);
                }
                if (s5 === o7 || a4 === l5) continue;
                const u4 = Math.floor(s5 / this._granularityCellSize), c5 = Math.ceil(o7 / this._granularityCellSize), h4 = Math.floor(a4 / this._granularityCellSize), p4 = Math.ceil(l5 / this._granularityCellSize);
                if (u4 !== c5 || h4 !== p4) for (let t6 = h4; t6 < p4; t6++) {
                  const n7 = this._scanlineGenerateVertexRingForCellRow(t6, i6, r8);
                  Bl(this._vertexBuffer, n7, e7);
                }
                else e7.push(...r8);
              }
              return e7;
            }
            _scanlineGenerateVertexRingForCellRow(t5, e7, r7) {
              const n6 = t5 * this._granularityCellSize, i6 = n6 + this._granularityCellSize, s5 = [];
              for (let t6 = 0; t6 < 3; t6++) {
                const a4 = e7[2 * t6], o7 = e7[2 * t6 + 1], l5 = e7[2 * (t6 + 1) % 6], u4 = e7[(2 * (t6 + 1) + 1) % 6], c5 = e7[2 * (t6 + 2) % 6], h4 = e7[(2 * (t6 + 2) + 1) % 6], p4 = l5 - a4, f4 = u4 - o7, d4 = 0 === p4, y4 = 0 === f4, m4 = (n6 - o7) / f4, g4 = (i6 - o7) / f4, x4 = Math.min(m4, g4), v4 = Math.max(m4, g4);
                if (!y4 && (x4 >= 1 || v4 <= 0) || y4 && (o7 < n6 || o7 > i6)) {
                  u4 >= n6 && u4 <= i6 && s5.push(r7[(t6 + 1) % 3]);
                  continue;
                }
                !y4 && x4 > 0 && s5.push(this._vertexToIndex(a4 + p4 * x4, o7 + f4 * x4));
                const b5 = a4 + p4 * Math.max(x4, 0), w4 = a4 + p4 * Math.min(v4, 1);
                d4 || this._generateIntraEdgeVertices(s5, a4, o7, l5, u4, b5, w4), !y4 && v4 < 1 && s5.push(this._vertexToIndex(a4 + p4 * v4, o7 + f4 * v4)), (y4 || u4 >= n6 && u4 <= i6) && s5.push(r7[(t6 + 1) % 3]), !y4 && (u4 <= n6 || u4 >= i6) && this._generateInterEdgeVertices(s5, a4, o7, l5, u4, c5, h4, w4, n6, i6);
              }
              return s5;
            }
            _generateIntraEdgeVertices(t5, e7, r7, n6, i6, s5, a4) {
              const o7 = n6 - e7, l5 = i6 - r7, u4 = 0 === l5, c5 = u4 ? Math.min(e7, n6) : Math.min(s5, a4), h4 = u4 ? Math.max(e7, n6) : Math.max(s5, a4), p4 = Math.floor(c5 / this._granularityCellSize) + 1, f4 = Math.ceil(h4 / this._granularityCellSize) - 1;
              if (u4 ? e7 < n6 : s5 < a4) for (let n7 = p4; n7 <= f4; n7++) {
                const i7 = n7 * this._granularityCellSize;
                t5.push(this._vertexToIndex(i7, r7 + l5 * (i7 - e7) / o7));
              }
              else for (let n7 = f4; n7 >= p4; n7--) {
                const i7 = n7 * this._granularityCellSize;
                t5.push(this._vertexToIndex(i7, r7 + l5 * (i7 - e7) / o7));
              }
            }
            _generateInterEdgeVertices(t5, e7, r7, n6, i6, s5, a4, o7, l5, u4) {
              const c5 = i6 - r7, h4 = s5 - n6, p4 = a4 - i6, f4 = (l5 - i6) / p4, d4 = (u4 - i6) / p4, y4 = Math.min(f4, d4), m4 = Math.max(f4, d4), g4 = n6 + h4 * y4;
              let x4 = Math.floor(Math.min(g4, o7) / this._granularityCellSize) + 1, v4 = Math.ceil(Math.max(g4, o7) / this._granularityCellSize) - 1, b5 = o7 < g4;
              const w4 = 0 === p4;
              if (w4 && (a4 === l5 || a4 === u4)) return;
              if (w4 || y4 >= 1 || m4 <= 0) {
                const t6 = r7 - a4, n7 = s5 + (e7 - s5) * Math.min((l5 - a4) / t6, (u4 - a4) / t6);
                x4 = Math.floor(Math.min(n7, o7) / this._granularityCellSize) + 1, v4 = Math.ceil(Math.max(n7, o7) / this._granularityCellSize) - 1, b5 = o7 < n7;
              }
              const _4 = c5 > 0 ? u4 : l5;
              if (b5) for (let e8 = x4; e8 <= v4; e8++) t5.push(this._vertexToIndex(e8 * this._granularityCellSize, _4));
              else for (let e8 = v4; e8 >= x4; e8--) t5.push(this._vertexToIndex(e8 * this._granularityCellSize, _4));
            }
            _generateOutline(t5) {
              const e7 = [];
              for (const r7 of t5) {
                const t6 = Cl(r7, this._granularity, true), n6 = this._pointArrayToIndices(t6), i6 = [];
                for (let t7 = 1; t7 < n6.length; t7++) i6.push(n6[t7 - 1]), i6.push(n6[t7]);
                e7.push(i6);
              }
              return e7;
            }
            _handlePoles(t5) {
              let e7 = false, r7 = false;
              this._canonical && (0 === this._canonical.y && (e7 = true), this._canonical.y === (1 << this._canonical.z) - 1 && (r7 = true)), (e7 || r7) && this._fillPoles(t5, e7, r7);
            }
            _ensureNoPoleVertices() {
              const t5 = this._vertexBuffer;
              for (let e7 = 0; e7 < t5.length; e7 += 2) {
                const r7 = t5[e7 + 1];
                r7 === Ml && (t5[e7 + 1] = -32767), r7 === Il && (t5[e7 + 1] = 32766);
              }
            }
            _generatePoleQuad(t5, e7, r7, n6, i6, s5) {
              n6 > i6 != (s5 === Ml) ? (t5.push(e7), t5.push(r7), t5.push(this._vertexToIndex(n6, s5)), t5.push(r7), t5.push(this._vertexToIndex(i6, s5)), t5.push(this._vertexToIndex(n6, s5))) : (t5.push(r7), t5.push(e7), t5.push(this._vertexToIndex(n6, s5)), t5.push(this._vertexToIndex(i6, s5)), t5.push(r7), t5.push(this._vertexToIndex(n6, s5)));
            }
            _fillPoles(t5, e7, r7) {
              const n6 = this._vertexBuffer, i6 = M4, s5 = t5.length;
              for (let a4 = 2; a4 < s5; a4 += 3) {
                const s6 = t5[a4 - 2], o7 = t5[a4 - 1], l5 = t5[a4], u4 = n6[2 * s6], c5 = n6[2 * s6 + 1], h4 = n6[2 * o7], p4 = n6[2 * o7 + 1], f4 = n6[2 * l5], d4 = n6[2 * l5 + 1];
                e7 && (0 === c5 && 0 === p4 && this._generatePoleQuad(t5, s6, o7, u4, h4, Ml), 0 === p4 && 0 === d4 && this._generatePoleQuad(t5, o7, l5, h4, f4, Ml), 0 === d4 && 0 === c5 && this._generatePoleQuad(t5, l5, s6, f4, u4, Ml)), r7 && (c5 === i6 && p4 === i6 && this._generatePoleQuad(t5, s6, o7, u4, h4, Il), p4 === i6 && d4 === i6 && this._generatePoleQuad(t5, o7, l5, h4, f4, Il), d4 === i6 && c5 === i6 && this._generatePoleQuad(t5, l5, s6, f4, u4, Il));
              }
            }
            _initializeVertices(t5) {
              for (let e7 = 0; e7 < t5.length; e7 += 2) this._vertexToIndex(t5[e7], t5[e7 + 1]);
            }
            subdividePolygonInternal(t5, e7) {
              if (this._used) throw new Error("Subdivision: multiple use not allowed.");
              this._used = true;
              const { flattened: r7, holeIndices: n6 } = function(t6) {
                const e8 = [], r8 = [];
                for (const n7 of t6) if (0 !== n7.length) {
                  n7 !== t6[0] && e8.push(r8.length / 2);
                  for (let t7 = 0; t7 < n7.length; t7++) r8.push(n7[t7].x), r8.push(n7[t7].y);
                }
                return { flattened: r8, holeIndices: e8 };
              }(t5);
              let i6;
              this._initializeVertices(r7);
              try {
                const t6 = function(t7, e9, r8 = 2) {
                  const n7 = e9 && e9.length, i7 = n7 ? e9[0] * r8 : t7.length;
                  let s6 = Qo(t7, 0, i7, r8, true);
                  const a4 = [];
                  if (!s6 || s6.next === s6.prev) return a4;
                  let o7, l5, u4;
                  if (n7 && (s6 = function(t8, e10, r9, n8) {
                    const i8 = [];
                    for (let r10 = 0, s7 = e10.length; r10 < s7; r10++) {
                      const a5 = Qo(t8, e10[r10] * n8, r10 < s7 - 1 ? e10[r10 + 1] * n8 : t8.length, n8, false);
                      a5 === a5.next && (a5.steiner = true), i8.push(cl(a5));
                    }
                    i8.sort(al);
                    for (let t9 = 0; t9 < i8.length; t9++) r9 = ol(i8[t9], r9);
                    return r9;
                  }(t7, e9, s6, r8)), t7.length > 80 * r8) {
                    o7 = 1 / 0, l5 = 1 / 0;
                    let e10 = -1 / 0, n8 = -1 / 0;
                    for (let s7 = r8; s7 < i7; s7 += r8) {
                      const r9 = t7[s7], i8 = t7[s7 + 1];
                      r9 < o7 && (o7 = r9), i8 < l5 && (l5 = i8), r9 > e10 && (e10 = r9), i8 > n8 && (n8 = i8);
                    }
                    u4 = Math.max(e10 - o7, n8 - l5), u4 = 0 !== u4 ? 32767 / u4 : 0;
                  }
                  return el(s6, a4, r8, o7, l5, u4, 0), a4;
                }(r7, n6), e8 = this._convertIndices(r7, t6);
                i6 = this._subdivideTrianglesScanline(e8);
              } catch (t6) {
                console.error(t6);
              }
              let s5 = [];
              return e7 && (s5 = this._generateOutline(t5)), this._ensureNoPoleVertices(), this._handlePoles(i6), { verticesFlattened: this._vertexBuffer, indicesTriangles: i6, indicesLineList: s5 };
            }
            _convertIndices(t5, e7) {
              const r7 = [];
              for (let n6 = 0; n6 < e7.length; n6++) r7.push(this._vertexToIndex(t5[2 * e7[n6]], t5[2 * e7[n6] + 1]));
              return r7;
            }
            _pointArrayToIndices(t5) {
              const e7 = [];
              for (let r7 = 0; r7 < t5.length; r7++) {
                const n6 = t5[r7];
                e7.push(this._vertexToIndex(n6.x, n6.y));
              }
              return e7;
            }
          }
          function Pl(t5, e7, r7, n6 = true) {
            return new zl(r7, e7).subdividePolygonInternal(t5, n6);
          }
          function Cl(t5, e7, r7 = false) {
            if (!t5 || t5.length < 1) return [];
            if (t5.length < 2) return [];
            const n6 = t5[0], i6 = t5[t5.length - 1], s5 = r7 && (n6.x !== i6.x || n6.y !== i6.y);
            if (e7 < 2) return s5 ? [...t5, t5[0]] : [...t5];
            const a4 = Math.floor(M4 / e7), o7 = [];
            o7.push(new l4(t5[0].x, t5[0].y));
            const u4 = t5.length, c5 = s5 ? u4 : u4 - 1;
            for (let e8 = 0; e8 < c5; e8++) {
              const r8 = t5[e8], n7 = e8 < u4 - 1 ? t5[e8 + 1] : t5[0], i7 = r8.x, s6 = r8.y, c6 = n7.x, h4 = n7.y, p4 = i7 !== c6, f4 = s6 !== h4;
              if (!p4 && !f4) continue;
              const d4 = c6 - i7, y4 = h4 - s6, m4 = Math.abs(d4), g4 = Math.abs(y4);
              let x4 = i7, v4 = s6;
              for (; ; ) {
                const t6 = d4 > 0 ? (Math.floor(x4 / a4) + 1) * a4 : (Math.ceil(x4 / a4) - 1) * a4, e9 = y4 > 0 ? (Math.floor(v4 / a4) + 1) * a4 : (Math.ceil(v4 / a4) - 1) * a4, r9 = Math.abs(x4 - t6), n8 = Math.abs(v4 - e9), i8 = Math.abs(x4 - c6), s7 = Math.abs(v4 - h4), u5 = p4 ? r9 / m4 : Number.POSITIVE_INFINITY, b6 = f4 ? n8 / g4 : Number.POSITIVE_INFINITY;
                if ((i8 <= r9 || !p4) && (s7 <= n8 || !f4)) break;
                if (u5 < b6 && p4 || !f4) {
                  x4 = t6, v4 += y4 * u5;
                  const e10 = new l4(x4, Math.round(v4));
                  o7[o7.length - 1].x === e10.x && o7[o7.length - 1].y === e10.y || o7.push(e10);
                } else {
                  x4 += d4 * b6, v4 = e9;
                  const t7 = new l4(Math.round(x4), v4);
                  o7[o7.length - 1].x === t7.x && o7[o7.length - 1].y === t7.y || o7.push(t7);
                }
              }
              const b5 = new l4(c6, h4);
              o7[o7.length - 1].x === b5.x && o7[o7.length - 1].y === b5.y || o7.push(b5);
            }
            return o7;
          }
          function Bl(t5, e7, r7) {
            if (0 === e7.length) throw new Error("Subdivision vertex ring is empty.");
            let n6 = 0, i6 = t5[2 * e7[0]];
            for (let r8 = 1; r8 < e7.length; r8++) {
              const s6 = t5[2 * e7[r8]];
              s6 < i6 && (i6 = s6, n6 = r8);
            }
            const s5 = e7.length;
            let a4 = n6, o7 = (a4 + 1) % s5;
            for (; ; ) {
              const n7 = a4 - 1 >= 0 ? a4 - 1 : s5 - 1, i7 = (o7 + 1) % s5, l5 = t5[2 * e7[n7]], u4 = t5[2 * e7[i7]], c5 = t5[2 * e7[a4]], h4 = t5[2 * e7[a4] + 1], p4 = t5[2 * e7[o7] + 1];
              let f4 = false;
              if (l5 < u4) f4 = true;
              else if (l5 > u4) f4 = false;
              else {
                const r8 = p4 - h4, s6 = -(t5[2 * e7[o7]] - c5), a5 = h4 < p4 ? 1 : -1;
                ((l5 - c5) * r8 + (t5[2 * e7[n7] + 1] - h4) * s6) * a5 > ((u4 - c5) * r8 + (t5[2 * e7[i7] + 1] - h4) * s6) * a5 && (f4 = true);
              }
              if (f4) {
                const t6 = e7[n7], i8 = e7[a4], l6 = e7[o7];
                t6 !== i8 && t6 !== l6 && i8 !== l6 && r7.push(l6, i8, t6), a4--, a4 < 0 && (a4 = s5 - 1);
              } else {
                const t6 = e7[i7], n8 = e7[a4], l6 = e7[o7];
                t6 !== n8 && t6 !== l6 && n8 !== l6 && r7.push(l6, n8, t6), o7++, o7 >= s5 && (o7 = 0);
              }
              if (n7 === i7) break;
            }
          }
          function Vl(t5, e7, r7, n6, i6, s5, a4, o7, l5) {
            const u4 = i6.length / 2, c5 = a4 && o7 && l5;
            if (u4 < Va.MAX_VERTEX_ARRAY_LENGTH) {
              const h4 = e7.prepareSegment(u4, r7, n6), p4 = h4.vertexLength;
              for (let t6 = 0; t6 < s5.length; t6 += 3) n6.emplaceBack(p4 + s5[t6], p4 + s5[t6 + 1], p4 + s5[t6 + 2]);
              let f4, d4;
              h4.vertexLength += u4, h4.primitiveLength += s5.length / 3, c5 && (d4 = a4.prepareSegment(u4, r7, o7), f4 = d4.vertexLength, d4.vertexLength += u4);
              for (let e8 = 0; e8 < i6.length; e8 += 2) t5(i6[e8], i6[e8 + 1]);
              if (c5) for (let t6 = 0; t6 < l5.length; t6++) {
                const e8 = l5[t6];
                for (let t7 = 1; t7 < e8.length; t7 += 2) o7.emplaceBack(f4 + e8[t7 - 1], f4 + e8[t7]);
                d4.primitiveLength += e8.length / 2;
              }
            } else !function(t6, e8, r8, n7, i7, s6) {
              const a5 = [];
              for (let t7 = 0; t7 < n7.length / 2; t7++) a5.push(-1);
              const o8 = { count: 0 };
              let l6 = 0, u5 = t6.getOrCreateLatestSegment(e8, r8), c6 = u5.vertexLength;
              for (let h4 = 2; h4 < i7.length; h4 += 3) {
                const p4 = i7[h4 - 2], f4 = i7[h4 - 1], d4 = i7[h4];
                let y4 = a5[p4] < l6, m4 = a5[f4] < l6, g4 = a5[d4] < l6;
                u5.vertexLength + ((y4 ? 1 : 0) + (m4 ? 1 : 0) + (g4 ? 1 : 0)) > Va.MAX_VERTEX_ARRAY_LENGTH && (u5 = t6.createNewSegment(e8, r8), l6 = o8.count, y4 = true, m4 = true, g4 = true, c6 = 0);
                const x4 = El(a5, n7, s6, o8, p4, y4, u5), v4 = El(a5, n7, s6, o8, f4, m4, u5), b5 = El(a5, n7, s6, o8, d4, g4, u5);
                r8.emplaceBack(c6 + x4 - l6, c6 + v4 - l6, c6 + b5 - l6), u5.primitiveLength++;
              }
            }(e7, r7, n6, i6, s5, t5), c5 && function(t6, e8, r8, n7, i7, s6) {
              const a5 = [];
              for (let t7 = 0; t7 < n7.length / 2; t7++) a5.push(-1);
              const o8 = { count: 0 };
              let l6 = 0, u5 = t6.getOrCreateLatestSegment(e8, r8), c6 = u5.vertexLength;
              for (let h4 = 0; h4 < i7.length; h4++) {
                const p4 = i7[h4];
                for (let f4 = 1; f4 < i7[h4].length; f4 += 2) {
                  const i8 = p4[f4 - 1], h5 = p4[f4];
                  let d4 = a5[i8] < l6, y4 = a5[h5] < l6;
                  u5.vertexLength + ((d4 ? 1 : 0) + (y4 ? 1 : 0)) > Va.MAX_VERTEX_ARRAY_LENGTH && (u5 = t6.createNewSegment(e8, r8), l6 = o8.count, d4 = true, y4 = true, c6 = 0);
                  const m4 = El(a5, n7, s6, o8, i8, d4, u5), g4 = El(a5, n7, s6, o8, h5, y4, u5);
                  r8.emplaceBack(c6 + m4 - l6, c6 + g4 - l6), u5.primitiveLength++;
                }
              }
            }(a4, r7, o7, i6, l5, t5), e7.forceNewSegmentOnNextPrepare(), null == a4 || a4.forceNewSegmentOnNextPrepare();
          }
          function El(t5, e7, r7, n6, i6, s5, a4) {
            if (s5) {
              const s6 = n6.count;
              return r7(e7[2 * i6], e7[2 * i6 + 1]), t5[i6] = n6.count, n6.count++, a4.vertexLength++, s6;
            }
            return t5[i6];
          }
          class Tl {
            constructor(t5) {
              this.zoom = t5.zoom, this.overscaling = t5.overscaling, this.layers = t5.layers, this.layerIds = this.layers.map((t6) => t6.id), this.index = t5.index, this.hasPattern = false, this.patternFeatures = [], this.layoutVertexArray = new xa(), this.indexArray = new za(), this.indexArray2 = new Pa(), this.programConfigurations = new so(t5.layers, t5.zoom), this.segments = new Va(), this.segments2 = new Va(), this.stateDependentLayerIds = this.layers.filter((t6) => t6.isStateDependent()).map((t6) => t6.id);
            }
            populate(t5, e7, r7) {
              this.hasPattern = Jo("fill", this.layers, e7);
              const n6 = this.layers[0].layout.get("fill-sort-key"), i6 = !n6.isConstant(), s5 = [];
              for (const { feature: a4, id: o7, index: l5, sourceLayerIndex: u4 } of t5) {
                const t6 = this.layers[0]._featureFilter.needGeometry, c5 = ho(a4, t6);
                if (!this.layers[0]._featureFilter.filter(new fs(this.zoom), c5, r7)) continue;
                const h4 = i6 ? n6.evaluate(c5, {}, r7, e7.availableImages) : void 0, p4 = { id: o7, properties: a4.properties, type: a4.type, sourceLayerIndex: u4, index: l5, geometry: t6 ? c5.geometry : co(a4), patterns: {}, sortKey: h4 };
                s5.push(p4);
              }
              i6 && s5.sort((t6, e8) => t6.sortKey - e8.sortKey);
              for (const n7 of s5) {
                const { geometry: i7, index: s6, sourceLayerIndex: a4 } = n7;
                if (this.hasPattern) {
                  const t6 = Wo("fill", this.layers, n7, this.zoom, e7);
                  this.patternFeatures.push(t6);
                } else this.addFeature(n7, i7, s6, r7, {}, e7.subdivisionGranularity);
                e7.featureIndex.insert(t5[s6].feature, i7, s6, a4, this.index);
              }
            }
            update(t5, e7, r7) {
              this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t5, e7, this.stateDependentLayers, r7);
            }
            addFeatures(t5, e7, r7) {
              for (const n6 of this.patternFeatures) this.addFeature(n6, n6.geometry, n6.index, e7, r7, t5.subdivisionGranularity);
            }
            isEmpty() {
              return 0 === this.layoutVertexArray.length;
            }
            uploadPending() {
              return !this.uploaded || this.programConfigurations.needsUpload;
            }
            upload(t5) {
              this.uploaded || (this.layoutVertexBuffer = t5.createVertexBuffer(this.layoutVertexArray, Yo), this.indexBuffer = t5.createIndexBuffer(this.indexArray), this.indexBuffer2 = t5.createIndexBuffer(this.indexArray2)), this.programConfigurations.upload(t5), this.uploaded = true;
            }
            destroy() {
              this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.indexBuffer2.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.segments2.destroy());
            }
            addFeature(t5, e7, r7, n6, i6, s5) {
              for (const t6 of Ur(e7, 500)) {
                const e8 = Pl(t6, n6, s5.fill.getGranularityForZoomLevel(n6.z)), r8 = this.layoutVertexArray;
                Vl((t7, e9) => {
                  r8.emplaceBack(t7, e9);
                }, this.segments, this.layoutVertexArray, this.indexArray, e8.verticesFlattened, e8.indicesTriangles, this.segments2, this.indexArray2, e8.indicesLineList);
              }
              this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t5, r7, i6, n6);
            }
          }
          let Fl, $l;
          Zi("FillBucket", Tl, { omit: ["layers", "patternFeatures"] });
          var Ll = { get paint() {
            return $l = $l || new Is({ "fill-antialias": new _s(dt.paint_fill["fill-antialias"]), "fill-opacity": new Ss(dt.paint_fill["fill-opacity"]), "fill-color": new Ss(dt.paint_fill["fill-color"]), "fill-outline-color": new Ss(dt.paint_fill["fill-outline-color"]), "fill-translate": new _s(dt.paint_fill["fill-translate"]), "fill-translate-anchor": new _s(dt.paint_fill["fill-translate-anchor"]), "fill-pattern": new As(dt.paint_fill["fill-pattern"]) });
          }, get layout() {
            return Fl = Fl || new Is({ "fill-sort-key": new Ss(dt.layout_fill["fill-sort-key"]) });
          } };
          class Ol extends Ps {
            constructor(t5) {
              super(t5, Ll);
            }
            recalculate(t5, e7) {
              super.recalculate(t5, e7);
              const r7 = this.paint._values["fill-outline-color"];
              "constant" === r7.value.kind && void 0 === r7.value.value && (this.paint._values["fill-outline-color"] = this.paint._values["fill-color"]);
            }
            createBucket(t5) {
              return new Tl(t5);
            }
            queryRadius() {
              return zo(this.paint.get("fill-translate"));
            }
            queryIntersectsFeature({ queryGeometry: t5, geometry: e7, transform: r7, pixelsToTileUnits: n6 }) {
              return xo(Po(t5, this.paint.get("fill-translate"), this.paint.get("fill-translate-anchor"), -r7.bearingInRadians, n6), e7);
            }
            isTileClipped() {
              return true;
            }
          }
          const Dl = Es([{ name: "a_pos", components: 2, type: "Int16" }, { name: "a_normal_ed", components: 4, type: "Int16" }], 4), Rl = Es([{ name: "a_centroid", components: 2, type: "Int16" }], 4), { members: jl } = Dl;
          var Nl, Ul, ql, Gl, Zl, Kl, Xl, Hl = {};
          function Yl() {
            if (Ul) return Nl;
            Ul = 1;
            var t5 = s4();
            function e7(t6, e8, n7, i6, s5) {
              this.properties = {}, this.extent = n7, this.type = 0, this._pbf = t6, this._geometry = -1, this._keys = i6, this._values = s5, t6.readFields(r7, this, e8);
            }
            function r7(t6, e8, r8) {
              1 == t6 ? e8.id = r8.readVarint() : 2 == t6 ? function(t7, e9) {
                for (var r9 = t7.readVarint() + t7.pos; t7.pos < r9; ) {
                  var n7 = e9._keys[t7.readVarint()], i6 = e9._values[t7.readVarint()];
                  e9.properties[n7] = i6;
                }
              }(r8, e8) : 3 == t6 ? e8.type = r8.readVarint() : 4 == t6 && (e8._geometry = r8.pos);
            }
            function n6(t6) {
              for (var e8, r8, n7 = 0, i6 = 0, s5 = t6.length, a4 = s5 - 1; i6 < s5; a4 = i6++) n7 += ((r8 = t6[a4]).x - (e8 = t6[i6]).x) * (e8.y + r8.y);
              return n7;
            }
            return Nl = e7, e7.types = ["Unknown", "Point", "LineString", "Polygon"], e7.prototype.loadGeometry = function() {
              var e8 = this._pbf;
              e8.pos = this._geometry;
              for (var r8, n7 = e8.readVarint() + e8.pos, i6 = 1, s5 = 0, a4 = 0, o7 = 0, l5 = []; e8.pos < n7; ) {
                if (s5 <= 0) {
                  var u4 = e8.readVarint();
                  i6 = 7 & u4, s5 = u4 >> 3;
                }
                if (s5--, 1 === i6 || 2 === i6) a4 += e8.readSVarint(), o7 += e8.readSVarint(), 1 === i6 && (r8 && l5.push(r8), r8 = []), r8.push(new t5(a4, o7));
                else {
                  if (7 !== i6) throw new Error("unknown command " + i6);
                  r8 && r8.push(r8[0].clone());
                }
              }
              return r8 && l5.push(r8), l5;
            }, e7.prototype.bbox = function() {
              var t6 = this._pbf;
              t6.pos = this._geometry;
              for (var e8 = t6.readVarint() + t6.pos, r8 = 1, n7 = 0, i6 = 0, s5 = 0, a4 = 1 / 0, o7 = -1 / 0, l5 = 1 / 0, u4 = -1 / 0; t6.pos < e8; ) {
                if (n7 <= 0) {
                  var c5 = t6.readVarint();
                  r8 = 7 & c5, n7 = c5 >> 3;
                }
                if (n7--, 1 === r8 || 2 === r8) (i6 += t6.readSVarint()) < a4 && (a4 = i6), i6 > o7 && (o7 = i6), (s5 += t6.readSVarint()) < l5 && (l5 = s5), s5 > u4 && (u4 = s5);
                else if (7 !== r8) throw new Error("unknown command " + r8);
              }
              return [a4, l5, o7, u4];
            }, e7.prototype.toGeoJSON = function(t6, r8, i6) {
              var s5, a4, o7 = this.extent * Math.pow(2, i6), l5 = this.extent * t6, u4 = this.extent * r8, c5 = this.loadGeometry(), h4 = e7.types[this.type];
              function p4(t7) {
                for (var e8 = 0; e8 < t7.length; e8++) {
                  var r9 = t7[e8];
                  t7[e8] = [360 * (r9.x + l5) / o7 - 180, 360 / Math.PI * Math.atan(Math.exp((180 - 360 * (r9.y + u4) / o7) * Math.PI / 180)) - 90];
                }
              }
              switch (this.type) {
                case 1:
                  var f4 = [];
                  for (s5 = 0; s5 < c5.length; s5++) f4[s5] = c5[s5][0];
                  p4(c5 = f4);
                  break;
                case 2:
                  for (s5 = 0; s5 < c5.length; s5++) p4(c5[s5]);
                  break;
                case 3:
                  for (c5 = function(t7) {
                    var e8 = t7.length;
                    if (e8 <= 1) return [t7];
                    for (var r9, i7, s6 = [], a5 = 0; a5 < e8; a5++) {
                      var o8 = n6(t7[a5]);
                      0 !== o8 && (void 0 === i7 && (i7 = o8 < 0), i7 === o8 < 0 ? (r9 && s6.push(r9), r9 = [t7[a5]]) : r9.push(t7[a5]));
                    }
                    return r9 && s6.push(r9), s6;
                  }(c5), s5 = 0; s5 < c5.length; s5++) for (a4 = 0; a4 < c5[s5].length; a4++) p4(c5[s5][a4]);
              }
              1 === c5.length ? c5 = c5[0] : h4 = "Multi" + h4;
              var d4 = { type: "Feature", geometry: { type: h4, coordinates: c5 }, properties: this.properties };
              return "id" in this && (d4.id = this.id), d4;
            }, Nl;
          }
          function Jl() {
            if (Gl) return ql;
            Gl = 1;
            var t5 = Yl();
            function e7(t6, e8) {
              this.version = 1, this.name = null, this.extent = 4096, this.length = 0, this._pbf = t6, this._keys = [], this._values = [], this._features = [], t6.readFields(r7, this, e8), this.length = this._features.length;
            }
            function r7(t6, e8, r8) {
              15 === t6 ? e8.version = r8.readVarint() : 1 === t6 ? e8.name = r8.readString() : 5 === t6 ? e8.extent = r8.readVarint() : 2 === t6 ? e8._features.push(r8.pos) : 3 === t6 ? e8._keys.push(r8.readString()) : 4 === t6 && e8._values.push(function(t7) {
                for (var e9 = null, r9 = t7.readVarint() + t7.pos; t7.pos < r9; ) {
                  var n6 = t7.readVarint() >> 3;
                  e9 = 1 === n6 ? t7.readString() : 2 === n6 ? t7.readFloat() : 3 === n6 ? t7.readDouble() : 4 === n6 ? t7.readVarint64() : 5 === n6 ? t7.readVarint() : 6 === n6 ? t7.readSVarint() : 7 === n6 ? t7.readBoolean() : null;
                }
                return e9;
              }(r8));
            }
            return ql = e7, e7.prototype.feature = function(e8) {
              if (e8 < 0 || e8 >= this._features.length) throw new Error("feature index out of bounds");
              this._pbf.pos = this._features[e8];
              var r8 = this._pbf.readVarint() + this._pbf.pos;
              return new t5(this._pbf, r8, this.extent, this._keys, this._values);
            }, ql;
          }
          function Wl() {
            return Xl || (Xl = 1, Hl.VectorTile = function() {
              if (Kl) return Zl;
              Kl = 1;
              var t5 = Jl();
              function e7(e8, r7, n6) {
                if (3 === e8) {
                  var i6 = new t5(n6, n6.readVarint() + n6.pos);
                  i6.length && (r7[i6.name] = i6);
                }
              }
              return Zl = function(t6, r7) {
                this.layers = t6.readFields(e7, {}, r7);
              }, Zl;
            }(), Hl.VectorTileFeature = Yl(), Hl.VectorTileLayer = Jl()), Hl;
          }
          var Ql = r6(Wl());
          const tu = Ql.VectorTileFeature.types, eu = Math.pow(2, 13);
          function ru(t5, e7, r7, n6, i6, s5, a4, o7) {
            t5.emplaceBack(e7, r7, 2 * Math.floor(n6 * eu) + a4, i6 * eu * 2, s5 * eu * 2, Math.round(o7));
          }
          class nu {
            constructor(t5) {
              this.zoom = t5.zoom, this.overscaling = t5.overscaling, this.layers = t5.layers, this.layerIds = this.layers.map((t6) => t6.id), this.index = t5.index, this.hasPattern = false, this.layoutVertexArray = new va(), this.centroidVertexArray = new ma(), this.indexArray = new za(), this.programConfigurations = new so(t5.layers, t5.zoom), this.segments = new Va(), this.stateDependentLayerIds = this.layers.filter((t6) => t6.isStateDependent()).map((t6) => t6.id);
            }
            populate(t5, e7, r7) {
              this.features = [], this.hasPattern = Jo("fill-extrusion", this.layers, e7);
              for (const { feature: n6, id: i6, index: s5, sourceLayerIndex: a4 } of t5) {
                const t6 = this.layers[0]._featureFilter.needGeometry, o7 = ho(n6, t6);
                if (!this.layers[0]._featureFilter.filter(new fs(this.zoom), o7, r7)) continue;
                const l5 = { id: i6, sourceLayerIndex: a4, index: s5, geometry: t6 ? o7.geometry : co(n6), properties: n6.properties, type: n6.type, patterns: {} };
                this.hasPattern ? this.features.push(Wo("fill-extrusion", this.layers, l5, this.zoom, e7)) : this.addFeature(l5, l5.geometry, s5, r7, {}, e7.subdivisionGranularity), e7.featureIndex.insert(n6, l5.geometry, s5, a4, this.index, true);
              }
            }
            addFeatures(t5, e7, r7) {
              for (const n6 of this.features) {
                const { geometry: i6 } = n6;
                this.addFeature(n6, i6, n6.index, e7, r7, t5.subdivisionGranularity);
              }
            }
            update(t5, e7, r7) {
              this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t5, e7, this.stateDependentLayers, r7);
            }
            isEmpty() {
              return 0 === this.layoutVertexArray.length && 0 === this.centroidVertexArray.length;
            }
            uploadPending() {
              return !this.uploaded || this.programConfigurations.needsUpload;
            }
            upload(t5) {
              this.uploaded || (this.layoutVertexBuffer = t5.createVertexBuffer(this.layoutVertexArray, jl), this.centroidVertexBuffer = t5.createVertexBuffer(this.centroidVertexArray, Rl.members, true), this.indexBuffer = t5.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(t5), this.uploaded = true;
            }
            destroy() {
              this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.centroidVertexBuffer.destroy());
            }
            addFeature(t5, e7, r7, n6, i6, s5) {
              for (const r8 of Ur(e7, 500)) {
                const e8 = { x: 0, y: 0, sampleCount: 0 }, i7 = this.layoutVertexArray.length;
                this.processPolygon(e8, n6, t5, r8, s5);
                const a4 = this.layoutVertexArray.length - i7, o7 = Math.floor(e8.x / e8.sampleCount), l5 = Math.floor(e8.y / e8.sampleCount);
                for (let t6 = 0; t6 < a4; t6++) this.centroidVertexArray.emplaceBack(o7, l5);
              }
              this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t5, r7, i6, n6);
            }
            processPolygon(t5, e7, r7, n6, i6) {
              if (n6.length < 1) return;
              if (au(n6[0])) return;
              for (const e8 of n6) 0 !== e8.length && iu(t5, e8);
              const s5 = { segment: this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray) }, a4 = i6.fill.getGranularityForZoomLevel(e7.z), o7 = "Polygon" === tu[r7.type];
              for (const t6 of n6) {
                if (0 === t6.length) continue;
                if (au(t6)) continue;
                const e8 = Cl(t6, a4, o7);
                this._generateSideFaces(e8, s5);
              }
              if (!o7) return;
              const l5 = Pl(n6, e7, a4, false), u4 = this.layoutVertexArray;
              Vl((t6, e8) => {
                ru(u4, t6, e8, 0, 0, 1, 1, 0);
              }, this.segments, this.layoutVertexArray, this.indexArray, l5.verticesFlattened, l5.indicesTriangles);
            }
            _generateSideFaces(t5, e7) {
              let r7 = 0;
              for (let n6 = 1; n6 < t5.length; n6++) {
                const i6 = t5[n6], s5 = t5[n6 - 1];
                if (su(i6, s5)) continue;
                e7.segment.vertexLength + 4 > Va.MAX_VERTEX_ARRAY_LENGTH && (e7.segment = this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray));
                const a4 = i6.sub(s5)._perp()._unit(), o7 = s5.dist(i6);
                r7 + o7 > 32768 && (r7 = 0), ru(this.layoutVertexArray, i6.x, i6.y, a4.x, a4.y, 0, 0, r7), ru(this.layoutVertexArray, i6.x, i6.y, a4.x, a4.y, 0, 1, r7), r7 += o7, ru(this.layoutVertexArray, s5.x, s5.y, a4.x, a4.y, 0, 0, r7), ru(this.layoutVertexArray, s5.x, s5.y, a4.x, a4.y, 0, 1, r7);
                const l5 = e7.segment.vertexLength;
                this.indexArray.emplaceBack(l5, l5 + 2, l5 + 1), this.indexArray.emplaceBack(l5 + 1, l5 + 2, l5 + 3), e7.segment.vertexLength += 4, e7.segment.primitiveLength += 2;
              }
            }
          }
          function iu(t5, e7) {
            for (let r7 = 0; r7 < e7.length; r7++) {
              const n6 = e7[r7];
              r7 === e7.length - 1 && e7[0].x === n6.x && e7[0].y === n6.y || (t5.x += n6.x, t5.y += n6.y, t5.sampleCount++);
            }
          }
          function su(t5, e7) {
            return t5.x === e7.x && (t5.x < 0 || t5.x > M4) || t5.y === e7.y && (t5.y < 0 || t5.y > M4);
          }
          function au(t5) {
            return t5.every((t6) => t6.x < 0) || t5.every((t6) => t6.x > M4) || t5.every((t6) => t6.y < 0) || t5.every((t6) => t6.y > M4);
          }
          let ou;
          Zi("FillExtrusionBucket", nu, { omit: ["layers", "features"] });
          var lu = { get paint() {
            return ou = ou || new Is({ "fill-extrusion-opacity": new _s(dt["paint_fill-extrusion"]["fill-extrusion-opacity"]), "fill-extrusion-color": new Ss(dt["paint_fill-extrusion"]["fill-extrusion-color"]), "fill-extrusion-translate": new _s(dt["paint_fill-extrusion"]["fill-extrusion-translate"]), "fill-extrusion-translate-anchor": new _s(dt["paint_fill-extrusion"]["fill-extrusion-translate-anchor"]), "fill-extrusion-pattern": new As(dt["paint_fill-extrusion"]["fill-extrusion-pattern"]), "fill-extrusion-height": new Ss(dt["paint_fill-extrusion"]["fill-extrusion-height"]), "fill-extrusion-base": new Ss(dt["paint_fill-extrusion"]["fill-extrusion-base"]), "fill-extrusion-vertical-gradient": new _s(dt["paint_fill-extrusion"]["fill-extrusion-vertical-gradient"]) });
          } };
          class uu extends Ps {
            constructor(t5) {
              super(t5, lu);
            }
            createBucket(t5) {
              return new nu(t5);
            }
            queryRadius() {
              return zo(this.paint.get("fill-extrusion-translate"));
            }
            is3D() {
              return true;
            }
            queryIntersectsFeature({ queryGeometry: t5, feature: e7, featureState: r7, geometry: n6, transform: i6, pixelsToTileUnits: s5, pixelPosMatrix: a4 }) {
              const o7 = Po(t5, this.paint.get("fill-extrusion-translate"), this.paint.get("fill-extrusion-translate-anchor"), -i6.bearingInRadians, s5), u4 = this.paint.get("fill-extrusion-height").evaluate(e7, r7), c5 = this.paint.get("fill-extrusion-base").evaluate(e7, r7), h4 = function(t6, e8, r8) {
                const n7 = [];
                for (const r9 of t6) {
                  const t7 = [r9.x, r9.y, 0, 1];
                  _3(t7, t7, e8), n7.push(new l4(t7[0] / t7[3], t7[1] / t7[3]));
                }
                return n7;
              }(o7, a4), p4 = function(t6, e8, r8, n7) {
                const i7 = [], s6 = [], a5 = n7[8] * e8, o8 = n7[9] * e8, u5 = n7[10] * e8, c6 = n7[11] * e8, h5 = n7[8] * r8, p5 = n7[9] * r8, f4 = n7[10] * r8, d4 = n7[11] * r8;
                for (const e9 of t6) {
                  const t7 = [], r9 = [];
                  for (const i8 of e9) {
                    const e10 = i8.x, s7 = i8.y, y4 = n7[0] * e10 + n7[4] * s7 + n7[12], m4 = n7[1] * e10 + n7[5] * s7 + n7[13], g4 = n7[2] * e10 + n7[6] * s7 + n7[14], x4 = n7[3] * e10 + n7[7] * s7 + n7[15], v4 = g4 + u5, b5 = x4 + c6, w4 = y4 + h5, _4 = m4 + p5, S5 = g4 + f4, A5 = x4 + d4, k4 = new l4((y4 + a5) / b5, (m4 + o8) / b5);
                    k4.z = v4 / b5, t7.push(k4);
                    const M5 = new l4(w4 / A5, _4 / A5);
                    M5.z = S5 / A5, r9.push(M5);
                  }
                  i7.push(t7), s6.push(r9);
                }
                return [i7, s6];
              }(n6, c5, u4, a4);
              return function(t6, e8, r8) {
                let n7 = 1 / 0;
                xo(r8, e8) && (n7 = hu(r8, e8[0]));
                for (let i7 = 0; i7 < e8.length; i7++) {
                  const s6 = e8[i7], a5 = t6[i7];
                  for (let t7 = 0; t7 < s6.length - 1; t7++) {
                    const e9 = s6[t7], i8 = [e9, s6[t7 + 1], a5[t7 + 1], a5[t7], e9];
                    mo(r8, i8) && (n7 = Math.min(n7, hu(r8, i8)));
                  }
                }
                return n7 !== 1 / 0 && n7;
              }(p4[0], p4[1], h4);
            }
          }
          function cu(t5, e7) {
            return t5.x * e7.x + t5.y * e7.y;
          }
          function hu(t5, e7) {
            if (1 === t5.length) {
              let r7 = 0;
              const n6 = e7[r7++];
              let i6;
              for (; !i6 || n6.equals(i6); ) if (i6 = e7[r7++], !i6) return 1 / 0;
              for (; r7 < e7.length; r7++) {
                const s5 = e7[r7], a4 = t5[0], o7 = i6.sub(n6), l5 = s5.sub(n6), u4 = a4.sub(n6), c5 = cu(o7, o7), h4 = cu(o7, l5), p4 = cu(l5, l5), f4 = cu(u4, o7), d4 = cu(u4, l5), y4 = c5 * p4 - h4 * h4, m4 = (p4 * f4 - h4 * d4) / y4, g4 = (c5 * d4 - h4 * f4) / y4, x4 = n6.z * (1 - m4 - g4) + i6.z * m4 + s5.z * g4;
                if (isFinite(x4)) return x4;
              }
              return 1 / 0;
            }
            {
              let t6 = 1 / 0;
              for (const r7 of e7) t6 = Math.min(t6, r7.z);
              return t6;
            }
          }
          const pu = Es([{ name: "a_pos_normal", components: 2, type: "Int16" }, { name: "a_data", components: 4, type: "Uint8" }], 4), { members: fu } = pu, du = Es([{ name: "a_uv_x", components: 1, type: "Float32" }, { name: "a_split_index", components: 1, type: "Float32" }]), { members: yu } = du, mu = Ql.VectorTileFeature.types, gu = Math.cos(Math.PI / 180 * 37.5), xu = Math.pow(2, 14) / 0.5;
          class vu {
            constructor(t5) {
              this.zoom = t5.zoom, this.overscaling = t5.overscaling, this.layers = t5.layers, this.layerIds = this.layers.map((t6) => t6.id), this.index = t5.index, this.hasPattern = false, this.patternFeatures = [], this.lineClipsArray = [], this.gradients = {}, this.layers.forEach((t6) => {
                this.gradients[t6.id] = {};
              }), this.layoutVertexArray = new ba(), this.layoutVertexArray2 = new wa(), this.indexArray = new za(), this.programConfigurations = new so(t5.layers, t5.zoom), this.segments = new Va(), this.maxLineLength = 0, this.stateDependentLayerIds = this.layers.filter((t6) => t6.isStateDependent()).map((t6) => t6.id);
            }
            populate(t5, e7, r7) {
              this.hasPattern = Jo("line", this.layers, e7);
              const n6 = this.layers[0].layout.get("line-sort-key"), i6 = !n6.isConstant(), s5 = [];
              for (const { feature: e8, id: a4, index: o7, sourceLayerIndex: l5 } of t5) {
                const t6 = this.layers[0]._featureFilter.needGeometry, u4 = ho(e8, t6);
                if (!this.layers[0]._featureFilter.filter(new fs(this.zoom), u4, r7)) continue;
                const c5 = i6 ? n6.evaluate(u4, {}, r7) : void 0, h4 = { id: a4, properties: e8.properties, type: e8.type, sourceLayerIndex: l5, index: o7, geometry: t6 ? u4.geometry : co(e8), patterns: {}, sortKey: c5 };
                s5.push(h4);
              }
              i6 && s5.sort((t6, e8) => t6.sortKey - e8.sortKey);
              for (const n7 of s5) {
                const { geometry: i7, index: s6, sourceLayerIndex: a4 } = n7;
                if (this.hasPattern) {
                  const t6 = Wo("line", this.layers, n7, this.zoom, e7);
                  this.patternFeatures.push(t6);
                } else this.addFeature(n7, i7, s6, r7, {}, e7.subdivisionGranularity);
                e7.featureIndex.insert(t5[s6].feature, i7, s6, a4, this.index);
              }
            }
            update(t5, e7, r7) {
              this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t5, e7, this.stateDependentLayers, r7);
            }
            addFeatures(t5, e7, r7) {
              for (const n6 of this.patternFeatures) this.addFeature(n6, n6.geometry, n6.index, e7, r7, t5.subdivisionGranularity);
            }
            isEmpty() {
              return 0 === this.layoutVertexArray.length;
            }
            uploadPending() {
              return !this.uploaded || this.programConfigurations.needsUpload;
            }
            upload(t5) {
              this.uploaded || (0 !== this.layoutVertexArray2.length && (this.layoutVertexBuffer2 = t5.createVertexBuffer(this.layoutVertexArray2, yu)), this.layoutVertexBuffer = t5.createVertexBuffer(this.layoutVertexArray, fu), this.indexBuffer = t5.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(t5), this.uploaded = true;
            }
            destroy() {
              this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy());
            }
            lineFeatureClips(t5) {
              if (t5.properties && Object.prototype.hasOwnProperty.call(t5.properties, "mapbox_clip_start") && Object.prototype.hasOwnProperty.call(t5.properties, "mapbox_clip_end")) return { start: +t5.properties.mapbox_clip_start, end: +t5.properties.mapbox_clip_end };
            }
            addFeature(t5, e7, r7, n6, i6, s5) {
              const a4 = this.layers[0].layout, o7 = a4.get("line-join").evaluate(t5, {}), l5 = a4.get("line-cap"), u4 = a4.get("line-miter-limit"), c5 = a4.get("line-round-limit");
              this.lineClips = this.lineFeatureClips(t5);
              for (const r8 of e7) this.addLine(r8, t5, o7, l5, u4, c5, n6, s5);
              this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t5, r7, i6, n6);
            }
            addLine(t5, e7, r7, n6, i6, s5, a4, o7) {
              if (this.distance = 0, this.scaledDistance = 0, this.totalDistance = 0, t5 = Cl(t5, a4 ? o7.line.getGranularityForZoomLevel(a4.z) : 1), this.lineClips) {
                this.lineClipsArray.push(this.lineClips);
                for (let e8 = 0; e8 < t5.length - 1; e8++) this.totalDistance += t5[e8].dist(t5[e8 + 1]);
                this.updateScaledDistance(), this.maxLineLength = Math.max(this.maxLineLength, this.totalDistance);
              }
              const l5 = "Polygon" === mu[e7.type];
              let u4 = t5.length;
              for (; u4 >= 2 && t5[u4 - 1].equals(t5[u4 - 2]); ) u4--;
              let c5 = 0;
              for (; c5 < u4 - 1 && t5[c5].equals(t5[c5 + 1]); ) c5++;
              if (u4 < (l5 ? 3 : 2)) return;
              "bevel" === r7 && (i6 = 1.05);
              const h4 = this.overscaling <= 16 ? 15 * M4 / (512 * this.overscaling) : 0, p4 = this.segments.prepareSegment(10 * u4, this.layoutVertexArray, this.indexArray);
              let f4, d4, y4, m4, g4;
              this.e1 = this.e2 = -1, l5 && (f4 = t5[u4 - 2], g4 = t5[c5].sub(f4)._unit()._perp());
              for (let e8 = c5; e8 < u4; e8++) {
                if (y4 = e8 === u4 - 1 ? l5 ? t5[c5 + 1] : void 0 : t5[e8 + 1], y4 && t5[e8].equals(y4)) continue;
                g4 && (m4 = g4), f4 && (d4 = f4), f4 = t5[e8], g4 = y4 ? y4.sub(f4)._unit()._perp() : m4, m4 = m4 || g4;
                let a5 = m4.add(g4);
                0 === a5.x && 0 === a5.y || a5._unit();
                const o8 = m4.x * g4.x + m4.y * g4.y, x4 = a5.x * g4.x + a5.y * g4.y, v4 = 0 !== x4 ? 1 / x4 : 1 / 0, b5 = 2 * Math.sqrt(2 - 2 * x4), w4 = x4 < gu && d4 && y4, _4 = m4.x * g4.y - m4.y * g4.x > 0;
                if (w4 && e8 > c5) {
                  const t6 = f4.dist(d4);
                  if (t6 > 2 * h4) {
                    const e9 = f4.sub(f4.sub(d4)._mult(h4 / t6)._round());
                    this.updateDistance(d4, e9), this.addCurrentVertex(e9, m4, 0, 0, p4), d4 = e9;
                  }
                }
                const S5 = d4 && y4;
                let A5 = S5 ? r7 : l5 ? "butt" : n6;
                if (S5 && "round" === A5 && (v4 < s5 ? A5 = "miter" : v4 <= 2 && (A5 = "fakeround")), "miter" === A5 && v4 > i6 && (A5 = "bevel"), "bevel" === A5 && (v4 > 2 && (A5 = "flipbevel"), v4 < i6 && (A5 = "miter")), d4 && this.updateDistance(d4, f4), "miter" === A5) a5._mult(v4), this.addCurrentVertex(f4, a5, 0, 0, p4);
                else if ("flipbevel" === A5) {
                  if (v4 > 100) a5 = g4.mult(-1);
                  else {
                    const t6 = v4 * m4.add(g4).mag() / m4.sub(g4).mag();
                    a5._perp()._mult(t6 * (_4 ? -1 : 1));
                  }
                  this.addCurrentVertex(f4, a5, 0, 0, p4), this.addCurrentVertex(f4, a5.mult(-1), 0, 0, p4);
                } else if ("bevel" === A5 || "fakeround" === A5) {
                  const t6 = -Math.sqrt(v4 * v4 - 1), e9 = _4 ? t6 : 0, r8 = _4 ? 0 : t6;
                  if (d4 && this.addCurrentVertex(f4, m4, e9, r8, p4), "fakeround" === A5) {
                    const t7 = Math.round(180 * b5 / Math.PI / 20);
                    for (let e10 = 1; e10 < t7; e10++) {
                      let r9 = e10 / t7;
                      if (0.5 !== r9) {
                        const t8 = r9 - 0.5;
                        r9 += r9 * t8 * (r9 - 1) * ((1.0904 + o8 * (o8 * (3.55645 - 1.43519 * o8) - 3.2452)) * t8 * t8 + (0.848013 + o8 * (0.215638 * o8 - 1.06021)));
                      }
                      const n7 = g4.sub(m4)._mult(r9)._add(m4)._unit()._mult(_4 ? -1 : 1);
                      this.addHalfVertex(f4, n7.x, n7.y, false, _4, 0, p4);
                    }
                  }
                  y4 && this.addCurrentVertex(f4, g4, -e9, -r8, p4);
                } else if ("butt" === A5) this.addCurrentVertex(f4, a5, 0, 0, p4);
                else if ("square" === A5) {
                  const t6 = d4 ? 1 : -1;
                  this.addCurrentVertex(f4, a5, t6, t6, p4);
                } else "round" === A5 && (d4 && (this.addCurrentVertex(f4, m4, 0, 0, p4), this.addCurrentVertex(f4, m4, 1, 1, p4, true)), y4 && (this.addCurrentVertex(f4, g4, -1, -1, p4, true), this.addCurrentVertex(f4, g4, 0, 0, p4)));
                if (w4 && e8 < u4 - 1) {
                  const t6 = f4.dist(y4);
                  if (t6 > 2 * h4) {
                    const e9 = f4.add(y4.sub(f4)._mult(h4 / t6)._round());
                    this.updateDistance(f4, e9), this.addCurrentVertex(e9, g4, 0, 0, p4), f4 = e9;
                  }
                }
              }
            }
            addCurrentVertex(t5, e7, r7, n6, i6, s5 = false) {
              const a4 = e7.y * n6 - e7.x, o7 = -e7.y - e7.x * n6;
              this.addHalfVertex(t5, e7.x + e7.y * r7, e7.y - e7.x * r7, s5, false, r7, i6), this.addHalfVertex(t5, a4, o7, s5, true, -n6, i6), this.distance > xu / 2 && 0 === this.totalDistance && (this.distance = 0, this.updateScaledDistance(), this.addCurrentVertex(t5, e7, r7, n6, i6, s5));
            }
            addHalfVertex({ x: t5, y: e7 }, r7, n6, i6, s5, a4, o7) {
              const l5 = 0.5 * (this.lineClips ? this.scaledDistance * (xu - 1) : this.scaledDistance);
              this.layoutVertexArray.emplaceBack((t5 << 1) + (i6 ? 1 : 0), (e7 << 1) + (s5 ? 1 : 0), Math.round(63 * r7) + 128, Math.round(63 * n6) + 128, 1 + (0 === a4 ? 0 : a4 < 0 ? -1 : 1) | (63 & l5) << 2, l5 >> 6), this.lineClips && this.layoutVertexArray2.emplaceBack((this.scaledDistance - this.lineClips.start) / (this.lineClips.end - this.lineClips.start), this.lineClipsArray.length);
              const u4 = o7.vertexLength++;
              this.e1 >= 0 && this.e2 >= 0 && (this.indexArray.emplaceBack(this.e1, u4, this.e2), o7.primitiveLength++), s5 ? this.e2 = u4 : this.e1 = u4;
            }
            updateScaledDistance() {
              this.scaledDistance = this.lineClips ? this.lineClips.start + (this.lineClips.end - this.lineClips.start) * this.distance / this.totalDistance : this.distance;
            }
            updateDistance(t5, e7) {
              this.distance += t5.dist(e7), this.updateScaledDistance();
            }
          }
          let bu, wu;
          Zi("LineBucket", vu, { omit: ["layers", "patternFeatures"] });
          var _u = { get paint() {
            return wu = wu || new Is({ "line-opacity": new Ss(dt.paint_line["line-opacity"]), "line-color": new Ss(dt.paint_line["line-color"]), "line-translate": new _s(dt.paint_line["line-translate"]), "line-translate-anchor": new _s(dt.paint_line["line-translate-anchor"]), "line-width": new Ss(dt.paint_line["line-width"]), "line-gap-width": new Ss(dt.paint_line["line-gap-width"]), "line-offset": new Ss(dt.paint_line["line-offset"]), "line-blur": new Ss(dt.paint_line["line-blur"]), "line-dasharray": new ks(dt.paint_line["line-dasharray"]), "line-pattern": new As(dt.paint_line["line-pattern"]), "line-gradient": new Ms(dt.paint_line["line-gradient"]) });
          }, get layout() {
            return bu = bu || new Is({ "line-cap": new _s(dt.layout_line["line-cap"]), "line-join": new Ss(dt.layout_line["line-join"]), "line-miter-limit": new _s(dt.layout_line["line-miter-limit"]), "line-round-limit": new _s(dt.layout_line["line-round-limit"]), "line-sort-key": new Ss(dt.layout_line["line-sort-key"]) });
          } };
          class Su extends Ss {
            possiblyEvaluate(t5, e7) {
              return e7 = new fs(Math.floor(e7.zoom), { now: e7.now, fadeDuration: e7.fadeDuration, zoomHistory: e7.zoomHistory, transition: e7.transition }), super.possiblyEvaluate(t5, e7);
            }
            evaluate(t5, e7, r7, n6) {
              return e7 = F2({}, e7, { zoom: Math.floor(e7.zoom) }), super.evaluate(t5, e7, r7, n6);
            }
          }
          let Au;
          class ku extends Ps {
            constructor(t5) {
              super(t5, _u), this.gradientVersion = 0, Au || (Au = new Su(_u.paint.properties["line-width"].specification), Au.useIntegerZoom = true);
            }
            _handleSpecialPaintPropertyUpdate(t5) {
              if ("line-gradient" === t5) {
                const t6 = this.gradientExpression();
                this.stepInterpolant = !!function(t7) {
                  return void 0 !== t7._styleExpression;
                }(t6) && t6._styleExpression.expression instanceof Ye, this.gradientVersion = (this.gradientVersion + 1) % Number.MAX_SAFE_INTEGER;
              }
            }
            gradientExpression() {
              return this._transitionablePaint._values["line-gradient"].value.expression;
            }
            recalculate(t5, e7) {
              super.recalculate(t5, e7), this.paint._values["line-floorwidth"] = Au.possiblyEvaluate(this._transitioningPaint._values["line-width"].value, t5);
            }
            createBucket(t5) {
              return new vu(t5);
            }
            queryRadius(t5) {
              const e7 = t5, r7 = Mu(Io("line-width", this, e7), Io("line-gap-width", this, e7)), n6 = Io("line-offset", this, e7);
              return r7 / 2 + Math.abs(n6) + zo(this.paint.get("line-translate"));
            }
            queryIntersectsFeature({ queryGeometry: t5, feature: e7, featureState: r7, geometry: n6, transform: i6, pixelsToTileUnits: s5 }) {
              const a4 = Po(t5, this.paint.get("line-translate"), this.paint.get("line-translate-anchor"), -i6.bearingInRadians, s5), o7 = s5 / 2 * Mu(this.paint.get("line-width").evaluate(e7, r7), this.paint.get("line-gap-width").evaluate(e7, r7)), u4 = this.paint.get("line-offset").evaluate(e7, r7);
              return u4 && (n6 = function(t6, e8) {
                const r8 = [];
                for (let n7 = 0; n7 < t6.length; n7++) {
                  const i7 = t6[n7], s6 = [];
                  for (let t7 = 0; t7 < i7.length; t7++) {
                    const r9 = i7[t7 - 1], n8 = i7[t7], a5 = i7[t7 + 1], o8 = 0 === t7 ? new l4(0, 0) : n8.sub(r9)._unit()._perp(), u5 = t7 === i7.length - 1 ? new l4(0, 0) : a5.sub(n8)._unit()._perp(), c5 = o8._add(u5)._unit(), h4 = c5.x * u5.x + c5.y * u5.y;
                    0 !== h4 && c5._mult(1 / h4), s6.push(c5._mult(e8)._add(n8));
                  }
                  r8.push(s6);
                }
                return r8;
              }(n6, u4 * s5)), function(t6, e8, r8) {
                for (let n7 = 0; n7 < e8.length; n7++) {
                  const i7 = e8[n7];
                  if (t6.length >= 3) {
                    for (let e9 = 0; e9 < i7.length; e9++) if (ko(t6, i7[e9])) return true;
                  }
                  if (vo(t6, i7, r8)) return true;
                }
                return false;
              }(a4, n6, o7);
            }
            isTileClipped() {
              return true;
            }
          }
          function Mu(t5, e7) {
            return e7 > 0 ? e7 + 2 * t5 : t5;
          }
          const Iu = Es([{ name: "a_pos_offset", components: 4, type: "Int16" }, { name: "a_data", components: 4, type: "Uint16" }, { name: "a_pixeloffset", components: 4, type: "Int16" }], 4), zu = Es([{ name: "a_projected_pos", components: 3, type: "Float32" }], 4);
          Es([{ name: "a_fade_opacity", components: 1, type: "Uint32" }], 4);
          const Pu = Es([{ name: "a_placed", components: 2, type: "Uint8" }, { name: "a_shift", components: 2, type: "Float32" }, { name: "a_box_real", components: 2, type: "Int16" }]);
          Es([{ type: "Int16", name: "anchorPointX" }, { type: "Int16", name: "anchorPointY" }, { type: "Int16", name: "x1" }, { type: "Int16", name: "y1" }, { type: "Int16", name: "x2" }, { type: "Int16", name: "y2" }, { type: "Uint32", name: "featureIndex" }, { type: "Uint16", name: "sourceLayerIndex" }, { type: "Uint16", name: "bucketIndex" }]);
          const Cu = Es([{ name: "a_pos", components: 2, type: "Int16" }, { name: "a_anchor_pos", components: 2, type: "Int16" }, { name: "a_extrude", components: 2, type: "Int16" }], 4), Bu = Es([{ name: "a_pos", components: 2, type: "Float32" }, { name: "a_radius", components: 1, type: "Float32" }, { name: "a_flags", components: 2, type: "Int16" }], 4);
          function Vu(t5, e7, r7) {
            return t5.sections.forEach((t6) => {
              t6.text = function(t7, e8, r8) {
                const n6 = e8.layout.get("text-transform").evaluate(r8, {});
                return "uppercase" === n6 ? t7 = t7.toLocaleUpperCase() : "lowercase" === n6 && (t7 = t7.toLocaleLowerCase()), ps.applyArabicShaping && (t7 = ps.applyArabicShaping(t7)), t7;
              }(t6.text, e7, r7);
            }), t5;
          }
          Es([{ name: "triangle", components: 3, type: "Uint16" }]), Es([{ type: "Int16", name: "anchorX" }, { type: "Int16", name: "anchorY" }, { type: "Uint16", name: "glyphStartIndex" }, { type: "Uint16", name: "numGlyphs" }, { type: "Uint32", name: "vertexStartIndex" }, { type: "Uint32", name: "lineStartIndex" }, { type: "Uint32", name: "lineLength" }, { type: "Uint16", name: "segment" }, { type: "Uint16", name: "lowerSize" }, { type: "Uint16", name: "upperSize" }, { type: "Float32", name: "lineOffsetX" }, { type: "Float32", name: "lineOffsetY" }, { type: "Uint8", name: "writingMode" }, { type: "Uint8", name: "placedOrientation" }, { type: "Uint8", name: "hidden" }, { type: "Uint32", name: "crossTileID" }, { type: "Int16", name: "associatedIconIndex" }]), Es([{ type: "Int16", name: "anchorX" }, { type: "Int16", name: "anchorY" }, { type: "Int16", name: "rightJustifiedTextSymbolIndex" }, { type: "Int16", name: "centerJustifiedTextSymbolIndex" }, { type: "Int16", name: "leftJustifiedTextSymbolIndex" }, { type: "Int16", name: "verticalPlacedTextSymbolIndex" }, { type: "Int16", name: "placedIconSymbolIndex" }, { type: "Int16", name: "verticalPlacedIconSymbolIndex" }, { type: "Uint16", name: "key" }, { type: "Uint16", name: "textBoxStartIndex" }, { type: "Uint16", name: "textBoxEndIndex" }, { type: "Uint16", name: "verticalTextBoxStartIndex" }, { type: "Uint16", name: "verticalTextBoxEndIndex" }, { type: "Uint16", name: "iconBoxStartIndex" }, { type: "Uint16", name: "iconBoxEndIndex" }, { type: "Uint16", name: "verticalIconBoxStartIndex" }, { type: "Uint16", name: "verticalIconBoxEndIndex" }, { type: "Uint16", name: "featureIndex" }, { type: "Uint16", name: "numHorizontalGlyphVertices" }, { type: "Uint16", name: "numVerticalGlyphVertices" }, { type: "Uint16", name: "numIconVertices" }, { type: "Uint16", name: "numVerticalIconVertices" }, { type: "Uint16", name: "useRuntimeCollisionCircles" }, { type: "Uint32", name: "crossTileID" }, { type: "Float32", name: "textBoxScale" }, { type: "Float32", name: "collisionCircleDiameter" }, { type: "Uint16", name: "textAnchorOffsetStartIndex" }, { type: "Uint16", name: "textAnchorOffsetEndIndex" }]), Es([{ type: "Float32", name: "offsetX" }]), Es([{ type: "Int16", name: "x" }, { type: "Int16", name: "y" }, { type: "Int16", name: "tileUnitDistanceFromAnchor" }]), Es([{ type: "Uint16", name: "textAnchor" }, { type: "Float32", components: 2, name: "textOffset" }]);
          const Eu = { "!": "\uFE15", "#": "\uFF03", $: "\uFF04", "%": "\uFF05", "&": "\uFF06", "(": "\uFE35", ")": "\uFE36", "*": "\uFF0A", "+": "\uFF0B", ",": "\uFE10", "-": "\uFE32", ".": "\u30FB", "/": "\uFF0F", ":": "\uFE13", ";": "\uFE14", "<": "\uFE3F", "=": "\uFF1D", ">": "\uFE40", "?": "\uFE16", "@": "\uFF20", "[": "\uFE47", "\\": "\uFF3C", "]": "\uFE48", "^": "\uFF3E", _: "\uFE33", "`": "\uFF40", "{": "\uFE37", "|": "\u2015", "}": "\uFE38", "~": "\uFF5E", "\xA2": "\uFFE0", "\xA3": "\uFFE1", "\xA5": "\uFFE5", "\xA6": "\uFFE4", "\xAC": "\uFFE2", "\xAF": "\uFFE3", "\u2013": "\uFE32", "\u2014": "\uFE31", "\u2018": "\uFE43", "\u2019": "\uFE44", "\u201C": "\uFE41", "\u201D": "\uFE42", "\u2026": "\uFE19", "\u2027": "\u30FB", "\u20A9": "\uFFE6", "\u3001": "\uFE11", "\u3002": "\uFE12", "\u3008": "\uFE3F", "\u3009": "\uFE40", "\u300A": "\uFE3D", "\u300B": "\uFE3E", "\u300C": "\uFE41", "\u300D": "\uFE42", "\u300E": "\uFE43", "\u300F": "\uFE44", "\u3010": "\uFE3B", "\u3011": "\uFE3C", "\u3014": "\uFE39", "\u3015": "\uFE3A", "\u3016": "\uFE17", "\u3017": "\uFE18", "\uFF01": "\uFE15", "\uFF08": "\uFE35", "\uFF09": "\uFE36", "\uFF0C": "\uFE10", "\uFF0D": "\uFE32", "\uFF0E": "\u30FB", "\uFF1A": "\uFE13", "\uFF1B": "\uFE14", "\uFF1C": "\uFE3F", "\uFF1E": "\uFE40", "\uFF1F": "\uFE16", "\uFF3B": "\uFE47", "\uFF3D": "\uFE48", "\uFF3F": "\uFE33", "\uFF5B": "\uFE37", "\uFF5C": "\u2015", "\uFF5D": "\uFE38", "\uFF5F": "\uFE35", "\uFF60": "\uFE36", "\uFF61": "\uFE12", "\uFF62": "\uFE41", "\uFF63": "\uFE42" };
          var Tu, Fu, $u, Lu = 24, Ou = {};
          function Du() {
            return Tu || (Tu = 1, Ou.read = function(t5, e7, r7, n6, i6) {
              var s5, a4, o7 = 8 * i6 - n6 - 1, l5 = (1 << o7) - 1, u4 = l5 >> 1, c5 = -7, h4 = r7 ? i6 - 1 : 0, p4 = r7 ? -1 : 1, f4 = t5[e7 + h4];
              for (h4 += p4, s5 = f4 & (1 << -c5) - 1, f4 >>= -c5, c5 += o7; c5 > 0; s5 = 256 * s5 + t5[e7 + h4], h4 += p4, c5 -= 8) ;
              for (a4 = s5 & (1 << -c5) - 1, s5 >>= -c5, c5 += n6; c5 > 0; a4 = 256 * a4 + t5[e7 + h4], h4 += p4, c5 -= 8) ;
              if (0 === s5) s5 = 1 - u4;
              else {
                if (s5 === l5) return a4 ? NaN : 1 / 0 * (f4 ? -1 : 1);
                a4 += Math.pow(2, n6), s5 -= u4;
              }
              return (f4 ? -1 : 1) * a4 * Math.pow(2, s5 - n6);
            }, Ou.write = function(t5, e7, r7, n6, i6, s5) {
              var a4, o7, l5, u4 = 8 * s5 - i6 - 1, c5 = (1 << u4) - 1, h4 = c5 >> 1, p4 = 23 === i6 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, f4 = n6 ? 0 : s5 - 1, d4 = n6 ? 1 : -1, y4 = e7 < 0 || 0 === e7 && 1 / e7 < 0 ? 1 : 0;
              for (e7 = Math.abs(e7), isNaN(e7) || e7 === 1 / 0 ? (o7 = isNaN(e7) ? 1 : 0, a4 = c5) : (a4 = Math.floor(Math.log(e7) / Math.LN2), e7 * (l5 = Math.pow(2, -a4)) < 1 && (a4--, l5 *= 2), (e7 += a4 + h4 >= 1 ? p4 / l5 : p4 * Math.pow(2, 1 - h4)) * l5 >= 2 && (a4++, l5 /= 2), a4 + h4 >= c5 ? (o7 = 0, a4 = c5) : a4 + h4 >= 1 ? (o7 = (e7 * l5 - 1) * Math.pow(2, i6), a4 += h4) : (o7 = e7 * Math.pow(2, h4 - 1) * Math.pow(2, i6), a4 = 0)); i6 >= 8; t5[r7 + f4] = 255 & o7, f4 += d4, o7 /= 256, i6 -= 8) ;
              for (a4 = a4 << i6 | o7, u4 += i6; u4 > 0; t5[r7 + f4] = 255 & a4, f4 += d4, a4 /= 256, u4 -= 8) ;
              t5[r7 + f4 - d4] |= 128 * y4;
            }), Ou;
          }
          function Ru() {
            if ($u) return Fu;
            $u = 1, Fu = e7;
            var t5 = Du();
            function e7(t6) {
              this.buf = ArrayBuffer.isView && ArrayBuffer.isView(t6) ? t6 : new Uint8Array(t6 || 0), this.pos = 0, this.type = 0, this.length = this.buf.length;
            }
            e7.Varint = 0, e7.Fixed64 = 1, e7.Bytes = 2, e7.Fixed32 = 5;
            var r7 = 4294967296, n6 = 1 / r7, i6 = "undefined" == typeof TextDecoder ? null : new TextDecoder("utf-8");
            function s5(t6) {
              return t6.type === e7.Bytes ? t6.readVarint() + t6.pos : t6.pos + 1;
            }
            function a4(t6, e8, r8) {
              return r8 ? 4294967296 * e8 + (t6 >>> 0) : 4294967296 * (e8 >>> 0) + (t6 >>> 0);
            }
            function o7(t6, e8, r8) {
              var n7 = e8 <= 16383 ? 1 : e8 <= 2097151 ? 2 : e8 <= 268435455 ? 3 : Math.floor(Math.log(e8) / (7 * Math.LN2));
              r8.realloc(n7);
              for (var i7 = r8.pos - 1; i7 >= t6; i7--) r8.buf[i7 + n7] = r8.buf[i7];
            }
            function l5(t6, e8) {
              for (var r8 = 0; r8 < t6.length; r8++) e8.writeVarint(t6[r8]);
            }
            function u4(t6, e8) {
              for (var r8 = 0; r8 < t6.length; r8++) e8.writeSVarint(t6[r8]);
            }
            function c5(t6, e8) {
              for (var r8 = 0; r8 < t6.length; r8++) e8.writeFloat(t6[r8]);
            }
            function h4(t6, e8) {
              for (var r8 = 0; r8 < t6.length; r8++) e8.writeDouble(t6[r8]);
            }
            function p4(t6, e8) {
              for (var r8 = 0; r8 < t6.length; r8++) e8.writeBoolean(t6[r8]);
            }
            function f4(t6, e8) {
              for (var r8 = 0; r8 < t6.length; r8++) e8.writeFixed32(t6[r8]);
            }
            function d4(t6, e8) {
              for (var r8 = 0; r8 < t6.length; r8++) e8.writeSFixed32(t6[r8]);
            }
            function y4(t6, e8) {
              for (var r8 = 0; r8 < t6.length; r8++) e8.writeFixed64(t6[r8]);
            }
            function m4(t6, e8) {
              for (var r8 = 0; r8 < t6.length; r8++) e8.writeSFixed64(t6[r8]);
            }
            function g4(t6, e8) {
              return (t6[e8] | t6[e8 + 1] << 8 | t6[e8 + 2] << 16) + 16777216 * t6[e8 + 3];
            }
            function x4(t6, e8, r8) {
              t6[r8] = e8, t6[r8 + 1] = e8 >>> 8, t6[r8 + 2] = e8 >>> 16, t6[r8 + 3] = e8 >>> 24;
            }
            function v4(t6, e8) {
              return (t6[e8] | t6[e8 + 1] << 8 | t6[e8 + 2] << 16) + (t6[e8 + 3] << 24);
            }
            return e7.prototype = { destroy: function() {
              this.buf = null;
            }, readFields: function(t6, e8, r8) {
              for (r8 = r8 || this.length; this.pos < r8; ) {
                var n7 = this.readVarint(), i7 = n7 >> 3, s6 = this.pos;
                this.type = 7 & n7, t6(i7, e8, this), this.pos === s6 && this.skip(n7);
              }
              return e8;
            }, readMessage: function(t6, e8) {
              return this.readFields(t6, e8, this.readVarint() + this.pos);
            }, readFixed32: function() {
              var t6 = g4(this.buf, this.pos);
              return this.pos += 4, t6;
            }, readSFixed32: function() {
              var t6 = v4(this.buf, this.pos);
              return this.pos += 4, t6;
            }, readFixed64: function() {
              var t6 = g4(this.buf, this.pos) + g4(this.buf, this.pos + 4) * r7;
              return this.pos += 8, t6;
            }, readSFixed64: function() {
              var t6 = g4(this.buf, this.pos) + v4(this.buf, this.pos + 4) * r7;
              return this.pos += 8, t6;
            }, readFloat: function() {
              var e8 = t5.read(this.buf, this.pos, true, 23, 4);
              return this.pos += 4, e8;
            }, readDouble: function() {
              var e8 = t5.read(this.buf, this.pos, true, 52, 8);
              return this.pos += 8, e8;
            }, readVarint: function(t6) {
              var e8, r8, n7 = this.buf;
              return e8 = 127 & (r8 = n7[this.pos++]), r8 < 128 ? e8 : (e8 |= (127 & (r8 = n7[this.pos++])) << 7, r8 < 128 ? e8 : (e8 |= (127 & (r8 = n7[this.pos++])) << 14, r8 < 128 ? e8 : (e8 |= (127 & (r8 = n7[this.pos++])) << 21, r8 < 128 ? e8 : function(t7, e9, r9) {
                var n8, i7, s6 = r9.buf;
                if (n8 = (112 & (i7 = s6[r9.pos++])) >> 4, i7 < 128) return a4(t7, n8, e9);
                if (n8 |= (127 & (i7 = s6[r9.pos++])) << 3, i7 < 128) return a4(t7, n8, e9);
                if (n8 |= (127 & (i7 = s6[r9.pos++])) << 10, i7 < 128) return a4(t7, n8, e9);
                if (n8 |= (127 & (i7 = s6[r9.pos++])) << 17, i7 < 128) return a4(t7, n8, e9);
                if (n8 |= (127 & (i7 = s6[r9.pos++])) << 24, i7 < 128) return a4(t7, n8, e9);
                if (n8 |= (1 & (i7 = s6[r9.pos++])) << 31, i7 < 128) return a4(t7, n8, e9);
                throw new Error("Expected varint not more than 10 bytes");
              }(e8 |= (15 & (r8 = n7[this.pos])) << 28, t6, this))));
            }, readVarint64: function() {
              return this.readVarint(true);
            }, readSVarint: function() {
              var t6 = this.readVarint();
              return t6 % 2 == 1 ? (t6 + 1) / -2 : t6 / 2;
            }, readBoolean: function() {
              return Boolean(this.readVarint());
            }, readString: function() {
              var t6 = this.readVarint() + this.pos, e8 = this.pos;
              return this.pos = t6, t6 - e8 >= 12 && i6 ? function(t7, e9, r8) {
                return i6.decode(t7.subarray(e9, r8));
              }(this.buf, e8, t6) : function(t7, e9, r8) {
                for (var n7 = "", i7 = e9; i7 < r8; ) {
                  var s6, a5, o8, l6 = t7[i7], u5 = null, c6 = l6 > 239 ? 4 : l6 > 223 ? 3 : l6 > 191 ? 2 : 1;
                  if (i7 + c6 > r8) break;
                  1 === c6 ? l6 < 128 && (u5 = l6) : 2 === c6 ? 128 == (192 & (s6 = t7[i7 + 1])) && (u5 = (31 & l6) << 6 | 63 & s6) <= 127 && (u5 = null) : 3 === c6 ? (a5 = t7[i7 + 2], 128 == (192 & (s6 = t7[i7 + 1])) && 128 == (192 & a5) && ((u5 = (15 & l6) << 12 | (63 & s6) << 6 | 63 & a5) <= 2047 || u5 >= 55296 && u5 <= 57343) && (u5 = null)) : 4 === c6 && (a5 = t7[i7 + 2], o8 = t7[i7 + 3], 128 == (192 & (s6 = t7[i7 + 1])) && 128 == (192 & a5) && 128 == (192 & o8) && ((u5 = (15 & l6) << 18 | (63 & s6) << 12 | (63 & a5) << 6 | 63 & o8) <= 65535 || u5 >= 1114112) && (u5 = null)), null === u5 ? (u5 = 65533, c6 = 1) : u5 > 65535 && (u5 -= 65536, n7 += String.fromCharCode(u5 >>> 10 & 1023 | 55296), u5 = 56320 | 1023 & u5), n7 += String.fromCharCode(u5), i7 += c6;
                }
                return n7;
              }(this.buf, e8, t6);
            }, readBytes: function() {
              var t6 = this.readVarint() + this.pos, e8 = this.buf.subarray(this.pos, t6);
              return this.pos = t6, e8;
            }, readPackedVarint: function(t6, r8) {
              if (this.type !== e7.Bytes) return t6.push(this.readVarint(r8));
              var n7 = s5(this);
              for (t6 = t6 || []; this.pos < n7; ) t6.push(this.readVarint(r8));
              return t6;
            }, readPackedSVarint: function(t6) {
              if (this.type !== e7.Bytes) return t6.push(this.readSVarint());
              var r8 = s5(this);
              for (t6 = t6 || []; this.pos < r8; ) t6.push(this.readSVarint());
              return t6;
            }, readPackedBoolean: function(t6) {
              if (this.type !== e7.Bytes) return t6.push(this.readBoolean());
              var r8 = s5(this);
              for (t6 = t6 || []; this.pos < r8; ) t6.push(this.readBoolean());
              return t6;
            }, readPackedFloat: function(t6) {
              if (this.type !== e7.Bytes) return t6.push(this.readFloat());
              var r8 = s5(this);
              for (t6 = t6 || []; this.pos < r8; ) t6.push(this.readFloat());
              return t6;
            }, readPackedDouble: function(t6) {
              if (this.type !== e7.Bytes) return t6.push(this.readDouble());
              var r8 = s5(this);
              for (t6 = t6 || []; this.pos < r8; ) t6.push(this.readDouble());
              return t6;
            }, readPackedFixed32: function(t6) {
              if (this.type !== e7.Bytes) return t6.push(this.readFixed32());
              var r8 = s5(this);
              for (t6 = t6 || []; this.pos < r8; ) t6.push(this.readFixed32());
              return t6;
            }, readPackedSFixed32: function(t6) {
              if (this.type !== e7.Bytes) return t6.push(this.readSFixed32());
              var r8 = s5(this);
              for (t6 = t6 || []; this.pos < r8; ) t6.push(this.readSFixed32());
              return t6;
            }, readPackedFixed64: function(t6) {
              if (this.type !== e7.Bytes) return t6.push(this.readFixed64());
              var r8 = s5(this);
              for (t6 = t6 || []; this.pos < r8; ) t6.push(this.readFixed64());
              return t6;
            }, readPackedSFixed64: function(t6) {
              if (this.type !== e7.Bytes) return t6.push(this.readSFixed64());
              var r8 = s5(this);
              for (t6 = t6 || []; this.pos < r8; ) t6.push(this.readSFixed64());
              return t6;
            }, skip: function(t6) {
              var r8 = 7 & t6;
              if (r8 === e7.Varint) for (; this.buf[this.pos++] > 127; ) ;
              else if (r8 === e7.Bytes) this.pos = this.readVarint() + this.pos;
              else if (r8 === e7.Fixed32) this.pos += 4;
              else {
                if (r8 !== e7.Fixed64) throw new Error("Unimplemented type: " + r8);
                this.pos += 8;
              }
            }, writeTag: function(t6, e8) {
              this.writeVarint(t6 << 3 | e8);
            }, realloc: function(t6) {
              for (var e8 = this.length || 16; e8 < this.pos + t6; ) e8 *= 2;
              if (e8 !== this.length) {
                var r8 = new Uint8Array(e8);
                r8.set(this.buf), this.buf = r8, this.length = e8;
              }
            }, finish: function() {
              return this.length = this.pos, this.pos = 0, this.buf.subarray(0, this.length);
            }, writeFixed32: function(t6) {
              this.realloc(4), x4(this.buf, t6, this.pos), this.pos += 4;
            }, writeSFixed32: function(t6) {
              this.realloc(4), x4(this.buf, t6, this.pos), this.pos += 4;
            }, writeFixed64: function(t6) {
              this.realloc(8), x4(this.buf, -1 & t6, this.pos), x4(this.buf, Math.floor(t6 * n6), this.pos + 4), this.pos += 8;
            }, writeSFixed64: function(t6) {
              this.realloc(8), x4(this.buf, -1 & t6, this.pos), x4(this.buf, Math.floor(t6 * n6), this.pos + 4), this.pos += 8;
            }, writeVarint: function(t6) {
              (t6 = +t6 || 0) > 268435455 || t6 < 0 ? function(t7, e8) {
                var r8, n7;
                if (t7 >= 0 ? (r8 = t7 % 4294967296 | 0, n7 = t7 / 4294967296 | 0) : (n7 = ~(-t7 / 4294967296), 4294967295 ^ (r8 = ~(-t7 % 4294967296)) ? r8 = r8 + 1 | 0 : (r8 = 0, n7 = n7 + 1 | 0)), t7 >= 18446744073709552e3 || t7 < -18446744073709552e3) throw new Error("Given varint doesn't fit into 10 bytes");
                e8.realloc(10), function(t8, e9, r9) {
                  r9.buf[r9.pos++] = 127 & t8 | 128, t8 >>>= 7, r9.buf[r9.pos++] = 127 & t8 | 128, t8 >>>= 7, r9.buf[r9.pos++] = 127 & t8 | 128, t8 >>>= 7, r9.buf[r9.pos++] = 127 & t8 | 128, r9.buf[r9.pos] = 127 & (t8 >>>= 7);
                }(r8, 0, e8), function(t8, e9) {
                  var r9 = (7 & t8) << 4;
                  e9.buf[e9.pos++] |= r9 | ((t8 >>>= 3) ? 128 : 0), t8 && (e9.buf[e9.pos++] = 127 & t8 | ((t8 >>>= 7) ? 128 : 0), t8 && (e9.buf[e9.pos++] = 127 & t8 | ((t8 >>>= 7) ? 128 : 0), t8 && (e9.buf[e9.pos++] = 127 & t8 | ((t8 >>>= 7) ? 128 : 0), t8 && (e9.buf[e9.pos++] = 127 & t8 | ((t8 >>>= 7) ? 128 : 0), t8 && (e9.buf[e9.pos++] = 127 & t8)))));
                }(n7, e8);
              }(t6, this) : (this.realloc(4), this.buf[this.pos++] = 127 & t6 | (t6 > 127 ? 128 : 0), t6 <= 127 || (this.buf[this.pos++] = 127 & (t6 >>>= 7) | (t6 > 127 ? 128 : 0), t6 <= 127 || (this.buf[this.pos++] = 127 & (t6 >>>= 7) | (t6 > 127 ? 128 : 0), t6 <= 127 || (this.buf[this.pos++] = t6 >>> 7 & 127))));
            }, writeSVarint: function(t6) {
              this.writeVarint(t6 < 0 ? 2 * -t6 - 1 : 2 * t6);
            }, writeBoolean: function(t6) {
              this.writeVarint(Boolean(t6));
            }, writeString: function(t6) {
              t6 = String(t6), this.realloc(4 * t6.length), this.pos++;
              var e8 = this.pos;
              this.pos = function(t7, e9, r9) {
                for (var n7, i7, s6 = 0; s6 < e9.length; s6++) {
                  if ((n7 = e9.charCodeAt(s6)) > 55295 && n7 < 57344) {
                    if (!i7) {
                      n7 > 56319 || s6 + 1 === e9.length ? (t7[r9++] = 239, t7[r9++] = 191, t7[r9++] = 189) : i7 = n7;
                      continue;
                    }
                    if (n7 < 56320) {
                      t7[r9++] = 239, t7[r9++] = 191, t7[r9++] = 189, i7 = n7;
                      continue;
                    }
                    n7 = i7 - 55296 << 10 | n7 - 56320 | 65536, i7 = null;
                  } else i7 && (t7[r9++] = 239, t7[r9++] = 191, t7[r9++] = 189, i7 = null);
                  n7 < 128 ? t7[r9++] = n7 : (n7 < 2048 ? t7[r9++] = n7 >> 6 | 192 : (n7 < 65536 ? t7[r9++] = n7 >> 12 | 224 : (t7[r9++] = n7 >> 18 | 240, t7[r9++] = n7 >> 12 & 63 | 128), t7[r9++] = n7 >> 6 & 63 | 128), t7[r9++] = 63 & n7 | 128);
                }
                return r9;
              }(this.buf, t6, this.pos);
              var r8 = this.pos - e8;
              r8 >= 128 && o7(e8, r8, this), this.pos = e8 - 1, this.writeVarint(r8), this.pos += r8;
            }, writeFloat: function(e8) {
              this.realloc(4), t5.write(this.buf, e8, this.pos, true, 23, 4), this.pos += 4;
            }, writeDouble: function(e8) {
              this.realloc(8), t5.write(this.buf, e8, this.pos, true, 52, 8), this.pos += 8;
            }, writeBytes: function(t6) {
              var e8 = t6.length;
              this.writeVarint(e8), this.realloc(e8);
              for (var r8 = 0; r8 < e8; r8++) this.buf[this.pos++] = t6[r8];
            }, writeRawMessage: function(t6, e8) {
              this.pos++;
              var r8 = this.pos;
              t6(e8, this);
              var n7 = this.pos - r8;
              n7 >= 128 && o7(r8, n7, this), this.pos = r8 - 1, this.writeVarint(n7), this.pos += n7;
            }, writeMessage: function(t6, r8, n7) {
              this.writeTag(t6, e7.Bytes), this.writeRawMessage(r8, n7);
            }, writePackedVarint: function(t6, e8) {
              e8.length && this.writeMessage(t6, l5, e8);
            }, writePackedSVarint: function(t6, e8) {
              e8.length && this.writeMessage(t6, u4, e8);
            }, writePackedBoolean: function(t6, e8) {
              e8.length && this.writeMessage(t6, p4, e8);
            }, writePackedFloat: function(t6, e8) {
              e8.length && this.writeMessage(t6, c5, e8);
            }, writePackedDouble: function(t6, e8) {
              e8.length && this.writeMessage(t6, h4, e8);
            }, writePackedFixed32: function(t6, e8) {
              e8.length && this.writeMessage(t6, f4, e8);
            }, writePackedSFixed32: function(t6, e8) {
              e8.length && this.writeMessage(t6, d4, e8);
            }, writePackedFixed64: function(t6, e8) {
              e8.length && this.writeMessage(t6, y4, e8);
            }, writePackedSFixed64: function(t6, e8) {
              e8.length && this.writeMessage(t6, m4, e8);
            }, writeBytesField: function(t6, r8) {
              this.writeTag(t6, e7.Bytes), this.writeBytes(r8);
            }, writeFixed32Field: function(t6, r8) {
              this.writeTag(t6, e7.Fixed32), this.writeFixed32(r8);
            }, writeSFixed32Field: function(t6, r8) {
              this.writeTag(t6, e7.Fixed32), this.writeSFixed32(r8);
            }, writeFixed64Field: function(t6, r8) {
              this.writeTag(t6, e7.Fixed64), this.writeFixed64(r8);
            }, writeSFixed64Field: function(t6, r8) {
              this.writeTag(t6, e7.Fixed64), this.writeSFixed64(r8);
            }, writeVarintField: function(t6, r8) {
              this.writeTag(t6, e7.Varint), this.writeVarint(r8);
            }, writeSVarintField: function(t6, r8) {
              this.writeTag(t6, e7.Varint), this.writeSVarint(r8);
            }, writeStringField: function(t6, r8) {
              this.writeTag(t6, e7.Bytes), this.writeString(r8);
            }, writeFloatField: function(t6, r8) {
              this.writeTag(t6, e7.Fixed32), this.writeFloat(r8);
            }, writeDoubleField: function(t6, r8) {
              this.writeTag(t6, e7.Fixed64), this.writeDouble(r8);
            }, writeBooleanField: function(t6, e8) {
              this.writeVarintField(t6, Boolean(e8));
            } }, Fu;
          }
          var ju = r6(Ru());
          const Nu = 3;
          function Uu(t5, e7, r7) {
            1 === t5 && r7.readMessage(qu, e7);
          }
          function qu(t5, e7, r7) {
            if (3 === t5) {
              const { id: t6, bitmap: n6, width: i6, height: s5, left: a4, top: o7, advance: l5 } = r7.readMessage(Gu, {});
              e7.push({ id: t6, bitmap: new jo({ width: i6 + 2 * Nu, height: s5 + 2 * Nu }, n6), metrics: { width: i6, height: s5, left: a4, top: o7, advance: l5 } });
            }
          }
          function Gu(t5, e7, r7) {
            1 === t5 ? e7.id = r7.readVarint() : 2 === t5 ? e7.bitmap = r7.readBytes() : 3 === t5 ? e7.width = r7.readVarint() : 4 === t5 ? e7.height = r7.readVarint() : 5 === t5 ? e7.left = r7.readSVarint() : 6 === t5 ? e7.top = r7.readSVarint() : 7 === t5 && (e7.advance = r7.readVarint());
          }
          const Zu = Nu;
          function Ku(t5) {
            let e7 = 0, r7 = 0;
            for (const n7 of t5) e7 += n7.w * n7.h, r7 = Math.max(r7, n7.w);
            t5.sort((t6, e8) => e8.h - t6.h);
            const n6 = [{ x: 0, y: 0, w: Math.max(Math.ceil(Math.sqrt(e7 / 0.95)), r7), h: 1 / 0 }];
            let i6 = 0, s5 = 0;
            for (const e8 of t5) for (let t6 = n6.length - 1; t6 >= 0; t6--) {
              const r8 = n6[t6];
              if (!(e8.w > r8.w || e8.h > r8.h)) {
                if (e8.x = r8.x, e8.y = r8.y, s5 = Math.max(s5, e8.y + e8.h), i6 = Math.max(i6, e8.x + e8.w), e8.w === r8.w && e8.h === r8.h) {
                  const e9 = n6.pop();
                  t6 < n6.length && (n6[t6] = e9);
                } else e8.h === r8.h ? (r8.x += e8.w, r8.w -= e8.w) : e8.w === r8.w ? (r8.y += e8.h, r8.h -= e8.h) : (n6.push({ x: r8.x + e8.w, y: r8.y, w: r8.w - e8.w, h: e8.h }), r8.y += e8.h, r8.h -= e8.h);
                break;
              }
            }
            return { w: i6, h: s5, fill: e7 / (i6 * s5) || 0 };
          }
          const Xu = 1;
          class Hu {
            constructor(t5, { pixelRatio: e7, version: r7, stretchX: n6, stretchY: i6, content: s5, textFitWidth: a4, textFitHeight: o7 }) {
              this.paddedRect = t5, this.pixelRatio = e7, this.stretchX = n6, this.stretchY = i6, this.content = s5, this.version = r7, this.textFitWidth = a4, this.textFitHeight = o7;
            }
            get tl() {
              return [this.paddedRect.x + Xu, this.paddedRect.y + Xu];
            }
            get br() {
              return [this.paddedRect.x + this.paddedRect.w - Xu, this.paddedRect.y + this.paddedRect.h - Xu];
            }
            get tlbr() {
              return this.tl.concat(this.br);
            }
            get displaySize() {
              return [(this.paddedRect.w - 2 * Xu) / this.pixelRatio, (this.paddedRect.h - 2 * Xu) / this.pixelRatio];
            }
          }
          class Yu {
            constructor(t5, e7) {
              const r7 = {}, n6 = {};
              this.haveRenderCallbacks = [];
              const i6 = [];
              this.addImages(t5, r7, i6), this.addImages(e7, n6, i6);
              const { w: s5, h: a4 } = Ku(i6), o7 = new No({ width: s5 || 1, height: a4 || 1 });
              for (const e8 in t5) {
                const n7 = t5[e8], i7 = r7[e8].paddedRect;
                No.copy(n7.data, o7, { x: 0, y: 0 }, { x: i7.x + Xu, y: i7.y + Xu }, n7.data);
              }
              for (const t6 in e7) {
                const r8 = e7[t6], i7 = n6[t6].paddedRect, s6 = i7.x + Xu, a5 = i7.y + Xu, l5 = r8.data.width, u4 = r8.data.height;
                No.copy(r8.data, o7, { x: 0, y: 0 }, { x: s6, y: a5 }, r8.data), No.copy(r8.data, o7, { x: 0, y: u4 - 1 }, { x: s6, y: a5 - 1 }, { width: l5, height: 1 }), No.copy(r8.data, o7, { x: 0, y: 0 }, { x: s6, y: a5 + u4 }, { width: l5, height: 1 }), No.copy(r8.data, o7, { x: l5 - 1, y: 0 }, { x: s6 - 1, y: a5 }, { width: 1, height: u4 }), No.copy(r8.data, o7, { x: 0, y: 0 }, { x: s6 + l5, y: a5 }, { width: 1, height: u4 });
              }
              this.image = o7, this.iconPositions = r7, this.patternPositions = n6;
            }
            addImages(t5, e7, r7) {
              for (const n6 in t5) {
                const i6 = t5[n6], s5 = { x: 0, y: 0, w: i6.data.width + 2 * Xu, h: i6.data.height + 2 * Xu };
                r7.push(s5), e7[n6] = new Hu(s5, i6), i6.hasRenderCallback && this.haveRenderCallbacks.push(n6);
              }
            }
            patchUpdatedImages(t5, e7) {
              t5.dispatchRenderCallbacks(this.haveRenderCallbacks);
              for (const r7 in t5.updatedImages) this.patchUpdatedImage(this.iconPositions[r7], t5.getImage(r7), e7), this.patchUpdatedImage(this.patternPositions[r7], t5.getImage(r7), e7);
            }
            patchUpdatedImage(t5, e7, r7) {
              if (!t5 || !e7) return;
              if (t5.version === e7.version) return;
              t5.version = e7.version;
              const [n6, i6] = t5.tl;
              r7.update(e7.data, void 0, { x: n6, y: i6 });
            }
          }
          var Ju;
          Zi("ImagePosition", Hu), Zi("ImageAtlas", Yu), t4.ah = void 0, (Ju = t4.ah || (t4.ah = {}))[Ju.none = 0] = "none", Ju[Ju.horizontal = 1] = "horizontal", Ju[Ju.vertical = 2] = "vertical", Ju[Ju.horizontalOnly = 3] = "horizontalOnly";
          const Wu = -17;
          class Qu {
            constructor() {
              this.scale = 1, this.fontStack = "", this.imageName = null, this.verticalAlign = "bottom";
            }
            static forText(t5, e7, r7) {
              const n6 = new Qu();
              return n6.scale = t5 || 1, n6.fontStack = e7, n6.verticalAlign = r7 || "bottom", n6;
            }
            static forImage(t5, e7) {
              const r7 = new Qu();
              return r7.imageName = t5, r7.verticalAlign = e7 || "bottom", r7;
            }
          }
          class tc {
            constructor() {
              this.text = "", this.sectionIndex = [], this.sections = [], this.imageSectionID = null;
            }
            static fromFeature(t5, e7) {
              const r7 = new tc();
              for (let n6 = 0; n6 < t5.sections.length; n6++) {
                const i6 = t5.sections[n6];
                i6.image ? r7.addImageSection(i6) : r7.addTextSection(i6, e7);
              }
              return r7;
            }
            length() {
              return this.text.length;
            }
            getSection(t5) {
              return this.sections[this.sectionIndex[t5]];
            }
            getSectionIndex(t5) {
              return this.sectionIndex[t5];
            }
            getCharCode(t5) {
              return this.text.charCodeAt(t5);
            }
            verticalizePunctuation() {
              this.text = function(t5) {
                let e7 = "";
                for (let r7 = 0; r7 < t5.length; r7++) {
                  const n6 = t5.charCodeAt(r7 + 1) || null, i6 = t5.charCodeAt(r7 - 1) || null;
                  e7 += n6 && os(n6) && !Eu[t5[r7 + 1]] || i6 && os(i6) && !Eu[t5[r7 - 1]] || !Eu[t5[r7]] ? t5[r7] : Eu[t5[r7]];
                }
                return e7;
              }(this.text);
            }
            trim() {
              let t5 = 0;
              for (let e8 = 0; e8 < this.text.length && rc[this.text.charCodeAt(e8)]; e8++) t5++;
              let e7 = this.text.length;
              for (let r7 = this.text.length - 1; r7 >= 0 && r7 >= t5 && rc[this.text.charCodeAt(r7)]; r7--) e7--;
              this.text = this.text.substring(t5, e7), this.sectionIndex = this.sectionIndex.slice(t5, e7);
            }
            substring(t5, e7) {
              const r7 = new tc();
              return r7.text = this.text.substring(t5, e7), r7.sectionIndex = this.sectionIndex.slice(t5, e7), r7.sections = this.sections, r7;
            }
            toString() {
              return this.text;
            }
            getMaxScale() {
              return this.sectionIndex.reduce((t5, e7) => Math.max(t5, this.sections[e7].scale), 0);
            }
            getMaxImageSize(t5) {
              let e7 = 0, r7 = 0;
              for (let n6 = 0; n6 < this.length(); n6++) {
                const i6 = this.getSection(n6);
                if (i6.imageName) {
                  const n7 = t5[i6.imageName];
                  if (!n7) continue;
                  const s5 = n7.displaySize;
                  e7 = Math.max(e7, s5[0]), r7 = Math.max(r7, s5[1]);
                }
              }
              return { maxImageWidth: e7, maxImageHeight: r7 };
            }
            addTextSection(t5, e7) {
              this.text += t5.text, this.sections.push(Qu.forText(t5.scale, t5.fontStack || e7, t5.verticalAlign));
              const r7 = this.sections.length - 1;
              for (let e8 = 0; e8 < t5.text.length; ++e8) this.sectionIndex.push(r7);
            }
            addImageSection(t5) {
              const e7 = t5.image ? t5.image.name : "";
              if (0 === e7.length) return void j3("Can't add FormattedSection with an empty image.");
              const r7 = this.getNextImageSectionCharCode();
              r7 ? (this.text += String.fromCharCode(r7), this.sections.push(Qu.forImage(e7, t5.verticalAlign)), this.sectionIndex.push(this.sections.length - 1)) : j3("Reached maximum number of images 6401");
            }
            getNextImageSectionCharCode() {
              return this.imageSectionID ? this.imageSectionID >= 63743 ? null : ++this.imageSectionID : (this.imageSectionID = 57344, this.imageSectionID);
            }
          }
          function ec2(e7, r7, n6, i6, s5, a4, o7, l5, u4, c5, h4, p4, f4, d4, y4) {
            const m4 = tc.fromFeature(e7, s5);
            let g4;
            p4 === t4.ah.vertical && m4.verticalizePunctuation();
            const { processBidirectionalText: x4, processStyledBidirectionalText: v4 } = ps;
            if (x4 && 1 === m4.sections.length) {
              g4 = [];
              const t5 = x4(m4.toString(), cc(m4, c5, a4, r7, i6, d4));
              for (const e8 of t5) {
                const t6 = new tc();
                t6.text = e8, t6.sections = m4.sections;
                for (let r8 = 0; r8 < e8.length; r8++) t6.sectionIndex.push(0);
                g4.push(t6);
              }
            } else if (v4) {
              g4 = [];
              const t5 = v4(m4.text, m4.sectionIndex, cc(m4, c5, a4, r7, i6, d4));
              for (const e8 of t5) {
                const t6 = new tc();
                t6.text = e8[0], t6.sectionIndex = e8[1], t6.sections = m4.sections, g4.push(t6);
              }
            } else g4 = function(t5, e8) {
              const r8 = [], n7 = t5.text;
              let i7 = 0;
              for (const n8 of e8) r8.push(t5.substring(i7, n8)), i7 = n8;
              return i7 < n7.length && r8.push(t5.substring(i7, n7.length)), r8;
            }(m4, cc(m4, c5, a4, r7, i6, d4));
            const b5 = [], w4 = { positionedLines: b5, text: m4.toString(), top: h4[1], bottom: h4[1], left: h4[0], right: h4[0], writingMode: p4, iconsInText: false, verticalizable: false };
            return function(t5, e8, r8, n7, i7, s6, a5, o8, l6, u5, c6, h5) {
              let p5 = 0, f5 = 0, d5 = 0, y5 = 0;
              const m5 = "right" === o8 ? 1 : "left" === o8 ? 0 : 0.5, g5 = Lu / h5;
              let x5 = 0;
              for (const a6 of i7) {
                a6.trim();
                const i8 = a6.getMaxScale(), o9 = { positionedGlyphs: [], lineOffset: 0 };
                t5.positionedLines[x5] = o9;
                const h6 = o9.positionedGlyphs;
                let v6 = 0;
                if (!a6.length()) {
                  f5 += s6, ++x5;
                  continue;
                }
                const b7 = pc(n7, a6, g5);
                for (let s7 = 0; s7 < a6.length(); s7++) {
                  const o10 = a6.getSection(s7), d6 = a6.getSectionIndex(s7), y6 = a6.getCharCode(s7), m6 = dc(l6, c6, y6);
                  let x6;
                  if (o10.imageName) {
                    if (t5.iconsInText = true, o10.scale = o10.scale * g5, x6 = mc(o10, m6, i8, b7, n7), !x6) continue;
                    v6 = Math.max(v6, x6.imageOffset);
                  } else if (x6 = yc(o10, y6, m6, b7, e8, r8), !x6) continue;
                  const { rect: w6, metrics: _4, baselineOffset: S5 } = x6;
                  h6.push({ glyph: y6, imageName: o10.imageName, x: p5, y: f5 + S5 + Wu, vertical: m6, scale: o10.scale, fontStack: o10.fontStack, sectionIndex: d6, metrics: _4, rect: w6 }), m6 ? (t5.verticalizable = true, p5 += (o10.imageName ? _4.advance : Lu) * o10.scale + u5) : p5 += _4.advance * o10.scale + u5;
                }
                0 !== h6.length && (d5 = Math.max(p5 - u5, d5), gc(h6, 0, h6.length - 1, m5)), p5 = 0, o9.lineOffset = Math.max(v6, (i8 - 1) * Lu);
                const w5 = s6 * i8 + v6;
                f5 += w5, y5 = Math.max(w5, y5), ++x5;
              }
              const { horizontalAlign: v5, verticalAlign: b6 } = hc(a5);
              (function(t6, e9, r9, n8, i8, s7, a6, o9, l7) {
                const u6 = (e9 - r9) * i8;
                let c7 = 0;
                c7 = s7 !== a6 ? -o9 * n8 - Wu : -n8 * l7 * a6 + 0.5 * a6;
                for (const e10 of t6) for (const t7 of e10.positionedGlyphs) t7.x += u6, t7.y += c7;
              })(t5.positionedLines, m5, v5, b6, d5, y5, s6, f5, i7.length), t5.top += -b6 * f5, t5.bottom = t5.top + f5, t5.left += -v5 * d5, t5.right = t5.left + d5;
            }(w4, r7, n6, i6, g4, o7, l5, u4, p4, c5, f4, y4), !function(t5) {
              for (const e8 of t5) if (0 !== e8.positionedGlyphs.length) return false;
              return true;
            }(b5) && w4;
          }
          const rc = { 9: true, 10: true, 11: true, 12: true, 13: true, 32: true }, nc = { 10: true, 32: true, 38: true, 41: true, 43: true, 45: true, 47: true, 173: true, 183: true, 8203: true, 8208: true, 8211: true, 8231: true }, ic = { 40: true };
          function sc(t5, e7, r7, n6, i6, s5) {
            if (e7.imageName) {
              const t6 = n6[e7.imageName];
              return t6 ? t6.displaySize[0] * e7.scale * Lu / s5 + i6 : 0;
            }
            {
              const n7 = r7[e7.fontStack], s6 = n7 && n7[t5];
              return s6 ? s6.metrics.advance * e7.scale + i6 : 0;
            }
          }
          function ac(t5, e7, r7, n6) {
            const i6 = Math.pow(t5 - e7, 2);
            return n6 ? t5 < e7 ? i6 / 2 : 2 * i6 : i6 + Math.abs(r7) * r7;
          }
          function oc(t5, e7, r7) {
            let n6 = 0;
            return 10 === t5 && (n6 -= 1e4), r7 && (n6 += 150), 40 !== t5 && 65288 !== t5 || (n6 += 50), 41 !== e7 && 65289 !== e7 || (n6 += 50), n6;
          }
          function lc(t5, e7, r7, n6, i6, s5) {
            let a4 = null, o7 = ac(e7, r7, i6, s5);
            for (const t6 of n6) {
              const n7 = ac(e7 - t6.x, r7, i6, s5) + t6.badness;
              n7 <= o7 && (a4 = t6, o7 = n7);
            }
            return { index: t5, x: e7, priorBreak: a4, badness: o7 };
          }
          function uc(t5) {
            return t5 ? uc(t5.priorBreak).concat(t5.index) : [];
          }
          function cc(t5, e7, r7, n6, i6, s5) {
            if (!t5) return [];
            const a4 = [], o7 = function(t6, e8, r8, n7, i7, s6) {
              let a5 = 0;
              for (let r9 = 0; r9 < t6.length(); r9++) {
                const o8 = t6.getSection(r9);
                a5 += sc(t6.getCharCode(r9), o8, n7, i7, e8, s6);
              }
              return a5 / Math.max(1, Math.ceil(a5 / r8));
            }(t5, e7, r7, n6, i6, s5), l5 = t5.text.indexOf("\u200B") >= 0;
            let u4 = 0;
            for (let r8 = 0; r8 < t5.length(); r8++) {
              const h4 = t5.getSection(r8), p4 = t5.getCharCode(r8);
              if (rc[p4] || (u4 += sc(p4, h4, n6, i6, e7, s5)), r8 < t5.length() - 1) {
                const e8 = !((c5 = p4) < 11904) && (!!Qi["CJK Compatibility Forms"](c5) || !!Qi["CJK Compatibility"](c5) || !!Qi["CJK Strokes"](c5) || !!Qi["CJK Symbols and Punctuation"](c5) || !!Qi["Enclosed CJK Letters and Months"](c5) || !!Qi["Halfwidth and Fullwidth Forms"](c5) || !!Qi["Ideographic Description Characters"](c5) || !!Qi["Vertical Forms"](c5) || ss.test(String.fromCodePoint(c5)));
                (nc[p4] || e8 || h4.imageName || r8 !== t5.length() - 2 && ic[t5.getCharCode(r8 + 1)]) && a4.push(lc(r8 + 1, u4, o7, a4, oc(p4, t5.getCharCode(r8 + 1), e8 && l5), false));
              }
            }
            var c5;
            return uc(lc(t5.length(), u4, o7, a4, 0, true));
          }
          function hc(t5) {
            let e7 = 0.5, r7 = 0.5;
            switch (t5) {
              case "right":
              case "top-right":
              case "bottom-right":
                e7 = 1;
                break;
              case "left":
              case "top-left":
              case "bottom-left":
                e7 = 0;
            }
            switch (t5) {
              case "bottom":
              case "bottom-right":
              case "bottom-left":
                r7 = 1;
                break;
              case "top":
              case "top-right":
              case "top-left":
                r7 = 0;
            }
            return { horizontalAlign: e7, verticalAlign: r7 };
          }
          function pc(t5, e7, r7) {
            const n6 = e7.getMaxScale() * Lu, { maxImageWidth: i6, maxImageHeight: s5 } = e7.getMaxImageSize(t5), a4 = Math.max(n6, s5 * r7);
            return { verticalLineContentWidth: Math.max(n6, i6 * r7), horizontalLineContentHeight: a4 };
          }
          function fc(t5) {
            switch (t5) {
              case "top":
                return 0;
              case "center":
                return 0.5;
              default:
                return 1;
            }
          }
          function dc(e7, r7, n6) {
            return !(e7 === t4.ah.horizontal || !r7 && !as(n6) || r7 && (rc[n6] || (i6 = n6, /\p{sc=Arab}/u.test(String.fromCodePoint(i6)))));
            var i6;
          }
          function yc(t5, e7, r7, n6, i6, s5) {
            const a4 = s5[t5.fontStack], o7 = function(t6, e8, r8, n7) {
              if (t6 && t6.rect) return t6;
              const i7 = e8[r8.fontStack], s6 = i7 && i7[n7];
              return s6 ? { rect: null, metrics: s6.metrics } : null;
            }(a4 && a4[e7], i6, t5, e7);
            if (null === o7) return null;
            let l5;
            if (r7) l5 = n6.verticalLineContentWidth - t5.scale * Lu;
            else {
              const e8 = fc(t5.verticalAlign);
              l5 = (n6.horizontalLineContentHeight - t5.scale * Lu) * e8;
            }
            return { rect: o7.rect, metrics: o7.metrics, baselineOffset: l5 };
          }
          function mc(t5, e7, r7, n6, i6) {
            const s5 = i6[t5.imageName];
            if (!s5) return null;
            const a4 = s5.paddedRect, o7 = s5.displaySize, l5 = { width: o7[0], height: o7[1], left: Xu, top: -3, advance: e7 ? o7[1] : o7[0] };
            let u4;
            if (e7) u4 = n6.verticalLineContentWidth - o7[1] * t5.scale;
            else {
              const e8 = fc(t5.verticalAlign);
              u4 = (n6.horizontalLineContentHeight - o7[1] * t5.scale) * e8;
            }
            return { rect: a4, metrics: l5, baselineOffset: u4, imageOffset: (e7 ? o7[0] : o7[1]) * t5.scale - Lu * r7 };
          }
          function gc(t5, e7, r7, n6) {
            if (0 === n6) return;
            const i6 = t5[r7], s5 = (t5[r7].x + i6.metrics.advance * i6.scale) * n6;
            for (let n7 = e7; n7 <= r7; n7++) t5[n7].x -= s5;
          }
          function xc(t5, e7, r7) {
            const { horizontalAlign: n6, verticalAlign: i6 } = hc(r7), s5 = e7[0] - t5.displaySize[0] * n6, a4 = e7[1] - t5.displaySize[1] * i6;
            return { image: t5, top: a4, bottom: a4 + t5.displaySize[1], left: s5, right: s5 + t5.displaySize[0] };
          }
          function vc(t5) {
            var e7, r7;
            let n6 = t5.left, i6 = t5.top, s5 = t5.right - n6, a4 = t5.bottom - i6;
            const o7 = null !== (e7 = t5.image.textFitWidth) && void 0 !== e7 ? e7 : "stretchOrShrink", l5 = null !== (r7 = t5.image.textFitHeight) && void 0 !== r7 ? r7 : "stretchOrShrink", u4 = (t5.image.content[2] - t5.image.content[0]) / (t5.image.content[3] - t5.image.content[1]);
            if ("proportional" === l5) {
              if ("stretchOnly" === o7 && s5 / a4 < u4 || "proportional" === o7) {
                const t6 = Math.ceil(a4 * u4);
                n6 *= t6 / s5, s5 = t6;
              }
            } else if ("proportional" === o7 && "stretchOnly" === l5 && 0 !== u4 && s5 / a4 > u4) {
              const t6 = Math.ceil(s5 / u4);
              i6 *= t6 / a4, a4 = t6;
            }
            return { x1: n6, y1: i6, x2: n6 + s5, y2: i6 + a4 };
          }
          function bc(t5, e7, r7, n6, i6, s5) {
            const a4 = t5.image;
            let o7;
            if (a4.content) {
              const t6 = a4.content, e8 = a4.pixelRatio || 1;
              o7 = [t6[0] / e8, t6[1] / e8, a4.displaySize[0] - t6[2] / e8, a4.displaySize[1] - t6[3] / e8];
            }
            const l5 = e7.left * s5, u4 = e7.right * s5;
            let c5, h4, p4, f4;
            "width" === r7 || "both" === r7 ? (f4 = i6[0] + l5 - n6[3], h4 = i6[0] + u4 + n6[1]) : (f4 = i6[0] + (l5 + u4 - a4.displaySize[0]) / 2, h4 = f4 + a4.displaySize[0]);
            const d4 = e7.top * s5, y4 = e7.bottom * s5;
            return "height" === r7 || "both" === r7 ? (c5 = i6[1] + d4 - n6[0], p4 = i6[1] + y4 + n6[2]) : (c5 = i6[1] + (d4 + y4 - a4.displaySize[1]) / 2, p4 = c5 + a4.displaySize[1]), { image: a4, top: c5, right: h4, bottom: p4, left: f4, collisionPadding: o7 };
          }
          const wc = 255, _c = 128, Sc = wc * _c;
          function Ac(t5, e7) {
            const { expression: r7 } = e7;
            if ("constant" === r7.kind) return { kind: "constant", layoutSize: r7.evaluate(new fs(t5 + 1)) };
            if ("source" === r7.kind) return { kind: "source" };
            {
              const { zoomStops: e8, interpolationType: n6 } = r7;
              let i6 = 0;
              for (; i6 < e8.length && e8[i6] <= t5; ) i6++;
              i6 = Math.max(0, i6 - 1);
              let s5 = i6;
              for (; s5 < e8.length && e8[s5] < t5 + 1; ) s5++;
              s5 = Math.min(e8.length - 1, s5);
              const a4 = e8[i6], o7 = e8[s5];
              return "composite" === r7.kind ? { kind: "composite", minZoom: a4, maxZoom: o7, interpolationType: n6 } : { kind: "camera", minZoom: a4, maxZoom: o7, minSize: r7.evaluate(new fs(a4)), maxSize: r7.evaluate(new fs(o7)), interpolationType: n6 };
            }
          }
          function kc(t5, e7, r7) {
            let n6 = "never";
            const i6 = t5.get(e7);
            return i6 ? n6 = i6 : t5.get(r7) && (n6 = "always"), n6;
          }
          const Mc = Ql.VectorTileFeature.types, Ic = [{ name: "a_fade_opacity", components: 1, type: "Uint8", offset: 0 }];
          function zc(t5, e7, r7, n6, i6, s5, a4, o7, l5, u4, c5, h4, p4) {
            const f4 = o7 ? Math.min(Sc, Math.round(o7[0])) : 0, d4 = o7 ? Math.min(Sc, Math.round(o7[1])) : 0;
            t5.emplaceBack(e7, r7, Math.round(32 * n6), Math.round(32 * i6), s5, a4, (f4 << 1) + (l5 ? 1 : 0), d4, 16 * u4, 16 * c5, 256 * h4, 256 * p4);
          }
          function Pc(t5, e7, r7) {
            t5.emplaceBack(e7.x, e7.y, r7), t5.emplaceBack(e7.x, e7.y, r7), t5.emplaceBack(e7.x, e7.y, r7), t5.emplaceBack(e7.x, e7.y, r7);
          }
          function Cc(t5) {
            for (const e7 of t5.sections) if (hs(e7.text)) return true;
            return false;
          }
          class Bc {
            constructor(t5) {
              this.layoutVertexArray = new Sa(), this.indexArray = new za(), this.programConfigurations = t5, this.segments = new Va(), this.dynamicLayoutVertexArray = new Aa(), this.opacityVertexArray = new ka(), this.hasVisibleVertices = false, this.placedSymbolArray = new oa();
            }
            isEmpty() {
              return 0 === this.layoutVertexArray.length && 0 === this.indexArray.length && 0 === this.dynamicLayoutVertexArray.length && 0 === this.opacityVertexArray.length;
            }
            upload(t5, e7, r7, n6) {
              this.isEmpty() || (r7 && (this.layoutVertexBuffer = t5.createVertexBuffer(this.layoutVertexArray, Iu.members), this.indexBuffer = t5.createIndexBuffer(this.indexArray, e7), this.dynamicLayoutVertexBuffer = t5.createVertexBuffer(this.dynamicLayoutVertexArray, zu.members, true), this.opacityVertexBuffer = t5.createVertexBuffer(this.opacityVertexArray, Ic, true), this.opacityVertexBuffer.itemSize = 1), (r7 || n6) && this.programConfigurations.upload(t5));
            }
            destroy() {
              this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.dynamicLayoutVertexBuffer.destroy(), this.opacityVertexBuffer.destroy());
            }
          }
          Zi("SymbolBuffers", Bc);
          class Vc {
            constructor(t5, e7, r7) {
              this.layoutVertexArray = new t5(), this.layoutAttributes = e7, this.indexArray = new r7(), this.segments = new Va(), this.collisionVertexArray = new Ia();
            }
            upload(t5) {
              this.layoutVertexBuffer = t5.createVertexBuffer(this.layoutVertexArray, this.layoutAttributes), this.indexBuffer = t5.createIndexBuffer(this.indexArray), this.collisionVertexBuffer = t5.createVertexBuffer(this.collisionVertexArray, Pu.members, true);
            }
            destroy() {
              this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.segments.destroy(), this.collisionVertexBuffer.destroy());
            }
          }
          Zi("CollisionBuffers", Vc);
          class Ec {
            constructor(e7) {
              this.collisionBoxArray = e7.collisionBoxArray, this.zoom = e7.zoom, this.overscaling = e7.overscaling, this.layers = e7.layers, this.layerIds = this.layers.map((t5) => t5.id), this.index = e7.index, this.pixelRatio = e7.pixelRatio, this.sourceLayerIndex = e7.sourceLayerIndex, this.hasPattern = false, this.hasRTLText = false, this.sortKeyRanges = [], this.collisionCircleArray = [];
              const r7 = this.layers[0]._unevaluatedLayout._values;
              this.textSizeData = Ac(this.zoom, r7["text-size"]), this.iconSizeData = Ac(this.zoom, r7["icon-size"]);
              const n6 = this.layers[0].layout, i6 = n6.get("symbol-sort-key"), s5 = n6.get("symbol-z-order");
              this.canOverlap = "never" !== kc(n6, "text-overlap", "text-allow-overlap") || "never" !== kc(n6, "icon-overlap", "icon-allow-overlap") || n6.get("text-ignore-placement") || n6.get("icon-ignore-placement"), this.sortFeaturesByKey = "viewport-y" !== s5 && !i6.isConstant(), this.sortFeaturesByY = ("viewport-y" === s5 || "auto" === s5 && !this.sortFeaturesByKey) && this.canOverlap, "point" === n6.get("symbol-placement") && (this.writingModes = n6.get("text-writing-mode").map((e8) => t4.ah[e8])), this.stateDependentLayerIds = this.layers.filter((t5) => t5.isStateDependent()).map((t5) => t5.id), this.sourceID = e7.sourceID;
            }
            createArrays() {
              this.text = new Bc(new so(this.layers, this.zoom, (t5) => /^text/.test(t5))), this.icon = new Bc(new so(this.layers, this.zoom, (t5) => /^icon/.test(t5))), this.glyphOffsetArray = new ca(), this.lineVertexArray = new ha(), this.symbolInstances = new ua(), this.textAnchorOffsets = new fa();
            }
            calculateGlyphDependencies(t5, e7, r7, n6, i6) {
              for (let s5 = 0; s5 < t5.length; s5++) if (e7[t5.charCodeAt(s5)] = true, (r7 || n6) && i6) {
                const r8 = Eu[t5.charAt(s5)];
                r8 && (e7[r8.charCodeAt(0)] = true);
              }
            }
            populate(e7, r7, n6) {
              const i6 = this.layers[0], s5 = i6.layout, a4 = s5.get("text-font"), o7 = s5.get("text-field"), l5 = s5.get("icon-image"), u4 = ("constant" !== o7.value.kind || o7.value.value instanceof _e && !o7.value.value.isEmpty() || o7.value.value.toString().length > 0) && ("constant" !== a4.value.kind || a4.value.value.length > 0), c5 = "constant" !== l5.value.kind || !!l5.value.value || Object.keys(l5.parameters).length > 0, h4 = s5.get("symbol-sort-key");
              if (this.features = [], !u4 && !c5) return;
              const p4 = r7.iconDependencies, f4 = r7.glyphDependencies, d4 = r7.availableImages, y4 = new fs(this.zoom);
              for (const { feature: r8, id: o8, index: l6, sourceLayerIndex: m4 } of e7) {
                const e8 = i6._featureFilter.needGeometry, g4 = ho(r8, e8);
                if (!i6._featureFilter.filter(y4, g4, n6)) continue;
                let x4, v4;
                if (e8 || (g4.geometry = co(r8)), u4) {
                  const t5 = i6.getValueAndResolveTokens("text-field", g4, n6, d4), e9 = _e.factory(t5), r9 = this.hasRTLText = this.hasRTLText || Cc(e9);
                  (!r9 || "unavailable" === ps.getRTLTextPluginStatus() || r9 && ps.isParsed()) && (x4 = Vu(e9, i6, g4));
                }
                if (c5) {
                  const t5 = i6.getValueAndResolveTokens("icon-image", g4, n6, d4);
                  v4 = t5 instanceof Ie ? t5 : Ie.fromString(t5);
                }
                if (!x4 && !v4) continue;
                const b5 = this.sortFeaturesByKey ? h4.evaluate(g4, {}, n6) : void 0;
                if (this.features.push({ id: o8, text: x4, icon: v4, index: l6, sourceLayerIndex: m4, geometry: g4.geometry, properties: r8.properties, type: Mc[r8.type], sortKey: b5 }), v4 && (p4[v4.name] = true), x4) {
                  const e9 = a4.evaluate(g4, {}, n6).join(","), r9 = "viewport" !== s5.get("text-rotation-alignment") && "point" !== s5.get("symbol-placement");
                  this.allowVerticalPlacement = this.writingModes && this.writingModes.indexOf(t4.ah.vertical) >= 0;
                  for (const t5 of x4.sections) if (t5.image) p4[t5.image.name] = true;
                  else {
                    const n7 = ts(x4.toString()), i7 = t5.fontStack || e9, s6 = f4[i7] = f4[i7] || {};
                    this.calculateGlyphDependencies(t5.text, s6, r9, this.allowVerticalPlacement, n7);
                  }
                }
              }
              "line" === s5.get("symbol-placement") && (this.features = function(t5) {
                const e8 = {}, r8 = {}, n7 = [];
                let i7 = 0;
                function s6(e9) {
                  n7.push(t5[e9]), i7++;
                }
                function a5(t6, e9, i8) {
                  const s7 = r8[t6];
                  return delete r8[t6], r8[e9] = s7, n7[s7].geometry[0].pop(), n7[s7].geometry[0] = n7[s7].geometry[0].concat(i8[0]), s7;
                }
                function o8(t6, r9, i8) {
                  const s7 = e8[r9];
                  return delete e8[r9], e8[t6] = s7, n7[s7].geometry[0].shift(), n7[s7].geometry[0] = i8[0].concat(n7[s7].geometry[0]), s7;
                }
                function l6(t6, e9, r9) {
                  const n8 = r9 ? e9[0][e9[0].length - 1] : e9[0][0];
                  return `${t6}:${n8.x}:${n8.y}`;
                }
                for (let u5 = 0; u5 < t5.length; u5++) {
                  const c6 = t5[u5], h5 = c6.geometry, p5 = c6.text ? c6.text.toString() : null;
                  if (!p5) {
                    s6(u5);
                    continue;
                  }
                  const f5 = l6(p5, h5), d5 = l6(p5, h5, true);
                  if (f5 in r8 && d5 in e8 && r8[f5] !== e8[d5]) {
                    const t6 = o8(f5, d5, h5), i8 = a5(f5, d5, n7[t6].geometry);
                    delete e8[f5], delete r8[d5], r8[l6(p5, n7[i8].geometry, true)] = i8, n7[t6].geometry = null;
                  } else f5 in r8 ? a5(f5, d5, h5) : d5 in e8 ? o8(f5, d5, h5) : (s6(u5), e8[f5] = i7 - 1, r8[d5] = i7 - 1);
                }
                return n7.filter((t6) => t6.geometry);
              }(this.features)), this.sortFeaturesByKey && this.features.sort((t5, e8) => t5.sortKey - e8.sortKey);
            }
            update(t5, e7, r7) {
              this.stateDependentLayers.length && (this.text.programConfigurations.updatePaintArrays(t5, e7, this.layers, r7), this.icon.programConfigurations.updatePaintArrays(t5, e7, this.layers, r7));
            }
            isEmpty() {
              return 0 === this.symbolInstances.length && !this.hasRTLText;
            }
            uploadPending() {
              return !this.uploaded || this.text.programConfigurations.needsUpload || this.icon.programConfigurations.needsUpload;
            }
            upload(t5) {
              !this.uploaded && this.hasDebugData() && (this.textCollisionBox.upload(t5), this.iconCollisionBox.upload(t5)), this.text.upload(t5, this.sortFeaturesByY, !this.uploaded, this.text.programConfigurations.needsUpload), this.icon.upload(t5, this.sortFeaturesByY, !this.uploaded, this.icon.programConfigurations.needsUpload), this.uploaded = true;
            }
            destroyDebugData() {
              this.textCollisionBox.destroy(), this.iconCollisionBox.destroy();
            }
            destroy() {
              this.text.destroy(), this.icon.destroy(), this.hasDebugData() && this.destroyDebugData();
            }
            addToLineVertexArray(t5, e7) {
              const r7 = this.lineVertexArray.length;
              if (void 0 !== t5.segment) {
                let r8 = t5.dist(e7[t5.segment + 1]), n6 = t5.dist(e7[t5.segment]);
                const i6 = {};
                for (let n7 = t5.segment + 1; n7 < e7.length; n7++) i6[n7] = { x: e7[n7].x, y: e7[n7].y, tileUnitDistanceFromAnchor: r8 }, n7 < e7.length - 1 && (r8 += e7[n7 + 1].dist(e7[n7]));
                for (let r9 = t5.segment || 0; r9 >= 0; r9--) i6[r9] = { x: e7[r9].x, y: e7[r9].y, tileUnitDistanceFromAnchor: n6 }, r9 > 0 && (n6 += e7[r9 - 1].dist(e7[r9]));
                for (let t6 = 0; t6 < e7.length; t6++) {
                  const e8 = i6[t6];
                  this.lineVertexArray.emplaceBack(e8.x, e8.y, e8.tileUnitDistanceFromAnchor);
                }
              }
              return { lineStartIndex: r7, lineLength: this.lineVertexArray.length - r7 };
            }
            addSymbols(e7, r7, n6, i6, s5, a4, o7, l5, u4, c5, h4, p4) {
              const f4 = e7.indexArray, d4 = e7.layoutVertexArray, y4 = e7.segments.prepareSegment(4 * r7.length, d4, f4, this.canOverlap ? a4.sortKey : void 0), m4 = this.glyphOffsetArray.length, g4 = y4.vertexLength, x4 = this.allowVerticalPlacement && o7 === t4.ah.vertical ? Math.PI / 2 : 0, v4 = a4.text && a4.text.sections;
              for (let t5 = 0; t5 < r7.length; t5++) {
                const { tl: i7, tr: s6, bl: o8, br: u5, tex: c6, pixelOffsetTL: h5, pixelOffsetBR: m5, minFontScaleX: g5, minFontScaleY: b5, glyphOffset: w4, isSDF: _4, sectionIndex: S5 } = r7[t5], A5 = y4.vertexLength, k4 = w4[1];
                zc(d4, l5.x, l5.y, i7.x, k4 + i7.y, c6.x, c6.y, n6, _4, h5.x, h5.y, g5, b5), zc(d4, l5.x, l5.y, s6.x, k4 + s6.y, c6.x + c6.w, c6.y, n6, _4, m5.x, h5.y, g5, b5), zc(d4, l5.x, l5.y, o8.x, k4 + o8.y, c6.x, c6.y + c6.h, n6, _4, h5.x, m5.y, g5, b5), zc(d4, l5.x, l5.y, u5.x, k4 + u5.y, c6.x + c6.w, c6.y + c6.h, n6, _4, m5.x, m5.y, g5, b5), Pc(e7.dynamicLayoutVertexArray, l5, x4), f4.emplaceBack(A5, A5 + 2, A5 + 1), f4.emplaceBack(A5 + 1, A5 + 2, A5 + 3), y4.vertexLength += 4, y4.primitiveLength += 2, this.glyphOffsetArray.emplaceBack(w4[0]), t5 !== r7.length - 1 && S5 === r7[t5 + 1].sectionIndex || e7.programConfigurations.populatePaintArrays(d4.length, a4, a4.index, {}, p4, v4 && v4[S5]);
              }
              e7.placedSymbolArray.emplaceBack(l5.x, l5.y, m4, this.glyphOffsetArray.length - m4, g4, u4, c5, l5.segment, n6 ? n6[0] : 0, n6 ? n6[1] : 0, i6[0], i6[1], o7, 0, false, 0, h4);
            }
            _addCollisionDebugVertex(t5, e7, r7, n6, i6, s5) {
              return e7.emplaceBack(0, 0), t5.emplaceBack(r7.x, r7.y, n6, i6, Math.round(s5.x), Math.round(s5.y));
            }
            addCollisionDebugVertices(t5, e7, r7, n6, i6, s5, a4) {
              const o7 = i6.segments.prepareSegment(4, i6.layoutVertexArray, i6.indexArray), u4 = o7.vertexLength, c5 = i6.layoutVertexArray, h4 = i6.collisionVertexArray, p4 = a4.anchorX, f4 = a4.anchorY;
              this._addCollisionDebugVertex(c5, h4, s5, p4, f4, new l4(t5, e7)), this._addCollisionDebugVertex(c5, h4, s5, p4, f4, new l4(r7, e7)), this._addCollisionDebugVertex(c5, h4, s5, p4, f4, new l4(r7, n6)), this._addCollisionDebugVertex(c5, h4, s5, p4, f4, new l4(t5, n6)), o7.vertexLength += 4;
              const d4 = i6.indexArray;
              d4.emplaceBack(u4, u4 + 1), d4.emplaceBack(u4 + 1, u4 + 2), d4.emplaceBack(u4 + 2, u4 + 3), d4.emplaceBack(u4 + 3, u4), o7.primitiveLength += 4;
            }
            addDebugCollisionBoxes(t5, e7, r7, n6) {
              for (let i6 = t5; i6 < e7; i6++) {
                const t6 = this.collisionBoxArray.get(i6);
                this.addCollisionDebugVertices(t6.x1, t6.y1, t6.x2, t6.y2, n6 ? this.textCollisionBox : this.iconCollisionBox, t6.anchorPoint, r7);
              }
            }
            generateCollisionDebugBuffers() {
              this.hasDebugData() && this.destroyDebugData(), this.textCollisionBox = new Vc(Ma, Cu.members, Pa), this.iconCollisionBox = new Vc(Ma, Cu.members, Pa);
              for (let t5 = 0; t5 < this.symbolInstances.length; t5++) {
                const e7 = this.symbolInstances.get(t5);
                this.addDebugCollisionBoxes(e7.textBoxStartIndex, e7.textBoxEndIndex, e7, true), this.addDebugCollisionBoxes(e7.verticalTextBoxStartIndex, e7.verticalTextBoxEndIndex, e7, true), this.addDebugCollisionBoxes(e7.iconBoxStartIndex, e7.iconBoxEndIndex, e7, false), this.addDebugCollisionBoxes(e7.verticalIconBoxStartIndex, e7.verticalIconBoxEndIndex, e7, false);
              }
            }
            _deserializeCollisionBoxesForSymbol(t5, e7, r7, n6, i6, s5, a4, o7, l5) {
              const u4 = {};
              for (let n7 = e7; n7 < r7; n7++) {
                const e8 = t5.get(n7);
                u4.textBox = { x1: e8.x1, y1: e8.y1, x2: e8.x2, y2: e8.y2, anchorPointX: e8.anchorPointX, anchorPointY: e8.anchorPointY }, u4.textFeatureIndex = e8.featureIndex;
                break;
              }
              for (let e8 = n6; e8 < i6; e8++) {
                const r8 = t5.get(e8);
                u4.verticalTextBox = { x1: r8.x1, y1: r8.y1, x2: r8.x2, y2: r8.y2, anchorPointX: r8.anchorPointX, anchorPointY: r8.anchorPointY }, u4.verticalTextFeatureIndex = r8.featureIndex;
                break;
              }
              for (let e8 = s5; e8 < a4; e8++) {
                const r8 = t5.get(e8);
                u4.iconBox = { x1: r8.x1, y1: r8.y1, x2: r8.x2, y2: r8.y2, anchorPointX: r8.anchorPointX, anchorPointY: r8.anchorPointY }, u4.iconFeatureIndex = r8.featureIndex;
                break;
              }
              for (let e8 = o7; e8 < l5; e8++) {
                const r8 = t5.get(e8);
                u4.verticalIconBox = { x1: r8.x1, y1: r8.y1, x2: r8.x2, y2: r8.y2, anchorPointX: r8.anchorPointX, anchorPointY: r8.anchorPointY }, u4.verticalIconFeatureIndex = r8.featureIndex;
                break;
              }
              return u4;
            }
            deserializeCollisionBoxes(t5) {
              this.collisionArrays = [];
              for (let e7 = 0; e7 < this.symbolInstances.length; e7++) {
                const r7 = this.symbolInstances.get(e7);
                this.collisionArrays.push(this._deserializeCollisionBoxesForSymbol(t5, r7.textBoxStartIndex, r7.textBoxEndIndex, r7.verticalTextBoxStartIndex, r7.verticalTextBoxEndIndex, r7.iconBoxStartIndex, r7.iconBoxEndIndex, r7.verticalIconBoxStartIndex, r7.verticalIconBoxEndIndex));
              }
            }
            hasTextData() {
              return this.text.segments.get().length > 0;
            }
            hasIconData() {
              return this.icon.segments.get().length > 0;
            }
            hasDebugData() {
              return this.textCollisionBox && this.iconCollisionBox;
            }
            hasTextCollisionBoxData() {
              return this.hasDebugData() && this.textCollisionBox.segments.get().length > 0;
            }
            hasIconCollisionBoxData() {
              return this.hasDebugData() && this.iconCollisionBox.segments.get().length > 0;
            }
            addIndicesForPlacedSymbol(t5, e7) {
              const r7 = t5.placedSymbolArray.get(e7), n6 = r7.vertexStartIndex + 4 * r7.numGlyphs;
              for (let e8 = r7.vertexStartIndex; e8 < n6; e8 += 4) t5.indexArray.emplaceBack(e8, e8 + 2, e8 + 1), t5.indexArray.emplaceBack(e8 + 1, e8 + 2, e8 + 3);
            }
            getSortedSymbolIndexes(t5) {
              if (this.sortedAngle === t5 && void 0 !== this.symbolInstanceIndexes) return this.symbolInstanceIndexes;
              const e7 = Math.sin(t5), r7 = Math.cos(t5), n6 = [], i6 = [], s5 = [];
              for (let t6 = 0; t6 < this.symbolInstances.length; ++t6) {
                s5.push(t6);
                const a4 = this.symbolInstances.get(t6);
                n6.push(0 | Math.round(e7 * a4.anchorX + r7 * a4.anchorY)), i6.push(a4.featureIndex);
              }
              return s5.sort((t6, e8) => n6[t6] - n6[e8] || i6[e8] - i6[t6]), s5;
            }
            addToSortKeyRanges(t5, e7) {
              const r7 = this.sortKeyRanges[this.sortKeyRanges.length - 1];
              r7 && r7.sortKey === e7 ? r7.symbolInstanceEnd = t5 + 1 : this.sortKeyRanges.push({ sortKey: e7, symbolInstanceStart: t5, symbolInstanceEnd: t5 + 1 });
            }
            sortFeatures(t5) {
              if (this.sortFeaturesByY && this.sortedAngle !== t5 && !(this.text.segments.get().length > 1 || this.icon.segments.get().length > 1)) {
                this.symbolInstanceIndexes = this.getSortedSymbolIndexes(t5), this.sortedAngle = t5, this.text.indexArray.clear(), this.icon.indexArray.clear(), this.featureSortOrder = [];
                for (const t6 of this.symbolInstanceIndexes) {
                  const e7 = this.symbolInstances.get(t6);
                  this.featureSortOrder.push(e7.featureIndex), [e7.rightJustifiedTextSymbolIndex, e7.centerJustifiedTextSymbolIndex, e7.leftJustifiedTextSymbolIndex].forEach((t7, e8, r7) => {
                    t7 >= 0 && r7.indexOf(t7) === e8 && this.addIndicesForPlacedSymbol(this.text, t7);
                  }), e7.verticalPlacedTextSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.text, e7.verticalPlacedTextSymbolIndex), e7.placedIconSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.icon, e7.placedIconSymbolIndex), e7.verticalPlacedIconSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.icon, e7.verticalPlacedIconSymbolIndex);
                }
                this.text.indexBuffer && this.text.indexBuffer.updateData(this.text.indexArray), this.icon.indexBuffer && this.icon.indexBuffer.updateData(this.icon.indexArray);
              }
            }
          }
          let Tc, Fc;
          Zi("SymbolBucket", Ec, { omit: ["layers", "collisionBoxArray", "features", "compareText"] }), Ec.MAX_GLYPHS = 65535, Ec.addDynamicAttributes = Pc;
          var $c = { get paint() {
            return Fc = Fc || new Is({ "icon-opacity": new Ss(dt.paint_symbol["icon-opacity"]), "icon-color": new Ss(dt.paint_symbol["icon-color"]), "icon-halo-color": new Ss(dt.paint_symbol["icon-halo-color"]), "icon-halo-width": new Ss(dt.paint_symbol["icon-halo-width"]), "icon-halo-blur": new Ss(dt.paint_symbol["icon-halo-blur"]), "icon-translate": new _s(dt.paint_symbol["icon-translate"]), "icon-translate-anchor": new _s(dt.paint_symbol["icon-translate-anchor"]), "text-opacity": new Ss(dt.paint_symbol["text-opacity"]), "text-color": new Ss(dt.paint_symbol["text-color"], { runtimeType: Tt, getOverride: (t5) => t5.textColor, hasOverride: (t5) => !!t5.textColor }), "text-halo-color": new Ss(dt.paint_symbol["text-halo-color"]), "text-halo-width": new Ss(dt.paint_symbol["text-halo-width"]), "text-halo-blur": new Ss(dt.paint_symbol["text-halo-blur"]), "text-translate": new _s(dt.paint_symbol["text-translate"]), "text-translate-anchor": new _s(dt.paint_symbol["text-translate-anchor"]) });
          }, get layout() {
            return Tc = Tc || new Is({ "symbol-placement": new _s(dt.layout_symbol["symbol-placement"]), "symbol-spacing": new _s(dt.layout_symbol["symbol-spacing"]), "symbol-avoid-edges": new _s(dt.layout_symbol["symbol-avoid-edges"]), "symbol-sort-key": new Ss(dt.layout_symbol["symbol-sort-key"]), "symbol-z-order": new _s(dt.layout_symbol["symbol-z-order"]), "icon-allow-overlap": new _s(dt.layout_symbol["icon-allow-overlap"]), "icon-overlap": new _s(dt.layout_symbol["icon-overlap"]), "icon-ignore-placement": new _s(dt.layout_symbol["icon-ignore-placement"]), "icon-optional": new _s(dt.layout_symbol["icon-optional"]), "icon-rotation-alignment": new _s(dt.layout_symbol["icon-rotation-alignment"]), "icon-size": new Ss(dt.layout_symbol["icon-size"]), "icon-text-fit": new _s(dt.layout_symbol["icon-text-fit"]), "icon-text-fit-padding": new _s(dt.layout_symbol["icon-text-fit-padding"]), "icon-image": new Ss(dt.layout_symbol["icon-image"]), "icon-rotate": new Ss(dt.layout_symbol["icon-rotate"]), "icon-padding": new Ss(dt.layout_symbol["icon-padding"]), "icon-keep-upright": new _s(dt.layout_symbol["icon-keep-upright"]), "icon-offset": new Ss(dt.layout_symbol["icon-offset"]), "icon-anchor": new Ss(dt.layout_symbol["icon-anchor"]), "icon-pitch-alignment": new _s(dt.layout_symbol["icon-pitch-alignment"]), "text-pitch-alignment": new _s(dt.layout_symbol["text-pitch-alignment"]), "text-rotation-alignment": new _s(dt.layout_symbol["text-rotation-alignment"]), "text-field": new Ss(dt.layout_symbol["text-field"]), "text-font": new Ss(dt.layout_symbol["text-font"]), "text-size": new Ss(dt.layout_symbol["text-size"]), "text-max-width": new Ss(dt.layout_symbol["text-max-width"]), "text-line-height": new _s(dt.layout_symbol["text-line-height"]), "text-letter-spacing": new Ss(dt.layout_symbol["text-letter-spacing"]), "text-justify": new Ss(dt.layout_symbol["text-justify"]), "text-radial-offset": new Ss(dt.layout_symbol["text-radial-offset"]), "text-variable-anchor": new _s(dt.layout_symbol["text-variable-anchor"]), "text-variable-anchor-offset": new Ss(dt.layout_symbol["text-variable-anchor-offset"]), "text-anchor": new Ss(dt.layout_symbol["text-anchor"]), "text-max-angle": new _s(dt.layout_symbol["text-max-angle"]), "text-writing-mode": new _s(dt.layout_symbol["text-writing-mode"]), "text-rotate": new Ss(dt.layout_symbol["text-rotate"]), "text-padding": new _s(dt.layout_symbol["text-padding"]), "text-keep-upright": new _s(dt.layout_symbol["text-keep-upright"]), "text-transform": new Ss(dt.layout_symbol["text-transform"]), "text-offset": new Ss(dt.layout_symbol["text-offset"]), "text-allow-overlap": new _s(dt.layout_symbol["text-allow-overlap"]), "text-overlap": new _s(dt.layout_symbol["text-overlap"]), "text-ignore-placement": new _s(dt.layout_symbol["text-ignore-placement"]), "text-optional": new _s(dt.layout_symbol["text-optional"]) });
          } };
          class Lc {
            constructor(t5) {
              if (void 0 === t5.property.overrides) throw new Error("overrides must be provided to instantiate FormatSectionOverride class");
              this.type = t5.property.overrides ? t5.property.overrides.runtimeType : Ct, this.defaultValue = t5;
            }
            evaluate(t5) {
              if (t5.formattedSection) {
                const e7 = this.defaultValue.property.overrides;
                if (e7 && e7.hasOverride(t5.formattedSection)) return e7.getOverride(t5.formattedSection);
              }
              return t5.feature && t5.featureState ? this.defaultValue.evaluate(t5.feature, t5.featureState) : this.defaultValue.property.specification.default;
            }
            eachChild(t5) {
              this.defaultValue.isConstant() || t5(this.defaultValue.value._styleExpression.expression);
            }
            outputDefined() {
              return false;
            }
            serialize() {
              return null;
            }
          }
          Zi("FormatSectionOverride", Lc, { omit: ["defaultValue"] });
          class Oc extends Ps {
            constructor(t5) {
              super(t5, $c);
            }
            recalculate(t5, e7) {
              if (super.recalculate(t5, e7), "auto" === this.layout.get("icon-rotation-alignment") && (this.layout._values["icon-rotation-alignment"] = "point" !== this.layout.get("symbol-placement") ? "map" : "viewport"), "auto" === this.layout.get("text-rotation-alignment") && (this.layout._values["text-rotation-alignment"] = "point" !== this.layout.get("symbol-placement") ? "map" : "viewport"), "auto" === this.layout.get("text-pitch-alignment") && (this.layout._values["text-pitch-alignment"] = "map" === this.layout.get("text-rotation-alignment") ? "map" : "viewport"), "auto" === this.layout.get("icon-pitch-alignment") && (this.layout._values["icon-pitch-alignment"] = this.layout.get("icon-rotation-alignment")), "point" === this.layout.get("symbol-placement")) {
                const t6 = this.layout.get("text-writing-mode");
                if (t6) {
                  const e8 = [];
                  for (const r7 of t6) e8.indexOf(r7) < 0 && e8.push(r7);
                  this.layout._values["text-writing-mode"] = e8;
                } else this.layout._values["text-writing-mode"] = ["horizontal"];
              }
              this._setPaintOverrides();
            }
            getValueAndResolveTokens(t5, e7, r7, n6) {
              const i6 = this.layout.get(t5).evaluate(e7, {}, r7, n6), s5 = this._unevaluatedLayout._values[t5];
              return s5.isDataDriven() || qn(s5.value) || !i6 ? i6 : function(t6, e8) {
                return e8.replace(/{([^{}]+)}/g, (e9, r8) => t6 && r8 in t6 ? String(t6[r8]) : "");
              }(e7.properties, i6);
            }
            createBucket(t5) {
              return new Ec(t5);
            }
            queryRadius() {
              return 0;
            }
            queryIntersectsFeature() {
              throw new Error("Should take a different path in FeatureIndex");
            }
            _setPaintOverrides() {
              for (const t5 of $c.paint.overridableProperties) {
                if (!Oc.hasPaintOverride(this.layout, t5)) continue;
                const e7 = this.paint.get(t5), r7 = new Lc(e7), n6 = new Un(r7, e7.property.specification);
                let i6 = null;
                i6 = "constant" === e7.value.kind || "source" === e7.value.kind ? new Zn("source", n6) : new Kn("composite", n6, e7.value.zoomStops), this.paint._values[t5] = new bs(e7.property, i6, e7.parameters);
              }
            }
            _handleOverridablePaintPropertyUpdate(t5, e7, r7) {
              return !(!this.layout || e7.isDataDriven() || r7.isDataDriven()) && Oc.hasPaintOverride(this.layout, t5);
            }
            static hasPaintOverride(t5, e7) {
              const r7 = t5.get("text-field"), n6 = $c.paint.properties[e7];
              let i6 = false;
              const s5 = (t6) => {
                for (const e8 of t6) if (n6.overrides && n6.overrides.hasOverride(e8)) return void (i6 = true);
              };
              if ("constant" === r7.value.kind && r7.value.value instanceof _e) s5(r7.value.value.sections);
              else if ("source" === r7.value.kind) {
                const t6 = (e9) => {
                  i6 || (e9 instanceof Ee && Be(e9.value) === Dt ? s5(e9.value.sections) : e9 instanceof gr ? s5(e9.sections) : e9.eachChild(t6));
                }, e8 = r7.value;
                e8._styleExpression && t6(e8._styleExpression.expression);
              }
              return i6;
            }
          }
          let Dc;
          var Rc = { get paint() {
            return Dc = Dc || new Is({ "background-color": new _s(dt.paint_background["background-color"]), "background-pattern": new ks(dt.paint_background["background-pattern"]), "background-opacity": new _s(dt.paint_background["background-opacity"]) });
          } };
          class jc extends Ps {
            constructor(t5) {
              super(t5, Rc);
            }
          }
          let Nc;
          var Uc = { get paint() {
            return Nc = Nc || new Is({ "raster-opacity": new _s(dt.paint_raster["raster-opacity"]), "raster-hue-rotate": new _s(dt.paint_raster["raster-hue-rotate"]), "raster-brightness-min": new _s(dt.paint_raster["raster-brightness-min"]), "raster-brightness-max": new _s(dt.paint_raster["raster-brightness-max"]), "raster-saturation": new _s(dt.paint_raster["raster-saturation"]), "raster-contrast": new _s(dt.paint_raster["raster-contrast"]), "raster-resampling": new _s(dt.paint_raster["raster-resampling"]), "raster-fade-duration": new _s(dt.paint_raster["raster-fade-duration"]) });
          } };
          class qc extends Ps {
            constructor(t5) {
              super(t5, Uc);
            }
          }
          class Gc extends Ps {
            constructor(t5) {
              super(t5, {}), this.onAdd = (t6) => {
                this.implementation.onAdd && this.implementation.onAdd(t6, t6.painter.context.gl);
              }, this.onRemove = (t6) => {
                this.implementation.onRemove && this.implementation.onRemove(t6, t6.painter.context.gl);
              }, this.implementation = t5;
            }
            is3D() {
              return "3d" === this.implementation.renderingMode;
            }
            hasOffscreenPass() {
              return void 0 !== this.implementation.prerender;
            }
            recalculate() {
            }
            updateTransitions() {
            }
            hasTransition() {
              return false;
            }
            serialize() {
              throw new Error("Custom layers cannot be serialized");
            }
          }
          class Zc {
            constructor(t5) {
              this._methodToThrottle = t5, this._triggered = false, "undefined" != typeof MessageChannel && (this._channel = new MessageChannel(), this._channel.port2.onmessage = () => {
                this._triggered = false, this._methodToThrottle();
              });
            }
            trigger() {
              this._triggered || (this._triggered = true, this._channel ? this._channel.port1.postMessage(true) : setTimeout(() => {
                this._triggered = false, this._methodToThrottle();
              }, 0));
            }
            remove() {
              delete this._channel, this._methodToThrottle = () => {
              };
            }
          }
          const Kc = { once: true }, Xc = 63710088e-1;
          class Hc {
            constructor(t5, e7) {
              if (isNaN(t5) || isNaN(e7)) throw new Error(`Invalid LngLat object: (${t5}, ${e7})`);
              if (this.lng = +t5, this.lat = +e7, this.lat > 90 || this.lat < -90) throw new Error("Invalid LngLat latitude value: must be between -90 and 90");
            }
            wrap() {
              return new Hc(T4(this.lng, -180, 180), this.lat);
            }
            toArray() {
              return [this.lng, this.lat];
            }
            toString() {
              return `LngLat(${this.lng}, ${this.lat})`;
            }
            distanceTo(t5) {
              const e7 = Math.PI / 180, r7 = this.lat * e7, n6 = t5.lat * e7, i6 = Math.sin(r7) * Math.sin(n6) + Math.cos(r7) * Math.cos(n6) * Math.cos((t5.lng - this.lng) * e7);
              return Xc * Math.acos(Math.min(i6, 1));
            }
            static convert(t5) {
              if (t5 instanceof Hc) return t5;
              if (Array.isArray(t5) && (2 === t5.length || 3 === t5.length)) return new Hc(Number(t5[0]), Number(t5[1]));
              if (!Array.isArray(t5) && "object" == typeof t5 && null !== t5) return new Hc(Number("lng" in t5 ? t5.lng : t5.lon), Number(t5.lat));
              throw new Error("`LngLatLike` argument must be specified as a LngLat instance, an object {lng: <lng>, lat: <lat>}, an object {lon: <lng>, lat: <lat>}, or an array of [<lng>, <lat>]");
            }
          }
          const Yc = 2 * Math.PI * Xc;
          function Jc(t5) {
            return Yc * Math.cos(t5 * Math.PI / 180);
          }
          function Wc(t5) {
            return (180 + t5) / 360;
          }
          function Qc(t5) {
            return (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + t5 * Math.PI / 360))) / 360;
          }
          function th(t5, e7) {
            return t5 / Jc(e7);
          }
          function eh(t5) {
            return 360 / Math.PI * Math.atan(Math.exp((180 - 360 * t5) * Math.PI / 180)) - 90;
          }
          function rh(t5, e7) {
            return t5 * Jc(eh(e7));
          }
          class nh {
            constructor(t5, e7, r7 = 0) {
              this.x = +t5, this.y = +e7, this.z = +r7;
            }
            static fromLngLat(t5, e7 = 0) {
              const r7 = Hc.convert(t5);
              return new nh(Wc(r7.lng), Qc(r7.lat), th(e7, r7.lat));
            }
            toLngLat() {
              return new Hc(360 * this.x - 180, eh(this.y));
            }
            toAltitude() {
              return rh(this.z, this.y);
            }
            meterInMercatorCoordinateUnits() {
              return 1 / Yc * (t5 = eh(this.y), 1 / Math.cos(t5 * Math.PI / 180));
              var t5;
            }
          }
          function ih(t5, e7, r7) {
            var n6 = 2 * Math.PI * 6378137 / 256 / Math.pow(2, r7);
            return [t5 * n6 - 2 * Math.PI * 6378137 / 2, e7 * n6 - 2 * Math.PI * 6378137 / 2];
          }
          class sh {
            constructor(t5, e7, r7) {
              if (!function(t6, e8, r8) {
                return !(t6 < 0 || t6 > 25 || r8 < 0 || r8 >= Math.pow(2, t6) || e8 < 0 || e8 >= Math.pow(2, t6));
              }(t5, e7, r7)) throw new Error(`x=${e7}, y=${r7}, z=${t5} outside of bounds. 0<=x<${Math.pow(2, t5)}, 0<=y<${Math.pow(2, t5)} 0<=z<=25 `);
              this.z = t5, this.x = e7, this.y = r7, this.key = lh(0, t5, t5, e7, r7);
            }
            equals(t5) {
              return this.z === t5.z && this.x === t5.x && this.y === t5.y;
            }
            url(t5, e7, r7) {
              const n6 = (s5 = this.y, a4 = this.z, o7 = ih(256 * (i6 = this.x), 256 * (s5 = Math.pow(2, a4) - s5 - 1), a4), l5 = ih(256 * (i6 + 1), 256 * (s5 + 1), a4), o7[0] + "," + o7[1] + "," + l5[0] + "," + l5[1]);
              var i6, s5, a4, o7, l5;
              const u4 = function(t6, e8, r8) {
                let n7, i7 = "";
                for (let s6 = t6; s6 > 0; s6--) n7 = 1 << s6 - 1, i7 += (e8 & n7 ? 1 : 0) + (r8 & n7 ? 2 : 0);
                return i7;
              }(this.z, this.x, this.y);
              return t5[(this.x + this.y) % t5.length].replace(/{prefix}/g, (this.x % 16).toString(16) + (this.y % 16).toString(16)).replace(/{z}/g, String(this.z)).replace(/{x}/g, String(this.x)).replace(/{y}/g, String("tms" === r7 ? Math.pow(2, this.z) - this.y - 1 : this.y)).replace(/{ratio}/g, e7 > 1 ? "@2x" : "").replace(/{quadkey}/g, u4).replace(/{bbox-epsg-3857}/g, n6);
            }
            isChildOf(t5) {
              const e7 = this.z - t5.z;
              return e7 > 0 && t5.x === this.x >> e7 && t5.y === this.y >> e7;
            }
            getTilePoint(t5) {
              const e7 = Math.pow(2, this.z);
              return new l4((t5.x * e7 - this.x) * M4, (t5.y * e7 - this.y) * M4);
            }
            toString() {
              return `${this.z}/${this.x}/${this.y}`;
            }
          }
          class ah {
            constructor(t5, e7) {
              this.wrap = t5, this.canonical = e7, this.key = lh(t5, e7.z, e7.z, e7.x, e7.y);
            }
          }
          class oh {
            constructor(t5, e7, r7, n6, i6) {
              if (this.terrainRttPosMatrix32f = null, t5 < r7) throw new Error(`overscaledZ should be >= z; overscaledZ = ${t5}; z = ${r7}`);
              this.overscaledZ = t5, this.wrap = e7, this.canonical = new sh(r7, +n6, +i6), this.key = lh(e7, t5, r7, n6, i6);
            }
            clone() {
              return new oh(this.overscaledZ, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y);
            }
            equals(t5) {
              return this.overscaledZ === t5.overscaledZ && this.wrap === t5.wrap && this.canonical.equals(t5.canonical);
            }
            scaledTo(t5) {
              if (t5 > this.overscaledZ) throw new Error(`targetZ > this.overscaledZ; targetZ = ${t5}; overscaledZ = ${this.overscaledZ}`);
              const e7 = this.canonical.z - t5;
              return t5 > this.canonical.z ? new oh(t5, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y) : new oh(t5, this.wrap, t5, this.canonical.x >> e7, this.canonical.y >> e7);
            }
            calculateScaledKey(t5, e7) {
              if (t5 > this.overscaledZ) throw new Error(`targetZ > this.overscaledZ; targetZ = ${t5}; overscaledZ = ${this.overscaledZ}`);
              const r7 = this.canonical.z - t5;
              return t5 > this.canonical.z ? lh(this.wrap * +e7, t5, this.canonical.z, this.canonical.x, this.canonical.y) : lh(this.wrap * +e7, t5, t5, this.canonical.x >> r7, this.canonical.y >> r7);
            }
            isChildOf(t5) {
              if (t5.wrap !== this.wrap) return false;
              const e7 = this.canonical.z - t5.canonical.z;
              return 0 === t5.overscaledZ || t5.overscaledZ < this.overscaledZ && t5.canonical.x === this.canonical.x >> e7 && t5.canonical.y === this.canonical.y >> e7;
            }
            children(t5) {
              if (this.overscaledZ >= t5) return [new oh(this.overscaledZ + 1, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y)];
              const e7 = this.canonical.z + 1, r7 = 2 * this.canonical.x, n6 = 2 * this.canonical.y;
              return [new oh(e7, this.wrap, e7, r7, n6), new oh(e7, this.wrap, e7, r7 + 1, n6), new oh(e7, this.wrap, e7, r7, n6 + 1), new oh(e7, this.wrap, e7, r7 + 1, n6 + 1)];
            }
            isLessThan(t5) {
              return this.wrap < t5.wrap || !(this.wrap > t5.wrap) && (this.overscaledZ < t5.overscaledZ || !(this.overscaledZ > t5.overscaledZ) && (this.canonical.x < t5.canonical.x || !(this.canonical.x > t5.canonical.x) && this.canonical.y < t5.canonical.y));
            }
            wrapped() {
              return new oh(this.overscaledZ, 0, this.canonical.z, this.canonical.x, this.canonical.y);
            }
            unwrapTo(t5) {
              return new oh(this.overscaledZ, t5, this.canonical.z, this.canonical.x, this.canonical.y);
            }
            overscaleFactor() {
              return Math.pow(2, this.overscaledZ - this.canonical.z);
            }
            toUnwrapped() {
              return new ah(this.wrap, this.canonical);
            }
            toString() {
              return `${this.overscaledZ}/${this.canonical.x}/${this.canonical.y}`;
            }
            getTilePoint(t5) {
              return this.canonical.getTilePoint(new nh(t5.x - this.wrap, t5.y));
            }
          }
          function lh(t5, e7, r7, n6, i6) {
            (t5 *= 2) < 0 && (t5 = -1 * t5 - 1);
            const s5 = 1 << r7;
            return (s5 * s5 * t5 + s5 * i6 + n6).toString(36) + r7.toString(36) + e7.toString(36);
          }
          Zi("CanonicalTileID", sh), Zi("OverscaledTileID", oh, { omit: ["terrainRttPosMatrix32f"] });
          class uh {
            constructor(t5, e7, r7, n6 = 1, i6 = 1, s5 = 1, a4 = 0) {
              if (this.uid = t5, e7.height !== e7.width) throw new RangeError("DEM tiles must be square");
              if (r7 && !["mapbox", "terrarium", "custom"].includes(r7)) return void j3(`"${r7}" is not a valid encoding type. Valid types include "mapbox", "terrarium" and "custom".`);
              this.stride = e7.height;
              const o7 = this.dim = e7.height - 2;
              switch (this.data = new Uint32Array(e7.data.buffer), r7) {
                case "terrarium":
                  this.redFactor = 256, this.greenFactor = 1, this.blueFactor = 1 / 256, this.baseShift = 32768;
                  break;
                case "custom":
                  this.redFactor = n6, this.greenFactor = i6, this.blueFactor = s5, this.baseShift = a4;
                  break;
                default:
                  this.redFactor = 6553.6, this.greenFactor = 25.6, this.blueFactor = 0.1, this.baseShift = 1e4;
              }
              for (let t6 = 0; t6 < o7; t6++) this.data[this._idx(-1, t6)] = this.data[this._idx(0, t6)], this.data[this._idx(o7, t6)] = this.data[this._idx(o7 - 1, t6)], this.data[this._idx(t6, -1)] = this.data[this._idx(t6, 0)], this.data[this._idx(t6, o7)] = this.data[this._idx(t6, o7 - 1)];
              this.data[this._idx(-1, -1)] = this.data[this._idx(0, 0)], this.data[this._idx(o7, -1)] = this.data[this._idx(o7 - 1, 0)], this.data[this._idx(-1, o7)] = this.data[this._idx(0, o7 - 1)], this.data[this._idx(o7, o7)] = this.data[this._idx(o7 - 1, o7 - 1)], this.min = Number.MAX_SAFE_INTEGER, this.max = Number.MIN_SAFE_INTEGER;
              for (let t6 = 0; t6 < o7; t6++) for (let e8 = 0; e8 < o7; e8++) {
                const r8 = this.get(t6, e8);
                r8 > this.max && (this.max = r8), r8 < this.min && (this.min = r8);
              }
            }
            get(t5, e7) {
              const r7 = new Uint8Array(this.data.buffer), n6 = 4 * this._idx(t5, e7);
              return this.unpack(r7[n6], r7[n6 + 1], r7[n6 + 2]);
            }
            getUnpackVector() {
              return [this.redFactor, this.greenFactor, this.blueFactor, this.baseShift];
            }
            _idx(t5, e7) {
              if (t5 < -1 || t5 >= this.dim + 1 || e7 < -1 || e7 >= this.dim + 1) throw new RangeError("out of range source coordinates for DEM data");
              return (e7 + 1) * this.stride + (t5 + 1);
            }
            unpack(t5, e7, r7) {
              return t5 * this.redFactor + e7 * this.greenFactor + r7 * this.blueFactor - this.baseShift;
            }
            getPixels() {
              return new No({ width: this.stride, height: this.stride }, new Uint8Array(this.data.buffer));
            }
            backfillBorder(t5, e7, r7) {
              if (this.dim !== t5.dim) throw new Error("dem dimension mismatch");
              let n6 = e7 * this.dim, i6 = e7 * this.dim + this.dim, s5 = r7 * this.dim, a4 = r7 * this.dim + this.dim;
              switch (e7) {
                case -1:
                  n6 = i6 - 1;
                  break;
                case 1:
                  i6 = n6 + 1;
              }
              switch (r7) {
                case -1:
                  s5 = a4 - 1;
                  break;
                case 1:
                  a4 = s5 + 1;
              }
              const o7 = -e7 * this.dim, l5 = -r7 * this.dim;
              for (let e8 = s5; e8 < a4; e8++) for (let r8 = n6; r8 < i6; r8++) this.data[this._idx(r8, e8)] = t5.data[this._idx(r8 + o7, e8 + l5)];
            }
          }
          Zi("DEMData", uh);
          class ch {
            constructor(t5) {
              this._stringToNumber = {}, this._numberToString = [];
              for (let e7 = 0; e7 < t5.length; e7++) {
                const r7 = t5[e7];
                this._stringToNumber[r7] = e7, this._numberToString[e7] = r7;
              }
            }
            encode(t5) {
              return this._stringToNumber[t5];
            }
            decode(t5) {
              if (t5 >= this._numberToString.length) throw new Error(`Out of bounds. Index requested n=${t5} can't be >= this._numberToString.length ${this._numberToString.length}`);
              return this._numberToString[t5];
            }
          }
          class hh {
            constructor(t5, e7, r7, n6, i6) {
              this.type = "Feature", this._vectorTileFeature = t5, t5._z = e7, t5._x = r7, t5._y = n6, this.properties = t5.properties, this.id = i6;
            }
            get geometry() {
              return void 0 === this._geometry && (this._geometry = this._vectorTileFeature.toGeoJSON(this._vectorTileFeature._x, this._vectorTileFeature._y, this._vectorTileFeature._z).geometry), this._geometry;
            }
            set geometry(t5) {
              this._geometry = t5;
            }
            toJSON() {
              const t5 = { geometry: this.geometry };
              for (const e7 in this) "_geometry" !== e7 && "_vectorTileFeature" !== e7 && (t5[e7] = this[e7]);
              return t5;
            }
          }
          class ph {
            constructor(t5, e7) {
              this.tileID = t5, this.x = t5.canonical.x, this.y = t5.canonical.y, this.z = t5.canonical.z, this.grid = new qi(M4, 16, 0), this.grid3D = new qi(M4, 16, 0), this.featureIndexArray = new ya(), this.promoteId = e7;
            }
            insert(t5, e7, r7, n6, i6, s5) {
              const a4 = this.featureIndexArray.length;
              this.featureIndexArray.emplaceBack(r7, n6, i6);
              const o7 = s5 ? this.grid3D : this.grid;
              for (let t6 = 0; t6 < e7.length; t6++) {
                const r8 = e7[t6], n7 = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
                for (let t7 = 0; t7 < r8.length; t7++) {
                  const e8 = r8[t7];
                  n7[0] = Math.min(n7[0], e8.x), n7[1] = Math.min(n7[1], e8.y), n7[2] = Math.max(n7[2], e8.x), n7[3] = Math.max(n7[3], e8.y);
                }
                n7[0] < M4 && n7[1] < M4 && n7[2] >= 0 && n7[3] >= 0 && o7.insert(a4, n7[0], n7[1], n7[2], n7[3]);
              }
            }
            loadVTLayers() {
              return this.vtLayers || (this.vtLayers = new Ql.VectorTile(new ju(this.rawTileData)).layers, this.sourceLayerCoder = new ch(this.vtLayers ? Object.keys(this.vtLayers).sort() : ["_geojsonTileLayer"])), this.vtLayers;
            }
            query(t5, e7, r7, n6) {
              this.loadVTLayers();
              const i6 = t5.params, s5 = M4 / t5.tileSize / t5.scale, a4 = Qn(i6.filter), o7 = t5.queryGeometry, u4 = t5.queryPadding * s5, c5 = dh(o7), h4 = this.grid.query(c5.minX - u4, c5.minY - u4, c5.maxX + u4, c5.maxY + u4), p4 = dh(t5.cameraQueryGeometry), f4 = this.grid3D.query(p4.minX - u4, p4.minY - u4, p4.maxX + u4, p4.maxY + u4, (e8, r8, n7, i7) => function(t6, e9, r9, n8, i8) {
                for (const s7 of t6) if (e9 <= s7.x && r9 <= s7.y && n8 >= s7.x && i8 >= s7.y) return true;
                const s6 = [new l4(e9, r9), new l4(e9, i8), new l4(n8, i8), new l4(n8, r9)];
                if (t6.length > 2) {
                  for (const e10 of s6) if (ko(t6, e10)) return true;
                }
                for (let e10 = 0; e10 < t6.length - 1; e10++) if (Mo(t6[e10], t6[e10 + 1], s6)) return true;
                return false;
              }(t5.cameraQueryGeometry, e8 - u4, r8 - u4, n7 + u4, i7 + u4));
              for (const t6 of f4) h4.push(t6);
              h4.sort(yh);
              const d4 = {};
              let y4;
              for (let l5 = 0; l5 < h4.length; l5++) {
                const u5 = h4[l5];
                if (u5 === y4) continue;
                y4 = u5;
                const c6 = this.featureIndexArray.get(u5);
                let p5 = null;
                this.loadMatchingFeature(d4, c6.bucketIndex, c6.sourceLayerIndex, c6.featureIndex, a4, i6.layers, i6.availableImages, e7, r7, n6, (e8, r8, n7) => (p5 || (p5 = co(e8)), r8.queryIntersectsFeature({ queryGeometry: o7, feature: e8, featureState: n7, geometry: p5, zoom: this.z, transform: t5.transform, pixelsToTileUnits: s5, pixelPosMatrix: t5.pixelPosMatrix, unwrappedTileID: this.tileID.toUnwrapped(), getElevation: t5.getElevation })));
              }
              return d4;
            }
            loadMatchingFeature(t5, e7, r7, n6, i6, s5, a4, o7, l5, u4, c5) {
              const h4 = this.bucketLayerIDs[e7];
              if (s5 && !h4.some((t6) => s5.has(t6))) return;
              const p4 = this.sourceLayerCoder.decode(r7), f4 = this.vtLayers[p4].feature(n6);
              if (i6.needGeometry) {
                const t6 = ho(f4, true);
                if (!i6.filter(new fs(this.tileID.overscaledZ), t6, this.tileID.canonical)) return;
              } else if (!i6.filter(new fs(this.tileID.overscaledZ), f4)) return;
              const d4 = this.getId(f4, p4);
              for (let e8 = 0; e8 < h4.length; e8++) {
                const r8 = h4[e8];
                if (s5 && !s5.has(r8)) continue;
                const i7 = o7[r8];
                if (!i7) continue;
                let p5 = {};
                d4 && u4 && (p5 = u4.getState(i7.sourceLayer || "_geojsonTileLayer", d4));
                const y4 = F2({}, l5[r8]);
                y4.paint = fh(y4.paint, i7.paint, f4, p5, a4), y4.layout = fh(y4.layout, i7.layout, f4, p5, a4);
                const m4 = !c5 || c5(f4, i7, p5);
                if (!m4) continue;
                const g4 = new hh(f4, this.z, this.x, this.y, d4);
                g4.layer = y4;
                let x4 = t5[r8];
                void 0 === x4 && (x4 = t5[r8] = []), x4.push({ featureIndex: n6, feature: g4, intersectionZ: m4 });
              }
            }
            lookupSymbolFeatures(t5, e7, r7, n6, i6, s5, a4, o7) {
              const l5 = {};
              this.loadVTLayers();
              const u4 = Qn(i6);
              for (const i7 of t5) this.loadMatchingFeature(l5, r7, n6, i7, u4, s5, a4, o7, e7);
              return l5;
            }
            hasLayer(t5) {
              for (const e7 of this.bucketLayerIDs) for (const r7 of e7) if (t5 === r7) return true;
              return false;
            }
            getId(t5, e7) {
              var r7;
              let n6 = t5.id;
              return this.promoteId && (n6 = t5.properties["string" == typeof this.promoteId ? this.promoteId : this.promoteId[e7]], "boolean" == typeof n6 && (n6 = Number(n6)), void 0 === n6 && (null === (r7 = t5.properties) || void 0 === r7 ? void 0 : r7.cluster) && this.promoteId && (n6 = Number(t5.properties.cluster_id))), n6;
            }
          }
          function fh(t5, e7, r7, n6, i6) {
            return L3(t5, (t6, s5) => {
              const a4 = e7 instanceof ws ? e7.get(s5) : null;
              return a4 && a4.evaluate ? a4.evaluate(r7, n6, i6) : a4;
            });
          }
          function dh(t5) {
            let e7 = 1 / 0, r7 = 1 / 0, n6 = -1 / 0, i6 = -1 / 0;
            for (const s5 of t5) e7 = Math.min(e7, s5.x), r7 = Math.min(r7, s5.y), n6 = Math.max(n6, s5.x), i6 = Math.max(i6, s5.y);
            return { minX: e7, minY: r7, maxX: n6, maxY: i6 };
          }
          function yh(t5, e7) {
            return e7 - t5;
          }
          function mh(t5, e7, r7, n6, i6) {
            const s5 = [];
            for (let a4 = 0; a4 < t5.length; a4++) {
              const o7 = t5[a4];
              let u4;
              for (let t6 = 0; t6 < o7.length - 1; t6++) {
                let a5 = o7[t6], c5 = o7[t6 + 1];
                a5.x < e7 && c5.x < e7 || (a5.x < e7 ? a5 = new l4(e7, a5.y + (e7 - a5.x) / (c5.x - a5.x) * (c5.y - a5.y))._round() : c5.x < e7 && (c5 = new l4(e7, a5.y + (e7 - a5.x) / (c5.x - a5.x) * (c5.y - a5.y))._round()), a5.y < r7 && c5.y < r7 || (a5.y < r7 ? a5 = new l4(a5.x + (r7 - a5.y) / (c5.y - a5.y) * (c5.x - a5.x), r7)._round() : c5.y < r7 && (c5 = new l4(a5.x + (r7 - a5.y) / (c5.y - a5.y) * (c5.x - a5.x), r7)._round()), a5.x >= n6 && c5.x >= n6 || (a5.x >= n6 ? a5 = new l4(n6, a5.y + (n6 - a5.x) / (c5.x - a5.x) * (c5.y - a5.y))._round() : c5.x >= n6 && (c5 = new l4(n6, a5.y + (n6 - a5.x) / (c5.x - a5.x) * (c5.y - a5.y))._round()), a5.y >= i6 && c5.y >= i6 || (a5.y >= i6 ? a5 = new l4(a5.x + (i6 - a5.y) / (c5.y - a5.y) * (c5.x - a5.x), i6)._round() : c5.y >= i6 && (c5 = new l4(a5.x + (i6 - a5.y) / (c5.y - a5.y) * (c5.x - a5.x), i6)._round()), u4 && a5.equals(u4[u4.length - 1]) || (u4 = [a5], s5.push(u4)), u4.push(c5)))));
              }
            }
            return s5;
          }
          Zi("FeatureIndex", ph, { omit: ["rawTileData", "sourceLayerCoder"] });
          class gh extends l4 {
            constructor(t5, e7, r7, n6) {
              super(t5, e7), this.angle = r7, void 0 !== n6 && (this.segment = n6);
            }
            clone() {
              return new gh(this.x, this.y, this.angle, this.segment);
            }
          }
          function xh(t5, e7, r7, n6, i6) {
            if (void 0 === e7.segment || 0 === r7) return true;
            let s5 = e7, a4 = e7.segment + 1, o7 = 0;
            for (; o7 > -r7 / 2; ) {
              if (a4--, a4 < 0) return false;
              o7 -= t5[a4].dist(s5), s5 = t5[a4];
            }
            o7 += t5[a4].dist(t5[a4 + 1]), a4++;
            const l5 = [];
            let u4 = 0;
            for (; o7 < r7 / 2; ) {
              const e8 = t5[a4], r8 = t5[a4 + 1];
              if (!r8) return false;
              let s6 = t5[a4 - 1].angleTo(e8) - e8.angleTo(r8);
              for (s6 = Math.abs((s6 + 3 * Math.PI) % (2 * Math.PI) - Math.PI), l5.push({ distance: o7, angleDelta: s6 }), u4 += s6; o7 - l5[0].distance > n6; ) u4 -= l5.shift().angleDelta;
              if (u4 > i6) return false;
              a4++, o7 += e8.dist(r8);
            }
            return true;
          }
          function vh(t5) {
            let e7 = 0;
            for (let r7 = 0; r7 < t5.length - 1; r7++) e7 += t5[r7].dist(t5[r7 + 1]);
            return e7;
          }
          function bh(t5, e7, r7) {
            return t5 ? 0.6 * e7 * r7 : 0;
          }
          function wh(t5, e7) {
            return Math.max(t5 ? t5.right - t5.left : 0, e7 ? e7.right - e7.left : 0);
          }
          function _h(t5, e7, r7, n6, i6, s5) {
            const a4 = bh(r7, i6, s5), o7 = wh(r7, n6) * s5;
            let l5 = 0;
            const u4 = vh(t5) / 2;
            for (let r8 = 0; r8 < t5.length - 1; r8++) {
              const n7 = t5[r8], i7 = t5[r8 + 1], s6 = n7.dist(i7);
              if (l5 + s6 > u4) {
                const c5 = (u4 - l5) / s6, h4 = ir.number(n7.x, i7.x, c5), p4 = ir.number(n7.y, i7.y, c5), f4 = new gh(h4, p4, i7.angleTo(n7), r8);
                return f4._round(), !a4 || xh(t5, f4, o7, a4, e7) ? f4 : void 0;
              }
              l5 += s6;
            }
          }
          function Sh(t5, e7, r7, n6, i6, s5, a4, o7, l5) {
            const u4 = bh(n6, s5, a4), c5 = wh(n6, i6), h4 = c5 * a4, p4 = 0 === t5[0].x || t5[0].x === l5 || 0 === t5[0].y || t5[0].y === l5;
            return e7 - h4 < e7 / 4 && (e7 = h4 + e7 / 4), Ah(t5, p4 ? e7 / 2 * o7 % e7 : (c5 / 2 + 2 * s5) * a4 * o7 % e7, e7, u4, r7, h4, p4, false, l5);
          }
          function Ah(t5, e7, r7, n6, i6, s5, a4, o7, l5) {
            const u4 = s5 / 2, c5 = vh(t5);
            let h4 = 0, p4 = e7 - r7, f4 = [];
            for (let e8 = 0; e8 < t5.length - 1; e8++) {
              const a5 = t5[e8], o8 = t5[e8 + 1], d4 = a5.dist(o8), y4 = o8.angleTo(a5);
              for (; p4 + r7 < h4 + d4; ) {
                p4 += r7;
                const m4 = (p4 - h4) / d4, g4 = ir.number(a5.x, o8.x, m4), x4 = ir.number(a5.y, o8.y, m4);
                if (g4 >= 0 && g4 < l5 && x4 >= 0 && x4 < l5 && p4 - u4 >= 0 && p4 + u4 <= c5) {
                  const r8 = new gh(g4, x4, y4, e8);
                  r8._round(), n6 && !xh(t5, r8, s5, n6, i6) || f4.push(r8);
                }
              }
              h4 += d4;
            }
            return o7 || f4.length || a4 || (f4 = Ah(t5, h4 / 2, r7, n6, i6, s5, a4, true, l5)), f4;
          }
          Zi("Anchor", gh);
          const kh = Xu;
          function Mh(t5, e7, r7, n6) {
            const i6 = [], s5 = t5.image, a4 = s5.pixelRatio, o7 = s5.paddedRect.w - 2 * kh, u4 = s5.paddedRect.h - 2 * kh;
            let c5 = { x1: t5.left, y1: t5.top, x2: t5.right, y2: t5.bottom };
            const h4 = s5.stretchX || [[0, o7]], p4 = s5.stretchY || [[0, u4]], f4 = (t6, e8) => t6 + e8[1] - e8[0], d4 = h4.reduce(f4, 0), y4 = p4.reduce(f4, 0), m4 = o7 - d4, g4 = u4 - y4;
            let x4 = 0, v4 = d4, b5 = 0, w4 = y4, _4 = 0, S5 = m4, A5 = 0, k4 = g4;
            if (s5.content && n6) {
              const e8 = s5.content, r8 = e8[2] - e8[0], n7 = e8[3] - e8[1];
              (s5.textFitWidth || s5.textFitHeight) && (c5 = vc(t5)), x4 = Ih(h4, 0, e8[0]), b5 = Ih(p4, 0, e8[1]), v4 = Ih(h4, e8[0], e8[2]), w4 = Ih(p4, e8[1], e8[3]), _4 = e8[0] - x4, A5 = e8[1] - b5, S5 = r8 - v4, k4 = n7 - w4;
            }
            const M5 = c5.x1, I4 = c5.y1, z4 = c5.x2 - M5, P4 = c5.y2 - I4, C4 = (t6, n7, i7, o8) => {
              const u5 = Ph(t6.stretch - x4, v4, z4, M5), c6 = Ch(t6.fixed - _4, S5, t6.stretch, d4), h5 = Ph(n7.stretch - b5, w4, P4, I4), p5 = Ch(n7.fixed - A5, k4, n7.stretch, y4), f5 = Ph(i7.stretch - x4, v4, z4, M5), m5 = Ch(i7.fixed - _4, S5, i7.stretch, d4), g5 = Ph(o8.stretch - b5, w4, P4, I4), C5 = Ch(o8.fixed - A5, k4, o8.stretch, y4), B5 = new l4(u5, h5), V3 = new l4(f5, h5), E4 = new l4(f5, g5), T5 = new l4(u5, g5), F3 = new l4(c6 / a4, p5 / a4), $3 = new l4(m5 / a4, C5 / a4), L4 = e7 * Math.PI / 180;
              if (L4) {
                const t7 = Math.sin(L4), e8 = Math.cos(L4), r8 = [e8, -t7, t7, e8];
                B5._matMult(r8), V3._matMult(r8), T5._matMult(r8), E4._matMult(r8);
              }
              const O3 = t6.stretch + t6.fixed, D3 = n7.stretch + n7.fixed;
              return { tl: B5, tr: V3, bl: T5, br: E4, tex: { x: s5.paddedRect.x + kh + O3, y: s5.paddedRect.y + kh + D3, w: i7.stretch + i7.fixed - O3, h: o8.stretch + o8.fixed - D3 }, writingMode: void 0, glyphOffset: [0, 0], sectionIndex: 0, pixelOffsetTL: F3, pixelOffsetBR: $3, minFontScaleX: S5 / a4 / z4, minFontScaleY: k4 / a4 / P4, isSDF: r7 };
            };
            if (n6 && (s5.stretchX || s5.stretchY)) {
              const t6 = zh(h4, m4, d4), e8 = zh(p4, g4, y4);
              for (let r8 = 0; r8 < t6.length - 1; r8++) {
                const n7 = t6[r8], s6 = t6[r8 + 1];
                for (let t7 = 0; t7 < e8.length - 1; t7++) i6.push(C4(n7, e8[t7], s6, e8[t7 + 1]));
              }
            } else i6.push(C4({ fixed: 0, stretch: -1 }, { fixed: 0, stretch: -1 }, { fixed: 0, stretch: o7 + 1 }, { fixed: 0, stretch: u4 + 1 }));
            return i6;
          }
          function Ih(t5, e7, r7) {
            let n6 = 0;
            for (const i6 of t5) n6 += Math.max(e7, Math.min(r7, i6[1])) - Math.max(e7, Math.min(r7, i6[0]));
            return n6;
          }
          function zh(t5, e7, r7) {
            const n6 = [{ fixed: -1, stretch: 0 }];
            for (const [e8, r8] of t5) {
              const t6 = n6[n6.length - 1];
              n6.push({ fixed: e8 - t6.stretch, stretch: t6.stretch }), n6.push({ fixed: e8 - t6.stretch, stretch: t6.stretch + (r8 - e8) });
            }
            return n6.push({ fixed: e7 + kh, stretch: r7 }), n6;
          }
          function Ph(t5, e7, r7, n6) {
            return t5 / e7 * r7 + n6;
          }
          function Ch(t5, e7, r7, n6) {
            return t5 - e7 * r7 / n6;
          }
          class Bh {
            constructor(t5, e7, r7, n6, i6, s5, a4, o7, u4, c5) {
              var h4;
              if (this.boxStartIndex = t5.length, u4) {
                let t6 = s5.top, e8 = s5.bottom;
                const r8 = s5.collisionPadding;
                r8 && (t6 -= r8[1], e8 += r8[3]);
                let n7 = e8 - t6;
                n7 > 0 && (n7 = Math.max(10, n7), this.circleDiameter = n7);
              } else {
                const u5 = (null === (h4 = s5.image) || void 0 === h4 ? void 0 : h4.content) && (s5.image.textFitWidth || s5.image.textFitHeight) ? vc(s5) : { x1: s5.left, y1: s5.top, x2: s5.right, y2: s5.bottom };
                u5.y1 = u5.y1 * a4 - o7[0], u5.y2 = u5.y2 * a4 + o7[2], u5.x1 = u5.x1 * a4 - o7[3], u5.x2 = u5.x2 * a4 + o7[1];
                const p4 = s5.collisionPadding;
                if (p4 && (u5.x1 -= p4[0] * a4, u5.y1 -= p4[1] * a4, u5.x2 += p4[2] * a4, u5.y2 += p4[3] * a4), c5) {
                  const t6 = new l4(u5.x1, u5.y1), e8 = new l4(u5.x2, u5.y1), r8 = new l4(u5.x1, u5.y2), n7 = new l4(u5.x2, u5.y2), i7 = c5 * Math.PI / 180;
                  t6._rotate(i7), e8._rotate(i7), r8._rotate(i7), n7._rotate(i7), u5.x1 = Math.min(t6.x, e8.x, r8.x, n7.x), u5.x2 = Math.max(t6.x, e8.x, r8.x, n7.x), u5.y1 = Math.min(t6.y, e8.y, r8.y, n7.y), u5.y2 = Math.max(t6.y, e8.y, r8.y, n7.y);
                }
                t5.emplaceBack(e7.x, e7.y, u5.x1, u5.y1, u5.x2, u5.y2, r7, n6, i6);
              }
              this.boxEndIndex = t5.length;
            }
          }
          class Vh {
            constructor(t5 = [], e7 = (t6, e8) => t6 < e8 ? -1 : t6 > e8 ? 1 : 0) {
              if (this.data = t5, this.length = this.data.length, this.compare = e7, this.length > 0) for (let t6 = (this.length >> 1) - 1; t6 >= 0; t6--) this._down(t6);
            }
            push(t5) {
              this.data.push(t5), this._up(this.length++);
            }
            pop() {
              if (0 === this.length) return;
              const t5 = this.data[0], e7 = this.data.pop();
              return --this.length > 0 && (this.data[0] = e7, this._down(0)), t5;
            }
            peek() {
              return this.data[0];
            }
            _up(t5) {
              const { data: e7, compare: r7 } = this, n6 = e7[t5];
              for (; t5 > 0; ) {
                const i6 = t5 - 1 >> 1, s5 = e7[i6];
                if (r7(n6, s5) >= 0) break;
                e7[t5] = s5, t5 = i6;
              }
              e7[t5] = n6;
            }
            _down(t5) {
              const { data: e7, compare: r7 } = this, n6 = this.length >> 1, i6 = e7[t5];
              for (; t5 < n6; ) {
                let n7 = 1 + (t5 << 1);
                const s5 = n7 + 1;
                if (s5 < this.length && r7(e7[s5], e7[n7]) < 0 && (n7 = s5), r7(e7[n7], i6) >= 0) break;
                e7[t5] = e7[n7], t5 = n7;
              }
              e7[t5] = i6;
            }
          }
          function Eh(t5, e7 = 1, r7 = false) {
            let n6 = 1 / 0, i6 = 1 / 0, s5 = -1 / 0, a4 = -1 / 0;
            const o7 = t5[0];
            for (let t6 = 0; t6 < o7.length; t6++) {
              const e8 = o7[t6];
              (!t6 || e8.x < n6) && (n6 = e8.x), (!t6 || e8.y < i6) && (i6 = e8.y), (!t6 || e8.x > s5) && (s5 = e8.x), (!t6 || e8.y > a4) && (a4 = e8.y);
            }
            const u4 = Math.min(s5 - n6, a4 - i6);
            let c5 = u4 / 2;
            const h4 = new Vh([], Th);
            if (0 === u4) return new l4(n6, i6);
            for (let e8 = n6; e8 < s5; e8 += u4) for (let r8 = i6; r8 < a4; r8 += u4) h4.push(new Fh(e8 + c5, r8 + c5, c5, t5));
            let p4 = function(t6) {
              let e8 = 0, r8 = 0, n7 = 0;
              const i7 = t6[0];
              for (let t7 = 0, s6 = i7.length, a5 = s6 - 1; t7 < s6; a5 = t7++) {
                const s7 = i7[t7], o8 = i7[a5], l5 = s7.x * o8.y - o8.x * s7.y;
                r8 += (s7.x + o8.x) * l5, n7 += (s7.y + o8.y) * l5, e8 += 3 * l5;
              }
              return new Fh(r8 / e8, n7 / e8, 0, t6);
            }(t5), f4 = h4.length;
            for (; h4.length; ) {
              const n7 = h4.pop();
              (n7.d > p4.d || !p4.d) && (p4 = n7, r7 && console.log("found best %d after %d probes", Math.round(1e4 * n7.d) / 1e4, f4)), n7.max - p4.d <= e7 || (c5 = n7.h / 2, h4.push(new Fh(n7.p.x - c5, n7.p.y - c5, c5, t5)), h4.push(new Fh(n7.p.x + c5, n7.p.y - c5, c5, t5)), h4.push(new Fh(n7.p.x - c5, n7.p.y + c5, c5, t5)), h4.push(new Fh(n7.p.x + c5, n7.p.y + c5, c5, t5)), f4 += 4);
            }
            return r7 && (console.log(`num probes: ${f4}`), console.log(`best distance: ${p4.d}`)), p4.p;
          }
          function Th(t5, e7) {
            return e7.max - t5.max;
          }
          function Fh(t5, e7, r7, n6) {
            this.p = new l4(t5, e7), this.h = r7, this.d = function(t6, e8) {
              let r8 = false, n7 = 1 / 0;
              for (let i6 = 0; i6 < e8.length; i6++) {
                const s5 = e8[i6];
                for (let e9 = 0, i7 = s5.length, a4 = i7 - 1; e9 < i7; a4 = e9++) {
                  const i8 = s5[e9], o7 = s5[a4];
                  i8.y > t6.y != o7.y > t6.y && t6.x < (o7.x - i8.x) * (t6.y - i8.y) / (o7.y - i8.y) + i8.x && (r8 = !r8), n7 = Math.min(n7, So(t6, i8, o7));
                }
              }
              return (r8 ? 1 : -1) * Math.sqrt(n7);
            }(this.p, n6), this.max = this.d + this.h * Math.SQRT2;
          }
          var $h;
          t4.ay = void 0, ($h = t4.ay || (t4.ay = {}))[$h.center = 1] = "center", $h[$h.left = 2] = "left", $h[$h.right = 3] = "right", $h[$h.top = 4] = "top", $h[$h.bottom = 5] = "bottom", $h[$h["top-left"] = 6] = "top-left", $h[$h["top-right"] = 7] = "top-right", $h[$h["bottom-left"] = 8] = "bottom-left", $h[$h["bottom-right"] = 9] = "bottom-right";
          const Lh = 7, Oh = Number.POSITIVE_INFINITY;
          function Dh(t5, e7) {
            return e7[1] !== Oh ? function(t6, e8, r7) {
              let n6 = 0, i6 = 0;
              switch (e8 = Math.abs(e8), r7 = Math.abs(r7), t6) {
                case "top-right":
                case "top-left":
                case "top":
                  i6 = r7 - Lh;
                  break;
                case "bottom-right":
                case "bottom-left":
                case "bottom":
                  i6 = -r7 + Lh;
              }
              switch (t6) {
                case "top-right":
                case "bottom-right":
                case "right":
                  n6 = -e8;
                  break;
                case "top-left":
                case "bottom-left":
                case "left":
                  n6 = e8;
              }
              return [n6, i6];
            }(t5, e7[0], e7[1]) : function(t6, e8) {
              let r7 = 0, n6 = 0;
              e8 < 0 && (e8 = 0);
              const i6 = e8 / Math.SQRT2;
              switch (t6) {
                case "top-right":
                case "top-left":
                  n6 = i6 - Lh;
                  break;
                case "bottom-right":
                case "bottom-left":
                  n6 = -i6 + Lh;
                  break;
                case "bottom":
                  n6 = -e8 + Lh;
                  break;
                case "top":
                  n6 = e8 - Lh;
              }
              switch (t6) {
                case "top-right":
                case "bottom-right":
                  r7 = -i6;
                  break;
                case "top-left":
                case "bottom-left":
                  r7 = i6;
                  break;
                case "left":
                  r7 = e8;
                  break;
                case "right":
                  r7 = -e8;
              }
              return [r7, n6];
            }(t5, e7[0]);
          }
          function Rh(t5, e7, r7) {
            var n6;
            const i6 = t5.layout, s5 = null === (n6 = i6.get("text-variable-anchor-offset")) || void 0 === n6 ? void 0 : n6.evaluate(e7, {}, r7);
            if (s5) {
              const t6 = s5.values, e8 = [];
              for (let r8 = 0; r8 < t6.length; r8 += 2) {
                const n7 = e8[r8] = t6[r8], i7 = t6[r8 + 1].map((t7) => t7 * Lu);
                n7.startsWith("top") ? i7[1] -= Lh : n7.startsWith("bottom") && (i7[1] += Lh), e8[r8 + 1] = i7;
              }
              return new Me(e8);
            }
            const a4 = i6.get("text-variable-anchor");
            if (a4) {
              let n7;
              n7 = void 0 !== t5._unevaluatedLayout.getValue("text-radial-offset") ? [i6.get("text-radial-offset").evaluate(e7, {}, r7) * Lu, Oh] : i6.get("text-offset").evaluate(e7, {}, r7).map((t6) => t6 * Lu);
              const s6 = [];
              for (const t6 of a4) s6.push(t6, Dh(t6, n7));
              return new Me(s6);
            }
            return null;
          }
          function jh(t5) {
            switch (t5) {
              case "right":
              case "top-right":
              case "bottom-right":
                return "right";
              case "left":
              case "top-left":
              case "bottom-left":
                return "left";
            }
            return "center";
          }
          function Nh(e7, r7, n6, i6, s5, a4, o7, l5, u4, c5, h4, p4) {
            let f4 = a4.textMaxSize.evaluate(r7, {});
            void 0 === f4 && (f4 = o7);
            const d4 = e7.layers[0].layout, y4 = d4.get("icon-offset").evaluate(r7, {}, h4), m4 = qh(n6.horizontal), g4 = o7 / 24, x4 = e7.tilePixelRatio * g4, v4 = e7.tilePixelRatio * f4 / 24, b5 = e7.tilePixelRatio * l5, w4 = e7.tilePixelRatio * d4.get("symbol-spacing"), _4 = d4.get("text-padding") * e7.tilePixelRatio, S5 = function(t5, e8, r8, n7 = 1) {
              const i7 = t5.get("icon-padding").evaluate(e8, {}, r8), s6 = i7 && i7.values;
              return [s6[0] * n7, s6[1] * n7, s6[2] * n7, s6[3] * n7];
            }(d4, r7, h4, e7.tilePixelRatio), A5 = d4.get("text-max-angle") / 180 * Math.PI, k4 = "viewport" !== d4.get("text-rotation-alignment") && "point" !== d4.get("symbol-placement"), I4 = "map" === d4.get("icon-rotation-alignment") && "point" !== d4.get("symbol-placement"), z4 = d4.get("symbol-placement"), P4 = w4 / 2, C4 = d4.get("icon-text-fit");
            let B5;
            i6 && "none" !== C4 && (e7.allowVerticalPlacement && n6.vertical && (B5 = bc(i6, n6.vertical, C4, d4.get("icon-text-fit-padding"), y4, g4)), m4 && (i6 = bc(i6, m4, C4, d4.get("icon-text-fit-padding"), y4, g4)));
            const V3 = h4 ? p4.line.getGranularityForZoomLevel(h4.z) : 1, E4 = (l6, p5) => {
              p5.x < 0 || p5.x >= M4 || p5.y < 0 || p5.y >= M4 || function(e8, r8, n7, i7, s6, a5, o8, l7, u5, c6, h5, p6, f5, d5, y5, m5, g5, x5, v5, b6, w5, _5, S6, A6, k5) {
                const M5 = e8.addToLineVertexArray(r8, n7);
                let I5, z5, P5, C5, B6 = 0, V4 = 0, E5 = 0, T5 = 0, F3 = -1, $3 = -1;
                const L4 = {};
                let O3 = Na("");
                if (e8.allowVerticalPlacement && i7.vertical) {
                  const t5 = l7.layout.get("text-rotate").evaluate(w5, {}, A6) + 90;
                  P5 = new Bh(u5, r8, c6, h5, p6, i7.vertical, f5, d5, y5, t5), o8 && (C5 = new Bh(u5, r8, c6, h5, p6, o8, g5, x5, y5, t5));
                }
                if (s6) {
                  const n8 = l7.layout.get("icon-rotate").evaluate(w5, {}), i8 = "none" !== l7.layout.get("icon-text-fit"), a6 = Mh(s6, n8, S6, i8), f6 = o8 ? Mh(o8, n8, S6, i8) : void 0;
                  z5 = new Bh(u5, r8, c6, h5, p6, s6, g5, x5, false, n8), B6 = 4 * a6.length;
                  const d6 = e8.iconSizeData;
                  let y6 = null;
                  "source" === d6.kind ? (y6 = [_c * l7.layout.get("icon-size").evaluate(w5, {})], y6[0] > Sc && j3(`${e8.layerIds[0]}: Value for "icon-size" is >= ${wc}. Reduce your "icon-size".`)) : "composite" === d6.kind && (y6 = [_c * _5.compositeIconSizes[0].evaluate(w5, {}, A6), _c * _5.compositeIconSizes[1].evaluate(w5, {}, A6)], (y6[0] > Sc || y6[1] > Sc) && j3(`${e8.layerIds[0]}: Value for "icon-size" is >= ${wc}. Reduce your "icon-size".`)), e8.addSymbols(e8.icon, a6, y6, b6, v5, w5, t4.ah.none, r8, M5.lineStartIndex, M5.lineLength, -1, A6), F3 = e8.icon.placedSymbolArray.length - 1, f6 && (V4 = 4 * f6.length, e8.addSymbols(e8.icon, f6, y6, b6, v5, w5, t4.ah.vertical, r8, M5.lineStartIndex, M5.lineLength, -1, A6), $3 = e8.icon.placedSymbolArray.length - 1);
                }
                const D3 = Object.keys(i7.horizontal);
                for (const n8 of D3) {
                  const s7 = i7.horizontal[n8];
                  if (!I5) {
                    O3 = Na(s7.text);
                    const t5 = l7.layout.get("text-rotate").evaluate(w5, {}, A6);
                    I5 = new Bh(u5, r8, c6, h5, p6, s7, f5, d5, y5, t5);
                  }
                  const o9 = 1 === s7.positionedLines.length;
                  if (E5 += Uh(e8, r8, s7, a5, l7, y5, w5, m5, M5, i7.vertical ? t4.ah.horizontal : t4.ah.horizontalOnly, o9 ? D3 : [n8], L4, F3, _5, A6), o9) break;
                }
                i7.vertical && (T5 += Uh(e8, r8, i7.vertical, a5, l7, y5, w5, m5, M5, t4.ah.vertical, ["vertical"], L4, $3, _5, A6));
                const R5 = I5 ? I5.boxStartIndex : e8.collisionBoxArray.length, N4 = I5 ? I5.boxEndIndex : e8.collisionBoxArray.length, U4 = P5 ? P5.boxStartIndex : e8.collisionBoxArray.length, q3 = P5 ? P5.boxEndIndex : e8.collisionBoxArray.length, G3 = z5 ? z5.boxStartIndex : e8.collisionBoxArray.length, Z3 = z5 ? z5.boxEndIndex : e8.collisionBoxArray.length, K3 = C5 ? C5.boxStartIndex : e8.collisionBoxArray.length, X3 = C5 ? C5.boxEndIndex : e8.collisionBoxArray.length;
                let H5 = -1;
                const Y3 = (t5, e9) => t5 && t5.circleDiameter ? Math.max(t5.circleDiameter, e9) : e9;
                H5 = Y3(I5, H5), H5 = Y3(P5, H5), H5 = Y3(z5, H5), H5 = Y3(C5, H5);
                const J3 = H5 > -1 ? 1 : 0;
                J3 && (H5 *= k5 / Lu), e8.glyphOffsetArray.length >= Ec.MAX_GLYPHS && j3("Too many glyphs being rendered in a tile. See https://github.com/mapbox/mapbox-gl-js/issues/2907"), void 0 !== w5.sortKey && e8.addToSortKeyRanges(e8.symbolInstances.length, w5.sortKey);
                const W2 = Rh(l7, w5, A6), [Q3, tt2] = function(e9, r9) {
                  const n8 = e9.length, i8 = null == r9 ? void 0 : r9.values;
                  if ((null == i8 ? void 0 : i8.length) > 0) for (let r10 = 0; r10 < i8.length; r10 += 2) {
                    const n9 = i8[r10 + 1];
                    e9.emplaceBack(t4.ay[i8[r10]], n9[0], n9[1]);
                  }
                  return [n8, e9.length];
                }(e8.textAnchorOffsets, W2);
                e8.symbolInstances.emplaceBack(r8.x, r8.y, L4.right >= 0 ? L4.right : -1, L4.center >= 0 ? L4.center : -1, L4.left >= 0 ? L4.left : -1, L4.vertical || -1, F3, $3, O3, R5, N4, U4, q3, G3, Z3, K3, X3, c6, E5, T5, B6, V4, J3, 0, f5, H5, Q3, tt2);
              }(e7, p5, l6, n6, i6, s5, B5, e7.layers[0], e7.collisionBoxArray, r7.index, r7.sourceLayerIndex, e7.index, x4, [_4, _4, _4, _4], k4, u4, b5, S5, I4, y4, r7, a4, c5, h4, o7);
            };
            if ("line" === z4) for (const t5 of mh(r7.geometry, 0, 0, M4, M4)) {
              const r8 = Cl(t5, V3), s6 = Sh(r8, w4, A5, n6.vertical || m4, i6, 24, v4, e7.overscaling, M4);
              for (const t6 of s6) m4 && Gh(e7, m4.text, P4, t6) || E4(r8, t6);
            }
            else if ("line-center" === z4) {
              for (const t5 of r7.geometry) if (t5.length > 1) {
                const e8 = Cl(t5, V3), r8 = _h(e8, A5, n6.vertical || m4, i6, 24, v4);
                r8 && E4(e8, r8);
              }
            } else if ("Polygon" === r7.type) for (const t5 of Ur(r7.geometry, 0)) {
              const e8 = Eh(t5, 16);
              E4(Cl(t5[0], V3, true), new gh(e8.x, e8.y, 0));
            }
            else if ("LineString" === r7.type) for (const t5 of r7.geometry) {
              const e8 = Cl(t5, V3);
              E4(e8, new gh(e8[0].x, e8[0].y, 0));
            }
            else if ("Point" === r7.type) for (const t5 of r7.geometry) for (const e8 of t5) E4([e8], new gh(e8.x, e8.y, 0));
          }
          function Uh(t5, e7, r7, n6, i6, s5, a4, o7, u4, c5, h4, p4, f4, d4, y4) {
            const m4 = function(t6, e8, r8, n7, i7, s6, a5, o8) {
              const u5 = n7.layout.get("text-rotate").evaluate(s6, {}) * Math.PI / 180, c6 = [];
              for (const t7 of e8.positionedLines) for (const n8 of t7.positionedGlyphs) {
                if (!n8.rect) continue;
                const s7 = n8.rect || {};
                let h5 = Zu + 1, p5 = true, f5 = 1, d5 = 0;
                const y5 = (i7 || o8) && n8.vertical, m5 = n8.metrics.advance * n8.scale / 2;
                if (o8 && e8.verticalizable && (d5 = t7.lineOffset / 2 - (n8.imageName ? -(Lu - n8.metrics.width * n8.scale) / 2 : (n8.scale - 1) * Lu)), n8.imageName) {
                  const t8 = a5[n8.imageName];
                  p5 = t8.sdf, f5 = t8.pixelRatio, h5 = Xu / f5;
                }
                const g5 = i7 ? [n8.x + m5, n8.y] : [0, 0];
                let x5 = i7 ? [0, 0] : [n8.x + m5 + r8[0], n8.y + r8[1] - d5], v4 = [0, 0];
                y5 && (v4 = x5, x5 = [0, 0]);
                const b5 = n8.metrics.isDoubleResolution ? 2 : 1, w4 = (n8.metrics.left - h5) * n8.scale - m5 + x5[0], _4 = (-n8.metrics.top - h5) * n8.scale + x5[1], S5 = w4 + s7.w / b5 * n8.scale / f5, A5 = _4 + s7.h / b5 * n8.scale / f5, k4 = new l4(w4, _4), M5 = new l4(S5, _4), I4 = new l4(w4, A5), z4 = new l4(S5, A5);
                if (y5) {
                  const t8 = new l4(-m5, m5 - Wu), e9 = -Math.PI / 2, r9 = Lu / 2 - m5, i8 = new l4(5 - Wu - r9, -(n8.imageName ? r9 : 0)), s8 = new l4(...v4);
                  k4._rotateAround(e9, t8)._add(i8)._add(s8), M5._rotateAround(e9, t8)._add(i8)._add(s8), I4._rotateAround(e9, t8)._add(i8)._add(s8), z4._rotateAround(e9, t8)._add(i8)._add(s8);
                }
                if (u5) {
                  const t8 = Math.sin(u5), e9 = Math.cos(u5), r9 = [e9, -t8, t8, e9];
                  k4._matMult(r9), M5._matMult(r9), I4._matMult(r9), z4._matMult(r9);
                }
                const P4 = new l4(0, 0), C4 = new l4(0, 0);
                c6.push({ tl: k4, tr: M5, bl: I4, br: z4, tex: s7, writingMode: e8.writingMode, glyphOffset: g5, sectionIndex: n8.sectionIndex, isSDF: p5, pixelOffsetTL: P4, pixelOffsetBR: C4, minFontScaleX: 0, minFontScaleY: 0 });
              }
              return c6;
            }(0, r7, o7, i6, s5, a4, n6, t5.allowVerticalPlacement), g4 = t5.textSizeData;
            let x4 = null;
            "source" === g4.kind ? (x4 = [_c * i6.layout.get("text-size").evaluate(a4, {})], x4[0] > Sc && j3(`${t5.layerIds[0]}: Value for "text-size" is >= ${wc}. Reduce your "text-size".`)) : "composite" === g4.kind && (x4 = [_c * d4.compositeTextSizes[0].evaluate(a4, {}, y4), _c * d4.compositeTextSizes[1].evaluate(a4, {}, y4)], (x4[0] > Sc || x4[1] > Sc) && j3(`${t5.layerIds[0]}: Value for "text-size" is >= ${wc}. Reduce your "text-size".`)), t5.addSymbols(t5.text, m4, x4, o7, s5, a4, c5, e7, u4.lineStartIndex, u4.lineLength, f4, y4);
            for (const e8 of h4) p4[e8] = t5.text.placedSymbolArray.length - 1;
            return 4 * m4.length;
          }
          function qh(t5) {
            for (const e7 in t5) return t5[e7];
            return null;
          }
          function Gh(t5, e7, r7, n6) {
            const i6 = t5.compareText;
            if (e7 in i6) {
              const t6 = i6[e7];
              for (let e8 = t6.length - 1; e8 >= 0; e8--) if (n6.dist(t6[e8]) < r7) return true;
            } else i6[e7] = [];
            return i6[e7].push(n6), false;
          }
          const Zh = [Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array];
          class Kh {
            static from(t5) {
              if (!(t5 instanceof ArrayBuffer)) throw new Error("Data must be an instance of ArrayBuffer.");
              const [e7, r7] = new Uint8Array(t5, 0, 2);
              if (219 !== e7) throw new Error("Data does not appear to be in a KDBush format.");
              const n6 = r7 >> 4;
              if (1 !== n6) throw new Error(`Got v${n6} data when expected v1.`);
              const i6 = Zh[15 & r7];
              if (!i6) throw new Error("Unrecognized array type.");
              const [s5] = new Uint16Array(t5, 2, 1), [a4] = new Uint32Array(t5, 4, 1);
              return new Kh(a4, s5, i6, t5);
            }
            constructor(t5, e7 = 64, r7 = Float64Array, n6) {
              if (isNaN(t5) || t5 < 0) throw new Error(`Unpexpected numItems value: ${t5}.`);
              this.numItems = +t5, this.nodeSize = Math.min(Math.max(+e7, 2), 65535), this.ArrayType = r7, this.IndexArrayType = t5 < 65536 ? Uint16Array : Uint32Array;
              const i6 = Zh.indexOf(this.ArrayType), s5 = 2 * t5 * this.ArrayType.BYTES_PER_ELEMENT, a4 = t5 * this.IndexArrayType.BYTES_PER_ELEMENT, o7 = (8 - a4 % 8) % 8;
              if (i6 < 0) throw new Error(`Unexpected typed array class: ${r7}.`);
              n6 && n6 instanceof ArrayBuffer ? (this.data = n6, this.ids = new this.IndexArrayType(this.data, 8, t5), this.coords = new this.ArrayType(this.data, 8 + a4 + o7, 2 * t5), this._pos = 2 * t5, this._finished = true) : (this.data = new ArrayBuffer(8 + s5 + a4 + o7), this.ids = new this.IndexArrayType(this.data, 8, t5), this.coords = new this.ArrayType(this.data, 8 + a4 + o7, 2 * t5), this._pos = 0, this._finished = false, new Uint8Array(this.data, 0, 2).set([219, 16 + i6]), new Uint16Array(this.data, 2, 1)[0] = e7, new Uint32Array(this.data, 4, 1)[0] = t5);
            }
            add(t5, e7) {
              const r7 = this._pos >> 1;
              return this.ids[r7] = r7, this.coords[this._pos++] = t5, this.coords[this._pos++] = e7, r7;
            }
            finish() {
              const t5 = this._pos >> 1;
              if (t5 !== this.numItems) throw new Error(`Added ${t5} items when expected ${this.numItems}.`);
              return Xh(this.ids, this.coords, this.nodeSize, 0, this.numItems - 1, 0), this._finished = true, this;
            }
            range(t5, e7, r7, n6) {
              if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
              const { ids: i6, coords: s5, nodeSize: a4 } = this, o7 = [0, i6.length - 1, 0], l5 = [];
              for (; o7.length; ) {
                const u4 = o7.pop() || 0, c5 = o7.pop() || 0, h4 = o7.pop() || 0;
                if (c5 - h4 <= a4) {
                  for (let a5 = h4; a5 <= c5; a5++) {
                    const o8 = s5[2 * a5], u5 = s5[2 * a5 + 1];
                    o8 >= t5 && o8 <= r7 && u5 >= e7 && u5 <= n6 && l5.push(i6[a5]);
                  }
                  continue;
                }
                const p4 = h4 + c5 >> 1, f4 = s5[2 * p4], d4 = s5[2 * p4 + 1];
                f4 >= t5 && f4 <= r7 && d4 >= e7 && d4 <= n6 && l5.push(i6[p4]), (0 === u4 ? t5 <= f4 : e7 <= d4) && (o7.push(h4), o7.push(p4 - 1), o7.push(1 - u4)), (0 === u4 ? r7 >= f4 : n6 >= d4) && (o7.push(p4 + 1), o7.push(c5), o7.push(1 - u4));
              }
              return l5;
            }
            within(t5, e7, r7) {
              if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
              const { ids: n6, coords: i6, nodeSize: s5 } = this, a4 = [0, n6.length - 1, 0], o7 = [], l5 = r7 * r7;
              for (; a4.length; ) {
                const u4 = a4.pop() || 0, c5 = a4.pop() || 0, h4 = a4.pop() || 0;
                if (c5 - h4 <= s5) {
                  for (let r8 = h4; r8 <= c5; r8++) Wh(i6[2 * r8], i6[2 * r8 + 1], t5, e7) <= l5 && o7.push(n6[r8]);
                  continue;
                }
                const p4 = h4 + c5 >> 1, f4 = i6[2 * p4], d4 = i6[2 * p4 + 1];
                Wh(f4, d4, t5, e7) <= l5 && o7.push(n6[p4]), (0 === u4 ? t5 - r7 <= f4 : e7 - r7 <= d4) && (a4.push(h4), a4.push(p4 - 1), a4.push(1 - u4)), (0 === u4 ? t5 + r7 >= f4 : e7 + r7 >= d4) && (a4.push(p4 + 1), a4.push(c5), a4.push(1 - u4));
              }
              return o7;
            }
          }
          function Xh(t5, e7, r7, n6, i6, s5) {
            if (i6 - n6 <= r7) return;
            const a4 = n6 + i6 >> 1;
            Hh(t5, e7, a4, n6, i6, s5), Xh(t5, e7, r7, n6, a4 - 1, 1 - s5), Xh(t5, e7, r7, a4 + 1, i6, 1 - s5);
          }
          function Hh(t5, e7, r7, n6, i6, s5) {
            for (; i6 > n6; ) {
              if (i6 - n6 > 600) {
                const a5 = i6 - n6 + 1, o8 = r7 - n6 + 1, l6 = Math.log(a5), u4 = 0.5 * Math.exp(2 * l6 / 3), c5 = 0.5 * Math.sqrt(l6 * u4 * (a5 - u4) / a5) * (o8 - a5 / 2 < 0 ? -1 : 1);
                Hh(t5, e7, r7, Math.max(n6, Math.floor(r7 - o8 * u4 / a5 + c5)), Math.min(i6, Math.floor(r7 + (a5 - o8) * u4 / a5 + c5)), s5);
              }
              const a4 = e7[2 * r7 + s5];
              let o7 = n6, l5 = i6;
              for (Yh(t5, e7, n6, r7), e7[2 * i6 + s5] > a4 && Yh(t5, e7, n6, i6); o7 < l5; ) {
                for (Yh(t5, e7, o7, l5), o7++, l5--; e7[2 * o7 + s5] < a4; ) o7++;
                for (; e7[2 * l5 + s5] > a4; ) l5--;
              }
              e7[2 * n6 + s5] === a4 ? Yh(t5, e7, n6, l5) : (l5++, Yh(t5, e7, l5, i6)), l5 <= r7 && (n6 = l5 + 1), r7 <= l5 && (i6 = l5 - 1);
            }
          }
          function Yh(t5, e7, r7, n6) {
            Jh(t5, r7, n6), Jh(e7, 2 * r7, 2 * n6), Jh(e7, 2 * r7 + 1, 2 * n6 + 1);
          }
          function Jh(t5, e7, r7) {
            const n6 = t5[e7];
            t5[e7] = t5[r7], t5[r7] = n6;
          }
          function Wh(t5, e7, r7, n6) {
            const i6 = t5 - r7, s5 = e7 - n6;
            return i6 * i6 + s5 * s5;
          }
          var Qh;
          t4.ck = void 0, (Qh = t4.ck || (t4.ck = {})).create = "create", Qh.load = "load", Qh.fullLoad = "fullLoad";
          let tp = null, ep = [];
          const rp = 1e3 / 60, np = "loadTime", ip = "fullLoadTime", sp = { mark(t5) {
            performance.mark(t5);
          }, frame(t5) {
            const e7 = t5;
            null != tp && ep.push(e7 - tp), tp = e7;
          }, clearMetrics() {
            tp = null, ep = [], performance.clearMeasures(np), performance.clearMeasures(ip);
            for (const e7 in t4.ck) performance.clearMarks(t4.ck[e7]);
          }, getPerformanceMetrics() {
            performance.measure(np, t4.ck.create, t4.ck.load), performance.measure(ip, t4.ck.create, t4.ck.fullLoad);
            const e7 = performance.getEntriesByName(np)[0].duration, r7 = performance.getEntriesByName(ip)[0].duration, n6 = ep.length, i6 = 1 / (ep.reduce((t5, e8) => t5 + e8, 0) / n6 / 1e3), s5 = ep.filter((t5) => t5 > rp).reduce((t5, e8) => t5 + (e8 - rp) / rp, 0);
            return { loadTime: e7, fullLoadTime: r7, fps: i6, percentDroppedFrames: s5 / (n6 + s5) * 100, totalFrames: n6 };
          } };
          t4.$ = nh, t4.A = g3, t4.B = ir, t4.C = fs, t4.D = _s, t4.E = ft, t4.F = Ri, t4.G = function(t5) {
            if (null == q2) {
              const e7 = t5.navigator ? t5.navigator.userAgent : null;
              q2 = !!t5.safari || !(!e7 || !(/\b(iPad|iPhone|iPod)\b/.test(e7) || e7.match("Safari") && !e7.match("Chrome")));
            }
            return q2;
          }, t4.H = class {
            constructor(t5, e7) {
              this.target = t5, this.mapId = e7, this.resolveRejects = {}, this.tasks = {}, this.taskQueue = [], this.abortControllers = {}, this.messageHandlers = {}, this.invoker = new Zc(() => this.process()), this.subscription = Y2(this.target, "message", (t6) => this.receive(t6), false), this.globalScope = U3(self) ? t5 : window;
            }
            registerMessageHandler(t5, e7) {
              this.messageHandlers[t5] = e7;
            }
            sendAsync(t5, e7) {
              return new Promise((r7, n6) => {
                const i6 = Math.round(1e18 * Math.random()).toString(36).substring(0, 10), s5 = e7 ? Y2(e7.signal, "abort", () => {
                  null == s5 || s5.unsubscribe(), delete this.resolveRejects[i6];
                  const e8 = { id: i6, type: "<cancel>", origin: location.origin, targetMapId: t5.targetMapId, sourceMapId: this.mapId };
                  this.target.postMessage(e8);
                }, Kc) : null;
                this.resolveRejects[i6] = { resolve: (t6) => {
                  null == s5 || s5.unsubscribe(), r7(t6);
                }, reject: (t6) => {
                  null == s5 || s5.unsubscribe(), n6(t6);
                } };
                const a4 = [], o7 = Object.assign(Object.assign({}, t5), { id: i6, sourceMapId: this.mapId, origin: location.origin, data: Yi(t5.data, a4) });
                this.target.postMessage(o7, { transfer: a4 });
              });
            }
            receive(t5) {
              const e7 = t5.data, r7 = e7.id;
              if (!("file://" !== e7.origin && "file://" !== location.origin && "resource://android" !== e7.origin && "resource://android" !== location.origin && e7.origin !== location.origin || e7.targetMapId && this.mapId !== e7.targetMapId)) {
                if ("<cancel>" === e7.type) {
                  delete this.tasks[r7];
                  const t6 = this.abortControllers[r7];
                  return delete this.abortControllers[r7], void (t6 && t6.abort());
                }
                if (U3(self) || e7.mustQueue) return this.tasks[r7] = e7, this.taskQueue.push(r7), void this.invoker.trigger();
                this.processTask(r7, e7);
              }
            }
            process() {
              if (0 === this.taskQueue.length) return;
              const t5 = this.taskQueue.shift(), e7 = this.tasks[t5];
              delete this.tasks[t5], this.taskQueue.length > 0 && this.invoker.trigger(), e7 && this.processTask(t5, e7);
            }
            processTask(t5, r7) {
              return e6(this, void 0, void 0, function* () {
                if ("<response>" === r7.type) {
                  const e8 = this.resolveRejects[t5];
                  if (delete this.resolveRejects[t5], !e8) return;
                  return void (r7.error ? e8.reject(Ji(r7.error)) : e8.resolve(Ji(r7.data)));
                }
                if (!this.messageHandlers[r7.type]) return void this.completeTask(t5, new Error(`Could not find a registered handler for ${r7.type}, map ID: ${this.mapId}, available handlers: ${Object.keys(this.messageHandlers).join(", ")}`));
                const e7 = Ji(r7.data), n6 = new AbortController();
                this.abortControllers[t5] = n6;
                try {
                  const i6 = yield this.messageHandlers[r7.type](r7.sourceMapId, e7, n6);
                  this.completeTask(t5, null, i6);
                } catch (e8) {
                  this.completeTask(t5, e8);
                }
              });
            }
            completeTask(t5, e7, r7) {
              const n6 = [];
              delete this.abortControllers[t5];
              const i6 = { id: t5, type: "<response>", sourceMapId: this.mapId, origin: location.origin, error: e7 ? Yi(e7) : null, data: Yi(r7, n6) };
              this.target.postMessage(i6, { transfer: n6 });
            }
            remove() {
              this.invoker.remove(), this.subscription.unsubscribe();
            }
          }, t4.I = Hu, t4.J = it, t4.K = function() {
            var t5 = new g3(16);
            return g3 != Float32Array && (t5[1] = 0, t5[2] = 0, t5[3] = 0, t5[4] = 0, t5[6] = 0, t5[7] = 0, t5[8] = 0, t5[9] = 0, t5[11] = 0, t5[12] = 0, t5[13] = 0, t5[14] = 0), t5[0] = 1, t5[5] = 1, t5[10] = 1, t5[15] = 1, t5;
          }, t4.L = function(t5, e7, r7) {
            var n6, i6, s5, a4, o7, l5, u4, c5, h4, p4, f4, d4, y4 = r7[0], m4 = r7[1], g4 = r7[2];
            return e7 === t5 ? (t5[12] = e7[0] * y4 + e7[4] * m4 + e7[8] * g4 + e7[12], t5[13] = e7[1] * y4 + e7[5] * m4 + e7[9] * g4 + e7[13], t5[14] = e7[2] * y4 + e7[6] * m4 + e7[10] * g4 + e7[14], t5[15] = e7[3] * y4 + e7[7] * m4 + e7[11] * g4 + e7[15]) : (i6 = e7[1], s5 = e7[2], a4 = e7[3], o7 = e7[4], l5 = e7[5], u4 = e7[6], c5 = e7[7], h4 = e7[8], p4 = e7[9], f4 = e7[10], d4 = e7[11], t5[0] = n6 = e7[0], t5[1] = i6, t5[2] = s5, t5[3] = a4, t5[4] = o7, t5[5] = l5, t5[6] = u4, t5[7] = c5, t5[8] = h4, t5[9] = p4, t5[10] = f4, t5[11] = d4, t5[12] = n6 * y4 + o7 * m4 + h4 * g4 + e7[12], t5[13] = i6 * y4 + l5 * m4 + p4 * g4 + e7[13], t5[14] = s5 * y4 + u4 * m4 + f4 * g4 + e7[14], t5[15] = a4 * y4 + c5 * m4 + d4 * g4 + e7[15]), t5;
          }, t4.M = function(t5, e7, r7) {
            var n6 = r7[0], i6 = r7[1], s5 = r7[2];
            return t5[0] = e7[0] * n6, t5[1] = e7[1] * n6, t5[2] = e7[2] * n6, t5[3] = e7[3] * n6, t5[4] = e7[4] * i6, t5[5] = e7[5] * i6, t5[6] = e7[6] * i6, t5[7] = e7[7] * i6, t5[8] = e7[8] * s5, t5[9] = e7[9] * s5, t5[10] = e7[10] * s5, t5[11] = e7[11] * s5, t5[12] = e7[12], t5[13] = e7[13], t5[14] = e7[14], t5[15] = e7[15], t5;
          }, t4.N = function(t5, e7, r7) {
            var n6 = e7[0], i6 = e7[1], s5 = e7[2], a4 = e7[3], o7 = e7[4], l5 = e7[5], u4 = e7[6], c5 = e7[7], h4 = e7[8], p4 = e7[9], f4 = e7[10], d4 = e7[11], y4 = e7[12], m4 = e7[13], g4 = e7[14], x4 = e7[15], v4 = r7[0], b5 = r7[1], w4 = r7[2], _4 = r7[3];
            return t5[0] = v4 * n6 + b5 * o7 + w4 * h4 + _4 * y4, t5[1] = v4 * i6 + b5 * l5 + w4 * p4 + _4 * m4, t5[2] = v4 * s5 + b5 * u4 + w4 * f4 + _4 * g4, t5[3] = v4 * a4 + b5 * c5 + w4 * d4 + _4 * x4, t5[4] = (v4 = r7[4]) * n6 + (b5 = r7[5]) * o7 + (w4 = r7[6]) * h4 + (_4 = r7[7]) * y4, t5[5] = v4 * i6 + b5 * l5 + w4 * p4 + _4 * m4, t5[6] = v4 * s5 + b5 * u4 + w4 * f4 + _4 * g4, t5[7] = v4 * a4 + b5 * c5 + w4 * d4 + _4 * x4, t5[8] = (v4 = r7[8]) * n6 + (b5 = r7[9]) * o7 + (w4 = r7[10]) * h4 + (_4 = r7[11]) * y4, t5[9] = v4 * i6 + b5 * l5 + w4 * p4 + _4 * m4, t5[10] = v4 * s5 + b5 * u4 + w4 * f4 + _4 * g4, t5[11] = v4 * a4 + b5 * c5 + w4 * d4 + _4 * x4, t5[12] = (v4 = r7[12]) * n6 + (b5 = r7[13]) * o7 + (w4 = r7[14]) * h4 + (_4 = r7[15]) * y4, t5[13] = v4 * i6 + b5 * l5 + w4 * p4 + _4 * m4, t5[14] = v4 * s5 + b5 * u4 + w4 * f4 + _4 * g4, t5[15] = v4 * a4 + b5 * c5 + w4 * d4 + _4 * x4, t5;
          }, t4.O = function(t5, e7) {
            const r7 = {};
            for (let n6 = 0; n6 < e7.length; n6++) {
              const i6 = e7[n6];
              i6 in t5 && (r7[i6] = t5[i6]);
            }
            return r7;
          }, t4.P = l4, t4.Q = Hc, t4.R = No, t4.S = Qc, t4.T = ms, t4.U = Wc, t4.V = f3, t4.W = d3, t4.X = K2, t4.Y = oh, t4.Z = M4, t4._ = e6, t4.a = rt, t4.a$ = function(t5, e7, r7) {
            var n6 = Math.sin(r7), i6 = Math.cos(r7), s5 = e7[4], a4 = e7[5], o7 = e7[6], l5 = e7[7], u4 = e7[8], c5 = e7[9], h4 = e7[10], p4 = e7[11];
            return e7 !== t5 && (t5[0] = e7[0], t5[1] = e7[1], t5[2] = e7[2], t5[3] = e7[3], t5[12] = e7[12], t5[13] = e7[13], t5[14] = e7[14], t5[15] = e7[15]), t5[4] = s5 * i6 + u4 * n6, t5[5] = a4 * i6 + c5 * n6, t5[6] = o7 * i6 + h4 * n6, t5[7] = l5 * i6 + p4 * n6, t5[8] = u4 * i6 - s5 * n6, t5[9] = c5 * i6 - a4 * n6, t5[10] = h4 * i6 - o7 * n6, t5[11] = p4 * i6 - l5 * n6, t5;
          }, t4.a0 = 25, t4.a1 = sh, t4.a2 = (t5) => {
            const e7 = window.document.createElement("video");
            return e7.muted = true, new Promise((r7) => {
              e7.onloadstart = () => {
                r7(e7);
              };
              for (const r8 of t5) {
                const t6 = window.document.createElement("source");
                lt(r8) || (e7.crossOrigin = "Anonymous"), t6.src = r8, e7.appendChild(t6);
              }
            });
          }, t4.a3 = Mt, t4.a4 = function() {
            return $2++;
          }, t4.a5 = sa, t4.a6 = Ec, t4.a7 = Qn, t4.a8 = ho, t4.a9 = hh, t4.aA = jh, t4.aB = hc, t4.aC = Kh, t4.aD = Es, t4.aE = kl, t4.aF = ma, t4.aG = Va, t4.aH = za, t4.aI = function(t5) {
            return Math.pow(2, t5);
          }, t4.aJ = 85.051129, t4.aK = th, t4.aL = T4, t4.aM = J2, t4.aN = rh, t4.aO = function(t5, e7, r7) {
            return t5[0] = e7[0] * r7, t5[1] = e7[1] * r7, t5[2] = e7[2] * r7, t5;
          }, t4.aP = function(t5, e7, r7) {
            return t5[0] = e7[0] + r7[0], t5[1] = e7[1] + r7[1], t5[2] = e7[2] + r7[2], t5;
          }, t4.aQ = function(t5) {
            var e7 = new g3(3);
            return e7[0] = t5[0], e7[1] = t5[1], e7[2] = t5[2], e7;
          }, t4.aR = function(t5, e7, r7) {
            return t5[0] = e7[0] * r7[0], t5[1] = e7[1] * r7[1], t5[2] = e7[2] * r7[2], t5[3] = e7[3] * r7[3], t5;
          }, t4.aS = function(t5, e7, r7) {
            return t5[0] = e7[0] - r7[0], t5[1] = e7[1] - r7[1], t5[2] = e7[2] - r7[2], t5;
          }, t4.aT = function(t5, e7) {
            var r7 = e7[0], n6 = e7[1], i6 = e7[2], s5 = r7 * r7 + n6 * n6 + i6 * i6;
            return s5 > 0 && (s5 = 1 / Math.sqrt(s5)), t5[0] = e7[0] * s5, t5[1] = e7[1] * s5, t5[2] = e7[2] * s5, t5;
          }, t4.aU = function(t5, e7, r7) {
            var n6 = e7[0], i6 = e7[1], s5 = e7[2], a4 = r7[0], o7 = r7[1], l5 = r7[2];
            return t5[0] = i6 * l5 - s5 * o7, t5[1] = s5 * a4 - n6 * l5, t5[2] = n6 * o7 - i6 * a4, t5;
          }, t4.aV = function(t5, e7) {
            return t5[0] * e7[0] + t5[1] * e7[1] + t5[2] * e7[2];
          }, t4.aW = ah, t4.aX = lh, t4.aY = function(t5, e7, r7, n6, i6) {
            var s5, a4 = 1 / Math.tan(e7 / 2);
            return t5[0] = a4 / r7, t5[1] = 0, t5[2] = 0, t5[3] = 0, t5[4] = 0, t5[5] = a4, t5[6] = 0, t5[7] = 0, t5[8] = 0, t5[9] = 0, t5[11] = -1, t5[12] = 0, t5[13] = 0, t5[15] = 0, null != i6 && i6 !== 1 / 0 ? (t5[10] = (i6 + n6) * (s5 = 1 / (n6 - i6)), t5[14] = 2 * i6 * n6 * s5) : (t5[10] = -1, t5[14] = -2 * n6), t5;
          }, t4.aZ = function(t5) {
            var e7 = new g3(16);
            return e7[0] = t5[0], e7[1] = t5[1], e7[2] = t5[2], e7[3] = t5[3], e7[4] = t5[4], e7[5] = t5[5], e7[6] = t5[6], e7[7] = t5[7], e7[8] = t5[8], e7[9] = t5[9], e7[10] = t5[10], e7[11] = t5[11], e7[12] = t5[12], e7[13] = t5[13], e7[14] = t5[14], e7[15] = t5[15], e7;
          }, t4.a_ = function(t5, e7, r7) {
            var n6 = Math.sin(r7), i6 = Math.cos(r7), s5 = e7[0], a4 = e7[1], o7 = e7[2], l5 = e7[3], u4 = e7[4], c5 = e7[5], h4 = e7[6], p4 = e7[7];
            return e7 !== t5 && (t5[8] = e7[8], t5[9] = e7[9], t5[10] = e7[10], t5[11] = e7[11], t5[12] = e7[12], t5[13] = e7[13], t5[14] = e7[14], t5[15] = e7[15]), t5[0] = s5 * i6 + u4 * n6, t5[1] = a4 * i6 + c5 * n6, t5[2] = o7 * i6 + h4 * n6, t5[3] = l5 * i6 + p4 * n6, t5[4] = u4 * i6 - s5 * n6, t5[5] = c5 * i6 - a4 * n6, t5[6] = h4 * i6 - o7 * n6, t5[7] = p4 * i6 - l5 * n6, t5;
          }, t4.aa = function(t5) {
            const e7 = {};
            if (t5.replace(/(?:^|(?:\s*\,\s*))([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)(?:\=(?:([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)|(?:\"((?:[^"\\]|\\.)*)\")))?/g, (t6, r7, n6, i6) => {
              const s5 = n6 || i6;
              return e7[r7] = !s5 || s5.toLowerCase(), "";
            }), e7["max-age"]) {
              const t6 = parseInt(e7["max-age"], 10);
              isNaN(t6) ? delete e7["max-age"] : e7["max-age"] = t6;
            }
            return e7;
          }, t4.ab = function(t5) {
            return Math.log(t5) / Math.LN2;
          }, t4.ac = function(t5) {
            var e7 = t5[0], r7 = t5[1];
            return e7 * e7 + r7 * r7;
          }, t4.ad = function(t5) {
            return t5 * Math.PI / 180;
          }, t4.ae = E3, t4.af = function(t5, e7) {
            const r7 = [];
            for (const n6 in t5) n6 in e7 || r7.push(n6);
            return r7;
          }, t4.ag = function(t5, e7) {
            let r7 = 0, n6 = 0;
            if ("constant" === t5.kind) n6 = t5.layoutSize;
            else if ("source" !== t5.kind) {
              const { interpolationType: i6, minZoom: s5, maxZoom: a4 } = t5, o7 = i6 ? E3(rr.interpolationFactor(i6, e7, s5, a4), 0, 1) : 0;
              "camera" === t5.kind ? n6 = ir.number(t5.minSize, t5.maxSize, o7) : r7 = o7;
            }
            return { uSizeT: r7, uSize: n6 };
          }, t4.ai = function(t5, { uSize: e7, uSizeT: r7 }, { lowerSize: n6, upperSize: i6 }) {
            return "source" === t5.kind ? n6 / _c : "composite" === t5.kind ? ir.number(n6 / _c, i6 / _c, r7) : e7;
          }, t4.aj = function(t5, e7) {
            var r7 = e7[0], n6 = e7[1], i6 = e7[2], s5 = e7[3], a4 = e7[4], o7 = e7[5], l5 = e7[6], u4 = e7[7], c5 = e7[8], h4 = e7[9], p4 = e7[10], f4 = e7[11], d4 = e7[12], y4 = e7[13], m4 = e7[14], g4 = e7[15], x4 = r7 * o7 - n6 * a4, v4 = r7 * l5 - i6 * a4, b5 = r7 * u4 - s5 * a4, w4 = n6 * l5 - i6 * o7, _4 = n6 * u4 - s5 * o7, S5 = i6 * u4 - s5 * l5, A5 = c5 * y4 - h4 * d4, k4 = c5 * m4 - p4 * d4, M5 = c5 * g4 - f4 * d4, I4 = h4 * m4 - p4 * y4, z4 = h4 * g4 - f4 * y4, P4 = p4 * g4 - f4 * m4, C4 = x4 * P4 - v4 * z4 + b5 * I4 + w4 * M5 - _4 * k4 + S5 * A5;
            return C4 ? (t5[0] = (o7 * P4 - l5 * z4 + u4 * I4) * (C4 = 1 / C4), t5[1] = (i6 * z4 - n6 * P4 - s5 * I4) * C4, t5[2] = (y4 * S5 - m4 * _4 + g4 * w4) * C4, t5[3] = (p4 * _4 - h4 * S5 - f4 * w4) * C4, t5[4] = (l5 * M5 - a4 * P4 - u4 * k4) * C4, t5[5] = (r7 * P4 - i6 * M5 + s5 * k4) * C4, t5[6] = (m4 * b5 - d4 * S5 - g4 * v4) * C4, t5[7] = (c5 * S5 - p4 * b5 + f4 * v4) * C4, t5[8] = (a4 * z4 - o7 * M5 + u4 * A5) * C4, t5[9] = (n6 * M5 - r7 * z4 - s5 * A5) * C4, t5[10] = (d4 * _4 - y4 * b5 + g4 * x4) * C4, t5[11] = (h4 * b5 - c5 * _4 - f4 * x4) * C4, t5[12] = (o7 * k4 - a4 * I4 - l5 * A5) * C4, t5[13] = (r7 * I4 - n6 * k4 + i6 * A5) * C4, t5[14] = (y4 * v4 - d4 * w4 - m4 * x4) * C4, t5[15] = (c5 * w4 - h4 * v4 + p4 * x4) * C4, t5) : null;
          }, t4.ak = A4, t4.al = function(t5) {
            return Math.hypot(t5[0], t5[1]);
          }, t4.am = function(t5) {
            return t5[0] = 0, t5[1] = 0, t5;
          }, t4.an = function(t5, e7, r7) {
            return t5[0] = e7[0] * r7, t5[1] = e7[1] * r7, t5;
          }, t4.ao = Pc, t4.ap = _3, t4.aq = function(t5, e7, r7, n6) {
            const i6 = e7.y - t5.y, s5 = e7.x - t5.x, a4 = n6.y - r7.y, o7 = n6.x - r7.x, u4 = a4 * s5 - o7 * i6;
            if (0 === u4) return null;
            const c5 = (o7 * (t5.y - r7.y) - a4 * (t5.x - r7.x)) / u4;
            return new l4(t5.x + c5 * s5, t5.y + c5 * i6);
          }, t4.ar = mh, t4.as = mo, t4.at = v3, t4.au = function(t5) {
            let e7 = 1 / 0, r7 = 1 / 0, n6 = -1 / 0, i6 = -1 / 0;
            for (const s5 of t5) e7 = Math.min(e7, s5.x), r7 = Math.min(r7, s5.y), n6 = Math.max(n6, s5.x), i6 = Math.max(i6, s5.y);
            return [e7, r7, n6, i6];
          }, t4.av = Lu, t4.aw = I3, t4.ax = function(t5, e7, r7, n6, i6 = false) {
            if (!r7[0] && !r7[1]) return [0, 0];
            const s5 = i6 ? "map" === n6 ? -t5.bearingInRadians : 0 : "viewport" === n6 ? t5.bearingInRadians : 0;
            if (s5) {
              const t6 = Math.sin(s5), e8 = Math.cos(s5);
              r7 = [r7[0] * e8 - r7[1] * t6, r7[0] * t6 + r7[1] * e8];
            }
            return [i6 ? r7[0] : I3(e7, r7[0], t5.zoom), i6 ? r7[1] : I3(e7, r7[1], t5.zoom)];
          }, t4.az = kc, t4.b = G2, t4.b$ = (t5) => "symbol" === t5.type, t4.b0 = function() {
            const t5 = new Float32Array(16);
            return v3(t5), t5;
          }, t4.b1 = function() {
            const t5 = new Float64Array(16);
            return v3(t5), t5;
          }, t4.b2 = function() {
            return new Float64Array(16);
          }, t4.b3 = function(t5, e7, r7) {
            const n6 = new Float64Array(4);
            return function(t6, e8, r8, n7) {
              var i6 = 0.5 * Math.PI / 180;
              e8 *= i6, r8 *= i6, n7 *= i6;
              var s5 = Math.sin(e8), a4 = Math.cos(e8), o7 = Math.sin(r8), l5 = Math.cos(r8), u4 = Math.sin(n7), c5 = Math.cos(n7);
              t6[0] = s5 * l5 * c5 - a4 * o7 * u4, t6[1] = a4 * o7 * c5 + s5 * l5 * u4, t6[2] = a4 * l5 * u4 - s5 * o7 * c5, t6[3] = a4 * l5 * c5 + s5 * o7 * u4;
            }(n6, t5, e7 - 90, r7), n6;
          }, t4.b4 = function(t5, e7, r7, n6) {
            var i6, s5, a4, o7, l5, u4 = e7[0], c5 = e7[1], h4 = e7[2], p4 = e7[3], f4 = r7[0], d4 = r7[1], y4 = r7[2], g4 = r7[3];
            return (s5 = u4 * f4 + c5 * d4 + h4 * y4 + p4 * g4) < 0 && (s5 = -s5, f4 = -f4, d4 = -d4, y4 = -y4, g4 = -g4), 1 - s5 > m3 ? (i6 = Math.acos(s5), a4 = Math.sin(i6), o7 = Math.sin((1 - n6) * i6) / a4, l5 = Math.sin(n6 * i6) / a4) : (o7 = 1 - n6, l5 = n6), t5[0] = o7 * u4 + l5 * f4, t5[1] = o7 * c5 + l5 * d4, t5[2] = o7 * h4 + l5 * y4, t5[3] = o7 * p4 + l5 * g4, t5;
          }, t4.b5 = function(t5) {
            const e7 = new Float64Array(9);
            var r7, n6, i6, s5, a4, o7, l5, u4, c5, h4, p4, f4, d4, y4, m4, g4, x4, v4;
            h4 = (i6 = (n6 = t5)[0]) * (l5 = i6 + i6), p4 = (s5 = n6[1]) * l5, d4 = (a4 = n6[2]) * l5, y4 = a4 * (u4 = s5 + s5), g4 = (o7 = n6[3]) * l5, x4 = o7 * u4, v4 = o7 * (c5 = a4 + a4), (r7 = e7)[0] = 1 - (f4 = s5 * u4) - (m4 = a4 * c5), r7[3] = p4 - v4, r7[6] = d4 + x4, r7[1] = p4 + v4, r7[4] = 1 - h4 - m4, r7[7] = y4 - g4, r7[2] = d4 - x4, r7[5] = y4 + g4, r7[8] = 1 - h4 - f4;
            const b5 = J2(-Math.asin(E3(e7[2], -1, 1)));
            let w4, _4;
            return Math.hypot(e7[5], e7[8]) < 1e-3 ? (w4 = 0, _4 = -J2(Math.atan2(e7[3], e7[4]))) : (w4 = J2(0 === e7[5] && 0 === e7[8] ? 0 : Math.atan2(e7[5], e7[8])), _4 = J2(0 === e7[1] && 0 === e7[0] ? 0 : Math.atan2(e7[1], e7[0]))), { roll: w4, pitch: b5 + 90, bearing: _4 };
          }, t4.b6 = function(t5, e7) {
            return t5.roll == e7.roll && t5.pitch == e7.pitch && t5.bearing == e7.bearing;
          }, t4.b7 = xe, t4.b8 = Xa, t4.b9 = Ml, t4.bA = function(t5, e7) {
            if (!t5) return [{ command: "setStyle", args: [e7] }];
            let r7 = [];
            try {
              if (!gt(t5.version, e7.version)) return [{ command: "setStyle", args: [e7] }];
              gt(t5.center, e7.center) || r7.push({ command: "setCenter", args: [e7.center] }), gt(t5.centerAltitude, e7.centerAltitude) || r7.push({ command: "setCenterAltitude", args: [e7.centerAltitude] }), gt(t5.zoom, e7.zoom) || r7.push({ command: "setZoom", args: [e7.zoom] }), gt(t5.bearing, e7.bearing) || r7.push({ command: "setBearing", args: [e7.bearing] }), gt(t5.pitch, e7.pitch) || r7.push({ command: "setPitch", args: [e7.pitch] }), gt(t5.roll, e7.roll) || r7.push({ command: "setRoll", args: [e7.roll] }), gt(t5.sprite, e7.sprite) || r7.push({ command: "setSprite", args: [e7.sprite] }), gt(t5.glyphs, e7.glyphs) || r7.push({ command: "setGlyphs", args: [e7.glyphs] }), gt(t5.transition, e7.transition) || r7.push({ command: "setTransition", args: [e7.transition] }), gt(t5.light, e7.light) || r7.push({ command: "setLight", args: [e7.light] }), gt(t5.terrain, e7.terrain) || r7.push({ command: "setTerrain", args: [e7.terrain] }), gt(t5.sky, e7.sky) || r7.push({ command: "setSky", args: [e7.sky] }), gt(t5.projection, e7.projection) || r7.push({ command: "setProjection", args: [e7.projection] });
              const n6 = {}, i6 = [];
              !function(t6, e8, r8, n7) {
                let i7;
                for (i7 in e8 = e8 || {}, t6 = t6 || {}) Object.prototype.hasOwnProperty.call(t6, i7) && (Object.prototype.hasOwnProperty.call(e8, i7) || bt(i7, r8, n7));
                for (i7 in e8) Object.prototype.hasOwnProperty.call(e8, i7) && (Object.prototype.hasOwnProperty.call(t6, i7) ? gt(t6[i7], e8[i7]) || ("geojson" === t6[i7].type && "geojson" === e8[i7].type && _t(t6, e8, i7) ? xt(r8, { command: "setGeoJSONSourceData", args: [i7, e8[i7].data] }) : wt(i7, e8, r8, n7)) : vt(i7, e8, r8));
              }(t5.sources, e7.sources, i6, n6);
              const s5 = [];
              t5.layers && t5.layers.forEach((t6) => {
                "source" in t6 && n6[t6.source] ? r7.push({ command: "removeLayer", args: [t6.id] }) : s5.push(t6);
              }), r7 = r7.concat(i6), function(t6, e8, r8) {
                e8 = e8 || [];
                const n7 = (t6 = t6 || []).map(At), i7 = e8.map(At), s6 = t6.reduce(kt, {}), a4 = e8.reduce(kt, {}), o7 = n7.slice(), l5 = /* @__PURE__ */ Object.create(null);
                let u4, c5, h4, p4, f4;
                for (let t7 = 0, e9 = 0; t7 < n7.length; t7++) u4 = n7[t7], Object.prototype.hasOwnProperty.call(a4, u4) ? e9++ : (xt(r8, { command: "removeLayer", args: [u4] }), o7.splice(o7.indexOf(u4, e9), 1));
                for (let t7 = 0, e9 = 0; t7 < i7.length; t7++) u4 = i7[i7.length - 1 - t7], o7[o7.length - 1 - t7] !== u4 && (Object.prototype.hasOwnProperty.call(s6, u4) ? (xt(r8, { command: "removeLayer", args: [u4] }), o7.splice(o7.lastIndexOf(u4, o7.length - e9), 1)) : e9++, p4 = o7[o7.length - t7], xt(r8, { command: "addLayer", args: [a4[u4], p4] }), o7.splice(o7.length - t7, 0, u4), l5[u4] = true);
                for (let t7 = 0; t7 < i7.length; t7++) if (u4 = i7[t7], c5 = s6[u4], h4 = a4[u4], !l5[u4] && !gt(c5, h4)) if (gt(c5.source, h4.source) && gt(c5["source-layer"], h4["source-layer"]) && gt(c5.type, h4.type)) {
                  for (f4 in St(c5.layout, h4.layout, r8, u4, null, "setLayoutProperty"), St(c5.paint, h4.paint, r8, u4, null, "setPaintProperty"), gt(c5.filter, h4.filter) || xt(r8, { command: "setFilter", args: [u4, h4.filter] }), gt(c5.minzoom, h4.minzoom) && gt(c5.maxzoom, h4.maxzoom) || xt(r8, { command: "setLayerZoomRange", args: [u4, h4.minzoom, h4.maxzoom] }), c5) Object.prototype.hasOwnProperty.call(c5, f4) && "layout" !== f4 && "paint" !== f4 && "filter" !== f4 && "metadata" !== f4 && "minzoom" !== f4 && "maxzoom" !== f4 && (0 === f4.indexOf("paint.") ? St(c5[f4], h4[f4], r8, u4, f4.slice(6), "setPaintProperty") : gt(c5[f4], h4[f4]) || xt(r8, { command: "setLayerProperty", args: [u4, f4, h4[f4]] }));
                  for (f4 in h4) Object.prototype.hasOwnProperty.call(h4, f4) && !Object.prototype.hasOwnProperty.call(c5, f4) && "layout" !== f4 && "paint" !== f4 && "filter" !== f4 && "metadata" !== f4 && "minzoom" !== f4 && "maxzoom" !== f4 && (0 === f4.indexOf("paint.") ? St(c5[f4], h4[f4], r8, u4, f4.slice(6), "setPaintProperty") : gt(c5[f4], h4[f4]) || xt(r8, { command: "setLayerProperty", args: [u4, f4, h4[f4]] }));
                } else xt(r8, { command: "removeLayer", args: [u4] }), p4 = o7[o7.lastIndexOf(u4) + 1], xt(r8, { command: "addLayer", args: [h4, p4] });
              }(s5, e7.layers, r7);
            } catch (t6) {
              console.warn("Unable to compute style diff:", t6), r7 = [{ command: "setStyle", args: [e7] }];
            }
            return r7;
          }, t4.bB = function(t5) {
            const e7 = [], r7 = t5.id;
            return void 0 === r7 && e7.push({ message: `layers.${r7}: missing required property "id"` }), void 0 === t5.render && e7.push({ message: `layers.${r7}: missing required method "render"` }), t5.renderingMode && "2d" !== t5.renderingMode && "3d" !== t5.renderingMode && e7.push({ message: `layers.${r7}: property "renderingMode" must be either "2d" or "3d"` }), e7;
          }, t4.bC = function t5(e7, r7) {
            if (Array.isArray(e7)) {
              if (!Array.isArray(r7) || e7.length !== r7.length) return false;
              for (let n6 = 0; n6 < e7.length; n6++) if (!t5(e7[n6], r7[n6])) return false;
              return true;
            }
            if ("object" == typeof e7 && null !== e7 && null !== r7) {
              if ("object" != typeof r7) return false;
              if (Object.keys(e7).length !== Object.keys(r7).length) return false;
              for (const n6 in e7) if (!t5(e7[n6], r7[n6])) return false;
              return true;
            }
            return e7 === r7;
          }, t4.bD = L3, t4.bE = O2, t4.bF = class extends Ka {
            constructor(t5, e7) {
              super(t5, e7), this.current = 0;
            }
            set(t5) {
              this.current !== t5 && (this.current = t5, this.gl.uniform1i(this.location, t5));
            }
          }, t4.bG = Ya, t4.bH = class extends Ka {
            constructor(t5, e7) {
              super(t5, e7), this.current = Ja;
            }
            set(t5) {
              if (t5[12] !== this.current[12] || t5[0] !== this.current[0]) return this.current = t5, void this.gl.uniformMatrix4fv(this.location, false, t5);
              for (let e7 = 1; e7 < 16; e7++) if (t5[e7] !== this.current[e7]) {
                this.current = t5, this.gl.uniformMatrix4fv(this.location, false, t5);
                break;
              }
            }
          }, t4.bI = Ha, t4.bJ = class extends Ka {
            constructor(t5, e7) {
              super(t5, e7), this.current = [0, 0, 0];
            }
            set(t5) {
              t5[0] === this.current[0] && t5[1] === this.current[1] && t5[2] === this.current[2] || (this.current = t5, this.gl.uniform3f(this.location, t5[0], t5[1], t5[2]));
            }
          }, t4.bK = class extends Ka {
            constructor(t5, e7) {
              super(t5, e7), this.current = [0, 0];
            }
            set(t5) {
              t5[0] === this.current[0] && t5[1] === this.current[1] || (this.current = t5, this.gl.uniform2f(this.location, t5[0], t5[1]));
            }
          }, t4.bL = x3, t4.bM = function(t5, e7) {
            var r7 = Math.sin(e7), n6 = Math.cos(e7);
            return t5[0] = n6, t5[1] = r7, t5[2] = 0, t5[3] = -r7, t5[4] = n6, t5[5] = 0, t5[6] = 0, t5[7] = 0, t5[8] = 1, t5;
          }, t4.bN = function(t5, e7, r7) {
            var n6 = e7[0], i6 = e7[1], s5 = e7[2];
            return t5[0] = n6 * r7[0] + i6 * r7[3] + s5 * r7[6], t5[1] = n6 * r7[1] + i6 * r7[4] + s5 * r7[7], t5[2] = n6 * r7[2] + i6 * r7[5] + s5 * r7[8], t5;
          }, t4.bO = function(t5, e7, r7, n6, i6, s5, a4) {
            var o7 = 1 / (e7 - r7), l5 = 1 / (n6 - i6), u4 = 1 / (s5 - a4);
            return t5[0] = -2 * o7, t5[1] = 0, t5[2] = 0, t5[3] = 0, t5[4] = 0, t5[5] = -2 * l5, t5[6] = 0, t5[7] = 0, t5[8] = 0, t5[9] = 0, t5[10] = 2 * u4, t5[11] = 0, t5[12] = (e7 + r7) * o7, t5[13] = (i6 + n6) * l5, t5[14] = (a4 + s5) * u4, t5[15] = 1, t5;
          }, t4.bP = class extends Ks {
          }, t4.bQ = Bu, t4.bR = class extends Hs {
          }, t4.bS = qo, t4.bT = function(t5) {
            return t5 <= 1 ? 1 : Math.pow(2, Math.ceil(Math.log(t5) / Math.LN2));
          }, t4.bU = Uo, t4.bV = function(t5, e7, r7) {
            var n6 = e7[0], i6 = e7[1], s5 = e7[2], a4 = r7[3] * n6 + r7[7] * i6 + r7[11] * s5 + r7[15];
            return t5[0] = (r7[0] * n6 + r7[4] * i6 + r7[8] * s5 + r7[12]) / (a4 = a4 || 1), t5[1] = (r7[1] * n6 + r7[5] * i6 + r7[9] * s5 + r7[13]) / a4, t5[2] = (r7[2] * n6 + r7[6] * i6 + r7[10] * s5 + r7[14]) / a4, t5;
          }, t4.bW = class extends Ls {
          }, t4.bX = class extends ra {
          }, t4.bY = function(t5, e7) {
            return t5[0] === e7[0] && t5[1] === e7[1] && t5[2] === e7[2] && t5[3] === e7[3] && t5[4] === e7[4] && t5[5] === e7[5] && t5[6] === e7[6] && t5[7] === e7[7] && t5[8] === e7[8] && t5[9] === e7[9] && t5[10] === e7[10] && t5[11] === e7[11] && t5[12] === e7[12] && t5[13] === e7[13] && t5[14] === e7[14] && t5[15] === e7[15];
          }, t4.bZ = function(t5, e7) {
            var r7 = t5[0], n6 = t5[1], i6 = t5[2], s5 = t5[3], a4 = t5[4], o7 = t5[5], l5 = t5[6], u4 = t5[7], c5 = t5[8], h4 = t5[9], p4 = t5[10], f4 = t5[11], d4 = t5[12], y4 = t5[13], g4 = t5[14], x4 = t5[15], v4 = e7[0], b5 = e7[1], w4 = e7[2], _4 = e7[3], S5 = e7[4], A5 = e7[5], k4 = e7[6], M5 = e7[7], I4 = e7[8], z4 = e7[9], P4 = e7[10], C4 = e7[11], B5 = e7[12], V3 = e7[13], E4 = e7[14], T5 = e7[15];
            return Math.abs(r7 - v4) <= m3 * Math.max(1, Math.abs(r7), Math.abs(v4)) && Math.abs(n6 - b5) <= m3 * Math.max(1, Math.abs(n6), Math.abs(b5)) && Math.abs(i6 - w4) <= m3 * Math.max(1, Math.abs(i6), Math.abs(w4)) && Math.abs(s5 - _4) <= m3 * Math.max(1, Math.abs(s5), Math.abs(_4)) && Math.abs(a4 - S5) <= m3 * Math.max(1, Math.abs(a4), Math.abs(S5)) && Math.abs(o7 - A5) <= m3 * Math.max(1, Math.abs(o7), Math.abs(A5)) && Math.abs(l5 - k4) <= m3 * Math.max(1, Math.abs(l5), Math.abs(k4)) && Math.abs(u4 - M5) <= m3 * Math.max(1, Math.abs(u4), Math.abs(M5)) && Math.abs(c5 - I4) <= m3 * Math.max(1, Math.abs(c5), Math.abs(I4)) && Math.abs(h4 - z4) <= m3 * Math.max(1, Math.abs(h4), Math.abs(z4)) && Math.abs(p4 - P4) <= m3 * Math.max(1, Math.abs(p4), Math.abs(P4)) && Math.abs(f4 - C4) <= m3 * Math.max(1, Math.abs(f4), Math.abs(C4)) && Math.abs(d4 - B5) <= m3 * Math.max(1, Math.abs(d4), Math.abs(B5)) && Math.abs(y4 - V3) <= m3 * Math.max(1, Math.abs(y4), Math.abs(V3)) && Math.abs(g4 - E4) <= m3 * Math.max(1, Math.abs(g4), Math.abs(E4)) && Math.abs(x4 - T5) <= m3 * Math.max(1, Math.abs(x4), Math.abs(T5));
          }, t4.b_ = function(t5, e7) {
            return t5[0] = e7[0], t5[1] = e7[1], t5[2] = e7[2], t5[3] = e7[3], t5[4] = e7[4], t5[5] = e7[5], t5[6] = e7[6], t5[7] = e7[7], t5[8] = e7[8], t5[9] = e7[9], t5[10] = e7[10], t5[11] = e7[11], t5[12] = e7[12], t5[13] = e7[13], t5[14] = e7[14], t5[15] = e7[15], t5;
          }, t4.ba = Il, t4.bb = Al, t4.bc = P3, t4.bd = C3, t4.be = ze, t4.bf = function(t5, e7, r7, n6, i6) {
            return P3(n6, i6, E3((t5 - e7) / (r7 - e7), 0, 1));
          }, t4.bg = z3, t4.bh = function() {
            return new Float64Array(4);
          }, t4.bi = function() {
            return new Float64Array(3);
          }, t4.bj = function(t5, e7, r7, n6) {
            var i6 = [], s5 = [];
            return i6[0] = e7[0] - r7[0], i6[1] = e7[1] - r7[1], i6[2] = e7[2] - r7[2], s5[0] = i6[0] * Math.cos(n6) - i6[1] * Math.sin(n6), s5[1] = i6[0] * Math.sin(n6) + i6[1] * Math.cos(n6), s5[2] = i6[2], t5[0] = s5[0] + r7[0], t5[1] = s5[1] + r7[1], t5[2] = s5[2] + r7[2], t5;
          }, t4.bk = function(t5, e7, r7, n6) {
            var i6 = [], s5 = [];
            return i6[0] = e7[0] - r7[0], i6[1] = e7[1] - r7[1], i6[2] = e7[2] - r7[2], s5[0] = i6[0], s5[1] = i6[1] * Math.cos(n6) - i6[2] * Math.sin(n6), s5[2] = i6[1] * Math.sin(n6) + i6[2] * Math.cos(n6), t5[0] = s5[0] + r7[0], t5[1] = s5[1] + r7[1], t5[2] = s5[2] + r7[2], t5;
          }, t4.bl = function(t5, e7, r7, n6) {
            var i6 = [], s5 = [];
            return i6[0] = e7[0] - r7[0], i6[1] = e7[1] - r7[1], i6[2] = e7[2] - r7[2], s5[0] = i6[2] * Math.sin(n6) + i6[0] * Math.cos(n6), s5[1] = i6[1], s5[2] = i6[2] * Math.cos(n6) - i6[0] * Math.sin(n6), t5[0] = s5[0] + r7[0], t5[1] = s5[1] + r7[1], t5[2] = s5[2] + r7[2], t5;
          }, t4.bm = function(t5, e7, r7) {
            var n6 = Math.sin(r7), i6 = Math.cos(r7), s5 = e7[0], a4 = e7[1], o7 = e7[2], l5 = e7[3], u4 = e7[8], c5 = e7[9], h4 = e7[10], p4 = e7[11];
            return e7 !== t5 && (t5[4] = e7[4], t5[5] = e7[5], t5[6] = e7[6], t5[7] = e7[7], t5[12] = e7[12], t5[13] = e7[13], t5[14] = e7[14], t5[15] = e7[15]), t5[0] = s5 * i6 - u4 * n6, t5[1] = a4 * i6 - c5 * n6, t5[2] = o7 * i6 - h4 * n6, t5[3] = l5 * i6 - p4 * n6, t5[8] = s5 * n6 + u4 * i6, t5[9] = a4 * n6 + c5 * i6, t5[10] = o7 * n6 + h4 * i6, t5[11] = l5 * n6 + p4 * i6, t5;
          }, t4.bn = function(t5, e7) {
            const r7 = z3(t5, 360), n6 = z3(e7, 360), i6 = n6 - r7, s5 = n6 > r7 ? i6 - 360 : i6 + 360;
            return Math.abs(i6) < Math.abs(s5) ? i6 : s5;
          }, t4.bo = function(t5) {
            return t5[0] = 0, t5[1] = 0, t5[2] = 0, t5;
          }, t4.bp = function(t5, e7, r7, n6) {
            const i6 = Math.sqrt(t5 * t5 + e7 * e7), s5 = Math.sqrt(r7 * r7 + n6 * n6);
            t5 /= i6, e7 /= i6, r7 /= s5, n6 /= s5;
            const a4 = Math.acos(t5 * r7 + e7 * n6);
            return -e7 * r7 + t5 * n6 > 0 ? a4 : -a4;
          }, t4.bq = function(t5, e7) {
            return t5[0] * e7[0] + t5[1] * e7[1] + t5[2] * e7[2] + t5[3];
          }, t4.br = Xc, t4.bs = function(t5, e7) {
            const r7 = z3(t5, 2 * Math.PI), n6 = z3(e7, 2 * Math.PI);
            return Math.min(Math.abs(r7 - n6), Math.abs(r7 - n6 + 2 * Math.PI), Math.abs(r7 - n6 - 2 * Math.PI));
          }, t4.bt = function(t5) {
            return Math.hypot(t5[0], t5[1], t5[2]);
          }, t4.bu = function() {
            const t5 = {}, e7 = dt.$version;
            for (const r7 in dt.$root) {
              const n6 = dt.$root[r7];
              if (n6.required) {
                let i6 = null;
                i6 = "version" === r7 ? e7 : "array" === n6.type ? [] : {}, null != i6 && (t5[r7] = i6);
              }
            }
            return t5;
          }, t4.bv = Wi, t4.bw = at, t4.bx = function(t5) {
            t5 = t5.slice();
            const e7 = /* @__PURE__ */ Object.create(null);
            for (let r7 = 0; r7 < t5.length; r7++) e7[t5[r7].id] = t5[r7];
            for (let r7 = 0; r7 < t5.length; r7++) "ref" in t5[r7] && (t5[r7] = mt(t5[r7], e7[t5[r7].ref]));
            return t5;
          }, t4.by = function(t5) {
            if ("custom" === t5.type) return new Gc(t5);
            switch (t5.type) {
              case "background":
                return new jc(t5);
              case "circle":
                return new Eo(t5);
              case "fill":
                return new Ol(t5);
              case "fill-extrusion":
                return new uu(t5);
              case "heatmap":
                return new Go(t5);
              case "hillshade":
                return new Xo(t5);
              case "line":
                return new ku(t5);
              case "raster":
                return new qc(t5);
              case "symbol":
                return new Oc(t5);
            }
          }, t4.bz = D2, t4.c = et2, t4.c0 = (t5) => "circle" === t5.type, t4.c1 = (t5) => "heatmap" === t5.type, t4.c2 = (t5) => "line" === t5.type, t4.c3 = (t5) => "fill" === t5.type, t4.c4 = (t5) => "fill-extrusion" === t5.type, t4.c5 = (t5) => "hillshade" === t5.type, t4.c6 = (t5) => "raster" === t5.type, t4.c7 = (t5) => "background" === t5.type, t4.c8 = (t5) => "custom" === t5.type, t4.c9 = B4, t4.cA = class {
            constructor(t5) {
              this._marks = { start: [t5.url, "start"].join("#"), end: [t5.url, "end"].join("#"), measure: t5.url.toString() }, performance.mark(this._marks.start);
            }
            finish() {
              performance.mark(this._marks.end);
              let t5 = performance.getEntriesByName(this._marks.measure);
              return 0 === t5.length && (performance.measure(this._marks.measure, this._marks.start, this._marks.end), t5 = performance.getEntriesByName(this._marks.measure), performance.clearMarks(this._marks.start), performance.clearMarks(this._marks.end), performance.clearMeasures(this._marks.measure)), t5;
            }
          }, t4.cB = function(t5, r7, n6, i6, s5) {
            return e6(this, void 0, void 0, function* () {
              if (d3()) try {
                return yield K2(t5, r7, n6, i6, s5);
              } catch (t6) {
              }
              return function(t6, e7, r8, n7, i7) {
                const s6 = t6.width, a4 = t6.height;
                X2 && H4 || (X2 = new OffscreenCanvas(s6, a4), H4 = X2.getContext("2d", { willReadFrequently: true })), X2.width = s6, X2.height = a4, H4.drawImage(t6, 0, 0, s6, a4);
                const o7 = H4.getImageData(e7, r8, n7, i7);
                return H4.clearRect(0, 0, s6, a4), o7.data;
              }(t5, r7, n6, i6, s5);
            });
          }, t4.cC = uh, t4.cD = r6, t4.cE = s4, t4.cF = Wl, t4.cG = Ru, t4.cH = Gn, t4.cI = ps, t4.ca = function(t5, e7, r7) {
            const n6 = k3(e7.x - r7.x, e7.y - r7.y), i6 = k3(t5.x - r7.x, t5.y - r7.y);
            var s5, a4;
            return J2(Math.atan2(n6[0] * i6[1] - n6[1] * i6[0], (s5 = n6)[0] * (a4 = i6)[0] + s5[1] * a4[1]));
          }, t4.cb = V2, t4.cc = function(t5, e7) {
            return Q2[e7] && (t5 instanceof MouseEvent || t5 instanceof WheelEvent);
          }, t4.cd = function(t5, e7) {
            return W[e7] && "touches" in t5;
          }, t4.ce = function(t5) {
            return W[t5] || Q2[t5];
          }, t4.cf = function(t5, e7, r7) {
            var n6 = e7[0], i6 = e7[1];
            return t5[0] = r7[0] * n6 + r7[4] * i6 + r7[12], t5[1] = r7[1] * n6 + r7[5] * i6 + r7[13], t5;
          }, t4.cg = function(t5, e7) {
            const { x: r7, y: n6 } = nh.fromLngLat(e7);
            return !(t5 < 0 || t5 > 25 || n6 < 0 || n6 >= 1 || r7 < 0 || r7 >= 1);
          }, t4.ch = function(t5, e7) {
            return t5[0] = e7[0], t5[1] = 0, t5[2] = 0, t5[3] = 0, t5[4] = 0, t5[5] = e7[1], t5[6] = 0, t5[7] = 0, t5[8] = 0, t5[9] = 0, t5[10] = e7[2], t5[11] = 0, t5[12] = 0, t5[13] = 0, t5[14] = 0, t5[15] = 1, t5;
          }, t4.ci = class extends $s {
          }, t4.cj = sp, t4.cl = function(t5) {
            return t5.message === tt;
          }, t4.cm = st, t4.cn = function(t5, e7) {
            rt.REGISTERED_PROTOCOLS[t5] = e7;
          }, t4.co = function(t5) {
            delete rt.REGISTERED_PROTOCOLS[t5];
          }, t4.cp = function(t5, e7) {
            const r7 = {};
            for (let n7 = 0; n7 < t5.length; n7++) {
              const i6 = e7 && e7[t5[n7].id] || li(t5[n7]);
              e7 && (e7[t5[n7].id] = i6);
              let s5 = r7[i6];
              s5 || (s5 = r7[i6] = []), s5.push(t5[n7]);
            }
            const n6 = [];
            for (const t6 in r7) n6.push(r7[t6]);
            return n6;
          }, t4.cq = Zi, t4.cr = ch, t4.cs = ph, t4.ct = Yu, t4.cu = function(e7) {
            e7.bucket.createArrays(), e7.bucket.tilePixelRatio = M4 / (512 * e7.bucket.overscaling), e7.bucket.compareText = {}, e7.bucket.iconsNeedLinear = false;
            const r7 = e7.bucket.layers[0], n6 = r7.layout, i6 = r7._unevaluatedLayout._values, s5 = { layoutIconSize: i6["icon-size"].possiblyEvaluate(new fs(e7.bucket.zoom + 1), e7.canonical), layoutTextSize: i6["text-size"].possiblyEvaluate(new fs(e7.bucket.zoom + 1), e7.canonical), textMaxSize: i6["text-size"].possiblyEvaluate(new fs(18)) };
            if ("composite" === e7.bucket.textSizeData.kind) {
              const { minZoom: t5, maxZoom: r8 } = e7.bucket.textSizeData;
              s5.compositeTextSizes = [i6["text-size"].possiblyEvaluate(new fs(t5), e7.canonical), i6["text-size"].possiblyEvaluate(new fs(r8), e7.canonical)];
            }
            if ("composite" === e7.bucket.iconSizeData.kind) {
              const { minZoom: t5, maxZoom: r8 } = e7.bucket.iconSizeData;
              s5.compositeIconSizes = [i6["icon-size"].possiblyEvaluate(new fs(t5), e7.canonical), i6["icon-size"].possiblyEvaluate(new fs(r8), e7.canonical)];
            }
            const a4 = n6.get("text-line-height") * Lu, o7 = "viewport" !== n6.get("text-rotation-alignment") && "point" !== n6.get("symbol-placement"), l5 = n6.get("text-keep-upright"), u4 = n6.get("text-size");
            for (const i7 of e7.bucket.features) {
              const c5 = n6.get("text-font").evaluate(i7, {}, e7.canonical).join(","), h4 = u4.evaluate(i7, {}, e7.canonical), p4 = s5.layoutTextSize.evaluate(i7, {}, e7.canonical), f4 = s5.layoutIconSize.evaluate(i7, {}, e7.canonical), d4 = { horizontal: {}, vertical: void 0 }, y4 = i7.text;
              let m4, g4 = [0, 0];
              if (y4) {
                const s6 = y4.toString(), u5 = n6.get("text-letter-spacing").evaluate(i7, {}, e7.canonical) * Lu, f5 = es(s6) ? u5 : 0, m5 = n6.get("text-anchor").evaluate(i7, {}, e7.canonical), x5 = Rh(r7, i7, e7.canonical);
                if (!x5) {
                  const t5 = n6.get("text-radial-offset").evaluate(i7, {}, e7.canonical);
                  g4 = t5 ? Dh(m5, [t5 * Lu, Oh]) : n6.get("text-offset").evaluate(i7, {}, e7.canonical).map((t6) => t6 * Lu);
                }
                let v5 = o7 ? "center" : n6.get("text-justify").evaluate(i7, {}, e7.canonical);
                const b5 = "point" === n6.get("symbol-placement") ? n6.get("text-max-width").evaluate(i7, {}, e7.canonical) * Lu : 1 / 0, w4 = () => {
                  e7.bucket.allowVerticalPlacement && ts(s6) && (d4.vertical = ec2(y4, e7.glyphMap, e7.glyphPositions, e7.imagePositions, c5, b5, a4, m5, "left", f5, g4, t4.ah.vertical, true, p4, h4));
                };
                if (!o7 && x5) {
                  const r8 = /* @__PURE__ */ new Set();
                  if ("auto" === v5) for (let t5 = 0; t5 < x5.values.length; t5 += 2) r8.add(jh(x5.values[t5]));
                  else r8.add(v5);
                  let n7 = false;
                  for (const i8 of r8) if (!d4.horizontal[i8]) if (n7) d4.horizontal[i8] = d4.horizontal[0];
                  else {
                    const r9 = ec2(y4, e7.glyphMap, e7.glyphPositions, e7.imagePositions, c5, b5, a4, "center", i8, f5, g4, t4.ah.horizontal, false, p4, h4);
                    r9 && (d4.horizontal[i8] = r9, n7 = 1 === r9.positionedLines.length);
                  }
                  w4();
                } else {
                  "auto" === v5 && (v5 = jh(m5));
                  const r8 = ec2(y4, e7.glyphMap, e7.glyphPositions, e7.imagePositions, c5, b5, a4, m5, v5, f5, g4, t4.ah.horizontal, false, p4, h4);
                  r8 && (d4.horizontal[v5] = r8), w4(), ts(s6) && o7 && l5 && (d4.vertical = ec2(y4, e7.glyphMap, e7.glyphPositions, e7.imagePositions, c5, b5, a4, m5, v5, f5, g4, t4.ah.vertical, false, p4, h4));
                }
              }
              let x4 = false;
              if (i7.icon && i7.icon.name) {
                const t5 = e7.imageMap[i7.icon.name];
                t5 && (m4 = xc(e7.imagePositions[i7.icon.name], n6.get("icon-offset").evaluate(i7, {}, e7.canonical), n6.get("icon-anchor").evaluate(i7, {}, e7.canonical)), x4 = !!t5.sdf, void 0 === e7.bucket.sdfIcons ? e7.bucket.sdfIcons = x4 : e7.bucket.sdfIcons !== x4 && j3("Style sheet warning: Cannot mix SDF and non-SDF icons in one buffer"), (t5.pixelRatio !== e7.bucket.pixelRatio || 0 !== n6.get("icon-rotate").constantOr(1)) && (e7.bucket.iconsNeedLinear = true));
              }
              const v4 = qh(d4.horizontal) || d4.vertical;
              e7.bucket.iconsInText = !!v4 && v4.iconsInText, (v4 || m4) && Nh(e7.bucket, i7, d4, m4, e7.imageMap, s5, p4, f4, g4, x4, e7.canonical, e7.subdivisionGranularity);
            }
            e7.showCollisionBoxes && e7.bucket.generateCollisionDebugBuffers();
          }, t4.cv = vu, t4.cw = Tl, t4.cx = nu, t4.cy = Ql, t4.cz = ju, t4.d = lt, t4.e = F2, t4.f = (t5) => e6(void 0, void 0, void 0, function* () {
            if (0 === t5.byteLength) return createImageBitmap(new ImageData(1, 1));
            const e7 = new Blob([new Uint8Array(t5)], { type: "image/png" });
            try {
              return createImageBitmap(e7);
            } catch (t6) {
              throw new Error(`Could not load image because of ${t6.message}. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported.`);
            }
          }), t4.g = nt, t4.h = (t5) => new Promise((e7, r7) => {
            const n6 = new Image();
            n6.onload = () => {
              e7(n6), URL.revokeObjectURL(n6.src), n6.onload = null, window.requestAnimationFrame(() => {
                n6.src = Z2;
              });
            }, n6.onerror = () => r7(new Error("Could not load image. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported."));
            const i6 = new Blob([new Uint8Array(t5)], { type: "image/png" });
            n6.src = t5.byteLength ? URL.createObjectURL(i6) : Z2;
          }), t4.i = U3, t4.j = (t5, e7) => ot(F2(t5, { type: "json" }), e7), t4.k = pt, t4.l = ht, t4.m = ot, t4.n = (t5, e7) => ot(F2(t5, { type: "arrayBuffer" }), e7), t4.o = function(t5) {
            return new ju(t5).readFields(Uu, []);
          }, t4.p = Ku, t4.q = jo, t4.r = Is, t4.s = Y2, t4.t = Di, t4.u = Qi, t4.v = dt, t4.w = j3, t4.x = Ui, t4.y = Oi, t4.z = function([t5, e7, r7]) {
            return e7 += 90, e7 *= Math.PI / 180, r7 *= Math.PI / 180, { x: t5 * Math.cos(e7) * Math.sin(r7), y: t5 * Math.sin(e7) * Math.sin(r7), z: t5 * Math.cos(r7) };
          };
        });
        define2("worker", ["./shared"], function(e6) {
          "use strict";
          class t4 {
            constructor(e7) {
              this.keyCache = {}, e7 && this.replace(e7);
            }
            replace(e7) {
              this._layerConfigs = {}, this._layers = {}, this.update(e7, []);
            }
            update(t5, o7) {
              for (const o8 of t5) {
                this._layerConfigs[o8.id] = o8;
                const t6 = this._layers[o8.id] = e6.by(o8);
                t6._featureFilter = e6.a7(t6.filter), this.keyCache[o8.id] && delete this.keyCache[o8.id];
              }
              for (const e7 of o7) delete this.keyCache[e7], delete this._layerConfigs[e7], delete this._layers[e7];
              this.familiesBySource = {};
              const i6 = e6.cp(Object.values(this._layerConfigs), this.keyCache);
              for (const e7 of i6) {
                const t6 = e7.map((e8) => this._layers[e8.id]), o8 = t6[0];
                if ("none" === o8.visibility) continue;
                const i7 = o8.source || "";
                let r7 = this.familiesBySource[i7];
                r7 || (r7 = this.familiesBySource[i7] = {});
                const s5 = o8.sourceLayer || "_geojsonTileLayer";
                let n6 = r7[s5];
                n6 || (n6 = r7[s5] = []), n6.push(t6);
              }
            }
          }
          class o6 {
            constructor(t5) {
              const o7 = {}, i6 = [];
              for (const e7 in t5) {
                const r8 = t5[e7], s6 = o7[e7] = {};
                for (const e8 in r8) {
                  const t6 = r8[+e8];
                  if (!t6 || 0 === t6.bitmap.width || 0 === t6.bitmap.height) continue;
                  const o8 = { x: 0, y: 0, w: t6.bitmap.width + 2, h: t6.bitmap.height + 2 };
                  i6.push(o8), s6[e8] = { rect: o8, metrics: t6.metrics };
                }
              }
              const { w: r7, h: s5 } = e6.p(i6), n6 = new e6.q({ width: r7 || 1, height: s5 || 1 });
              for (const i7 in t5) {
                const r8 = t5[i7];
                for (const t6 in r8) {
                  const s6 = r8[+t6];
                  if (!s6 || 0 === s6.bitmap.width || 0 === s6.bitmap.height) continue;
                  const a4 = o7[i7][t6].rect;
                  e6.q.copy(s6.bitmap, n6, { x: 0, y: 0 }, { x: a4.x + 1, y: a4.y + 1 }, s6.bitmap);
                }
              }
              this.image = n6, this.positions = o7;
            }
          }
          e6.cq("GlyphAtlas", o6);
          class i5 {
            constructor(t5) {
              this.tileID = new e6.Y(t5.tileID.overscaledZ, t5.tileID.wrap, t5.tileID.canonical.z, t5.tileID.canonical.x, t5.tileID.canonical.y), this.uid = t5.uid, this.zoom = t5.zoom, this.pixelRatio = t5.pixelRatio, this.tileSize = t5.tileSize, this.source = t5.source, this.overscaling = this.tileID.overscaleFactor(), this.showCollisionBoxes = t5.showCollisionBoxes, this.collectResourceTiming = !!t5.collectResourceTiming, this.returnDependencies = !!t5.returnDependencies, this.promoteId = t5.promoteId, this.inFlightDependencies = [];
            }
            parse(t5, i6, s5, n6, a4) {
              return e6._(this, void 0, void 0, function* () {
                this.status = "parsing", this.data = t5, this.collisionBoxArray = new e6.a5();
                const l5 = new e6.cr(Object.keys(t5.layers).sort()), c5 = new e6.cs(this.tileID, this.promoteId);
                c5.bucketLayerIDs = [];
                const u4 = {}, h4 = { featureIndex: c5, iconDependencies: {}, patternDependencies: {}, glyphDependencies: {}, availableImages: s5, subdivisionGranularity: a4 }, d4 = i6.familiesBySource[this.source];
                for (const o7 in d4) {
                  const i7 = t5.layers[o7];
                  if (!i7) continue;
                  1 === i7.version && e6.w(`Vector tile source "${this.source}" layer "${o7}" does not use vector tile spec v2 and therefore may have some rendering errors.`);
                  const n7 = l5.encode(o7), a5 = [];
                  for (let e7 = 0; e7 < i7.length; e7++) {
                    const t6 = i7.feature(e7), r7 = c5.getId(t6, o7);
                    a5.push({ feature: t6, id: r7, index: e7, sourceLayerIndex: n7 });
                  }
                  for (const t6 of d4[o7]) {
                    const o8 = t6[0];
                    o8.source !== this.source && e6.w(`layer.source = ${o8.source} does not equal this.source = ${this.source}`), o8.minzoom && this.zoom < Math.floor(o8.minzoom) || o8.maxzoom && this.zoom >= o8.maxzoom || "none" !== o8.visibility && (r6(t6, this.zoom, s5), (u4[o8.id] = o8.createBucket({ index: c5.bucketLayerIDs.length, layers: t6, zoom: this.zoom, pixelRatio: this.pixelRatio, overscaling: this.overscaling, collisionBoxArray: this.collisionBoxArray, sourceLayerIndex: n7, sourceID: this.source })).populate(a5, h4, this.tileID.canonical), c5.bucketLayerIDs.push(t6.map((e7) => e7.id)));
                  }
                }
                const f4 = e6.bD(h4.glyphDependencies, (e7) => Object.keys(e7).map(Number));
                this.inFlightDependencies.forEach((e7) => null == e7 ? void 0 : e7.abort()), this.inFlightDependencies = [];
                let g4 = Promise.resolve({});
                if (Object.keys(f4).length) {
                  const e7 = new AbortController();
                  this.inFlightDependencies.push(e7), g4 = n6.sendAsync({ type: "GG", data: { stacks: f4, source: this.source, tileID: this.tileID, type: "glyphs" } }, e7);
                }
                const p4 = Object.keys(h4.iconDependencies);
                let m4 = Promise.resolve({});
                if (p4.length) {
                  const e7 = new AbortController();
                  this.inFlightDependencies.push(e7), m4 = n6.sendAsync({ type: "GI", data: { icons: p4, source: this.source, tileID: this.tileID, type: "icons" } }, e7);
                }
                const y4 = Object.keys(h4.patternDependencies);
                let v4 = Promise.resolve({});
                if (y4.length) {
                  const e7 = new AbortController();
                  this.inFlightDependencies.push(e7), v4 = n6.sendAsync({ type: "GI", data: { icons: y4, source: this.source, tileID: this.tileID, type: "patterns" } }, e7);
                }
                const [w4, x4, _4] = yield Promise.all([g4, m4, v4]), b5 = new o6(w4), M5 = new e6.ct(x4, _4);
                for (const t6 in u4) {
                  const o7 = u4[t6];
                  o7 instanceof e6.a6 ? (r6(o7.layers, this.zoom, s5), e6.cu({ bucket: o7, glyphMap: w4, glyphPositions: b5.positions, imageMap: x4, imagePositions: M5.iconPositions, showCollisionBoxes: this.showCollisionBoxes, canonical: this.tileID.canonical, subdivisionGranularity: h4.subdivisionGranularity })) : o7.hasPattern && (o7 instanceof e6.cv || o7 instanceof e6.cw || o7 instanceof e6.cx) && (r6(o7.layers, this.zoom, s5), o7.addFeatures(h4, this.tileID.canonical, M5.patternPositions));
                }
                return this.status = "done", { buckets: Object.values(u4).filter((e7) => !e7.isEmpty()), featureIndex: c5, collisionBoxArray: this.collisionBoxArray, glyphAtlasImage: b5.image, imageAtlas: M5, glyphMap: this.returnDependencies ? w4 : null, iconMap: this.returnDependencies ? x4 : null, glyphPositions: this.returnDependencies ? b5.positions : null };
              });
            }
          }
          function r6(t5, o7, i6) {
            const r7 = new e6.C(o7);
            for (const e7 of t5) e7.recalculate(r7, i6);
          }
          class s4 {
            constructor(e7, t5, o7) {
              this.actor = e7, this.layerIndex = t5, this.availableImages = o7, this.fetching = {}, this.loading = {}, this.loaded = {};
            }
            loadVectorTile(t5, o7) {
              return e6._(this, void 0, void 0, function* () {
                const i6 = yield e6.n(t5.request, o7);
                try {
                  return { vectorTile: new e6.cy.VectorTile(new e6.cz(i6.data)), rawData: i6.data, cacheControl: i6.cacheControl, expires: i6.expires };
                } catch (e7) {
                  const o8 = new Uint8Array(i6.data);
                  let r7 = `Unable to parse the tile at ${t5.request.url}, `;
                  throw r7 += 31 === o8[0] && 139 === o8[1] ? "please make sure the data is not gzipped and that you have configured the relevant header in the server" : `got error: ${e7.message}`, new Error(r7);
                }
              });
            }
            loadTile(t5) {
              return e6._(this, void 0, void 0, function* () {
                const o7 = t5.uid, r7 = !!(t5 && t5.request && t5.request.collectResourceTiming) && new e6.cA(t5.request), s5 = new i5(t5);
                this.loading[o7] = s5;
                const n6 = new AbortController();
                s5.abort = n6;
                try {
                  const i6 = yield this.loadVectorTile(t5, n6);
                  if (delete this.loading[o7], !i6) return null;
                  const a4 = i6.rawData, l5 = {};
                  i6.expires && (l5.expires = i6.expires), i6.cacheControl && (l5.cacheControl = i6.cacheControl);
                  const c5 = {};
                  if (r7) {
                    const e7 = r7.finish();
                    e7 && (c5.resourceTiming = JSON.parse(JSON.stringify(e7)));
                  }
                  s5.vectorTile = i6.vectorTile;
                  const u4 = s5.parse(i6.vectorTile, this.layerIndex, this.availableImages, this.actor, t5.subdivisionGranularity);
                  this.loaded[o7] = s5, this.fetching[o7] = { rawTileData: a4, cacheControl: l5, resourceTiming: c5 };
                  try {
                    const t6 = yield u4;
                    return e6.e({ rawTileData: a4.slice(0) }, t6, l5, c5);
                  } finally {
                    delete this.fetching[o7];
                  }
                } catch (e7) {
                  throw delete this.loading[o7], s5.status = "done", this.loaded[o7] = s5, e7;
                }
              });
            }
            reloadTile(t5) {
              return e6._(this, void 0, void 0, function* () {
                const o7 = t5.uid;
                if (!this.loaded || !this.loaded[o7]) throw new Error("Should not be trying to reload a tile that was never loaded or has been removed");
                const i6 = this.loaded[o7];
                if (i6.showCollisionBoxes = t5.showCollisionBoxes, "parsing" === i6.status) {
                  const r7 = yield i6.parse(i6.vectorTile, this.layerIndex, this.availableImages, this.actor, t5.subdivisionGranularity);
                  let s5;
                  if (this.fetching[o7]) {
                    const { rawTileData: t6, cacheControl: i7, resourceTiming: n6 } = this.fetching[o7];
                    delete this.fetching[o7], s5 = e6.e({ rawTileData: t6.slice(0) }, r7, i7, n6);
                  } else s5 = r7;
                  return s5;
                }
                if ("done" === i6.status && i6.vectorTile) return i6.parse(i6.vectorTile, this.layerIndex, this.availableImages, this.actor, t5.subdivisionGranularity);
              });
            }
            abortTile(t5) {
              return e6._(this, void 0, void 0, function* () {
                const e7 = this.loading, o7 = t5.uid;
                e7 && e7[o7] && e7[o7].abort && (e7[o7].abort.abort(), delete e7[o7]);
              });
            }
            removeTile(t5) {
              return e6._(this, void 0, void 0, function* () {
                this.loaded && this.loaded[t5.uid] && delete this.loaded[t5.uid];
              });
            }
          }
          class n5 {
            constructor() {
              this.loaded = {};
            }
            loadTile(t5) {
              return e6._(this, void 0, void 0, function* () {
                const { uid: o7, encoding: i6, rawImageData: r7, redFactor: s5, greenFactor: n6, blueFactor: a4, baseShift: l5 } = t5, c5 = r7.width + 2, u4 = r7.height + 2, h4 = e6.b(r7) ? new e6.R({ width: c5, height: u4 }, yield e6.cB(r7, -1, -1, c5, u4)) : r7, d4 = new e6.cC(o7, h4, i6, s5, n6, a4, l5);
                return this.loaded = this.loaded || {}, this.loaded[o7] = d4, d4;
              });
            }
            removeTile(e7) {
              const t5 = this.loaded, o7 = e7.uid;
              t5 && t5[o7] && delete t5[o7];
            }
          }
          var a3, l4, c4 = function() {
            if (l4) return a3;
            function e7(e8, o7) {
              if (0 !== e8.length) {
                t5(e8[0], o7);
                for (var i6 = 1; i6 < e8.length; i6++) t5(e8[i6], !o7);
              }
            }
            function t5(e8, t6) {
              for (var o7 = 0, i6 = 0, r7 = 0, s5 = e8.length, n6 = s5 - 1; r7 < s5; n6 = r7++) {
                var a4 = (e8[r7][0] - e8[n6][0]) * (e8[n6][1] + e8[r7][1]), l5 = o7 + a4;
                i6 += Math.abs(o7) >= Math.abs(a4) ? o7 - l5 + a4 : a4 - l5 + o7, o7 = l5;
              }
              o7 + i6 >= 0 != !!t6 && e8.reverse();
            }
            return l4 = 1, a3 = function t6(o7, i6) {
              var r7, s5 = o7 && o7.type;
              if ("FeatureCollection" === s5) for (r7 = 0; r7 < o7.features.length; r7++) t6(o7.features[r7], i6);
              else if ("GeometryCollection" === s5) for (r7 = 0; r7 < o7.geometries.length; r7++) t6(o7.geometries[r7], i6);
              else if ("Feature" === s5) t6(o7.geometry, i6);
              else if ("Polygon" === s5) e7(o7.coordinates, i6);
              else if ("MultiPolygon" === s5) for (r7 = 0; r7 < o7.coordinates.length; r7++) e7(o7.coordinates[r7], i6);
              return o7;
            };
          }(), u3 = e6.cD(c4);
          const h3 = e6.cy.VectorTileFeature.prototype.toGeoJSON;
          class d3 {
            constructor(t5) {
              this._feature = t5, this.extent = e6.Z, this.type = t5.type, this.properties = t5.tags, "id" in t5 && !isNaN(t5.id) && (this.id = parseInt(t5.id, 10));
            }
            loadGeometry() {
              if (1 === this._feature.type) {
                const t5 = [];
                for (const o7 of this._feature.geometry) t5.push([new e6.P(o7[0], o7[1])]);
                return t5;
              }
              {
                const t5 = [];
                for (const o7 of this._feature.geometry) {
                  const i6 = [];
                  for (const t6 of o7) i6.push(new e6.P(t6[0], t6[1]));
                  t5.push(i6);
                }
                return t5;
              }
            }
            toGeoJSON(e7, t5, o7) {
              return h3.call(this, e7, t5, o7);
            }
          }
          class f3 {
            constructor(t5) {
              this.layers = { _geojsonTileLayer: this }, this.name = "_geojsonTileLayer", this.extent = e6.Z, this.length = t5.length, this._features = t5;
            }
            feature(e7) {
              return new d3(this._features[e7]);
            }
          }
          var g3, p3, m3, y3 = { exports: {} }, v3 = function() {
            if (m3) return y3.exports;
            m3 = 1;
            var t5 = e6.cG(), o7 = function() {
              if (p3) return g3;
              p3 = 1;
              var t6 = e6.cE(), o8 = e6.cF().VectorTileFeature;
              function i7(e7, t7) {
                this.options = t7 || {}, this.features = e7, this.length = e7.length;
              }
              function r8(e7, t7) {
                this.id = "number" == typeof e7.id ? e7.id : void 0, this.type = e7.type, this.rawGeometry = 1 === e7.type ? [e7.geometry] : e7.geometry, this.properties = e7.tags, this.extent = t7 || 4096;
              }
              return g3 = i7, i7.prototype.feature = function(e7) {
                return new r8(this.features[e7], this.options.extent);
              }, r8.prototype.loadGeometry = function() {
                var e7 = this.rawGeometry;
                this.geometry = [];
                for (var o9 = 0; o9 < e7.length; o9++) {
                  for (var i8 = e7[o9], r9 = [], s6 = 0; s6 < i8.length; s6++) r9.push(new t6(i8[s6][0], i8[s6][1]));
                  this.geometry.push(r9);
                }
                return this.geometry;
              }, r8.prototype.bbox = function() {
                this.geometry || this.loadGeometry();
                for (var e7 = this.geometry, t7 = 1 / 0, o9 = -1 / 0, i8 = 1 / 0, r9 = -1 / 0, s6 = 0; s6 < e7.length; s6++) for (var n7 = e7[s6], a5 = 0; a5 < n7.length; a5++) {
                  var l6 = n7[a5];
                  t7 = Math.min(t7, l6.x), o9 = Math.max(o9, l6.x), i8 = Math.min(i8, l6.y), r9 = Math.max(r9, l6.y);
                }
                return [t7, i8, o9, r9];
              }, r8.prototype.toGeoJSON = o8.prototype.toGeoJSON, g3;
            }();
            function i6(e7) {
              var o8 = new t5();
              return function(e8, t6) {
                for (var o9 in e8.layers) t6.writeMessage(3, r7, e8.layers[o9]);
              }(e7, o8), o8.finish();
            }
            function r7(e7, t6) {
              var o8;
              t6.writeVarintField(15, e7.version || 1), t6.writeStringField(1, e7.name || ""), t6.writeVarintField(5, e7.extent || 4096);
              var i7 = { keys: [], values: [], keycache: {}, valuecache: {} };
              for (o8 = 0; o8 < e7.length; o8++) i7.feature = e7.feature(o8), t6.writeMessage(2, s5, i7);
              var r8 = i7.keys;
              for (o8 = 0; o8 < r8.length; o8++) t6.writeStringField(3, r8[o8]);
              var n7 = i7.values;
              for (o8 = 0; o8 < n7.length; o8++) t6.writeMessage(4, u4, n7[o8]);
            }
            function s5(e7, t6) {
              var o8 = e7.feature;
              void 0 !== o8.id && t6.writeVarintField(1, o8.id), t6.writeMessage(2, n6, e7), t6.writeVarintField(3, o8.type), t6.writeMessage(4, c5, o8);
            }
            function n6(e7, t6) {
              var o8 = e7.feature, i7 = e7.keys, r8 = e7.values, s6 = e7.keycache, n7 = e7.valuecache;
              for (var a5 in o8.properties) {
                var l6 = o8.properties[a5], c6 = s6[a5];
                if (null !== l6) {
                  void 0 === c6 && (i7.push(a5), s6[a5] = c6 = i7.length - 1), t6.writeVarint(c6);
                  var u5 = typeof l6;
                  "string" !== u5 && "boolean" !== u5 && "number" !== u5 && (l6 = JSON.stringify(l6));
                  var h4 = u5 + ":" + l6, d4 = n7[h4];
                  void 0 === d4 && (r8.push(l6), n7[h4] = d4 = r8.length - 1), t6.writeVarint(d4);
                }
              }
            }
            function a4(e7, t6) {
              return (t6 << 3) + (7 & e7);
            }
            function l5(e7) {
              return e7 << 1 ^ e7 >> 31;
            }
            function c5(e7, t6) {
              for (var o8 = e7.loadGeometry(), i7 = e7.type, r8 = 0, s6 = 0, n7 = o8.length, c6 = 0; c6 < n7; c6++) {
                var u5 = o8[c6], h4 = 1;
                1 === i7 && (h4 = u5.length), t6.writeVarint(a4(1, h4));
                for (var d4 = 3 === i7 ? u5.length - 1 : u5.length, f4 = 0; f4 < d4; f4++) {
                  1 === f4 && 1 !== i7 && t6.writeVarint(a4(2, d4 - 1));
                  var g4 = u5[f4].x - r8, p4 = u5[f4].y - s6;
                  t6.writeVarint(l5(g4)), t6.writeVarint(l5(p4)), r8 += g4, s6 += p4;
                }
                3 === i7 && t6.writeVarint(a4(7, 1));
              }
            }
            function u4(e7, t6) {
              var o8 = typeof e7;
              "string" === o8 ? t6.writeStringField(1, e7) : "boolean" === o8 ? t6.writeBooleanField(7, e7) : "number" === o8 && (e7 % 1 != 0 ? t6.writeDoubleField(3, e7) : e7 < 0 ? t6.writeSVarintField(6, e7) : t6.writeVarintField(5, e7));
            }
            return y3.exports = i6, y3.exports.fromVectorTileJs = i6, y3.exports.fromGeojsonVt = function(e7, t6) {
              t6 = t6 || {};
              var r8 = {};
              for (var s6 in e7) r8[s6] = new o7(e7[s6].features, t6), r8[s6].name = s6, r8[s6].version = t6.version, r8[s6].extent = t6.extent;
              return i6({ layers: r8 });
            }, y3.exports.GeoJSONWrapper = o7, y3.exports;
          }(), w3 = e6.cD(v3);
          const x3 = { minZoom: 0, maxZoom: 16, minPoints: 2, radius: 40, extent: 512, nodeSize: 64, log: false, generateId: false, reduce: null, map: (e7) => e7 }, _3 = Math.fround || (b4 = new Float32Array(1), (e7) => (b4[0] = +e7, b4[0]));
          var b4;
          const M4 = 3, S4 = 5, I3 = 6;
          class P3 {
            constructor(e7) {
              this.options = Object.assign(Object.create(x3), e7), this.trees = new Array(this.options.maxZoom + 1), this.stride = this.options.reduce ? 7 : 6, this.clusterProps = [];
            }
            load(e7) {
              const { log: t5, minZoom: o7, maxZoom: i6 } = this.options;
              t5 && console.time("total time");
              const r7 = `prepare ${e7.length} points`;
              t5 && console.time(r7), this.points = e7;
              const s5 = [];
              for (let t6 = 0; t6 < e7.length; t6++) {
                const o8 = e7[t6];
                if (!o8.geometry) continue;
                const [i7, r8] = o8.geometry.coordinates, n7 = _3(D2(i7)), a4 = _3(C3(r8));
                s5.push(n7, a4, 1 / 0, t6, -1, 1), this.options.reduce && s5.push(0);
              }
              let n6 = this.trees[i6 + 1] = this._createTree(s5);
              t5 && console.timeEnd(r7);
              for (let e8 = i6; e8 >= o7; e8--) {
                const o8 = +Date.now();
                n6 = this.trees[e8] = this._createTree(this._cluster(n6, e8)), t5 && console.log("z%d: %d clusters in %dms", e8, n6.numItems, +Date.now() - o8);
              }
              return t5 && console.timeEnd("total time"), this;
            }
            getClusters(e7, t5) {
              let o7 = ((e7[0] + 180) % 360 + 360) % 360 - 180;
              const i6 = Math.max(-90, Math.min(90, e7[1]));
              let r7 = 180 === e7[2] ? 180 : ((e7[2] + 180) % 360 + 360) % 360 - 180;
              const s5 = Math.max(-90, Math.min(90, e7[3]));
              if (e7[2] - e7[0] >= 360) o7 = -180, r7 = 180;
              else if (o7 > r7) {
                const e8 = this.getClusters([o7, i6, 180, s5], t5), n7 = this.getClusters([-180, i6, r7, s5], t5);
                return e8.concat(n7);
              }
              const n6 = this.trees[this._limitZoom(t5)], a4 = n6.range(D2(o7), C3(s5), D2(r7), C3(i6)), l5 = n6.data, c5 = [];
              for (const e8 of a4) {
                const t6 = this.stride * e8;
                c5.push(l5[t6 + S4] > 1 ? k3(l5, t6, this.clusterProps) : this.points[l5[t6 + M4]]);
              }
              return c5;
            }
            getChildren(e7) {
              const t5 = this._getOriginId(e7), o7 = this._getOriginZoom(e7), i6 = "No cluster with the specified id.", r7 = this.trees[o7];
              if (!r7) throw new Error(i6);
              const s5 = r7.data;
              if (t5 * this.stride >= s5.length) throw new Error(i6);
              const n6 = this.options.radius / (this.options.extent * Math.pow(2, o7 - 1)), a4 = r7.within(s5[t5 * this.stride], s5[t5 * this.stride + 1], n6), l5 = [];
              for (const t6 of a4) {
                const o8 = t6 * this.stride;
                s5[o8 + 4] === e7 && l5.push(s5[o8 + S4] > 1 ? k3(s5, o8, this.clusterProps) : this.points[s5[o8 + M4]]);
              }
              if (0 === l5.length) throw new Error(i6);
              return l5;
            }
            getLeaves(e7, t5, o7) {
              const i6 = [];
              return this._appendLeaves(i6, e7, t5 = t5 || 10, o7 = o7 || 0, 0), i6;
            }
            getTile(e7, t5, o7) {
              const i6 = this.trees[this._limitZoom(e7)], r7 = Math.pow(2, e7), { extent: s5, radius: n6 } = this.options, a4 = n6 / s5, l5 = (o7 - a4) / r7, c5 = (o7 + 1 + a4) / r7, u4 = { features: [] };
              return this._addTileFeatures(i6.range((t5 - a4) / r7, l5, (t5 + 1 + a4) / r7, c5), i6.data, t5, o7, r7, u4), 0 === t5 && this._addTileFeatures(i6.range(1 - a4 / r7, l5, 1, c5), i6.data, r7, o7, r7, u4), t5 === r7 - 1 && this._addTileFeatures(i6.range(0, l5, a4 / r7, c5), i6.data, -1, o7, r7, u4), u4.features.length ? u4 : null;
            }
            getClusterExpansionZoom(e7) {
              let t5 = this._getOriginZoom(e7) - 1;
              for (; t5 <= this.options.maxZoom; ) {
                const o7 = this.getChildren(e7);
                if (t5++, 1 !== o7.length) break;
                e7 = o7[0].properties.cluster_id;
              }
              return t5;
            }
            _appendLeaves(e7, t5, o7, i6, r7) {
              const s5 = this.getChildren(t5);
              for (const t6 of s5) {
                const s6 = t6.properties;
                if (s6 && s6.cluster ? r7 + s6.point_count <= i6 ? r7 += s6.point_count : r7 = this._appendLeaves(e7, s6.cluster_id, o7, i6, r7) : r7 < i6 ? r7++ : e7.push(t6), e7.length === o7) break;
              }
              return r7;
            }
            _createTree(t5) {
              const o7 = new e6.aC(t5.length / this.stride | 0, this.options.nodeSize, Float32Array);
              for (let e7 = 0; e7 < t5.length; e7 += this.stride) o7.add(t5[e7], t5[e7 + 1]);
              return o7.finish(), o7.data = t5, o7;
            }
            _addTileFeatures(e7, t5, o7, i6, r7, s5) {
              for (const n6 of e7) {
                const e8 = n6 * this.stride, a4 = t5[e8 + S4] > 1;
                let l5, c5, u4;
                if (a4) l5 = T4(t5, e8, this.clusterProps), c5 = t5[e8], u4 = t5[e8 + 1];
                else {
                  const o8 = this.points[t5[e8 + M4]];
                  l5 = o8.properties;
                  const [i7, r8] = o8.geometry.coordinates;
                  c5 = D2(i7), u4 = C3(r8);
                }
                const h4 = { type: 1, geometry: [[Math.round(this.options.extent * (c5 * r7 - o7)), Math.round(this.options.extent * (u4 * r7 - i6))]], tags: l5 };
                let d4;
                d4 = a4 || this.options.generateId ? t5[e8 + M4] : this.points[t5[e8 + M4]].id, void 0 !== d4 && (h4.id = d4), s5.features.push(h4);
              }
            }
            _limitZoom(e7) {
              return Math.max(this.options.minZoom, Math.min(Math.floor(+e7), this.options.maxZoom + 1));
            }
            _cluster(e7, t5) {
              const { radius: o7, extent: i6, reduce: r7, minPoints: s5 } = this.options, n6 = o7 / (i6 * Math.pow(2, t5)), a4 = e7.data, l5 = [], c5 = this.stride;
              for (let o8 = 0; o8 < a4.length; o8 += c5) {
                if (a4[o8 + 2] <= t5) continue;
                a4[o8 + 2] = t5;
                const i7 = a4[o8], u4 = a4[o8 + 1], h4 = e7.within(a4[o8], a4[o8 + 1], n6), d4 = a4[o8 + S4];
                let f4 = d4;
                for (const e8 of h4) {
                  const o9 = e8 * c5;
                  a4[o9 + 2] > t5 && (f4 += a4[o9 + S4]);
                }
                if (f4 > d4 && f4 >= s5) {
                  let e8, s6 = i7 * d4, n7 = u4 * d4, g4 = -1;
                  const p4 = ((o8 / c5 | 0) << 5) + (t5 + 1) + this.points.length;
                  for (const i8 of h4) {
                    const l6 = i8 * c5;
                    if (a4[l6 + 2] <= t5) continue;
                    a4[l6 + 2] = t5;
                    const u5 = a4[l6 + S4];
                    s6 += a4[l6] * u5, n7 += a4[l6 + 1] * u5, a4[l6 + 4] = p4, r7 && (e8 || (e8 = this._map(a4, o8, true), g4 = this.clusterProps.length, this.clusterProps.push(e8)), r7(e8, this._map(a4, l6)));
                  }
                  a4[o8 + 4] = p4, l5.push(s6 / f4, n7 / f4, 1 / 0, p4, -1, f4), r7 && l5.push(g4);
                } else {
                  for (let e8 = 0; e8 < c5; e8++) l5.push(a4[o8 + e8]);
                  if (f4 > 1) for (const e8 of h4) {
                    const o9 = e8 * c5;
                    if (!(a4[o9 + 2] <= t5)) {
                      a4[o9 + 2] = t5;
                      for (let e9 = 0; e9 < c5; e9++) l5.push(a4[o9 + e9]);
                    }
                  }
                }
              }
              return l5;
            }
            _getOriginId(e7) {
              return e7 - this.points.length >> 5;
            }
            _getOriginZoom(e7) {
              return (e7 - this.points.length) % 32;
            }
            _map(e7, t5, o7) {
              if (e7[t5 + S4] > 1) {
                const i7 = this.clusterProps[e7[t5 + I3]];
                return o7 ? Object.assign({}, i7) : i7;
              }
              const i6 = this.points[e7[t5 + M4]].properties, r7 = this.options.map(i6);
              return o7 && r7 === i6 ? Object.assign({}, r7) : r7;
            }
          }
          function k3(e7, t5, o7) {
            return { type: "Feature", id: e7[t5 + M4], properties: T4(e7, t5, o7), geometry: { type: "Point", coordinates: [(i6 = e7[t5], 360 * (i6 - 0.5)), O2(e7[t5 + 1])] } };
            var i6;
          }
          function T4(e7, t5, o7) {
            const i6 = e7[t5 + S4], r7 = i6 >= 1e4 ? `${Math.round(i6 / 1e3)}k` : i6 >= 1e3 ? Math.round(i6 / 100) / 10 + "k" : i6, s5 = e7[t5 + I3], n6 = -1 === s5 ? {} : Object.assign({}, o7[s5]);
            return Object.assign(n6, { cluster: true, cluster_id: e7[t5 + M4], point_count: i6, point_count_abbreviated: r7 });
          }
          function D2(e7) {
            return e7 / 360 + 0.5;
          }
          function C3(e7) {
            const t5 = Math.sin(e7 * Math.PI / 180), o7 = 0.5 - 0.25 * Math.log((1 + t5) / (1 - t5)) / Math.PI;
            return o7 < 0 ? 0 : o7 > 1 ? 1 : o7;
          }
          function O2(e7) {
            const t5 = (180 - 360 * e7) * Math.PI / 180;
            return 360 * Math.atan(Math.exp(t5)) / Math.PI - 90;
          }
          function L3(e7, t5, o7, i6) {
            let r7 = i6;
            const s5 = t5 + (o7 - t5 >> 1);
            let n6, a4 = o7 - t5;
            const l5 = e7[t5], c5 = e7[t5 + 1], u4 = e7[o7], h4 = e7[o7 + 1];
            for (let i7 = t5 + 3; i7 < o7; i7 += 3) {
              const t6 = F2(e7[i7], e7[i7 + 1], l5, c5, u4, h4);
              if (t6 > r7) n6 = i7, r7 = t6;
              else if (t6 === r7) {
                const e8 = Math.abs(i7 - s5);
                e8 < a4 && (n6 = i7, a4 = e8);
              }
            }
            r7 > i6 && (n6 - t5 > 3 && L3(e7, t5, n6, i6), e7[n6 + 2] = r7, o7 - n6 > 3 && L3(e7, n6, o7, i6));
          }
          function F2(e7, t5, o7, i6, r7, s5) {
            let n6 = r7 - o7, a4 = s5 - i6;
            if (0 !== n6 || 0 !== a4) {
              const l5 = ((e7 - o7) * n6 + (t5 - i6) * a4) / (n6 * n6 + a4 * a4);
              l5 > 1 ? (o7 = r7, i6 = s5) : l5 > 0 && (o7 += n6 * l5, i6 += a4 * l5);
            }
            return n6 = e7 - o7, a4 = t5 - i6, n6 * n6 + a4 * a4;
          }
          function G2(e7, t5, o7, i6) {
            const r7 = { id: null == e7 ? null : e7, type: t5, geometry: o7, tags: i6, minX: 1 / 0, minY: 1 / 0, maxX: -1 / 0, maxY: -1 / 0 };
            if ("Point" === t5 || "MultiPoint" === t5 || "LineString" === t5) z3(r7, o7);
            else if ("Polygon" === t5) z3(r7, o7[0]);
            else if ("MultiLineString" === t5) for (const e8 of o7) z3(r7, e8);
            else if ("MultiPolygon" === t5) for (const e8 of o7) z3(r7, e8[0]);
            return r7;
          }
          function z3(e7, t5) {
            for (let o7 = 0; o7 < t5.length; o7 += 3) e7.minX = Math.min(e7.minX, t5[o7]), e7.minY = Math.min(e7.minY, t5[o7 + 1]), e7.maxX = Math.max(e7.maxX, t5[o7]), e7.maxY = Math.max(e7.maxY, t5[o7 + 1]);
          }
          function A4(e7, t5, o7, i6) {
            if (!t5.geometry) return;
            const r7 = t5.geometry.coordinates;
            if (r7 && 0 === r7.length) return;
            const s5 = t5.geometry.type, n6 = Math.pow(o7.tolerance / ((1 << o7.maxZoom) * o7.extent), 2);
            let a4 = [], l5 = t5.id;
            if (o7.promoteId ? l5 = t5.properties[o7.promoteId] : o7.generateId && (l5 = i6 || 0), "Point" === s5) j3(r7, a4);
            else if ("MultiPoint" === s5) for (const e8 of r7) j3(e8, a4);
            else if ("LineString" === s5) E3(r7, a4, n6, false);
            else if ("MultiLineString" === s5) {
              if (o7.lineMetrics) {
                for (const o8 of r7) a4 = [], E3(o8, a4, n6, false), e7.push(G2(l5, "LineString", a4, t5.properties));
                return;
              }
              Z2(r7, a4, n6, false);
            } else if ("Polygon" === s5) Z2(r7, a4, n6, true);
            else {
              if ("MultiPolygon" !== s5) {
                if ("GeometryCollection" === s5) {
                  for (const r8 of t5.geometry.geometries) A4(e7, { id: l5, geometry: r8, properties: t5.properties }, o7, i6);
                  return;
                }
                throw new Error("Input data is not a valid GeoJSON object.");
              }
              for (const e8 of r7) {
                const t6 = [];
                Z2(e8, t6, n6, true), a4.push(t6);
              }
            }
            e7.push(G2(l5, s5, a4, t5.properties));
          }
          function j3(e7, t5) {
            t5.push(N3(e7[0]), J2(e7[1]), 0);
          }
          function E3(e7, t5, o7, i6) {
            let r7, s5, n6 = 0;
            for (let o8 = 0; o8 < e7.length; o8++) {
              const a5 = N3(e7[o8][0]), l5 = J2(e7[o8][1]);
              t5.push(a5, l5, 0), o8 > 0 && (n6 += i6 ? (r7 * l5 - a5 * s5) / 2 : Math.sqrt(Math.pow(a5 - r7, 2) + Math.pow(l5 - s5, 2))), r7 = a5, s5 = l5;
            }
            const a4 = t5.length - 3;
            t5[2] = 1, L3(t5, 0, a4, o7), t5[a4 + 2] = 1, t5.size = Math.abs(n6), t5.start = 0, t5.end = t5.size;
          }
          function Z2(e7, t5, o7, i6) {
            for (let r7 = 0; r7 < e7.length; r7++) {
              const s5 = [];
              E3(e7[r7], s5, o7, i6), t5.push(s5);
            }
          }
          function N3(e7) {
            return e7 / 360 + 0.5;
          }
          function J2(e7) {
            const t5 = Math.sin(e7 * Math.PI / 180), o7 = 0.5 - 0.25 * Math.log((1 + t5) / (1 - t5)) / Math.PI;
            return o7 < 0 ? 0 : o7 > 1 ? 1 : o7;
          }
          function W(e7, t5, o7, i6, r7, s5, n6, a4) {
            if (i6 /= t5, s5 >= (o7 /= t5) && n6 < i6) return e7;
            if (n6 < o7 || s5 >= i6) return null;
            const l5 = [];
            for (const t6 of e7) {
              const e8 = t6.geometry;
              let s6 = t6.type;
              const n7 = 0 === r7 ? t6.minX : t6.minY, c5 = 0 === r7 ? t6.maxX : t6.maxY;
              if (n7 >= o7 && c5 < i6) {
                l5.push(t6);
                continue;
              }
              if (c5 < o7 || n7 >= i6) continue;
              let u4 = [];
              if ("Point" === s6 || "MultiPoint" === s6) R4(e8, u4, o7, i6, r7);
              else if ("LineString" === s6) Y2(e8, u4, o7, i6, r7, false, a4.lineMetrics);
              else if ("MultiLineString" === s6) H4(e8, u4, o7, i6, r7, false);
              else if ("Polygon" === s6) H4(e8, u4, o7, i6, r7, true);
              else if ("MultiPolygon" === s6) for (const t7 of e8) {
                const e9 = [];
                H4(t7, e9, o7, i6, r7, true), e9.length && u4.push(e9);
              }
              if (u4.length) {
                if (a4.lineMetrics && "LineString" === s6) {
                  for (const e9 of u4) l5.push(G2(t6.id, s6, e9, t6.tags));
                  continue;
                }
                "LineString" !== s6 && "MultiLineString" !== s6 || (1 === u4.length ? (s6 = "LineString", u4 = u4[0]) : s6 = "MultiLineString"), "Point" !== s6 && "MultiPoint" !== s6 || (s6 = 3 === u4.length ? "Point" : "MultiPoint"), l5.push(G2(t6.id, s6, u4, t6.tags));
              }
            }
            return l5.length ? l5 : null;
          }
          function R4(e7, t5, o7, i6, r7) {
            for (let s5 = 0; s5 < e7.length; s5 += 3) {
              const n6 = e7[s5 + r7];
              n6 >= o7 && n6 <= i6 && V2(t5, e7[s5], e7[s5 + 1], e7[s5 + 2]);
            }
          }
          function Y2(e7, t5, o7, i6, r7, s5, n6) {
            let a4 = q2(e7);
            const l5 = 0 === r7 ? X2 : B4;
            let c5, u4, h4 = e7.start;
            for (let d5 = 0; d5 < e7.length - 3; d5 += 3) {
              const f5 = e7[d5], g5 = e7[d5 + 1], p5 = e7[d5 + 2], m4 = e7[d5 + 3], y4 = e7[d5 + 4], v4 = 0 === r7 ? f5 : g5, w4 = 0 === r7 ? m4 : y4;
              let x4 = false;
              n6 && (c5 = Math.sqrt(Math.pow(f5 - m4, 2) + Math.pow(g5 - y4, 2))), v4 < o7 ? w4 > o7 && (u4 = l5(a4, f5, g5, m4, y4, o7), n6 && (a4.start = h4 + c5 * u4)) : v4 > i6 ? w4 < i6 && (u4 = l5(a4, f5, g5, m4, y4, i6), n6 && (a4.start = h4 + c5 * u4)) : V2(a4, f5, g5, p5), w4 < o7 && v4 >= o7 && (u4 = l5(a4, f5, g5, m4, y4, o7), x4 = true), w4 > i6 && v4 <= i6 && (u4 = l5(a4, f5, g5, m4, y4, i6), x4 = true), !s5 && x4 && (n6 && (a4.end = h4 + c5 * u4), t5.push(a4), a4 = q2(e7)), n6 && (h4 += c5);
            }
            let d4 = e7.length - 3;
            const f4 = e7[d4], g4 = e7[d4 + 1], p4 = 0 === r7 ? f4 : g4;
            p4 >= o7 && p4 <= i6 && V2(a4, f4, g4, e7[d4 + 2]), d4 = a4.length - 3, s5 && d4 >= 3 && (a4[d4] !== a4[0] || a4[d4 + 1] !== a4[1]) && V2(a4, a4[0], a4[1], a4[2]), a4.length && t5.push(a4);
          }
          function q2(e7) {
            const t5 = [];
            return t5.size = e7.size, t5.start = e7.start, t5.end = e7.end, t5;
          }
          function H4(e7, t5, o7, i6, r7, s5) {
            for (const n6 of e7) Y2(n6, t5, o7, i6, r7, s5, false);
          }
          function V2(e7, t5, o7, i6) {
            e7.push(t5, o7, i6);
          }
          function X2(e7, t5, o7, i6, r7, s5) {
            const n6 = (s5 - t5) / (i6 - t5);
            return V2(e7, s5, o7 + (r7 - o7) * n6, 1), n6;
          }
          function B4(e7, t5, o7, i6, r7, s5) {
            const n6 = (s5 - o7) / (r7 - o7);
            return V2(e7, t5 + (i6 - t5) * n6, s5, 1), n6;
          }
          function $2(e7, t5) {
            const o7 = [];
            for (let i6 = 0; i6 < e7.length; i6++) {
              const r7 = e7[i6], s5 = r7.type;
              let n6;
              if ("Point" === s5 || "MultiPoint" === s5 || "LineString" === s5) n6 = U3(r7.geometry, t5);
              else if ("MultiLineString" === s5 || "Polygon" === s5) {
                n6 = [];
                for (const e8 of r7.geometry) n6.push(U3(e8, t5));
              } else if ("MultiPolygon" === s5) {
                n6 = [];
                for (const e8 of r7.geometry) {
                  const o8 = [];
                  for (const i7 of e8) o8.push(U3(i7, t5));
                  n6.push(o8);
                }
              }
              o7.push(G2(r7.id, s5, n6, r7.tags));
            }
            return o7;
          }
          function U3(e7, t5) {
            const o7 = [];
            o7.size = e7.size, void 0 !== e7.start && (o7.start = e7.start, o7.end = e7.end);
            for (let i6 = 0; i6 < e7.length; i6 += 3) o7.push(e7[i6] + t5, e7[i6 + 1], e7[i6 + 2]);
            return o7;
          }
          function K2(e7, t5) {
            if (e7.transformed) return e7;
            const o7 = 1 << e7.z, i6 = e7.x, r7 = e7.y;
            for (const s5 of e7.features) {
              const e8 = s5.geometry, n6 = s5.type;
              if (s5.geometry = [], 1 === n6) for (let n7 = 0; n7 < e8.length; n7 += 2) s5.geometry.push(Q2(e8[n7], e8[n7 + 1], t5, o7, i6, r7));
              else for (let n7 = 0; n7 < e8.length; n7++) {
                const a4 = [];
                for (let s6 = 0; s6 < e8[n7].length; s6 += 2) a4.push(Q2(e8[n7][s6], e8[n7][s6 + 1], t5, o7, i6, r7));
                s5.geometry.push(a4);
              }
            }
            return e7.transformed = true, e7;
          }
          function Q2(e7, t5, o7, i6, r7, s5) {
            return [Math.round(o7 * (e7 * i6 - r7)), Math.round(o7 * (t5 * i6 - s5))];
          }
          function ee(e7, t5, o7, i6, r7) {
            const s5 = t5 === r7.maxZoom ? 0 : r7.tolerance / ((1 << t5) * r7.extent), n6 = { features: [], numPoints: 0, numSimplified: 0, numFeatures: e7.length, source: null, x: o7, y: i6, z: t5, transformed: false, minX: 2, minY: 1, maxX: -1, maxY: 0 };
            for (const t6 of e7) te(n6, t6, s5, r7);
            return n6;
          }
          function te(e7, t5, o7, i6) {
            const r7 = t5.geometry, s5 = t5.type, n6 = [];
            if (e7.minX = Math.min(e7.minX, t5.minX), e7.minY = Math.min(e7.minY, t5.minY), e7.maxX = Math.max(e7.maxX, t5.maxX), e7.maxY = Math.max(e7.maxY, t5.maxY), "Point" === s5 || "MultiPoint" === s5) for (let t6 = 0; t6 < r7.length; t6 += 3) n6.push(r7[t6], r7[t6 + 1]), e7.numPoints++, e7.numSimplified++;
            else if ("LineString" === s5) oe(n6, r7, e7, o7, false, false);
            else if ("MultiLineString" === s5 || "Polygon" === s5) for (let t6 = 0; t6 < r7.length; t6++) oe(n6, r7[t6], e7, o7, "Polygon" === s5, 0 === t6);
            else if ("MultiPolygon" === s5) for (let t6 = 0; t6 < r7.length; t6++) {
              const i7 = r7[t6];
              for (let t7 = 0; t7 < i7.length; t7++) oe(n6, i7[t7], e7, o7, true, 0 === t7);
            }
            if (n6.length) {
              let o8 = t5.tags || null;
              if ("LineString" === s5 && i6.lineMetrics) {
                o8 = {};
                for (const e8 in t5.tags) o8[e8] = t5.tags[e8];
                o8.mapbox_clip_start = r7.start / r7.size, o8.mapbox_clip_end = r7.end / r7.size;
              }
              const a4 = { geometry: n6, type: "Polygon" === s5 || "MultiPolygon" === s5 ? 3 : "LineString" === s5 || "MultiLineString" === s5 ? 2 : 1, tags: o8 };
              null !== t5.id && (a4.id = t5.id), e7.features.push(a4);
            }
          }
          function oe(e7, t5, o7, i6, r7, s5) {
            const n6 = i6 * i6;
            if (i6 > 0 && t5.size < (r7 ? n6 : i6)) return void (o7.numPoints += t5.length / 3);
            const a4 = [];
            for (let e8 = 0; e8 < t5.length; e8 += 3) (0 === i6 || t5[e8 + 2] > n6) && (o7.numSimplified++, a4.push(t5[e8], t5[e8 + 1])), o7.numPoints++;
            r7 && function(e8, t6) {
              let o8 = 0;
              for (let t7 = 0, i7 = e8.length, r8 = i7 - 2; t7 < i7; r8 = t7, t7 += 2) o8 += (e8[t7] - e8[r8]) * (e8[t7 + 1] + e8[r8 + 1]);
              if (o8 > 0 === t6) for (let t7 = 0, o9 = e8.length; t7 < o9 / 2; t7 += 2) {
                const i7 = e8[t7], r8 = e8[t7 + 1];
                e8[t7] = e8[o9 - 2 - t7], e8[t7 + 1] = e8[o9 - 1 - t7], e8[o9 - 2 - t7] = i7, e8[o9 - 1 - t7] = r8;
              }
            }(a4, s5), e7.push(a4);
          }
          const ie2 = { maxZoom: 14, indexMaxZoom: 5, indexMaxPoints: 1e5, tolerance: 3, extent: 4096, buffer: 64, lineMetrics: false, promoteId: null, generateId: false, debug: 0 };
          class re2 {
            constructor(e7, t5) {
              const o7 = (t5 = this.options = function(e8, t6) {
                for (const o8 in t6) e8[o8] = t6[o8];
                return e8;
              }(Object.create(ie2), t5)).debug;
              if (o7 && console.time("preprocess data"), t5.maxZoom < 0 || t5.maxZoom > 24) throw new Error("maxZoom should be in the 0-24 range");
              if (t5.promoteId && t5.generateId) throw new Error("promoteId and generateId cannot be used together.");
              let i6 = function(e8, t6) {
                const o8 = [];
                if ("FeatureCollection" === e8.type) for (let i7 = 0; i7 < e8.features.length; i7++) A4(o8, e8.features[i7], t6, i7);
                else A4(o8, "Feature" === e8.type ? e8 : { geometry: e8 }, t6);
                return o8;
              }(e7, t5);
              this.tiles = {}, this.tileCoords = [], o7 && (console.timeEnd("preprocess data"), console.log("index: maxZoom: %d, maxPoints: %d", t5.indexMaxZoom, t5.indexMaxPoints), console.time("generate tiles"), this.stats = {}, this.total = 0), i6 = function(e8, t6) {
                const o8 = t6.buffer / t6.extent;
                let i7 = e8;
                const r7 = W(e8, 1, -1 - o8, o8, 0, -1, 2, t6), s5 = W(e8, 1, 1 - o8, 2 + o8, 0, -1, 2, t6);
                return (r7 || s5) && (i7 = W(e8, 1, -o8, 1 + o8, 0, -1, 2, t6) || [], r7 && (i7 = $2(r7, 1).concat(i7)), s5 && (i7 = i7.concat($2(s5, -1)))), i7;
              }(i6, t5), i6.length && this.splitTile(i6, 0, 0, 0), o7 && (i6.length && console.log("features: %d, points: %d", this.tiles[0].numFeatures, this.tiles[0].numPoints), console.timeEnd("generate tiles"), console.log("tiles generated:", this.total, JSON.stringify(this.stats)));
            }
            splitTile(e7, t5, o7, i6, r7, s5, n6) {
              const a4 = [e7, t5, o7, i6], l5 = this.options, c5 = l5.debug;
              for (; a4.length; ) {
                i6 = a4.pop(), o7 = a4.pop(), t5 = a4.pop(), e7 = a4.pop();
                const u4 = 1 << t5, h4 = se(t5, o7, i6);
                let d4 = this.tiles[h4];
                if (!d4 && (c5 > 1 && console.time("creation"), d4 = this.tiles[h4] = ee(e7, t5, o7, i6, l5), this.tileCoords.push({ z: t5, x: o7, y: i6 }), c5)) {
                  c5 > 1 && (console.log("tile z%d-%d-%d (features: %d, points: %d, simplified: %d)", t5, o7, i6, d4.numFeatures, d4.numPoints, d4.numSimplified), console.timeEnd("creation"));
                  const e8 = `z${t5}`;
                  this.stats[e8] = (this.stats[e8] || 0) + 1, this.total++;
                }
                if (d4.source = e7, null == r7) {
                  if (t5 === l5.indexMaxZoom || d4.numPoints <= l5.indexMaxPoints) continue;
                } else {
                  if (t5 === l5.maxZoom || t5 === r7) continue;
                  if (null != r7) {
                    const e8 = r7 - t5;
                    if (o7 !== s5 >> e8 || i6 !== n6 >> e8) continue;
                  }
                }
                if (d4.source = null, 0 === e7.length) continue;
                c5 > 1 && console.time("clipping");
                const f4 = 0.5 * l5.buffer / l5.extent, g4 = 0.5 - f4, p4 = 0.5 + f4, m4 = 1 + f4;
                let y4 = null, v4 = null, w4 = null, x4 = null, _4 = W(e7, u4, o7 - f4, o7 + p4, 0, d4.minX, d4.maxX, l5), b5 = W(e7, u4, o7 + g4, o7 + m4, 0, d4.minX, d4.maxX, l5);
                e7 = null, _4 && (y4 = W(_4, u4, i6 - f4, i6 + p4, 1, d4.minY, d4.maxY, l5), v4 = W(_4, u4, i6 + g4, i6 + m4, 1, d4.minY, d4.maxY, l5), _4 = null), b5 && (w4 = W(b5, u4, i6 - f4, i6 + p4, 1, d4.minY, d4.maxY, l5), x4 = W(b5, u4, i6 + g4, i6 + m4, 1, d4.minY, d4.maxY, l5), b5 = null), c5 > 1 && console.timeEnd("clipping"), a4.push(y4 || [], t5 + 1, 2 * o7, 2 * i6), a4.push(v4 || [], t5 + 1, 2 * o7, 2 * i6 + 1), a4.push(w4 || [], t5 + 1, 2 * o7 + 1, 2 * i6), a4.push(x4 || [], t5 + 1, 2 * o7 + 1, 2 * i6 + 1);
              }
            }
            getTile(e7, t5, o7) {
              e7 = +e7, t5 = +t5, o7 = +o7;
              const i6 = this.options, { extent: r7, debug: s5 } = i6;
              if (e7 < 0 || e7 > 24) return null;
              const n6 = 1 << e7, a4 = se(e7, t5 = t5 + n6 & n6 - 1, o7);
              if (this.tiles[a4]) return K2(this.tiles[a4], r7);
              s5 > 1 && console.log("drilling down to z%d-%d-%d", e7, t5, o7);
              let l5, c5 = e7, u4 = t5, h4 = o7;
              for (; !l5 && c5 > 0; ) c5--, u4 >>= 1, h4 >>= 1, l5 = this.tiles[se(c5, u4, h4)];
              return l5 && l5.source ? (s5 > 1 && (console.log("found parent tile z%d-%d-%d", c5, u4, h4), console.time("drilling down")), this.splitTile(l5.source, c5, u4, h4, e7, t5, o7), s5 > 1 && console.timeEnd("drilling down"), this.tiles[a4] ? K2(this.tiles[a4], r7) : null) : null;
            }
          }
          function se(e7, t5, o7) {
            return 32 * ((1 << e7) * o7 + t5) + e7;
          }
          function ne(e7, t5) {
            return t5 ? e7.properties[t5] : e7.id;
          }
          function ae(e7, t5) {
            if (null == e7) return true;
            if ("Feature" === e7.type) return null != ne(e7, t5);
            if ("FeatureCollection" === e7.type) {
              const o7 = /* @__PURE__ */ new Set();
              for (const i6 of e7.features) {
                const e8 = ne(i6, t5);
                if (null == e8) return false;
                if (o7.has(e8)) return false;
                o7.add(e8);
              }
              return true;
            }
            return false;
          }
          function le(e7, t5) {
            const o7 = /* @__PURE__ */ new Map();
            if (null == e7) ;
            else if ("Feature" === e7.type) o7.set(ne(e7, t5), e7);
            else for (const i6 of e7.features) o7.set(ne(i6, t5), i6);
            return o7;
          }
          class ce extends s4 {
            constructor() {
              super(...arguments), this._dataUpdateable = /* @__PURE__ */ new Map();
            }
            loadVectorTile(t5, o7) {
              return e6._(this, void 0, void 0, function* () {
                const e7 = t5.tileID.canonical;
                if (!this._geoJSONIndex) throw new Error("Unable to parse the data into a cluster or geojson");
                const o8 = this._geoJSONIndex.getTile(e7.z, e7.x, e7.y);
                if (!o8) return null;
                const i6 = new f3(o8.features);
                let r7 = w3(i6);
                return 0 === r7.byteOffset && r7.byteLength === r7.buffer.byteLength || (r7 = new Uint8Array(r7)), { vectorTile: i6, rawData: r7.buffer };
              });
            }
            loadData(t5) {
              return e6._(this, void 0, void 0, function* () {
                var o7;
                null === (o7 = this._pendingRequest) || void 0 === o7 || o7.abort();
                const i6 = !!(t5 && t5.request && t5.request.collectResourceTiming) && new e6.cA(t5.request);
                this._pendingRequest = new AbortController();
                try {
                  this._pendingData = this.loadAndProcessGeoJSON(t5, this._pendingRequest), this._geoJSONIndex = t5.cluster ? new P3(function({ superclusterOptions: t6, clusterProperties: o9 }) {
                    if (!o9 || !t6) return t6;
                    const i7 = {}, r8 = {}, s5 = { accumulated: null, zoom: 0 }, n6 = { properties: null }, a4 = Object.keys(o9);
                    for (const t7 of a4) {
                      const [s6, n7] = o9[t7], a5 = e6.cH(n7), l5 = e6.cH("string" == typeof s6 ? [s6, ["accumulated"], ["get", t7]] : s6);
                      i7[t7] = a5.value, r8[t7] = l5.value;
                    }
                    return t6.map = (e7) => {
                      n6.properties = e7;
                      const t7 = {};
                      for (const e8 of a4) t7[e8] = i7[e8].evaluate(s5, n6);
                      return t7;
                    }, t6.reduce = (e7, t7) => {
                      n6.properties = t7;
                      for (const t8 of a4) s5.accumulated = e7[t8], e7[t8] = r8[t8].evaluate(s5, n6);
                    }, t6;
                  }(t5)).load((yield this._pendingData).features) : (r7 = yield this._pendingData, new re2(r7, t5.geojsonVtOptions)), this.loaded = {};
                  const o8 = {};
                  if (i6) {
                    const e7 = i6.finish();
                    e7 && (o8.resourceTiming = {}, o8.resourceTiming[t5.source] = JSON.parse(JSON.stringify(e7)));
                  }
                  return o8;
                } catch (t6) {
                  if (delete this._pendingRequest, e6.cl(t6)) return { abandoned: true };
                  throw t6;
                }
                var r7;
              });
            }
            getData() {
              return e6._(this, void 0, void 0, function* () {
                return this._pendingData;
              });
            }
            reloadTile(e7) {
              const t5 = this.loaded;
              return t5 && t5[e7.uid] ? super.reloadTile(e7) : this.loadTile(e7);
            }
            loadAndProcessGeoJSON(t5, o7) {
              return e6._(this, void 0, void 0, function* () {
                let i6 = yield this.loadGeoJSON(t5, o7);
                if (delete this._pendingRequest, "object" != typeof i6) throw new Error(`Input data given to '${t5.source}' is not a valid GeoJSON object.`);
                if (u3(i6, true), t5.filter) {
                  const o8 = e6.cH(t5.filter, { type: "boolean", "property-type": "data-driven", overridable: false, transition: false });
                  if ("error" === o8.result) throw new Error(o8.value.map((e7) => `${e7.key}: ${e7.message}`).join(", "));
                  const r7 = i6.features.filter((e7) => o8.value.evaluate({ zoom: 0 }, e7));
                  i6 = { type: "FeatureCollection", features: r7 };
                }
                return i6;
              });
            }
            loadGeoJSON(t5, o7) {
              return e6._(this, void 0, void 0, function* () {
                const { promoteId: i6 } = t5;
                if (t5.request) {
                  const r7 = yield e6.j(t5.request, o7);
                  return this._dataUpdateable = ae(r7.data, i6) ? le(r7.data, i6) : void 0, r7.data;
                }
                if ("string" == typeof t5.data) try {
                  const e7 = JSON.parse(t5.data);
                  return this._dataUpdateable = ae(e7, i6) ? le(e7, i6) : void 0, e7;
                } catch (e7) {
                  throw new Error(`Input data given to '${t5.source}' is not a valid GeoJSON object.`);
                }
                if (!t5.dataDiff) throw new Error(`Input data given to '${t5.source}' is not a valid GeoJSON object.`);
                if (!this._dataUpdateable) throw new Error(`Cannot update existing geojson data in ${t5.source}`);
                return function(e7, t6, o8) {
                  var i7, r7, s5, n6;
                  if (t6.removeAll && e7.clear(), t6.remove) for (const o9 of t6.remove) e7.delete(o9);
                  if (t6.add) for (const i8 of t6.add) {
                    const t7 = ne(i8, o8);
                    null != t7 && e7.set(t7, i8);
                  }
                  if (t6.update) for (const o9 of t6.update) {
                    let t7 = e7.get(o9.id);
                    if (null == t7) continue;
                    const a4 = !o9.removeAllProperties && ((null === (i7 = o9.removeProperties) || void 0 === i7 ? void 0 : i7.length) > 0 || (null === (r7 = o9.addOrUpdateProperties) || void 0 === r7 ? void 0 : r7.length) > 0);
                    if ((o9.newGeometry || o9.removeAllProperties || a4) && (t7 = Object.assign({}, t7), e7.set(o9.id, t7), a4 && (t7.properties = Object.assign({}, t7.properties))), o9.newGeometry && (t7.geometry = o9.newGeometry), o9.removeAllProperties) t7.properties = {};
                    else if ((null === (s5 = o9.removeProperties) || void 0 === s5 ? void 0 : s5.length) > 0) for (const e8 of o9.removeProperties) Object.prototype.hasOwnProperty.call(t7.properties, e8) && delete t7.properties[e8];
                    if ((null === (n6 = o9.addOrUpdateProperties) || void 0 === n6 ? void 0 : n6.length) > 0) for (const { key: e8, value: i8 } of o9.addOrUpdateProperties) t7.properties[e8] = i8;
                  }
                }(this._dataUpdateable, t5.dataDiff, i6), { type: "FeatureCollection", features: Array.from(this._dataUpdateable.values()) };
              });
            }
            removeSource(t5) {
              return e6._(this, void 0, void 0, function* () {
                this._pendingRequest && this._pendingRequest.abort();
              });
            }
            getClusterExpansionZoom(e7) {
              return this._geoJSONIndex.getClusterExpansionZoom(e7.clusterId);
            }
            getClusterChildren(e7) {
              return this._geoJSONIndex.getChildren(e7.clusterId);
            }
            getClusterLeaves(e7) {
              return this._geoJSONIndex.getLeaves(e7.clusterId, e7.limit, e7.offset);
            }
          }
          class ue {
            constructor(t5) {
              this.self = t5, this.actor = new e6.H(t5), this.layerIndexes = {}, this.availableImages = {}, this.workerSources = {}, this.demWorkerSources = {}, this.externalWorkerSourceTypes = {}, this.self.registerWorkerSource = (e7, t6) => {
                if (this.externalWorkerSourceTypes[e7]) throw new Error(`Worker source with name "${e7}" already registered.`);
                this.externalWorkerSourceTypes[e7] = t6;
              }, this.self.addProtocol = e6.cn, this.self.removeProtocol = e6.co, this.self.registerRTLTextPlugin = (t6) => {
                e6.cI.setMethods(t6);
              }, this.actor.registerMessageHandler("LDT", (e7, t6) => this._getDEMWorkerSource(e7, t6.source).loadTile(t6)), this.actor.registerMessageHandler("RDT", (t6, o7) => e6._(this, void 0, void 0, function* () {
                this._getDEMWorkerSource(t6, o7.source).removeTile(o7);
              })), this.actor.registerMessageHandler("GCEZ", (t6, o7) => e6._(this, void 0, void 0, function* () {
                return this._getWorkerSource(t6, o7.type, o7.source).getClusterExpansionZoom(o7);
              })), this.actor.registerMessageHandler("GCC", (t6, o7) => e6._(this, void 0, void 0, function* () {
                return this._getWorkerSource(t6, o7.type, o7.source).getClusterChildren(o7);
              })), this.actor.registerMessageHandler("GCL", (t6, o7) => e6._(this, void 0, void 0, function* () {
                return this._getWorkerSource(t6, o7.type, o7.source).getClusterLeaves(o7);
              })), this.actor.registerMessageHandler("LD", (e7, t6) => this._getWorkerSource(e7, t6.type, t6.source).loadData(t6)), this.actor.registerMessageHandler("GD", (e7, t6) => this._getWorkerSource(e7, t6.type, t6.source).getData()), this.actor.registerMessageHandler("LT", (e7, t6) => this._getWorkerSource(e7, t6.type, t6.source).loadTile(t6)), this.actor.registerMessageHandler("RT", (e7, t6) => this._getWorkerSource(e7, t6.type, t6.source).reloadTile(t6)), this.actor.registerMessageHandler("AT", (e7, t6) => this._getWorkerSource(e7, t6.type, t6.source).abortTile(t6)), this.actor.registerMessageHandler("RMT", (e7, t6) => this._getWorkerSource(e7, t6.type, t6.source).removeTile(t6)), this.actor.registerMessageHandler("RS", (t6, o7) => e6._(this, void 0, void 0, function* () {
                if (!this.workerSources[t6] || !this.workerSources[t6][o7.type] || !this.workerSources[t6][o7.type][o7.source]) return;
                const e7 = this.workerSources[t6][o7.type][o7.source];
                delete this.workerSources[t6][o7.type][o7.source], void 0 !== e7.removeSource && e7.removeSource(o7);
              })), this.actor.registerMessageHandler("RM", (t6) => e6._(this, void 0, void 0, function* () {
                delete this.layerIndexes[t6], delete this.availableImages[t6], delete this.workerSources[t6], delete this.demWorkerSources[t6];
              })), this.actor.registerMessageHandler("SR", (t6, o7) => e6._(this, void 0, void 0, function* () {
                this.referrer = o7;
              })), this.actor.registerMessageHandler("SRPS", (e7, t6) => this._syncRTLPluginState(e7, t6)), this.actor.registerMessageHandler("IS", (t6, o7) => e6._(this, void 0, void 0, function* () {
                this.self.importScripts(o7);
              })), this.actor.registerMessageHandler("SI", (e7, t6) => this._setImages(e7, t6)), this.actor.registerMessageHandler("UL", (t6, o7) => e6._(this, void 0, void 0, function* () {
                this._getLayerIndex(t6).update(o7.layers, o7.removedIds);
              })), this.actor.registerMessageHandler("SL", (t6, o7) => e6._(this, void 0, void 0, function* () {
                this._getLayerIndex(t6).replace(o7);
              }));
            }
            _setImages(t5, o7) {
              return e6._(this, void 0, void 0, function* () {
                this.availableImages[t5] = o7;
                for (const e7 in this.workerSources[t5]) {
                  const i6 = this.workerSources[t5][e7];
                  for (const e8 in i6) i6[e8].availableImages = o7;
                }
              });
            }
            _syncRTLPluginState(t5, o7) {
              return e6._(this, void 0, void 0, function* () {
                return yield e6.cI.syncState(o7, this.self.importScripts);
              });
            }
            _getAvailableImages(e7) {
              let t5 = this.availableImages[e7];
              return t5 || (t5 = []), t5;
            }
            _getLayerIndex(e7) {
              let o7 = this.layerIndexes[e7];
              return o7 || (o7 = this.layerIndexes[e7] = new t4()), o7;
            }
            _getWorkerSource(e7, t5, o7) {
              if (this.workerSources[e7] || (this.workerSources[e7] = {}), this.workerSources[e7][t5] || (this.workerSources[e7][t5] = {}), !this.workerSources[e7][t5][o7]) {
                const i6 = { sendAsync: (t6, o8) => (t6.targetMapId = e7, this.actor.sendAsync(t6, o8)) };
                switch (t5) {
                  case "vector":
                    this.workerSources[e7][t5][o7] = new s4(i6, this._getLayerIndex(e7), this._getAvailableImages(e7));
                    break;
                  case "geojson":
                    this.workerSources[e7][t5][o7] = new ce(i6, this._getLayerIndex(e7), this._getAvailableImages(e7));
                    break;
                  default:
                    this.workerSources[e7][t5][o7] = new this.externalWorkerSourceTypes[t5](i6, this._getLayerIndex(e7), this._getAvailableImages(e7));
                }
              }
              return this.workerSources[e7][t5][o7];
            }
            _getDEMWorkerSource(e7, t5) {
              return this.demWorkerSources[e7] || (this.demWorkerSources[e7] = {}), this.demWorkerSources[e7][t5] || (this.demWorkerSources[e7][t5] = new n5()), this.demWorkerSources[e7][t5];
            }
          }
          return e6.i(self) && (self.worker = new ue(self)), ue;
        });
        define2("index", ["exports", "./shared"], function(e6, t4) {
          "use strict";
          var i5 = "5.3.1";
          function r6() {
            var e7 = new t4.A(4);
            return t4.A != Float32Array && (e7[1] = 0, e7[2] = 0), e7[0] = 1, e7[3] = 1, e7;
          }
          let o6, a3;
          const s4 = { now: "undefined" != typeof performance && performance && performance.now ? performance.now.bind(performance) : Date.now.bind(Date), frame(e7, i6, r7) {
            const o7 = requestAnimationFrame((e8) => {
              a4(), i6(e8);
            }), { unsubscribe: a4 } = t4.s(e7.signal, "abort", () => {
              a4(), cancelAnimationFrame(o7), r7(t4.c());
            }, false);
          }, frameAsync(e7) {
            return new Promise((t5, i6) => {
              this.frame(e7, t5, i6);
            });
          }, getImageData(e7, t5 = 0) {
            return this.getImageCanvasContext(e7).getImageData(-t5, -t5, e7.width + 2 * t5, e7.height + 2 * t5);
          }, getImageCanvasContext(e7) {
            const t5 = window.document.createElement("canvas"), i6 = t5.getContext("2d", { willReadFrequently: true });
            if (!i6) throw new Error("failed to create canvas 2d context");
            return t5.width = e7.width, t5.height = e7.height, i6.drawImage(e7, 0, 0, e7.width, e7.height), i6;
          }, resolveURL: (e7) => (o6 || (o6 = document.createElement("a")), o6.href = e7, o6.href), hardwareConcurrency: "undefined" != typeof navigator && navigator.hardwareConcurrency || 4, get prefersReducedMotion() {
            return !!matchMedia && (null == a3 && (a3 = matchMedia("(prefers-reduced-motion: reduce)")), a3.matches);
          } };
          class n5 {
            static testProp(e7) {
              if (!n5.docStyle) return e7[0];
              for (let t5 = 0; t5 < e7.length; t5++) if (e7[t5] in n5.docStyle) return e7[t5];
              return e7[0];
            }
            static create(e7, t5, i6) {
              const r7 = window.document.createElement(e7);
              return void 0 !== t5 && (r7.className = t5), i6 && i6.appendChild(r7), r7;
            }
            static createNS(e7, t5) {
              return window.document.createElementNS(e7, t5);
            }
            static disableDrag() {
              n5.docStyle && n5.selectProp && (n5.userSelect = n5.docStyle[n5.selectProp], n5.docStyle[n5.selectProp] = "none");
            }
            static enableDrag() {
              n5.docStyle && n5.selectProp && (n5.docStyle[n5.selectProp] = n5.userSelect);
            }
            static setTransform(e7, t5) {
              e7.style[n5.transformProp] = t5;
            }
            static addEventListener(e7, t5, i6, r7 = {}) {
              e7.addEventListener(t5, i6, "passive" in r7 ? r7 : r7.capture);
            }
            static removeEventListener(e7, t5, i6, r7 = {}) {
              e7.removeEventListener(t5, i6, "passive" in r7 ? r7 : r7.capture);
            }
            static suppressClickInternal(e7) {
              e7.preventDefault(), e7.stopPropagation(), window.removeEventListener("click", n5.suppressClickInternal, true);
            }
            static suppressClick() {
              window.addEventListener("click", n5.suppressClickInternal, true), window.setTimeout(() => {
                window.removeEventListener("click", n5.suppressClickInternal, true);
              }, 0);
            }
            static getScale(e7) {
              const t5 = e7.getBoundingClientRect();
              return { x: t5.width / e7.offsetWidth || 1, y: t5.height / e7.offsetHeight || 1, boundingClientRect: t5 };
            }
            static getPoint(e7, i6, r7) {
              const o7 = i6.boundingClientRect;
              return new t4.P((r7.clientX - o7.left) / i6.x - e7.clientLeft, (r7.clientY - o7.top) / i6.y - e7.clientTop);
            }
            static mousePos(e7, t5) {
              const i6 = n5.getScale(e7);
              return n5.getPoint(e7, i6, t5);
            }
            static touchPos(e7, t5) {
              const i6 = [], r7 = n5.getScale(e7);
              for (let o7 = 0; o7 < t5.length; o7++) i6.push(n5.getPoint(e7, r7, t5[o7]));
              return i6;
            }
            static mouseButton(e7) {
              return e7.button;
            }
            static remove(e7) {
              e7.parentNode && e7.parentNode.removeChild(e7);
            }
            static sanitize(e7) {
              const t5 = new DOMParser().parseFromString(e7, "text/html").body || document.createElement("body"), i6 = t5.querySelectorAll("script");
              for (const e8 of i6) e8.remove();
              return n5.clean(t5), t5.innerHTML;
            }
            static isPossiblyDangerous(e7, t5) {
              const i6 = t5.replace(/\s+/g, "").toLowerCase();
              return !(!["src", "href", "xlink:href"].includes(e7) || !i6.includes("javascript:") && !i6.includes("data:")) || !!e7.startsWith("on") || void 0;
            }
            static clean(e7) {
              const t5 = e7.children;
              for (const e8 of t5) n5.removeAttributes(e8), n5.clean(e8);
            }
            static removeAttributes(e7) {
              for (const { name: t5, value: i6 } of e7.attributes) n5.isPossiblyDangerous(t5, i6) && e7.removeAttribute(t5);
            }
          }
          n5.docStyle = "undefined" != typeof window && window.document && window.document.documentElement.style, n5.selectProp = n5.testProp(["userSelect", "MozUserSelect", "WebkitUserSelect", "msUserSelect"]), n5.transformProp = n5.testProp(["transform", "WebkitTransform"]);
          const l4 = { supported: false, testSupport: function(e7) {
            !u3 && h3 && (d3 ? _3(e7) : c4 = e7);
          } };
          let c4, h3, u3 = false, d3 = false;
          function _3(e7) {
            const t5 = e7.createTexture();
            e7.bindTexture(e7.TEXTURE_2D, t5);
            try {
              if (e7.texImage2D(e7.TEXTURE_2D, 0, e7.RGBA, e7.RGBA, e7.UNSIGNED_BYTE, h3), e7.isContextLost()) return;
              l4.supported = true;
            } catch (e8) {
            }
            e7.deleteTexture(t5), u3 = true;
          }
          var p3;
          "undefined" != typeof document && (h3 = document.createElement("img"), h3.onload = () => {
            c4 && _3(c4), c4 = null, d3 = true;
          }, h3.onerror = () => {
            u3 = true, c4 = null;
          }, h3.src = "data:image/webp;base64,UklGRh4AAABXRUJQVlA4TBEAAAAvAQAAAAfQ//73v/+BiOh/AAA="), function(e7) {
            let i6, r7, o7, a4;
            e7.resetRequestQueue = () => {
              i6 = [], r7 = 0, o7 = 0, a4 = {};
            }, e7.addThrottleControl = (e8) => {
              const t5 = o7++;
              return a4[t5] = e8, t5;
            }, e7.removeThrottleControl = (e8) => {
              delete a4[e8], n6();
            }, e7.getImage = (e8, r8, o8 = true) => new Promise((a5, s6) => {
              l4.supported && (e8.headers || (e8.headers = {}), e8.headers.accept = "image/webp,*/*"), t4.e(e8, { type: "image" }), i6.push({ abortController: r8, requestParameters: e8, supportImageRefresh: o8, state: "queued", onError: (e9) => {
                s6(e9);
              }, onSuccess: (e9) => {
                a5(e9);
              } }), n6();
            });
            const s5 = (e8) => t4._(this, void 0, void 0, function* () {
              e8.state = "running";
              const { requestParameters: i7, supportImageRefresh: o8, onError: a5, onSuccess: s6, abortController: l5 } = e8, h4 = false === o8 && !t4.i(self) && !t4.g(i7.url) && (!i7.headers || Object.keys(i7.headers).reduce((e9, t5) => e9 && "accept" === t5, true));
              r7++;
              const u4 = h4 ? c5(i7, l5) : t4.m(i7, l5);
              try {
                const i8 = yield u4;
                delete e8.abortController, e8.state = "completed", i8.data instanceof HTMLImageElement || t4.b(i8.data) ? s6(i8) : i8.data && s6({ data: yield (d4 = i8.data, "function" == typeof createImageBitmap ? t4.f(d4) : t4.h(d4)), cacheControl: i8.cacheControl, expires: i8.expires });
              } catch (t5) {
                delete e8.abortController, a5(t5);
              } finally {
                r7--, n6();
              }
              var d4;
            }), n6 = () => {
              const e8 = (() => {
                for (const e9 of Object.keys(a4)) if (a4[e9]()) return true;
                return false;
              })() ? t4.a.MAX_PARALLEL_IMAGE_REQUESTS_PER_FRAME : t4.a.MAX_PARALLEL_IMAGE_REQUESTS;
              for (let t5 = r7; t5 < e8 && i6.length > 0; t5++) {
                const e9 = i6.shift();
                e9.abortController.signal.aborted ? t5-- : s5(e9);
              }
            }, c5 = (e8, i7) => new Promise((r8, o8) => {
              const a5 = new Image(), s6 = e8.url, n7 = e8.credentials;
              n7 && "include" === n7 ? a5.crossOrigin = "use-credentials" : (n7 && "same-origin" === n7 || !t4.d(s6)) && (a5.crossOrigin = "anonymous"), i7.signal.addEventListener("abort", () => {
                a5.src = "", o8(t4.c());
              }), a5.fetchPriority = "high", a5.onload = () => {
                a5.onerror = a5.onload = null, r8({ data: a5 });
              }, a5.onerror = () => {
                a5.onerror = a5.onload = null, i7.signal.aborted || o8(new Error("Could not load image. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported."));
              }, a5.src = s6;
            });
          }(p3 || (p3 = {})), p3.resetRequestQueue();
          class m3 {
            constructor(e7) {
              this._transformRequestFn = e7;
            }
            transformRequest(e7, t5) {
              return this._transformRequestFn && this._transformRequestFn(e7, t5) || { url: e7 };
            }
            setTransformRequest(e7) {
              this._transformRequestFn = e7;
            }
          }
          function f3(e7) {
            const t5 = [];
            if ("string" == typeof e7) t5.push({ id: "default", url: e7 });
            else if (e7 && e7.length > 0) {
              const i6 = [];
              for (const { id: r7, url: o7 } of e7) {
                const e8 = `${r7}${o7}`;
                -1 === i6.indexOf(e8) && (i6.push(e8), t5.push({ id: r7, url: o7 }));
              }
            }
            return t5;
          }
          function g3(e7, t5, i6) {
            try {
              const r7 = new URL(e7);
              return r7.pathname += `${t5}${i6}`, r7.toString();
            } catch (t6) {
              throw new Error(`Invalid sprite URL "${e7}", must be absolute. Modify style specification directly or use TransformStyleFunction to correct the issue dynamically`);
            }
          }
          class v3 {
            constructor(e7, t5, i6, r7) {
              this.context = e7, this.format = i6, this.texture = e7.gl.createTexture(), this.update(t5, r7);
            }
            update(e7, i6, r7) {
              const { width: o7, height: a4 } = e7, s5 = !(this.size && this.size[0] === o7 && this.size[1] === a4 || r7), { context: n6 } = this, { gl: l5 } = n6;
              if (this.useMipmap = Boolean(i6 && i6.useMipmap), l5.bindTexture(l5.TEXTURE_2D, this.texture), n6.pixelStoreUnpackFlipY.set(false), n6.pixelStoreUnpack.set(1), n6.pixelStoreUnpackPremultiplyAlpha.set(this.format === l5.RGBA && (!i6 || false !== i6.premultiply)), s5) this.size = [o7, a4], e7 instanceof HTMLImageElement || e7 instanceof HTMLCanvasElement || e7 instanceof HTMLVideoElement || e7 instanceof ImageData || t4.b(e7) ? l5.texImage2D(l5.TEXTURE_2D, 0, this.format, this.format, l5.UNSIGNED_BYTE, e7) : l5.texImage2D(l5.TEXTURE_2D, 0, this.format, o7, a4, 0, this.format, l5.UNSIGNED_BYTE, e7.data);
              else {
                const { x: i7, y: s6 } = r7 || { x: 0, y: 0 };
                e7 instanceof HTMLImageElement || e7 instanceof HTMLCanvasElement || e7 instanceof HTMLVideoElement || e7 instanceof ImageData || t4.b(e7) ? l5.texSubImage2D(l5.TEXTURE_2D, 0, i7, s6, l5.RGBA, l5.UNSIGNED_BYTE, e7) : l5.texSubImage2D(l5.TEXTURE_2D, 0, i7, s6, o7, a4, l5.RGBA, l5.UNSIGNED_BYTE, e7.data);
              }
              this.useMipmap && this.isSizePowerOfTwo() && l5.generateMipmap(l5.TEXTURE_2D), n6.pixelStoreUnpackFlipY.setDefault(), n6.pixelStoreUnpack.setDefault(), n6.pixelStoreUnpackPremultiplyAlpha.setDefault();
            }
            bind(e7, t5, i6) {
              const { context: r7 } = this, { gl: o7 } = r7;
              o7.bindTexture(o7.TEXTURE_2D, this.texture), i6 !== o7.LINEAR_MIPMAP_NEAREST || this.isSizePowerOfTwo() || (i6 = o7.LINEAR), e7 !== this.filter && (o7.texParameteri(o7.TEXTURE_2D, o7.TEXTURE_MAG_FILTER, e7), o7.texParameteri(o7.TEXTURE_2D, o7.TEXTURE_MIN_FILTER, i6 || e7), this.filter = e7), t5 !== this.wrap && (o7.texParameteri(o7.TEXTURE_2D, o7.TEXTURE_WRAP_S, t5), o7.texParameteri(o7.TEXTURE_2D, o7.TEXTURE_WRAP_T, t5), this.wrap = t5);
            }
            isSizePowerOfTwo() {
              return this.size[0] === this.size[1] && Math.log(this.size[0]) / Math.LN2 % 1 == 0;
            }
            destroy() {
              const { gl: e7 } = this.context;
              e7.deleteTexture(this.texture), this.texture = null;
            }
          }
          function x3(e7) {
            const { userImage: t5 } = e7;
            return !!(t5 && t5.render && t5.render()) && (e7.data.replace(new Uint8Array(t5.data.buffer)), true);
          }
          class b4 extends t4.E {
            constructor() {
              super(), this.images = {}, this.updatedImages = {}, this.callbackDispatchedThisFrame = {}, this.loaded = false, this.requestors = [], this.patterns = {}, this.atlasImage = new t4.R({ width: 1, height: 1 }), this.dirty = true;
            }
            isLoaded() {
              return this.loaded;
            }
            setLoaded(e7) {
              if (this.loaded !== e7 && (this.loaded = e7, e7)) {
                for (const { ids: e8, promiseResolve: t5 } of this.requestors) t5(this._getImagesForIds(e8));
                this.requestors = [];
              }
            }
            getImage(e7) {
              const i6 = this.images[e7];
              if (i6 && !i6.data && i6.spriteData) {
                const e8 = i6.spriteData;
                i6.data = new t4.R({ width: e8.width, height: e8.height }, e8.context.getImageData(e8.x, e8.y, e8.width, e8.height).data), i6.spriteData = null;
              }
              return i6;
            }
            addImage(e7, t5) {
              if (this.images[e7]) throw new Error(`Image id ${e7} already exist, use updateImage instead`);
              this._validate(e7, t5) && (this.images[e7] = t5);
            }
            _validate(e7, i6) {
              let r7 = true;
              const o7 = i6.data || i6.spriteData;
              return this._validateStretch(i6.stretchX, o7 && o7.width) || (this.fire(new t4.k(new Error(`Image "${e7}" has invalid "stretchX" value`))), r7 = false), this._validateStretch(i6.stretchY, o7 && o7.height) || (this.fire(new t4.k(new Error(`Image "${e7}" has invalid "stretchY" value`))), r7 = false), this._validateContent(i6.content, i6) || (this.fire(new t4.k(new Error(`Image "${e7}" has invalid "content" value`))), r7 = false), r7;
            }
            _validateStretch(e7, t5) {
              if (!e7) return true;
              let i6 = 0;
              for (const r7 of e7) {
                if (r7[0] < i6 || r7[1] < r7[0] || t5 < r7[1]) return false;
                i6 = r7[1];
              }
              return true;
            }
            _validateContent(e7, t5) {
              if (!e7) return true;
              if (4 !== e7.length) return false;
              const i6 = t5.spriteData, r7 = i6 && i6.width || t5.data.width, o7 = i6 && i6.height || t5.data.height;
              return !(e7[0] < 0 || r7 < e7[0] || e7[1] < 0 || o7 < e7[1] || e7[2] < 0 || r7 < e7[2] || e7[3] < 0 || o7 < e7[3] || e7[2] < e7[0] || e7[3] < e7[1]);
            }
            updateImage(e7, t5, i6 = true) {
              const r7 = this.getImage(e7);
              if (i6 && (r7.data.width !== t5.data.width || r7.data.height !== t5.data.height)) throw new Error(`size mismatch between old image (${r7.data.width}x${r7.data.height}) and new image (${t5.data.width}x${t5.data.height}).`);
              t5.version = r7.version + 1, this.images[e7] = t5, this.updatedImages[e7] = true;
            }
            removeImage(e7) {
              const t5 = this.images[e7];
              delete this.images[e7], delete this.patterns[e7], t5.userImage && t5.userImage.onRemove && t5.userImage.onRemove();
            }
            listImages() {
              return Object.keys(this.images);
            }
            getImages(e7) {
              return new Promise((t5, i6) => {
                let r7 = true;
                if (!this.isLoaded()) for (const t6 of e7) this.images[t6] || (r7 = false);
                this.isLoaded() || r7 ? t5(this._getImagesForIds(e7)) : this.requestors.push({ ids: e7, promiseResolve: t5 });
              });
            }
            _getImagesForIds(e7) {
              const i6 = {};
              for (const r7 of e7) {
                let e8 = this.getImage(r7);
                e8 || (this.fire(new t4.l("styleimagemissing", { id: r7 })), e8 = this.getImage(r7)), e8 ? i6[r7] = { data: e8.data.clone(), pixelRatio: e8.pixelRatio, sdf: e8.sdf, version: e8.version, stretchX: e8.stretchX, stretchY: e8.stretchY, content: e8.content, textFitWidth: e8.textFitWidth, textFitHeight: e8.textFitHeight, hasRenderCallback: Boolean(e8.userImage && e8.userImage.render) } : t4.w(`Image "${r7}" could not be loaded. Please make sure you have added the image with map.addImage() or a "sprite" property in your style. You can provide missing images by listening for the "styleimagemissing" map event.`);
              }
              return i6;
            }
            getPixelSize() {
              const { width: e7, height: t5 } = this.atlasImage;
              return { width: e7, height: t5 };
            }
            getPattern(e7) {
              const i6 = this.patterns[e7], r7 = this.getImage(e7);
              if (!r7) return null;
              if (i6 && i6.position.version === r7.version) return i6.position;
              if (i6) i6.position.version = r7.version;
              else {
                const i7 = { w: r7.data.width + 2, h: r7.data.height + 2, x: 0, y: 0 }, o7 = new t4.I(i7, r7);
                this.patterns[e7] = { bin: i7, position: o7 };
              }
              return this._updatePatternAtlas(), this.patterns[e7].position;
            }
            bind(e7) {
              const t5 = e7.gl;
              this.atlasTexture ? this.dirty && (this.atlasTexture.update(this.atlasImage), this.dirty = false) : this.atlasTexture = new v3(e7, this.atlasImage, t5.RGBA), this.atlasTexture.bind(t5.LINEAR, t5.CLAMP_TO_EDGE);
            }
            _updatePatternAtlas() {
              const e7 = [];
              for (const t5 in this.patterns) e7.push(this.patterns[t5].bin);
              const { w: i6, h: r7 } = t4.p(e7), o7 = this.atlasImage;
              o7.resize({ width: i6 || 1, height: r7 || 1 });
              for (const e8 in this.patterns) {
                const { bin: i7 } = this.patterns[e8], r8 = i7.x + 1, a4 = i7.y + 1, s5 = this.getImage(e8).data, n6 = s5.width, l5 = s5.height;
                t4.R.copy(s5, o7, { x: 0, y: 0 }, { x: r8, y: a4 }, { width: n6, height: l5 }), t4.R.copy(s5, o7, { x: 0, y: l5 - 1 }, { x: r8, y: a4 - 1 }, { width: n6, height: 1 }), t4.R.copy(s5, o7, { x: 0, y: 0 }, { x: r8, y: a4 + l5 }, { width: n6, height: 1 }), t4.R.copy(s5, o7, { x: n6 - 1, y: 0 }, { x: r8 - 1, y: a4 }, { width: 1, height: l5 }), t4.R.copy(s5, o7, { x: 0, y: 0 }, { x: r8 + n6, y: a4 }, { width: 1, height: l5 });
              }
              this.dirty = true;
            }
            beginFrame() {
              this.callbackDispatchedThisFrame = {};
            }
            dispatchRenderCallbacks(e7) {
              for (const i6 of e7) {
                if (this.callbackDispatchedThisFrame[i6]) continue;
                this.callbackDispatchedThisFrame[i6] = true;
                const e8 = this.getImage(i6);
                e8 || t4.w(`Image with ID: "${i6}" was not found`), x3(e8) && this.updateImage(i6, e8);
              }
            }
          }
          const y3 = 1e20;
          function w3(e7, t5, i6, r7, o7, a4, s5, n6, l5) {
            for (let c5 = t5; c5 < t5 + r7; c5++) T4(e7, i6 * a4 + c5, a4, o7, s5, n6, l5);
            for (let c5 = i6; c5 < i6 + o7; c5++) T4(e7, c5 * a4 + t5, 1, r7, s5, n6, l5);
          }
          function T4(e7, t5, i6, r7, o7, a4, s5) {
            a4[0] = 0, s5[0] = -1e20, s5[1] = y3, o7[0] = e7[t5];
            for (let n6 = 1, l5 = 0, c5 = 0; n6 < r7; n6++) {
              o7[n6] = e7[t5 + n6 * i6];
              const r8 = n6 * n6;
              do {
                const e8 = a4[l5];
                c5 = (o7[n6] - o7[e8] + r8 - e8 * e8) / (n6 - e8) / 2;
              } while (c5 <= s5[l5] && --l5 > -1);
              l5++, a4[l5] = n6, s5[l5] = c5, s5[l5 + 1] = y3;
            }
            for (let n6 = 0, l5 = 0; n6 < r7; n6++) {
              for (; s5[l5 + 1] < n6; ) l5++;
              const r8 = a4[l5], c5 = n6 - r8;
              e7[t5 + n6 * i6] = o7[r8] + c5 * c5;
            }
          }
          class P3 {
            constructor(e7, t5) {
              this.requestManager = e7, this.localIdeographFontFamily = t5, this.entries = {};
            }
            setURL(e7) {
              this.url = e7;
            }
            getGlyphs(e7) {
              return t4._(this, void 0, void 0, function* () {
                const t5 = [];
                for (const i7 in e7) for (const r8 of e7[i7]) t5.push(this._getAndCacheGlyphsPromise(i7, r8));
                const i6 = yield Promise.all(t5), r7 = {};
                for (const { stack: e8, id: t6, glyph: o7 } of i6) r7[e8] || (r7[e8] = {}), r7[e8][t6] = o7 && { id: o7.id, bitmap: o7.bitmap.clone(), metrics: o7.metrics };
                return r7;
              });
            }
            _getAndCacheGlyphsPromise(e7, i6) {
              return t4._(this, void 0, void 0, function* () {
                let t5 = this.entries[e7];
                t5 || (t5 = this.entries[e7] = { glyphs: {}, requests: {}, ranges: {} });
                let r7 = t5.glyphs[i6];
                if (void 0 !== r7) return { stack: e7, id: i6, glyph: r7 };
                if (r7 = this._tinySDF(t5, e7, i6), r7) return t5.glyphs[i6] = r7, { stack: e7, id: i6, glyph: r7 };
                const o7 = Math.floor(i6 / 256);
                if (256 * o7 > 65535) throw new Error("glyphs > 65535 not supported");
                if (t5.ranges[o7]) return { stack: e7, id: i6, glyph: r7 };
                if (!this.url) throw new Error("glyphsUrl is not set");
                if (!t5.requests[o7]) {
                  const i7 = P3.loadGlyphRange(e7, o7, this.url, this.requestManager);
                  t5.requests[o7] = i7;
                }
                const a4 = yield t5.requests[o7];
                for (const e8 in a4) this._doesCharSupportLocalGlyph(+e8) || (t5.glyphs[+e8] = a4[+e8]);
                return t5.ranges[o7] = true, { stack: e7, id: i6, glyph: a4[i6] || null };
              });
            }
            _doesCharSupportLocalGlyph(e7) {
              return !!this.localIdeographFontFamily && (/\p{Ideo}|\p{sc=Hang}|\p{sc=Hira}|\p{sc=Kana}/u.test(String.fromCodePoint(e7)) || t4.u["CJK Unified Ideographs"](e7) || t4.u["Hangul Syllables"](e7) || t4.u.Hiragana(e7) || t4.u.Katakana(e7) || t4.u["CJK Symbols and Punctuation"](e7) || t4.u["Halfwidth and Fullwidth Forms"](e7));
            }
            _tinySDF(e7, i6, r7) {
              const o7 = this.localIdeographFontFamily;
              if (!o7) return;
              if (!this._doesCharSupportLocalGlyph(r7)) return;
              let a4 = e7.tinySDF;
              if (!a4) {
                let t5 = "400";
                /bold/i.test(i6) ? t5 = "900" : /medium/i.test(i6) ? t5 = "500" : /light/i.test(i6) && (t5 = "200"), a4 = e7.tinySDF = new P3.TinySDF({ fontSize: 48, buffer: 6, radius: 16, cutoff: 0.25, fontFamily: o7, fontWeight: t5 });
              }
              const s5 = a4.draw(String.fromCharCode(r7));
              return { id: r7, bitmap: new t4.q({ width: s5.width || 60, height: s5.height || 60 }, s5.data), metrics: { width: s5.glyphWidth / 2 || 24, height: s5.glyphHeight / 2 || 24, left: s5.glyphLeft / 2 + 0.5 || 0, top: s5.glyphTop / 2 - 27.5 || -8, advance: s5.glyphAdvance / 2 || 24, isDoubleResolution: true } };
            }
          }
          P3.loadGlyphRange = function(e7, i6, r7, o7) {
            return t4._(this, void 0, void 0, function* () {
              const a4 = 256 * i6, s5 = a4 + 255, n6 = o7.transformRequest(r7.replace("{fontstack}", e7).replace("{range}", `${a4}-${s5}`), "Glyphs"), l5 = yield t4.n(n6, new AbortController());
              if (!l5 || !l5.data) throw new Error(`Could not load glyph range. range: ${i6}, ${a4}-${s5}`);
              const c5 = {};
              for (const e8 of t4.o(l5.data)) c5[e8.id] = e8;
              return c5;
            });
          }, P3.TinySDF = class {
            constructor({ fontSize: e7 = 24, buffer: t5 = 3, radius: i6 = 8, cutoff: r7 = 0.25, fontFamily: o7 = "sans-serif", fontWeight: a4 = "normal", fontStyle: s5 = "normal" } = {}) {
              this.buffer = t5, this.cutoff = r7, this.radius = i6;
              const n6 = this.size = e7 + 4 * t5, l5 = this._createCanvas(n6), c5 = this.ctx = l5.getContext("2d", { willReadFrequently: true });
              c5.font = `${s5} ${a4} ${e7}px ${o7}`, c5.textBaseline = "alphabetic", c5.textAlign = "left", c5.fillStyle = "black", this.gridOuter = new Float64Array(n6 * n6), this.gridInner = new Float64Array(n6 * n6), this.f = new Float64Array(n6), this.z = new Float64Array(n6 + 1), this.v = new Uint16Array(n6);
            }
            _createCanvas(e7) {
              const t5 = document.createElement("canvas");
              return t5.width = t5.height = e7, t5;
            }
            draw(e7) {
              const { width: t5, actualBoundingBoxAscent: i6, actualBoundingBoxDescent: r7, actualBoundingBoxLeft: o7, actualBoundingBoxRight: a4 } = this.ctx.measureText(e7), s5 = Math.ceil(i6), n6 = Math.max(0, Math.min(this.size - this.buffer, Math.ceil(a4 - o7))), l5 = Math.min(this.size - this.buffer, s5 + Math.ceil(r7)), c5 = n6 + 2 * this.buffer, h4 = l5 + 2 * this.buffer, u4 = Math.max(c5 * h4, 0), d4 = new Uint8ClampedArray(u4), _4 = { data: d4, width: c5, height: h4, glyphWidth: n6, glyphHeight: l5, glyphTop: s5, glyphLeft: 0, glyphAdvance: t5 };
              if (0 === n6 || 0 === l5) return _4;
              const { ctx: p4, buffer: m4, gridInner: f4, gridOuter: g4 } = this;
              p4.clearRect(m4, m4, n6, l5), p4.fillText(e7, m4, m4 + s5);
              const v4 = p4.getImageData(m4, m4, n6, l5);
              g4.fill(y3, 0, u4), f4.fill(0, 0, u4);
              for (let e8 = 0; e8 < l5; e8++) for (let t6 = 0; t6 < n6; t6++) {
                const i7 = v4.data[4 * (e8 * n6 + t6) + 3] / 255;
                if (0 === i7) continue;
                const r8 = (e8 + m4) * c5 + t6 + m4;
                if (1 === i7) g4[r8] = 0, f4[r8] = y3;
                else {
                  const e9 = 0.5 - i7;
                  g4[r8] = e9 > 0 ? e9 * e9 : 0, f4[r8] = e9 < 0 ? e9 * e9 : 0;
                }
              }
              w3(g4, 0, 0, c5, h4, c5, this.f, this.v, this.z), w3(f4, m4, m4, n6, l5, c5, this.f, this.v, this.z);
              for (let e8 = 0; e8 < u4; e8++) {
                const t6 = Math.sqrt(g4[e8]) - Math.sqrt(f4[e8]);
                d4[e8] = Math.round(255 - 255 * (t6 / this.radius + this.cutoff));
              }
              return _4;
            }
          };
          class C3 {
            constructor() {
              this.specification = t4.v.light.position;
            }
            possiblyEvaluate(e7, i6) {
              return t4.z(e7.expression.evaluate(i6));
            }
            interpolate(e7, i6, r7) {
              return { x: t4.B.number(e7.x, i6.x, r7), y: t4.B.number(e7.y, i6.y, r7), z: t4.B.number(e7.z, i6.z, r7) };
            }
          }
          let I3;
          class M4 extends t4.E {
            constructor(e7) {
              super(), I3 = I3 || new t4.r({ anchor: new t4.D(t4.v.light.anchor), position: new C3(), color: new t4.D(t4.v.light.color), intensity: new t4.D(t4.v.light.intensity) }), this._transitionable = new t4.T(I3), this.setLight(e7), this._transitioning = this._transitionable.untransitioned();
            }
            getLight() {
              return this._transitionable.serialize();
            }
            setLight(e7, i6 = {}) {
              if (!this._validate(t4.t, e7, i6)) for (const t5 in e7) {
                const i7 = e7[t5];
                t5.endsWith("-transition") ? this._transitionable.setTransition(t5.slice(0, -11), i7) : this._transitionable.setValue(t5, i7);
              }
            }
            updateTransitions(e7) {
              this._transitioning = this._transitionable.transitioned(e7, this._transitioning);
            }
            hasTransition() {
              return this._transitioning.hasTransition();
            }
            recalculate(e7) {
              this.properties = this._transitioning.possiblyEvaluate(e7);
            }
            _validate(e7, i6, r7) {
              return (!r7 || false !== r7.validate) && t4.x(this, e7.call(t4.y, { value: i6, style: { glyphs: true, sprite: true }, styleSpec: t4.v }));
            }
          }
          const E3 = new t4.r({ "sky-color": new t4.D(t4.v.sky["sky-color"]), "horizon-color": new t4.D(t4.v.sky["horizon-color"]), "fog-color": new t4.D(t4.v.sky["fog-color"]), "fog-ground-blend": new t4.D(t4.v.sky["fog-ground-blend"]), "horizon-fog-blend": new t4.D(t4.v.sky["horizon-fog-blend"]), "sky-horizon-blend": new t4.D(t4.v.sky["sky-horizon-blend"]), "atmosphere-blend": new t4.D(t4.v.sky["atmosphere-blend"]) });
          class S4 extends t4.E {
            constructor(e7) {
              super(), this._transitionable = new t4.T(E3), this.setSky(e7), this._transitioning = this._transitionable.untransitioned(), this.recalculate(new t4.C(0));
            }
            setSky(e7, i6 = {}) {
              if (!this._validate(t4.F, e7, i6)) {
                e7 || (e7 = { "sky-color": "transparent", "horizon-color": "transparent", "fog-color": "transparent", "fog-ground-blend": 1, "atmosphere-blend": 0 });
                for (const t5 in e7) {
                  const i7 = e7[t5];
                  t5.endsWith("-transition") ? this._transitionable.setTransition(t5.slice(0, -11), i7) : this._transitionable.setValue(t5, i7);
                }
              }
            }
            getSky() {
              return this._transitionable.serialize();
            }
            updateTransitions(e7) {
              this._transitioning = this._transitionable.transitioned(e7, this._transitioning);
            }
            hasTransition() {
              return this._transitioning.hasTransition();
            }
            recalculate(e7) {
              this.properties = this._transitioning.possiblyEvaluate(e7);
            }
            _validate(e7, i6, r7 = {}) {
              return false !== (null == r7 ? void 0 : r7.validate) && t4.x(this, e7.call(t4.y, t4.e({ value: i6, style: { glyphs: true, sprite: true }, styleSpec: t4.v })));
            }
            calculateFogBlendOpacity(e7) {
              return e7 < 60 ? 0 : e7 < 70 ? (e7 - 60) / 10 : 1;
            }
          }
          class R4 {
            constructor(e7, t5) {
              this.width = e7, this.height = t5, this.nextRow = 0, this.data = new Uint8Array(this.width * this.height), this.dashEntry = {};
            }
            getDash(e7, t5) {
              const i6 = e7.join(",") + String(t5);
              return this.dashEntry[i6] || (this.dashEntry[i6] = this.addDash(e7, t5)), this.dashEntry[i6];
            }
            getDashRanges(e7, t5, i6) {
              const r7 = [];
              let o7 = e7.length % 2 == 1 ? -e7[e7.length - 1] * i6 : 0, a4 = e7[0] * i6, s5 = true;
              r7.push({ left: o7, right: a4, isDash: s5, zeroLength: 0 === e7[0] });
              let n6 = e7[0];
              for (let t6 = 1; t6 < e7.length; t6++) {
                s5 = !s5;
                const l5 = e7[t6];
                o7 = n6 * i6, n6 += l5, a4 = n6 * i6, r7.push({ left: o7, right: a4, isDash: s5, zeroLength: 0 === l5 });
              }
              return r7;
            }
            addRoundDash(e7, t5, i6) {
              const r7 = t5 / 2;
              for (let t6 = -i6; t6 <= i6; t6++) {
                const o7 = this.width * (this.nextRow + i6 + t6);
                let a4 = 0, s5 = e7[a4];
                for (let n6 = 0; n6 < this.width; n6++) {
                  n6 / s5.right > 1 && (s5 = e7[++a4]);
                  const l5 = Math.abs(n6 - s5.left), c5 = Math.abs(n6 - s5.right), h4 = Math.min(l5, c5);
                  let u4;
                  const d4 = t6 / i6 * (r7 + 1);
                  if (s5.isDash) {
                    const e8 = r7 - Math.abs(d4);
                    u4 = Math.sqrt(h4 * h4 + e8 * e8);
                  } else u4 = r7 - Math.sqrt(h4 * h4 + d4 * d4);
                  this.data[o7 + n6] = Math.max(0, Math.min(255, u4 + 128));
                }
              }
            }
            addRegularDash(e7) {
              for (let t6 = e7.length - 1; t6 >= 0; --t6) {
                const i7 = e7[t6], r8 = e7[t6 + 1];
                i7.zeroLength ? e7.splice(t6, 1) : r8 && r8.isDash === i7.isDash && (r8.left = i7.left, e7.splice(t6, 1));
              }
              const t5 = e7[0], i6 = e7[e7.length - 1];
              t5.isDash === i6.isDash && (t5.left = i6.left - this.width, i6.right = t5.right + this.width);
              const r7 = this.width * this.nextRow;
              let o7 = 0, a4 = e7[o7];
              for (let t6 = 0; t6 < this.width; t6++) {
                t6 / a4.right > 1 && (a4 = e7[++o7]);
                const i7 = Math.abs(t6 - a4.left), s5 = Math.abs(t6 - a4.right), n6 = Math.min(i7, s5);
                this.data[r7 + t6] = Math.max(0, Math.min(255, (a4.isDash ? n6 : -n6) + 128));
              }
            }
            addDash(e7, i6) {
              const r7 = i6 ? 7 : 0, o7 = 2 * r7 + 1;
              if (this.nextRow + o7 > this.height) return t4.w("LineAtlas out of space"), null;
              let a4 = 0;
              for (let t5 = 0; t5 < e7.length; t5++) a4 += e7[t5];
              if (0 !== a4) {
                const t5 = this.width / a4, o8 = this.getDashRanges(e7, this.width, t5);
                i6 ? this.addRoundDash(o8, t5, r7) : this.addRegularDash(o8);
              }
              const s5 = { y: (this.nextRow + r7 + 0.5) / this.height, height: 2 * r7 / this.height, width: a4 };
              return this.nextRow += o7, this.dirty = true, s5;
            }
            bind(e7) {
              const t5 = e7.gl;
              this.texture ? (t5.bindTexture(t5.TEXTURE_2D, this.texture), this.dirty && (this.dirty = false, t5.texSubImage2D(t5.TEXTURE_2D, 0, 0, 0, this.width, this.height, t5.ALPHA, t5.UNSIGNED_BYTE, this.data))) : (this.texture = t5.createTexture(), t5.bindTexture(t5.TEXTURE_2D, this.texture), t5.texParameteri(t5.TEXTURE_2D, t5.TEXTURE_WRAP_S, t5.REPEAT), t5.texParameteri(t5.TEXTURE_2D, t5.TEXTURE_WRAP_T, t5.REPEAT), t5.texParameteri(t5.TEXTURE_2D, t5.TEXTURE_MIN_FILTER, t5.LINEAR), t5.texParameteri(t5.TEXTURE_2D, t5.TEXTURE_MAG_FILTER, t5.LINEAR), t5.texImage2D(t5.TEXTURE_2D, 0, t5.ALPHA, this.width, this.height, 0, t5.ALPHA, t5.UNSIGNED_BYTE, this.data));
            }
          }
          const D2 = "maplibre_preloaded_worker_pool";
          class z3 {
            constructor() {
              this.active = {};
            }
            acquire(e7) {
              if (!this.workers) for (this.workers = []; this.workers.length < z3.workerCount; ) this.workers.push(new Worker(t4.a.WORKER_URL));
              return this.active[e7] = true, this.workers.slice();
            }
            release(e7) {
              delete this.active[e7], 0 === this.numActive() && (this.workers.forEach((e8) => {
                e8.terminate();
              }), this.workers = null);
            }
            isPreloaded() {
              return !!this.active[D2];
            }
            numActive() {
              return Object.keys(this.active).length;
            }
          }
          const A4 = Math.floor(s4.hardwareConcurrency / 2);
          let L3, k3;
          function F2() {
            return L3 || (L3 = new z3()), L3;
          }
          z3.workerCount = t4.G(globalThis) ? Math.max(Math.min(A4, 3), 1) : 1;
          class B4 {
            constructor(e7, i6) {
              this.workerPool = e7, this.actors = [], this.currentActor = 0, this.id = i6;
              const r7 = this.workerPool.acquire(i6);
              for (let e8 = 0; e8 < r7.length; e8++) {
                const o7 = new t4.H(r7[e8], i6);
                o7.name = `Worker ${e8}`, this.actors.push(o7);
              }
              if (!this.actors.length) throw new Error("No actors found");
            }
            broadcast(e7, t5) {
              const i6 = [];
              for (const r7 of this.actors) i6.push(r7.sendAsync({ type: e7, data: t5 }));
              return Promise.all(i6);
            }
            getActor() {
              return this.currentActor = (this.currentActor + 1) % this.actors.length, this.actors[this.currentActor];
            }
            remove(e7 = true) {
              this.actors.forEach((e8) => {
                e8.remove();
              }), this.actors = [], e7 && this.workerPool.release(this.id);
            }
            registerMessageHandler(e7, t5) {
              for (const i6 of this.actors) i6.registerMessageHandler(e7, t5);
            }
          }
          function O2() {
            return k3 || (k3 = new B4(F2(), t4.J), k3.registerMessageHandler("GR", (e7, i6, r7) => t4.m(i6, r7))), k3;
          }
          function j3(e7, i6) {
            const r7 = t4.K();
            return t4.L(r7, r7, [1, 1, 0]), t4.M(r7, r7, [0.5 * e7.width, 0.5 * e7.height, 1]), e7.calculatePosMatrix ? t4.N(r7, r7, e7.calculatePosMatrix(i6.toUnwrapped())) : r7;
          }
          function Z2(e7, t5, i6, r7, o7, a4, s5) {
            var n6;
            const l5 = function(e8, t6, i7) {
              if (e8) for (const r8 of e8) {
                const e9 = t6[r8];
                if (e9 && e9.source === i7 && "fill-extrusion" === e9.type) return true;
              }
              else for (const e9 in t6) {
                const r8 = t6[e9];
                if (r8.source === i7 && "fill-extrusion" === r8.type) return true;
              }
              return false;
            }(null !== (n6 = null == o7 ? void 0 : o7.layers) && void 0 !== n6 ? n6 : null, t5, e7.id), c5 = a4.maxPitchScaleFactor(), h4 = e7.tilesIn(r7, c5, l5);
            h4.sort(N3);
            const u4 = [];
            for (const r8 of h4) u4.push({ wrappedTileID: r8.tileID.wrapped().key, queryResults: r8.tile.queryRenderedFeatures(t5, i6, e7._state, r8.queryGeometry, r8.cameraQueryGeometry, r8.scale, o7, a4, c5, j3(e7.transform, r8.tileID), s5 ? (e8, t6) => s5(r8.tileID, e8, t6) : void 0) });
            return function(e8, t6) {
              for (const i7 in e8) for (const r8 of e8[i7]) G2(r8, t6);
              return e8;
            }(function(e8) {
              const t6 = {}, i7 = {};
              for (const r8 of e8) {
                const e9 = r8.queryResults, o8 = r8.wrappedTileID, a5 = i7[o8] = i7[o8] || {};
                for (const i8 in e9) {
                  const r9 = e9[i8], o9 = a5[i8] = a5[i8] || {}, s6 = t6[i8] = t6[i8] || [];
                  for (const e10 of r9) o9[e10.featureIndex] || (o9[e10.featureIndex] = true, s6.push(e10));
                }
              }
              return t6;
            }(u4), e7);
          }
          function N3(e7, t5) {
            const i6 = e7.tileID, r7 = t5.tileID;
            return i6.overscaledZ - r7.overscaledZ || i6.canonical.y - r7.canonical.y || i6.wrap - r7.wrap || i6.canonical.x - r7.canonical.x;
          }
          function G2(e7, t5) {
            const i6 = e7.feature, r7 = t5.getFeatureState(i6.layer["source-layer"], i6.id);
            i6.source = i6.layer.source, i6.layer["source-layer"] && (i6.sourceLayer = i6.layer["source-layer"]), i6.state = r7;
          }
          function U3(e7, i6, r7) {
            return t4._(this, void 0, void 0, function* () {
              let o7 = e7;
              if (e7.url ? o7 = (yield t4.j(i6.transformRequest(e7.url, "Source"), r7)).data : yield s4.frameAsync(r7), !o7) return null;
              const a4 = t4.O(t4.e(o7, e7), ["tiles", "minzoom", "maxzoom", "attribution", "bounds", "scheme", "tileSize", "encoding"]);
              return "vector_layers" in o7 && o7.vector_layers && (a4.vectorLayerIds = o7.vector_layers.map((e8) => e8.id)), a4;
            });
          }
          class V2 {
            constructor(e7, t5) {
              e7 && (t5 ? this.setSouthWest(e7).setNorthEast(t5) : Array.isArray(e7) && (4 === e7.length ? this.setSouthWest([e7[0], e7[1]]).setNorthEast([e7[2], e7[3]]) : this.setSouthWest(e7[0]).setNorthEast(e7[1])));
            }
            setNorthEast(e7) {
              return this._ne = e7 instanceof t4.Q ? new t4.Q(e7.lng, e7.lat) : t4.Q.convert(e7), this;
            }
            setSouthWest(e7) {
              return this._sw = e7 instanceof t4.Q ? new t4.Q(e7.lng, e7.lat) : t4.Q.convert(e7), this;
            }
            extend(e7) {
              const i6 = this._sw, r7 = this._ne;
              let o7, a4;
              if (e7 instanceof t4.Q) o7 = e7, a4 = e7;
              else {
                if (!(e7 instanceof V2)) return Array.isArray(e7) ? 4 === e7.length || e7.every(Array.isArray) ? this.extend(V2.convert(e7)) : this.extend(t4.Q.convert(e7)) : e7 && ("lng" in e7 || "lon" in e7) && "lat" in e7 ? this.extend(t4.Q.convert(e7)) : this;
                if (o7 = e7._sw, a4 = e7._ne, !o7 || !a4) return this;
              }
              return i6 || r7 ? (i6.lng = Math.min(o7.lng, i6.lng), i6.lat = Math.min(o7.lat, i6.lat), r7.lng = Math.max(a4.lng, r7.lng), r7.lat = Math.max(a4.lat, r7.lat)) : (this._sw = new t4.Q(o7.lng, o7.lat), this._ne = new t4.Q(a4.lng, a4.lat)), this;
            }
            getCenter() {
              return new t4.Q((this._sw.lng + this._ne.lng) / 2, (this._sw.lat + this._ne.lat) / 2);
            }
            getSouthWest() {
              return this._sw;
            }
            getNorthEast() {
              return this._ne;
            }
            getNorthWest() {
              return new t4.Q(this.getWest(), this.getNorth());
            }
            getSouthEast() {
              return new t4.Q(this.getEast(), this.getSouth());
            }
            getWest() {
              return this._sw.lng;
            }
            getSouth() {
              return this._sw.lat;
            }
            getEast() {
              return this._ne.lng;
            }
            getNorth() {
              return this._ne.lat;
            }
            toArray() {
              return [this._sw.toArray(), this._ne.toArray()];
            }
            toString() {
              return `LngLatBounds(${this._sw.toString()}, ${this._ne.toString()})`;
            }
            isEmpty() {
              return !(this._sw && this._ne);
            }
            contains(e7) {
              const { lng: i6, lat: r7 } = t4.Q.convert(e7);
              let o7 = this._sw.lng <= i6 && i6 <= this._ne.lng;
              return this._sw.lng > this._ne.lng && (o7 = this._sw.lng >= i6 && i6 >= this._ne.lng), this._sw.lat <= r7 && r7 <= this._ne.lat && o7;
            }
            static convert(e7) {
              return e7 instanceof V2 ? e7 : e7 ? new V2(e7) : e7;
            }
            static fromLngLat(e7, i6 = 0) {
              const r7 = 360 * i6 / 40075017, o7 = r7 / Math.cos(Math.PI / 180 * e7.lat);
              return new V2(new t4.Q(e7.lng - o7, e7.lat - r7), new t4.Q(e7.lng + o7, e7.lat + r7));
            }
            adjustAntiMeridian() {
              const e7 = new t4.Q(this._sw.lng, this._sw.lat), i6 = new t4.Q(this._ne.lng, this._ne.lat);
              return new V2(e7, e7.lng > i6.lng ? new t4.Q(i6.lng + 360, i6.lat) : i6);
            }
          }
          class q2 {
            constructor(e7, t5, i6) {
              this.bounds = V2.convert(this.validateBounds(e7)), this.minzoom = t5 || 0, this.maxzoom = i6 || 24;
            }
            validateBounds(e7) {
              return Array.isArray(e7) && 4 === e7.length ? [Math.max(-180, e7[0]), Math.max(-90, e7[1]), Math.min(180, e7[2]), Math.min(90, e7[3])] : [-180, -90, 180, 90];
            }
            contains(e7) {
              const i6 = Math.pow(2, e7.z), r7 = Math.floor(t4.U(this.bounds.getWest()) * i6), o7 = Math.floor(t4.S(this.bounds.getNorth()) * i6), a4 = Math.ceil(t4.U(this.bounds.getEast()) * i6), s5 = Math.ceil(t4.S(this.bounds.getSouth()) * i6);
              return e7.x >= r7 && e7.x < a4 && e7.y >= o7 && e7.y < s5;
            }
          }
          class W extends t4.E {
            constructor(e7, i6, r7, o7) {
              if (super(), this.id = e7, this.dispatcher = r7, this.type = "vector", this.minzoom = 0, this.maxzoom = 22, this.scheme = "xyz", this.tileSize = 512, this.reparseOverscaled = true, this.isTileClipped = true, this._loaded = false, t4.e(this, t4.O(i6, ["url", "scheme", "tileSize", "promoteId"])), this._options = t4.e({ type: "vector" }, i6), this._collectResourceTiming = i6.collectResourceTiming, 512 !== this.tileSize) throw new Error("vector tile sources must have a tileSize of 512");
              this.setEventedParent(o7);
            }
            load() {
              return t4._(this, void 0, void 0, function* () {
                this._loaded = false, this.fire(new t4.l("dataloading", { dataType: "source" })), this._tileJSONRequest = new AbortController();
                try {
                  const e7 = yield U3(this._options, this.map._requestManager, this._tileJSONRequest);
                  this._tileJSONRequest = null, this._loaded = true, this.map.style.sourceCaches[this.id].clearTiles(), e7 && (t4.e(this, e7), e7.bounds && (this.tileBounds = new q2(e7.bounds, this.minzoom, this.maxzoom)), this.fire(new t4.l("data", { dataType: "source", sourceDataType: "metadata" })), this.fire(new t4.l("data", { dataType: "source", sourceDataType: "content" })));
                } catch (e7) {
                  this._tileJSONRequest = null, this.fire(new t4.k(e7));
                }
              });
            }
            loaded() {
              return this._loaded;
            }
            hasTile(e7) {
              return !this.tileBounds || this.tileBounds.contains(e7.canonical);
            }
            onAdd(e7) {
              this.map = e7, this.load();
            }
            setSourceProperty(e7) {
              this._tileJSONRequest && this._tileJSONRequest.abort(), e7(), this.load();
            }
            setTiles(e7) {
              return this.setSourceProperty(() => {
                this._options.tiles = e7;
              }), this;
            }
            setUrl(e7) {
              return this.setSourceProperty(() => {
                this.url = e7, this._options.url = e7;
              }), this;
            }
            onRemove() {
              this._tileJSONRequest && (this._tileJSONRequest.abort(), this._tileJSONRequest = null);
            }
            serialize() {
              return t4.e({}, this._options);
            }
            loadTile(e7) {
              return t4._(this, void 0, void 0, function* () {
                const t5 = e7.tileID.canonical.url(this.tiles, this.map.getPixelRatio(), this.scheme), i6 = { request: this.map._requestManager.transformRequest(t5, "Tile"), uid: e7.uid, tileID: e7.tileID, zoom: e7.tileID.overscaledZ, tileSize: this.tileSize * e7.tileID.overscaleFactor(), type: this.type, source: this.id, pixelRatio: this.map.getPixelRatio(), showCollisionBoxes: this.map.showCollisionBoxes, promoteId: this.promoteId, subdivisionGranularity: this.map.style.projection.subdivisionGranularity };
                i6.request.collectResourceTiming = this._collectResourceTiming;
                let r7 = "RT";
                if (e7.actor && "expired" !== e7.state) {
                  if ("loading" === e7.state) return new Promise((t6, i7) => {
                    e7.reloadPromise = { resolve: t6, reject: i7 };
                  });
                } else e7.actor = this.dispatcher.getActor(), r7 = "LT";
                e7.abortController = new AbortController();
                try {
                  const t6 = yield e7.actor.sendAsync({ type: r7, data: i6 }, e7.abortController);
                  if (delete e7.abortController, e7.aborted) return;
                  this._afterTileLoadWorkerResponse(e7, t6);
                } catch (t6) {
                  if (delete e7.abortController, e7.aborted) return;
                  if (t6 && 404 !== t6.status) throw t6;
                  this._afterTileLoadWorkerResponse(e7, null);
                }
              });
            }
            _afterTileLoadWorkerResponse(e7, t5) {
              if (t5 && t5.resourceTiming && (e7.resourceTiming = t5.resourceTiming), t5 && this.map._refreshExpiredTiles && e7.setExpiryData(t5), e7.loadVectorData(t5, this.map.painter), e7.reloadPromise) {
                const t6 = e7.reloadPromise;
                e7.reloadPromise = null, this.loadTile(e7).then(t6.resolve).catch(t6.reject);
              }
            }
            abortTile(e7) {
              return t4._(this, void 0, void 0, function* () {
                e7.abortController && (e7.abortController.abort(), delete e7.abortController), e7.actor && (yield e7.actor.sendAsync({ type: "AT", data: { uid: e7.uid, type: this.type, source: this.id } }));
              });
            }
            unloadTile(e7) {
              return t4._(this, void 0, void 0, function* () {
                e7.unloadVectorData(), e7.actor && (yield e7.actor.sendAsync({ type: "RMT", data: { uid: e7.uid, type: this.type, source: this.id } }));
              });
            }
            hasTransition() {
              return false;
            }
          }
          class $2 extends t4.E {
            constructor(e7, i6, r7, o7) {
              super(), this.id = e7, this.dispatcher = r7, this.setEventedParent(o7), this.type = "raster", this.minzoom = 0, this.maxzoom = 22, this.roundZoom = true, this.scheme = "xyz", this.tileSize = 512, this._loaded = false, this._options = t4.e({ type: "raster" }, i6), t4.e(this, t4.O(i6, ["url", "scheme", "tileSize"]));
            }
            load() {
              return t4._(this, arguments, void 0, function* (e7 = false) {
                this._loaded = false, this.fire(new t4.l("dataloading", { dataType: "source" })), this._tileJSONRequest = new AbortController();
                try {
                  const i6 = yield U3(this._options, this.map._requestManager, this._tileJSONRequest);
                  this._tileJSONRequest = null, this._loaded = true, i6 && (t4.e(this, i6), i6.bounds && (this.tileBounds = new q2(i6.bounds, this.minzoom, this.maxzoom)), this.fire(new t4.l("data", { dataType: "source", sourceDataType: "metadata" })), this.fire(new t4.l("data", { dataType: "source", sourceDataType: "content", sourceDataChanged: e7 })));
                } catch (e8) {
                  this._tileJSONRequest = null, this.fire(new t4.k(e8));
                }
              });
            }
            loaded() {
              return this._loaded;
            }
            onAdd(e7) {
              this.map = e7, this.load();
            }
            onRemove() {
              this._tileJSONRequest && (this._tileJSONRequest.abort(), this._tileJSONRequest = null);
            }
            setSourceProperty(e7) {
              this._tileJSONRequest && (this._tileJSONRequest.abort(), this._tileJSONRequest = null), e7(), this.load(true);
            }
            setTiles(e7) {
              return this.setSourceProperty(() => {
                this._options.tiles = e7;
              }), this;
            }
            setUrl(e7) {
              return this.setSourceProperty(() => {
                this.url = e7, this._options.url = e7;
              }), this;
            }
            serialize() {
              return t4.e({}, this._options);
            }
            hasTile(e7) {
              return !this.tileBounds || this.tileBounds.contains(e7.canonical);
            }
            loadTile(e7) {
              return t4._(this, void 0, void 0, function* () {
                const t5 = e7.tileID.canonical.url(this.tiles, this.map.getPixelRatio(), this.scheme);
                e7.abortController = new AbortController();
                try {
                  const i6 = yield p3.getImage(this.map._requestManager.transformRequest(t5, "Tile"), e7.abortController, this.map._refreshExpiredTiles);
                  if (delete e7.abortController, e7.aborted) return void (e7.state = "unloaded");
                  if (i6 && i6.data) {
                    this.map._refreshExpiredTiles && i6.cacheControl && i6.expires && e7.setExpiryData({ cacheControl: i6.cacheControl, expires: i6.expires });
                    const t6 = this.map.painter.context, r7 = t6.gl, o7 = i6.data;
                    e7.texture = this.map.painter.getTileTexture(o7.width), e7.texture ? e7.texture.update(o7, { useMipmap: true }) : (e7.texture = new v3(t6, o7, r7.RGBA, { useMipmap: true }), e7.texture.bind(r7.LINEAR, r7.CLAMP_TO_EDGE, r7.LINEAR_MIPMAP_NEAREST)), e7.state = "loaded";
                  }
                } catch (t6) {
                  if (delete e7.abortController, e7.aborted) e7.state = "unloaded";
                  else if (t6) throw e7.state = "errored", t6;
                }
              });
            }
            abortTile(e7) {
              return t4._(this, void 0, void 0, function* () {
                e7.abortController && (e7.abortController.abort(), delete e7.abortController);
              });
            }
            unloadTile(e7) {
              return t4._(this, void 0, void 0, function* () {
                e7.texture && this.map.painter.saveTileTexture(e7.texture);
              });
            }
            hasTransition() {
              return false;
            }
          }
          class H4 extends $2 {
            constructor(e7, i6, r7, o7) {
              super(e7, i6, r7, o7), this.type = "raster-dem", this.maxzoom = 22, this._options = t4.e({ type: "raster-dem" }, i6), this.encoding = i6.encoding || "mapbox", this.redFactor = i6.redFactor, this.greenFactor = i6.greenFactor, this.blueFactor = i6.blueFactor, this.baseShift = i6.baseShift;
            }
            loadTile(e7) {
              return t4._(this, void 0, void 0, function* () {
                const i6 = e7.tileID.canonical.url(this.tiles, this.map.getPixelRatio(), this.scheme), r7 = this.map._requestManager.transformRequest(i6, "Tile");
                e7.neighboringTiles = this._getNeighboringTiles(e7.tileID), e7.abortController = new AbortController();
                try {
                  const i7 = yield p3.getImage(r7, e7.abortController, this.map._refreshExpiredTiles);
                  if (delete e7.abortController, e7.aborted) return void (e7.state = "unloaded");
                  if (i7 && i7.data) {
                    const r8 = i7.data;
                    this.map._refreshExpiredTiles && i7.cacheControl && i7.expires && e7.setExpiryData({ cacheControl: i7.cacheControl, expires: i7.expires });
                    const o7 = t4.b(r8) && t4.V() ? r8 : yield this.readImageNow(r8), a4 = { type: this.type, uid: e7.uid, source: this.id, rawImageData: o7, encoding: this.encoding, redFactor: this.redFactor, greenFactor: this.greenFactor, blueFactor: this.blueFactor, baseShift: this.baseShift };
                    if (!e7.actor || "expired" === e7.state) {
                      e7.actor = this.dispatcher.getActor();
                      const t5 = yield e7.actor.sendAsync({ type: "LDT", data: a4 });
                      e7.dem = t5, e7.needsHillshadePrepare = true, e7.needsTerrainPrepare = true, e7.state = "loaded";
                    }
                  }
                } catch (t5) {
                  if (delete e7.abortController, e7.aborted) e7.state = "unloaded";
                  else if (t5) throw e7.state = "errored", t5;
                }
              });
            }
            readImageNow(e7) {
              return t4._(this, void 0, void 0, function* () {
                if ("undefined" != typeof VideoFrame && t4.W()) {
                  const i6 = e7.width + 2, r7 = e7.height + 2;
                  try {
                    return new t4.R({ width: i6, height: r7 }, yield t4.X(e7, -1, -1, i6, r7));
                  } catch (e8) {
                  }
                }
                return s4.getImageData(e7, 1);
              });
            }
            _getNeighboringTiles(e7) {
              const i6 = e7.canonical, r7 = Math.pow(2, i6.z), o7 = (i6.x - 1 + r7) % r7, a4 = 0 === i6.x ? e7.wrap - 1 : e7.wrap, s5 = (i6.x + 1 + r7) % r7, n6 = i6.x + 1 === r7 ? e7.wrap + 1 : e7.wrap, l5 = {};
              return l5[new t4.Y(e7.overscaledZ, a4, i6.z, o7, i6.y).key] = { backfilled: false }, l5[new t4.Y(e7.overscaledZ, n6, i6.z, s5, i6.y).key] = { backfilled: false }, i6.y > 0 && (l5[new t4.Y(e7.overscaledZ, a4, i6.z, o7, i6.y - 1).key] = { backfilled: false }, l5[new t4.Y(e7.overscaledZ, e7.wrap, i6.z, i6.x, i6.y - 1).key] = { backfilled: false }, l5[new t4.Y(e7.overscaledZ, n6, i6.z, s5, i6.y - 1).key] = { backfilled: false }), i6.y + 1 < r7 && (l5[new t4.Y(e7.overscaledZ, a4, i6.z, o7, i6.y + 1).key] = { backfilled: false }, l5[new t4.Y(e7.overscaledZ, e7.wrap, i6.z, i6.x, i6.y + 1).key] = { backfilled: false }, l5[new t4.Y(e7.overscaledZ, n6, i6.z, s5, i6.y + 1).key] = { backfilled: false }), l5;
            }
            unloadTile(e7) {
              return t4._(this, void 0, void 0, function* () {
                e7.demTexture && this.map.painter.saveTileTexture(e7.demTexture), e7.fbo && (e7.fbo.destroy(), delete e7.fbo), e7.dem && delete e7.dem, delete e7.neighboringTiles, e7.state = "unloaded", e7.actor && (yield e7.actor.sendAsync({ type: "RDT", data: { type: this.type, uid: e7.uid, source: this.id } }));
              });
            }
          }
          class K2 extends t4.E {
            constructor(e7, i6, r7, o7) {
              super(), this.id = e7, this.type = "geojson", this.minzoom = 0, this.maxzoom = 18, this.tileSize = 512, this.isTileClipped = true, this.reparseOverscaled = true, this._removed = false, this._pendingLoads = 0, this.actor = r7.getActor(), this.setEventedParent(o7), this._data = i6.data, this._options = t4.e({}, i6), this._collectResourceTiming = i6.collectResourceTiming, void 0 !== i6.maxzoom && (this.maxzoom = i6.maxzoom), i6.type && (this.type = i6.type), i6.attribution && (this.attribution = i6.attribution), this.promoteId = i6.promoteId, void 0 !== i6.clusterMaxZoom && this.maxzoom <= i6.clusterMaxZoom && t4.w(`The maxzoom value "${this.maxzoom}" is expected to be greater than the clusterMaxZoom value "${i6.clusterMaxZoom}".`), this.workerOptions = t4.e({ source: this.id, cluster: i6.cluster || false, geojsonVtOptions: { buffer: this._pixelsToTileUnits(void 0 !== i6.buffer ? i6.buffer : 128), tolerance: this._pixelsToTileUnits(void 0 !== i6.tolerance ? i6.tolerance : 0.375), extent: t4.Z, maxZoom: this.maxzoom, lineMetrics: i6.lineMetrics || false, generateId: i6.generateId || false }, superclusterOptions: { maxZoom: void 0 !== i6.clusterMaxZoom ? i6.clusterMaxZoom : this.maxzoom - 1, minPoints: Math.max(2, i6.clusterMinPoints || 2), extent: t4.Z, radius: this._pixelsToTileUnits(i6.clusterRadius || 50), log: false, generateId: i6.generateId || false }, clusterProperties: i6.clusterProperties, filter: i6.filter }, i6.workerOptions), "string" == typeof this.promoteId && (this.workerOptions.promoteId = this.promoteId);
            }
            _pixelsToTileUnits(e7) {
              return e7 * (t4.Z / this.tileSize);
            }
            load() {
              return t4._(this, void 0, void 0, function* () {
                yield this._updateWorkerData();
              });
            }
            onAdd(e7) {
              this.map = e7, this.load();
            }
            setData(e7) {
              return this._data = e7, this._updateWorkerData(), this;
            }
            updateData(e7) {
              return this._updateWorkerData(e7), this;
            }
            getData() {
              return t4._(this, void 0, void 0, function* () {
                const e7 = t4.e({ type: this.type }, this.workerOptions);
                return this.actor.sendAsync({ type: "GD", data: e7 });
              });
            }
            getCoordinatesFromGeometry(e7) {
              return "GeometryCollection" === e7.type ? e7.geometries.map((e8) => e8.coordinates).flat(1 / 0) : e7.coordinates.flat(1 / 0);
            }
            getBounds() {
              return t4._(this, void 0, void 0, function* () {
                const e7 = new V2(), t5 = yield this.getData();
                let i6;
                switch (t5.type) {
                  case "FeatureCollection":
                    i6 = t5.features.map((e8) => this.getCoordinatesFromGeometry(e8.geometry)).flat(1 / 0);
                    break;
                  case "Feature":
                    i6 = this.getCoordinatesFromGeometry(t5.geometry);
                    break;
                  default:
                    i6 = this.getCoordinatesFromGeometry(t5);
                }
                if (0 == i6.length) return e7;
                for (let t6 = 0; t6 < i6.length - 1; t6 += 2) e7.extend([i6[t6], i6[t6 + 1]]);
                return e7;
              });
            }
            setClusterOptions(e7) {
              return this.workerOptions.cluster = e7.cluster, e7 && (void 0 !== e7.clusterRadius && (this.workerOptions.superclusterOptions.radius = this._pixelsToTileUnits(e7.clusterRadius)), void 0 !== e7.clusterMaxZoom && (this.workerOptions.superclusterOptions.maxZoom = e7.clusterMaxZoom)), this._updateWorkerData(), this;
            }
            getClusterExpansionZoom(e7) {
              return this.actor.sendAsync({ type: "GCEZ", data: { type: this.type, clusterId: e7, source: this.id } });
            }
            getClusterChildren(e7) {
              return this.actor.sendAsync({ type: "GCC", data: { type: this.type, clusterId: e7, source: this.id } });
            }
            getClusterLeaves(e7, t5, i6) {
              return this.actor.sendAsync({ type: "GCL", data: { type: this.type, source: this.id, clusterId: e7, limit: t5, offset: i6 } });
            }
            _updateWorkerData(e7) {
              return t4._(this, void 0, void 0, function* () {
                const i6 = t4.e({ type: this.type }, this.workerOptions);
                e7 ? i6.dataDiff = e7 : "string" == typeof this._data ? (i6.request = this.map._requestManager.transformRequest(s4.resolveURL(this._data), "Source"), i6.request.collectResourceTiming = this._collectResourceTiming) : i6.data = JSON.stringify(this._data), this._pendingLoads++, this.fire(new t4.l("dataloading", { dataType: "source" }));
                try {
                  const e8 = yield this.actor.sendAsync({ type: "LD", data: i6 });
                  if (this._pendingLoads--, this._removed || e8.abandoned) return void this.fire(new t4.l("dataabort", { dataType: "source" }));
                  let r7 = null;
                  e8.resourceTiming && e8.resourceTiming[this.id] && (r7 = e8.resourceTiming[this.id].slice(0));
                  const o7 = { dataType: "source" };
                  this._collectResourceTiming && r7 && r7.length > 0 && t4.e(o7, { resourceTiming: r7 }), this.fire(new t4.l("data", Object.assign(Object.assign({}, o7), { sourceDataType: "metadata" }))), this.fire(new t4.l("data", Object.assign(Object.assign({}, o7), { sourceDataType: "content" })));
                } catch (e8) {
                  if (this._pendingLoads--, this._removed) return void this.fire(new t4.l("dataabort", { dataType: "source" }));
                  this.fire(new t4.k(e8));
                }
              });
            }
            loaded() {
              return 0 === this._pendingLoads;
            }
            loadTile(e7) {
              return t4._(this, void 0, void 0, function* () {
                const t5 = e7.actor ? "RT" : "LT";
                e7.actor = this.actor;
                const i6 = { type: this.type, uid: e7.uid, tileID: e7.tileID, zoom: e7.tileID.overscaledZ, maxZoom: this.maxzoom, tileSize: this.tileSize, source: this.id, pixelRatio: this.map.getPixelRatio(), showCollisionBoxes: this.map.showCollisionBoxes, promoteId: this.promoteId, subdivisionGranularity: this.map.style.projection.subdivisionGranularity };
                e7.abortController = new AbortController();
                const r7 = yield this.actor.sendAsync({ type: t5, data: i6 }, e7.abortController);
                delete e7.abortController, e7.unloadVectorData(), e7.aborted || e7.loadVectorData(r7, this.map.painter, "RT" === t5);
              });
            }
            abortTile(e7) {
              return t4._(this, void 0, void 0, function* () {
                e7.abortController && (e7.abortController.abort(), delete e7.abortController), e7.aborted = true;
              });
            }
            unloadTile(e7) {
              return t4._(this, void 0, void 0, function* () {
                e7.unloadVectorData(), yield this.actor.sendAsync({ type: "RMT", data: { uid: e7.uid, type: this.type, source: this.id } });
              });
            }
            onRemove() {
              this._removed = true, this.actor.sendAsync({ type: "RS", data: { type: this.type, source: this.id } });
            }
            serialize() {
              return t4.e({}, this._options, { type: this.type, data: this._data });
            }
            hasTransition() {
              return false;
            }
          }
          class X2 extends t4.E {
            constructor(e7, t5, i6, r7) {
              super(), this.flippedWindingOrder = false, this.id = e7, this.dispatcher = i6, this.coordinates = t5.coordinates, this.type = "image", this.minzoom = 0, this.maxzoom = 22, this.tileSize = 512, this.tiles = {}, this._loaded = false, this.setEventedParent(r7), this.options = t5;
            }
            load(e7) {
              return t4._(this, void 0, void 0, function* () {
                this._loaded = false, this.fire(new t4.l("dataloading", { dataType: "source" })), this.url = this.options.url, this._request = new AbortController();
                try {
                  const t5 = yield p3.getImage(this.map._requestManager.transformRequest(this.url, "Image"), this._request);
                  this._request = null, this._loaded = true, t5 && t5.data && (this.image = t5.data, e7 && (this.coordinates = e7), this._finishLoading());
                } catch (e8) {
                  this._request = null, this._loaded = true, this.fire(new t4.k(e8));
                }
              });
            }
            loaded() {
              return this._loaded;
            }
            updateImage(e7) {
              return e7.url ? (this._request && (this._request.abort(), this._request = null), this.options.url = e7.url, this.load(e7.coordinates).finally(() => {
                this.texture = null;
              }), this) : this;
            }
            _finishLoading() {
              this.map && (this.setCoordinates(this.coordinates), this.fire(new t4.l("data", { dataType: "source", sourceDataType: "metadata" })));
            }
            onAdd(e7) {
              this.map = e7, this.load();
            }
            onRemove() {
              this._request && (this._request.abort(), this._request = null);
            }
            setCoordinates(e7) {
              this.coordinates = e7;
              const i6 = e7.map(t4.$.fromLngLat);
              var r7;
              return this.tileID = function(e8) {
                let i7 = 1 / 0, r8 = 1 / 0, o7 = -1 / 0, a4 = -1 / 0;
                for (const t5 of e8) i7 = Math.min(i7, t5.x), r8 = Math.min(r8, t5.y), o7 = Math.max(o7, t5.x), a4 = Math.max(a4, t5.y);
                const s5 = Math.max(o7 - i7, a4 - r8), n6 = Math.max(0, Math.floor(-Math.log(s5) / Math.LN2)), l5 = Math.pow(2, n6);
                return new t4.a1(n6, Math.floor((i7 + o7) / 2 * l5), Math.floor((r8 + a4) / 2 * l5));
              }(i6), this.terrainTileRanges = this._getOverlappingTileRanges(i6), this.minzoom = this.maxzoom = this.tileID.z, this.tileCoords = i6.map((e8) => this.tileID.getTilePoint(e8)._round()), this.flippedWindingOrder = ((r7 = this.tileCoords)[1].x - r7[0].x) * (r7[2].y - r7[0].y) - (r7[1].y - r7[0].y) * (r7[2].x - r7[0].x) < 0, this.fire(new t4.l("data", { dataType: "source", sourceDataType: "content" })), this;
            }
            prepare() {
              if (0 === Object.keys(this.tiles).length || !this.image) return;
              const e7 = this.map.painter.context, i6 = e7.gl;
              this.texture || (this.texture = new v3(e7, this.image, i6.RGBA), this.texture.bind(i6.LINEAR, i6.CLAMP_TO_EDGE));
              let r7 = false;
              for (const e8 in this.tiles) {
                const t5 = this.tiles[e8];
                "loaded" !== t5.state && (t5.state = "loaded", t5.texture = this.texture, r7 = true);
              }
              r7 && this.fire(new t4.l("data", { dataType: "source", sourceDataType: "idle", sourceId: this.id }));
            }
            loadTile(e7) {
              return t4._(this, void 0, void 0, function* () {
                this.tileID && this.tileID.equals(e7.tileID.canonical) ? (this.tiles[String(e7.tileID.wrap)] = e7, e7.buckets = {}) : e7.state = "errored";
              });
            }
            serialize() {
              return { type: "image", url: this.options.url, coordinates: this.coordinates };
            }
            hasTransition() {
              return false;
            }
            _getOverlappingTileRanges(e7) {
              let i6 = 1 / 0, r7 = 1 / 0, o7 = -1 / 0, a4 = -1 / 0;
              for (const t5 of e7) i6 = Math.min(i6, t5.x), r7 = Math.min(r7, t5.y), o7 = Math.max(o7, t5.x), a4 = Math.max(a4, t5.y);
              const s5 = {};
              for (let e8 = 0; e8 <= t4.a0; e8++) {
                const t5 = Math.pow(2, e8), n6 = Math.floor(i6 * t5), l5 = Math.floor(r7 * t5), c5 = Math.floor(o7 * t5), h4 = Math.floor(a4 * t5);
                s5[e8] = { minTileX: n6, minTileY: l5, maxTileX: c5, maxTileY: h4 };
              }
              return s5;
            }
          }
          class Q2 extends X2 {
            constructor(e7, t5, i6, r7) {
              super(e7, t5, i6, r7), this.roundZoom = true, this.type = "video", this.options = t5;
            }
            load() {
              return t4._(this, void 0, void 0, function* () {
                this._loaded = false;
                const e7 = this.options;
                this.urls = [];
                for (const t5 of e7.urls) this.urls.push(this.map._requestManager.transformRequest(t5, "Source").url);
                try {
                  const e8 = yield t4.a2(this.urls);
                  if (this._loaded = true, !e8) return;
                  this.video = e8, this.video.loop = true, this.video.addEventListener("playing", () => {
                    this.map.triggerRepaint();
                  }), this.map && this.video.play(), this._finishLoading();
                } catch (e8) {
                  this.fire(new t4.k(e8));
                }
              });
            }
            pause() {
              this.video && this.video.pause();
            }
            play() {
              this.video && this.video.play();
            }
            seek(e7) {
              if (this.video) {
                const i6 = this.video.seekable;
                e7 < i6.start(0) || e7 > i6.end(0) ? this.fire(new t4.k(new t4.a3(`sources.${this.id}`, null, `Playback for this video can be set only between the ${i6.start(0)} and ${i6.end(0)}-second mark.`))) : this.video.currentTime = e7;
              }
            }
            getVideo() {
              return this.video;
            }
            onAdd(e7) {
              this.map || (this.map = e7, this.load(), this.video && (this.video.play(), this.setCoordinates(this.coordinates)));
            }
            prepare() {
              if (0 === Object.keys(this.tiles).length || this.video.readyState < 2) return;
              const e7 = this.map.painter.context, i6 = e7.gl;
              this.texture ? this.video.paused || (this.texture.bind(i6.LINEAR, i6.CLAMP_TO_EDGE), i6.texSubImage2D(i6.TEXTURE_2D, 0, 0, 0, i6.RGBA, i6.UNSIGNED_BYTE, this.video)) : (this.texture = new v3(e7, this.video, i6.RGBA), this.texture.bind(i6.LINEAR, i6.CLAMP_TO_EDGE));
              let r7 = false;
              for (const e8 in this.tiles) {
                const t5 = this.tiles[e8];
                "loaded" !== t5.state && (t5.state = "loaded", t5.texture = this.texture, r7 = true);
              }
              r7 && this.fire(new t4.l("data", { dataType: "source", sourceDataType: "idle", sourceId: this.id }));
            }
            serialize() {
              return { type: "video", urls: this.urls, coordinates: this.coordinates };
            }
            hasTransition() {
              return this.video && !this.video.paused;
            }
          }
          class Y2 extends X2 {
            constructor(e7, i6, r7, o7) {
              super(e7, i6, r7, o7), i6.coordinates ? Array.isArray(i6.coordinates) && 4 === i6.coordinates.length && !i6.coordinates.some((e8) => !Array.isArray(e8) || 2 !== e8.length || e8.some((e9) => "number" != typeof e9)) || this.fire(new t4.k(new t4.a3(`sources.${e7}`, null, '"coordinates" property must be an array of 4 longitude/latitude array pairs'))) : this.fire(new t4.k(new t4.a3(`sources.${e7}`, null, 'missing required property "coordinates"'))), i6.animate && "boolean" != typeof i6.animate && this.fire(new t4.k(new t4.a3(`sources.${e7}`, null, 'optional "animate" property must be a boolean value'))), i6.canvas ? "string" == typeof i6.canvas || i6.canvas instanceof HTMLCanvasElement || this.fire(new t4.k(new t4.a3(`sources.${e7}`, null, '"canvas" must be either a string representing the ID of the canvas element from which to read, or an HTMLCanvasElement instance'))) : this.fire(new t4.k(new t4.a3(`sources.${e7}`, null, 'missing required property "canvas"'))), this.options = i6, this.animate = void 0 === i6.animate || i6.animate;
            }
            load() {
              return t4._(this, void 0, void 0, function* () {
                this._loaded = true, this.canvas || (this.canvas = this.options.canvas instanceof HTMLCanvasElement ? this.options.canvas : document.getElementById(this.options.canvas)), this.width = this.canvas.width, this.height = this.canvas.height, this._hasInvalidDimensions() ? this.fire(new t4.k(new Error("Canvas dimensions cannot be less than or equal to zero."))) : (this.play = function() {
                  this._playing = true, this.map.triggerRepaint();
                }, this.pause = function() {
                  this._playing && (this.prepare(), this._playing = false);
                }, this._finishLoading());
              });
            }
            getCanvas() {
              return this.canvas;
            }
            onAdd(e7) {
              this.map = e7, this.load(), this.canvas && this.animate && this.play();
            }
            onRemove() {
              this.pause();
            }
            prepare() {
              let e7 = false;
              if (this.canvas.width !== this.width && (this.width = this.canvas.width, e7 = true), this.canvas.height !== this.height && (this.height = this.canvas.height, e7 = true), this._hasInvalidDimensions()) return;
              if (0 === Object.keys(this.tiles).length) return;
              const i6 = this.map.painter.context, r7 = i6.gl;
              this.texture ? (e7 || this._playing) && this.texture.update(this.canvas, { premultiply: true }) : this.texture = new v3(i6, this.canvas, r7.RGBA, { premultiply: true });
              let o7 = false;
              for (const e8 in this.tiles) {
                const t5 = this.tiles[e8];
                "loaded" !== t5.state && (t5.state = "loaded", t5.texture = this.texture, o7 = true);
              }
              o7 && this.fire(new t4.l("data", { dataType: "source", sourceDataType: "idle", sourceId: this.id }));
            }
            serialize() {
              return { type: "canvas", coordinates: this.coordinates };
            }
            hasTransition() {
              return this._playing;
            }
            _hasInvalidDimensions() {
              for (const e7 of [this.canvas.width, this.canvas.height]) if (isNaN(e7) || e7 <= 0) return true;
              return false;
            }
          }
          const J2 = {}, ee = (e7) => {
            switch (e7) {
              case "geojson":
                return K2;
              case "image":
                return X2;
              case "raster":
                return $2;
              case "raster-dem":
                return H4;
              case "vector":
                return W;
              case "video":
                return Q2;
              case "canvas":
                return Y2;
            }
            return J2[e7];
          }, te = "RTLPluginLoaded";
          class ie2 extends t4.E {
            constructor() {
              super(...arguments), this.status = "unavailable", this.url = null, this.dispatcher = O2();
            }
            _syncState(e7) {
              return this.status = e7, this.dispatcher.broadcast("SRPS", { pluginStatus: e7, pluginURL: this.url }).catch((e8) => {
                throw this.status = "error", e8;
              });
            }
            getRTLTextPluginStatus() {
              return this.status;
            }
            clearRTLTextPlugin() {
              this.status = "unavailable", this.url = null;
            }
            setRTLTextPlugin(e7) {
              return t4._(this, arguments, void 0, function* (e8, t5 = false) {
                if (this.url) throw new Error("setRTLTextPlugin cannot be called multiple times.");
                if (this.url = s4.resolveURL(e8), !this.url) throw new Error(`requested url ${e8} is invalid`);
                if ("unavailable" === this.status) {
                  if (!t5) return this._requestImport();
                  this.status = "deferred", this._syncState(this.status);
                } else if ("requested" === this.status) return this._requestImport();
              });
            }
            _requestImport() {
              return t4._(this, void 0, void 0, function* () {
                yield this._syncState("loading"), this.status = "loaded", this.fire(new t4.l(te));
              });
            }
            lazyLoad() {
              "unavailable" === this.status ? this.status = "requested" : "deferred" === this.status && this._requestImport();
            }
          }
          let re2 = null;
          function oe() {
            return re2 || (re2 = new ie2()), re2;
          }
          class ae {
            constructor(e7, i6) {
              this.timeAdded = 0, this.fadeEndTime = 0, this.tileID = e7, this.uid = t4.a4(), this.uses = 0, this.tileSize = i6, this.buckets = {}, this.expirationTime = null, this.queryPadding = 0, this.hasSymbolBuckets = false, this.hasRTLText = false, this.dependencies = {}, this.rtt = [], this.rttCoords = {}, this.expiredRequestCount = 0, this.state = "loading";
            }
            registerFadeDuration(e7) {
              const t5 = e7 + this.timeAdded;
              t5 < this.fadeEndTime || (this.fadeEndTime = t5);
            }
            wasRequested() {
              return "errored" === this.state || "loaded" === this.state || "reloading" === this.state;
            }
            clearTextures(e7) {
              this.demTexture && e7.saveTileTexture(this.demTexture), this.demTexture = null;
            }
            loadVectorData(e7, i6, r7) {
              if (this.hasData() && this.unloadVectorData(), this.state = "loaded", e7) {
                e7.featureIndex && (this.latestFeatureIndex = e7.featureIndex, e7.rawTileData ? (this.latestRawTileData = e7.rawTileData, this.latestFeatureIndex.rawTileData = e7.rawTileData) : this.latestRawTileData && (this.latestFeatureIndex.rawTileData = this.latestRawTileData)), this.collisionBoxArray = e7.collisionBoxArray, this.buckets = function(e8, t5) {
                  const i7 = {};
                  if (!t5) return i7;
                  for (const r8 of e8) {
                    const e9 = r8.layerIds.map((e10) => t5.getLayer(e10)).filter(Boolean);
                    if (0 !== e9.length) {
                      r8.layers = e9, r8.stateDependentLayerIds && (r8.stateDependentLayers = r8.stateDependentLayerIds.map((t6) => e9.filter((e10) => e10.id === t6)[0]));
                      for (const t6 of e9) i7[t6.id] = r8;
                    }
                  }
                  return i7;
                }(e7.buckets, null == i6 ? void 0 : i6.style), this.hasSymbolBuckets = false;
                for (const e8 in this.buckets) {
                  const i7 = this.buckets[e8];
                  if (i7 instanceof t4.a6) {
                    if (this.hasSymbolBuckets = true, !r7) break;
                    i7.justReloaded = true;
                  }
                }
                if (this.hasRTLText = false, this.hasSymbolBuckets) for (const e8 in this.buckets) {
                  const i7 = this.buckets[e8];
                  if (i7 instanceof t4.a6 && i7.hasRTLText) {
                    this.hasRTLText = true, oe().lazyLoad();
                    break;
                  }
                }
                this.queryPadding = 0;
                for (const e8 in this.buckets) {
                  const t5 = this.buckets[e8];
                  this.queryPadding = Math.max(this.queryPadding, i6.style.getLayer(e8).queryRadius(t5));
                }
                e7.imageAtlas && (this.imageAtlas = e7.imageAtlas), e7.glyphAtlasImage && (this.glyphAtlasImage = e7.glyphAtlasImage);
              } else this.collisionBoxArray = new t4.a5();
            }
            unloadVectorData() {
              for (const e7 in this.buckets) this.buckets[e7].destroy();
              this.buckets = {}, this.imageAtlasTexture && this.imageAtlasTexture.destroy(), this.imageAtlas && (this.imageAtlas = null), this.glyphAtlasTexture && this.glyphAtlasTexture.destroy(), this.latestFeatureIndex = null, this.state = "unloaded";
            }
            getBucket(e7) {
              return this.buckets[e7.id];
            }
            upload(e7) {
              for (const t6 in this.buckets) {
                const i6 = this.buckets[t6];
                i6.uploadPending() && i6.upload(e7);
              }
              const t5 = e7.gl;
              this.imageAtlas && !this.imageAtlas.uploaded && (this.imageAtlasTexture = new v3(e7, this.imageAtlas.image, t5.RGBA), this.imageAtlas.uploaded = true), this.glyphAtlasImage && (this.glyphAtlasTexture = new v3(e7, this.glyphAtlasImage, t5.ALPHA), this.glyphAtlasImage = null);
            }
            prepare(e7) {
              this.imageAtlas && this.imageAtlas.patchUpdatedImages(e7, this.imageAtlasTexture);
            }
            queryRenderedFeatures(e7, t5, i6, r7, o7, a4, s5, n6, l5, c5, h4) {
              return this.latestFeatureIndex && this.latestFeatureIndex.rawTileData ? this.latestFeatureIndex.query({ queryGeometry: r7, cameraQueryGeometry: o7, scale: a4, tileSize: this.tileSize, pixelPosMatrix: c5, transform: n6, params: s5, queryPadding: this.queryPadding * l5, getElevation: h4 }, e7, t5, i6) : {};
            }
            querySourceFeatures(e7, i6) {
              const r7 = this.latestFeatureIndex;
              if (!r7 || !r7.rawTileData) return;
              const o7 = r7.loadVTLayers(), a4 = i6 && i6.sourceLayer ? i6.sourceLayer : "", s5 = o7._geojsonTileLayer || o7[a4];
              if (!s5) return;
              const n6 = t4.a7(i6 && i6.filter), { z: l5, x: c5, y: h4 } = this.tileID.canonical, u4 = { z: l5, x: c5, y: h4 };
              for (let i7 = 0; i7 < s5.length; i7++) {
                const o8 = s5.feature(i7);
                if (n6.needGeometry) {
                  const e8 = t4.a8(o8, true);
                  if (!n6.filter(new t4.C(this.tileID.overscaledZ), e8, this.tileID.canonical)) continue;
                } else if (!n6.filter(new t4.C(this.tileID.overscaledZ), o8)) continue;
                const d4 = r7.getId(o8, a4), _4 = new t4.a9(o8, l5, c5, h4, d4);
                _4.tile = u4, e7.push(_4);
              }
            }
            hasData() {
              return "loaded" === this.state || "reloading" === this.state || "expired" === this.state;
            }
            patternsLoaded() {
              return this.imageAtlas && !!Object.keys(this.imageAtlas.patternPositions).length;
            }
            setExpiryData(e7) {
              const i6 = this.expirationTime;
              if (e7.cacheControl) {
                const i7 = t4.aa(e7.cacheControl);
                i7["max-age"] && (this.expirationTime = Date.now() + 1e3 * i7["max-age"]);
              } else e7.expires && (this.expirationTime = new Date(e7.expires).getTime());
              if (this.expirationTime) {
                const e8 = Date.now();
                let t5 = false;
                if (this.expirationTime > e8) t5 = false;
                else if (i6) if (this.expirationTime < i6) t5 = true;
                else {
                  const r7 = this.expirationTime - i6;
                  r7 ? this.expirationTime = e8 + Math.max(r7, 3e4) : t5 = true;
                }
                else t5 = true;
                t5 ? (this.expiredRequestCount++, this.state = "expired") : this.expiredRequestCount = 0;
              }
            }
            getExpiryTimeout() {
              if (this.expirationTime) return this.expiredRequestCount ? 1e3 * (1 << Math.min(this.expiredRequestCount - 1, 31)) : Math.min(this.expirationTime - (/* @__PURE__ */ new Date()).getTime(), Math.pow(2, 31) - 1);
            }
            setFeatureState(e7, t5) {
              if (!this.latestFeatureIndex || !this.latestFeatureIndex.rawTileData || 0 === Object.keys(e7).length) return;
              const i6 = this.latestFeatureIndex.loadVTLayers();
              for (const r7 in this.buckets) {
                if (!t5.style.hasLayer(r7)) continue;
                const o7 = this.buckets[r7], a4 = o7.layers[0].sourceLayer || "_geojsonTileLayer", s5 = i6[a4], n6 = e7[a4];
                if (!s5 || !n6 || 0 === Object.keys(n6).length) continue;
                o7.update(n6, s5, this.imageAtlas && this.imageAtlas.patternPositions || {});
                const l5 = t5 && t5.style && t5.style.getLayer(r7);
                l5 && (this.queryPadding = Math.max(this.queryPadding, l5.queryRadius(o7)));
              }
            }
            holdingForFade() {
              return void 0 !== this.symbolFadeHoldUntil;
            }
            symbolFadeFinished() {
              return !this.symbolFadeHoldUntil || this.symbolFadeHoldUntil < s4.now();
            }
            clearFadeHold() {
              this.symbolFadeHoldUntil = void 0;
            }
            setHoldDuration(e7) {
              this.symbolFadeHoldUntil = s4.now() + e7;
            }
            setDependencies(e7, t5) {
              const i6 = {};
              for (const e8 of t5) i6[e8] = true;
              this.dependencies[e7] = i6;
            }
            hasDependency(e7, t5) {
              for (const i6 of e7) {
                const e8 = this.dependencies[i6];
                if (e8) {
                  for (const i7 of t5) if (e8[i7]) return true;
                }
              }
              return false;
            }
          }
          class se {
            constructor(e7, t5) {
              this.max = e7, this.onRemove = t5, this.reset();
            }
            reset() {
              for (const e7 in this.data) for (const t5 of this.data[e7]) t5.timeout && clearTimeout(t5.timeout), this.onRemove(t5.value);
              return this.data = {}, this.order = [], this;
            }
            add(e7, t5, i6) {
              const r7 = e7.wrapped().key;
              void 0 === this.data[r7] && (this.data[r7] = []);
              const o7 = { value: t5, timeout: void 0 };
              if (void 0 !== i6 && (o7.timeout = setTimeout(() => {
                this.remove(e7, o7);
              }, i6)), this.data[r7].push(o7), this.order.push(r7), this.order.length > this.max) {
                const e8 = this._getAndRemoveByKey(this.order[0]);
                e8 && this.onRemove(e8);
              }
              return this;
            }
            has(e7) {
              return e7.wrapped().key in this.data;
            }
            getAndRemove(e7) {
              return this.has(e7) ? this._getAndRemoveByKey(e7.wrapped().key) : null;
            }
            _getAndRemoveByKey(e7) {
              const t5 = this.data[e7].shift();
              return t5.timeout && clearTimeout(t5.timeout), 0 === this.data[e7].length && delete this.data[e7], this.order.splice(this.order.indexOf(e7), 1), t5.value;
            }
            getByKey(e7) {
              const t5 = this.data[e7];
              return t5 ? t5[0].value : null;
            }
            get(e7) {
              return this.has(e7) ? this.data[e7.wrapped().key][0].value : null;
            }
            remove(e7, t5) {
              if (!this.has(e7)) return this;
              const i6 = e7.wrapped().key, r7 = void 0 === t5 ? 0 : this.data[i6].indexOf(t5), o7 = this.data[i6][r7];
              return this.data[i6].splice(r7, 1), o7.timeout && clearTimeout(o7.timeout), 0 === this.data[i6].length && delete this.data[i6], this.onRemove(o7.value), this.order.splice(this.order.indexOf(i6), 1), this;
            }
            setMaxSize(e7) {
              for (this.max = e7; this.order.length > this.max; ) {
                const e8 = this._getAndRemoveByKey(this.order[0]);
                e8 && this.onRemove(e8);
              }
              return this;
            }
            filter(e7) {
              const t5 = [];
              for (const i6 in this.data) for (const r7 of this.data[i6]) e7(r7.value) || t5.push(r7);
              for (const e8 of t5) this.remove(e8.value.tileID, e8);
            }
          }
          class ne {
            constructor() {
              this.state = {}, this.stateChanges = {}, this.deletedStates = {};
            }
            updateState(e7, i6, r7) {
              const o7 = String(i6);
              if (this.stateChanges[e7] = this.stateChanges[e7] || {}, this.stateChanges[e7][o7] = this.stateChanges[e7][o7] || {}, t4.e(this.stateChanges[e7][o7], r7), null === this.deletedStates[e7]) {
                this.deletedStates[e7] = {};
                for (const t5 in this.state[e7]) t5 !== o7 && (this.deletedStates[e7][t5] = null);
              } else if (this.deletedStates[e7] && null === this.deletedStates[e7][o7]) {
                this.deletedStates[e7][o7] = {};
                for (const t5 in this.state[e7][o7]) r7[t5] || (this.deletedStates[e7][o7][t5] = null);
              } else for (const t5 in r7) this.deletedStates[e7] && this.deletedStates[e7][o7] && null === this.deletedStates[e7][o7][t5] && delete this.deletedStates[e7][o7][t5];
            }
            removeFeatureState(e7, t5, i6) {
              if (null === this.deletedStates[e7]) return;
              const r7 = String(t5);
              if (this.deletedStates[e7] = this.deletedStates[e7] || {}, i6 && void 0 !== t5) null !== this.deletedStates[e7][r7] && (this.deletedStates[e7][r7] = this.deletedStates[e7][r7] || {}, this.deletedStates[e7][r7][i6] = null);
              else if (void 0 !== t5) if (this.stateChanges[e7] && this.stateChanges[e7][r7]) for (i6 in this.deletedStates[e7][r7] = {}, this.stateChanges[e7][r7]) this.deletedStates[e7][r7][i6] = null;
              else this.deletedStates[e7][r7] = null;
              else this.deletedStates[e7] = null;
            }
            getState(e7, i6) {
              const r7 = String(i6), o7 = t4.e({}, (this.state[e7] || {})[r7], (this.stateChanges[e7] || {})[r7]);
              if (null === this.deletedStates[e7]) return {};
              if (this.deletedStates[e7]) {
                const t5 = this.deletedStates[e7][i6];
                if (null === t5) return {};
                for (const e8 in t5) delete o7[e8];
              }
              return o7;
            }
            initializeTileState(e7, t5) {
              e7.setFeatureState(this.state, t5);
            }
            coalesceChanges(e7, i6) {
              const r7 = {};
              for (const e8 in this.stateChanges) {
                this.state[e8] = this.state[e8] || {};
                const i7 = {};
                for (const r8 in this.stateChanges[e8]) this.state[e8][r8] || (this.state[e8][r8] = {}), t4.e(this.state[e8][r8], this.stateChanges[e8][r8]), i7[r8] = this.state[e8][r8];
                r7[e8] = i7;
              }
              for (const e8 in this.deletedStates) {
                this.state[e8] = this.state[e8] || {};
                const i7 = {};
                if (null === this.deletedStates[e8]) for (const t5 in this.state[e8]) i7[t5] = {}, this.state[e8][t5] = {};
                else for (const t5 in this.deletedStates[e8]) {
                  if (null === this.deletedStates[e8][t5]) this.state[e8][t5] = {};
                  else for (const i8 of Object.keys(this.deletedStates[e8][t5])) delete this.state[e8][t5][i8];
                  i7[t5] = this.state[e8][t5];
                }
                r7[e8] = r7[e8] || {}, t4.e(r7[e8], i7);
              }
              if (this.stateChanges = {}, this.deletedStates = {}, 0 !== Object.keys(r7).length) for (const t5 in e7) e7[t5].setFeatureState(r7, i6);
            }
          }
          function le(e7, t5, i6) {
            const r7 = t5.intersectsFrustum(e7);
            if (!i6) return r7;
            const o7 = t5.intersectsPlane(i6);
            return 0 === r7 || 0 === o7 ? 0 : 2 === r7 && 2 === o7 ? 2 : 1;
          }
          function ce(e7, i6, r7, o7, a4) {
            let s5 = e7;
            const n6 = Math.atan(i6 / r7), l5 = Math.hypot(i6, r7);
            return s5 = e7 + t4.ab(o7 / l5 / Math.max(0.5, Math.cos(t4.ad(a4 / 2)))), s5 += 1 * t4.ab(Math.cos(n6)) / 2, s5 += t4.ae(e7 - s5, -0, 0), s5;
          }
          function he(e7, i6) {
            const r7 = (i6.roundZoom ? Math.round : Math.floor)(e7.zoom + t4.ab(e7.tileSize / i6.tileSize));
            return Math.max(0, r7);
          }
          function ue(e7, i6) {
            const r7 = e7.getCameraFrustum(), o7 = e7.getClippingPlane(), a4 = e7.screenPointToMercatorCoordinate(e7.getCameraPoint()), s5 = t4.$.fromLngLat(e7.center, e7.elevation);
            a4.z = s5.z + Math.cos(e7.pitchInRadians) * e7.cameraToCenterDistance / e7.worldSize;
            const n6 = e7.getCoveringTilesDetailsProvider(), l5 = n6.allowVariableZoom(e7, i6), c5 = he(e7, i6), h4 = i6.minzoom || 0, u4 = void 0 !== i6.maxzoom ? i6.maxzoom : e7.maxZoom, d4 = Math.min(Math.max(0, c5), u4), _4 = Math.pow(2, d4), p4 = [_4 * a4.x, _4 * a4.y, 0], m4 = [_4 * s5.x, _4 * s5.y, 0], f4 = Math.hypot(s5.x - a4.x, s5.y - a4.y), g4 = Math.abs(s5.z - a4.z), v4 = Math.hypot(f4, g4), x4 = (e8) => ({ zoom: 0, x: 0, y: 0, wrap: e8, fullyVisible: false }), b5 = [], y4 = [];
            if (e7.renderWorldCopies && n6.allowWorldCopies()) for (let e8 = 1; e8 <= 3; e8++) b5.push(x4(-e8)), b5.push(x4(e8));
            for (b5.push(x4(0)); b5.length > 0; ) {
              const _5 = b5.pop(), f5 = _5.x, x5 = _5.y;
              let w4 = _5.fullyVisible;
              const T5 = { x: f5, y: x5, z: _5.zoom }, P4 = n6.getTileAABB(T5, _5.wrap, e7.elevation, i6);
              if (!w4) {
                const e8 = le(r7, P4, o7);
                if (0 === e8) continue;
                w4 = 2 === e8;
              }
              const C4 = n6.distanceToTile2d(a4.x, a4.y, T5, P4);
              let I4 = c5;
              l5 && (I4 = (i6.calculateTileZoom || ce)(e7.zoom + t4.ab(e7.tileSize / i6.tileSize), C4, g4, v4, e7.fov)), I4 = (i6.roundZoom ? Math.round : Math.floor)(I4), I4 = Math.max(0, I4);
              const M5 = Math.min(I4, u4);
              if (_5.wrap = n6.getWrap(s5, T5, _5.wrap), _5.zoom >= M5) {
                if (_5.zoom < h4) continue;
                const e8 = d4 - _5.zoom, r8 = p4[0] - 0.5 - (f5 << e8), o8 = p4[1] - 0.5 - (x5 << e8), a5 = i6.reparseOverscaled ? Math.max(_5.zoom, I4) : _5.zoom;
                y4.push({ tileID: new t4.Y(_5.zoom === u4 ? a5 : _5.zoom, _5.wrap, _5.zoom, f5, x5), distanceSq: t4.ac([m4[0] - 0.5 - f5, m4[1] - 0.5 - x5]), tileDistanceToCamera: Math.sqrt(r8 * r8 + o8 * o8) });
              } else for (let e8 = 0; e8 < 4; e8++) b5.push({ zoom: _5.zoom + 1, x: (f5 << 1) + e8 % 2, y: (x5 << 1) + (e8 >> 1), wrap: _5.wrap, fullyVisible: w4 });
            }
            return y4.sort((e8, t5) => e8.distanceSq - t5.distanceSq).map((e8) => e8.tileID);
          }
          class de extends t4.E {
            constructor(e7, t5, i6) {
              super(), this.id = e7, this.dispatcher = i6, this.on("data", (e8) => this._dataHandler(e8)), this.on("dataloading", () => {
                this._sourceErrored = false;
              }), this.on("error", () => {
                this._sourceErrored = this._source.loaded();
              }), this._source = ((e8, t6, i7, r7) => {
                const o7 = new (ee(t6.type))(e8, t6, i7, r7);
                if (o7.id !== e8) throw new Error(`Expected Source id to be ${e8} instead of ${o7.id}`);
                return o7;
              })(e7, t5, i6, this), this._tiles = {}, this._cache = new se(0, (e8) => this._unloadTile(e8)), this._timers = {}, this._cacheTimers = {}, this._maxTileCacheSize = null, this._maxTileCacheZoomLevels = null, this._loadedParentTiles = {}, this._coveredTiles = {}, this._state = new ne(), this._didEmitContent = false, this._updated = false;
            }
            onAdd(e7) {
              this.map = e7, this._maxTileCacheSize = e7 ? e7._maxTileCacheSize : null, this._maxTileCacheZoomLevels = e7 ? e7._maxTileCacheZoomLevels : null, this._source && this._source.onAdd && this._source.onAdd(e7);
            }
            onRemove(e7) {
              this.clearTiles(), this._source && this._source.onRemove && this._source.onRemove(e7);
            }
            loaded() {
              if (this._sourceErrored) return true;
              if (!this._sourceLoaded) return false;
              if (!this._source.loaded()) return false;
              if (!(void 0 === this.used && void 0 === this.usedForTerrain || this.used || this.usedForTerrain)) return true;
              if (!this._updated) return false;
              for (const e7 in this._tiles) {
                const t5 = this._tiles[e7];
                if ("loaded" !== t5.state && "errored" !== t5.state) return false;
              }
              return true;
            }
            getSource() {
              return this._source;
            }
            pause() {
              this._paused = true;
            }
            resume() {
              if (!this._paused) return;
              const e7 = this._shouldReloadOnResume;
              this._paused = false, this._shouldReloadOnResume = false, e7 && this.reload(), this.transform && this.update(this.transform, this.terrain);
            }
            _loadTile(e7, i6, r7) {
              return t4._(this, void 0, void 0, function* () {
                try {
                  yield this._source.loadTile(e7), this._tileLoaded(e7, i6, r7);
                } catch (i7) {
                  e7.state = "errored", 404 !== i7.status ? this._source.fire(new t4.k(i7, { tile: e7 })) : this.update(this.transform, this.terrain);
                }
              });
            }
            _unloadTile(e7) {
              this._source.unloadTile && this._source.unloadTile(e7);
            }
            _abortTile(e7) {
              this._source.abortTile && this._source.abortTile(e7), this._source.fire(new t4.l("dataabort", { tile: e7, coord: e7.tileID, dataType: "source" }));
            }
            serialize() {
              return this._source.serialize();
            }
            prepare(e7) {
              this._source.prepare && this._source.prepare(), this._state.coalesceChanges(this._tiles, this.map ? this.map.painter : null);
              for (const t5 in this._tiles) {
                const i6 = this._tiles[t5];
                i6.upload(e7), i6.prepare(this.map.style.imageManager);
              }
            }
            getIds() {
              return Object.values(this._tiles).map((e7) => e7.tileID).sort(_e).map((e7) => e7.key);
            }
            getRenderableIds(e7) {
              const i6 = [];
              for (const t5 in this._tiles) this._isIdRenderable(t5, e7) && i6.push(this._tiles[t5]);
              return e7 ? i6.sort((e8, i7) => {
                const r7 = e8.tileID, o7 = i7.tileID, a4 = new t4.P(r7.canonical.x, r7.canonical.y)._rotate(-this.transform.bearingInRadians), s5 = new t4.P(o7.canonical.x, o7.canonical.y)._rotate(-this.transform.bearingInRadians);
                return r7.overscaledZ - o7.overscaledZ || s5.y - a4.y || s5.x - a4.x;
              }).map((e8) => e8.tileID.key) : i6.map((e8) => e8.tileID).sort(_e).map((e8) => e8.key);
            }
            hasRenderableParent(e7) {
              const t5 = this.findLoadedParent(e7, 0);
              return !!t5 && this._isIdRenderable(t5.tileID.key);
            }
            _isIdRenderable(e7, t5) {
              return this._tiles[e7] && this._tiles[e7].hasData() && !this._coveredTiles[e7] && (t5 || !this._tiles[e7].holdingForFade());
            }
            reload(e7) {
              if (this._paused) this._shouldReloadOnResume = true;
              else {
                this._cache.reset();
                for (const t5 in this._tiles) (e7 || "errored" !== this._tiles[t5].state) && this._reloadTile(t5, "reloading");
              }
            }
            _reloadTile(e7, i6) {
              return t4._(this, void 0, void 0, function* () {
                const t5 = this._tiles[e7];
                t5 && ("loading" !== t5.state && (t5.state = i6), yield this._loadTile(t5, e7, i6));
              });
            }
            _tileLoaded(e7, i6, r7) {
              e7.timeAdded = s4.now(), "expired" === r7 && (e7.refreshedUponExpiration = true), this._setTileReloadTimer(i6, e7), "raster-dem" === this.getSource().type && e7.dem && this._backfillDEM(e7), this._state.initializeTileState(e7, this.map ? this.map.painter : null), e7.aborted || this._source.fire(new t4.l("data", { dataType: "source", tile: e7, coord: e7.tileID }));
            }
            _backfillDEM(e7) {
              const t5 = this.getRenderableIds();
              for (let r7 = 0; r7 < t5.length; r7++) {
                const o7 = t5[r7];
                if (e7.neighboringTiles && e7.neighboringTiles[o7]) {
                  const t6 = this.getTileByID(o7);
                  i6(e7, t6), i6(t6, e7);
                }
              }
              function i6(e8, t6) {
                e8.needsHillshadePrepare = true, e8.needsTerrainPrepare = true;
                let i7 = t6.tileID.canonical.x - e8.tileID.canonical.x;
                const r7 = t6.tileID.canonical.y - e8.tileID.canonical.y, o7 = Math.pow(2, e8.tileID.canonical.z), a4 = t6.tileID.key;
                0 === i7 && 0 === r7 || Math.abs(r7) > 1 || (Math.abs(i7) > 1 && (1 === Math.abs(i7 + o7) ? i7 += o7 : 1 === Math.abs(i7 - o7) && (i7 -= o7)), t6.dem && e8.dem && (e8.dem.backfillBorder(t6.dem, i7, r7), e8.neighboringTiles && e8.neighboringTiles[a4] && (e8.neighboringTiles[a4].backfilled = true)));
              }
            }
            getTile(e7) {
              return this.getTileByID(e7.key);
            }
            getTileByID(e7) {
              return this._tiles[e7];
            }
            _retainLoadedChildren(e7, t5, i6, r7) {
              for (const o7 in this._tiles) {
                let a4 = this._tiles[o7];
                if (r7[o7] || !a4.hasData() || a4.tileID.overscaledZ <= t5 || a4.tileID.overscaledZ > i6) continue;
                let s5 = a4.tileID;
                for (; a4 && a4.tileID.overscaledZ > t5 + 1; ) {
                  const e8 = a4.tileID.scaledTo(a4.tileID.overscaledZ - 1);
                  a4 = this._tiles[e8.key], a4 && a4.hasData() && (s5 = e8);
                }
                let n6 = s5;
                for (; n6.overscaledZ > t5; ) if (n6 = n6.scaledTo(n6.overscaledZ - 1), e7[n6.key] || e7[n6.canonical.key]) {
                  r7[s5.key] = s5;
                  break;
                }
              }
            }
            findLoadedParent(e7, t5) {
              if (e7.key in this._loadedParentTiles) {
                const i6 = this._loadedParentTiles[e7.key];
                return i6 && i6.tileID.overscaledZ >= t5 ? i6 : null;
              }
              for (let i6 = e7.overscaledZ - 1; i6 >= t5; i6--) {
                const t6 = e7.scaledTo(i6), r7 = this._getLoadedTile(t6);
                if (r7) return r7;
              }
            }
            findLoadedSibling(e7) {
              return this._getLoadedTile(e7);
            }
            _getLoadedTile(e7) {
              const t5 = this._tiles[e7.key];
              return t5 && t5.hasData() ? t5 : this._cache.getByKey(e7.wrapped().key);
            }
            updateCacheSize(e7) {
              const i6 = Math.ceil(e7.width / this._source.tileSize) + 1, r7 = Math.ceil(e7.height / this._source.tileSize) + 1, o7 = Math.floor(i6 * r7 * (null === this._maxTileCacheZoomLevels ? t4.a.MAX_TILE_CACHE_ZOOM_LEVELS : this._maxTileCacheZoomLevels)), a4 = "number" == typeof this._maxTileCacheSize ? Math.min(this._maxTileCacheSize, o7) : o7;
              this._cache.setMaxSize(a4);
            }
            handleWrapJump(e7) {
              const t5 = Math.round((e7 - (void 0 === this._prevLng ? e7 : this._prevLng)) / 360);
              if (this._prevLng = e7, t5) {
                const e8 = {};
                for (const i6 in this._tiles) {
                  const r7 = this._tiles[i6];
                  r7.tileID = r7.tileID.unwrapTo(r7.tileID.wrap + t5), e8[r7.tileID.key] = r7;
                }
                this._tiles = e8;
                for (const e9 in this._timers) clearTimeout(this._timers[e9]), delete this._timers[e9];
                for (const e9 in this._tiles) this._setTileReloadTimer(e9, this._tiles[e9]);
              }
            }
            _updateCoveredAndRetainedTiles(e7, t5, i6, r7, o7, a4) {
              const n6 = {}, l5 = {}, c5 = Object.keys(e7), h4 = s4.now();
              for (const i7 of c5) {
                const r8 = e7[i7], o8 = this._tiles[i7];
                if (!o8 || 0 !== o8.fadeEndTime && o8.fadeEndTime <= h4) continue;
                const a5 = this.findLoadedParent(r8, t5), s5 = this.findLoadedSibling(r8), c6 = a5 || s5 || null;
                c6 && (this._addTile(c6.tileID), n6[c6.tileID.key] = c6.tileID), l5[i7] = r8;
              }
              this._retainLoadedChildren(l5, r7, i6, e7);
              for (const t6 in n6) e7[t6] || (this._coveredTiles[t6] = true, e7[t6] = n6[t6]);
              if (a4) {
                const t6 = {}, i7 = {};
                for (const e8 of o7) this._tiles[e8.key].hasData() ? t6[e8.key] = e8 : i7[e8.key] = e8;
                for (const r8 in i7) {
                  const o8 = i7[r8].children(this._source.maxzoom);
                  this._tiles[o8[0].key] && this._tiles[o8[1].key] && this._tiles[o8[2].key] && this._tiles[o8[3].key] && (t6[o8[0].key] = e7[o8[0].key] = o8[0], t6[o8[1].key] = e7[o8[1].key] = o8[1], t6[o8[2].key] = e7[o8[2].key] = o8[2], t6[o8[3].key] = e7[o8[3].key] = o8[3], delete i7[r8]);
                }
                for (const r8 in i7) {
                  const o8 = i7[r8], a5 = this.findLoadedParent(o8, this._source.minzoom), s5 = this.findLoadedSibling(o8), n7 = a5 || s5 || null;
                  if (n7) {
                    t6[n7.tileID.key] = e7[n7.tileID.key] = n7.tileID;
                    for (const e8 in t6) t6[e8].isChildOf(n7.tileID) && delete t6[e8];
                  }
                }
                for (const e8 in this._tiles) t6[e8] || (this._coveredTiles[e8] = true);
              }
            }
            update(e7, i6) {
              if (!this._sourceLoaded || this._paused) return;
              let r7;
              this.transform = e7, this.terrain = i6, this.updateCacheSize(e7), this.handleWrapJump(this.transform.center.lng), this._coveredTiles = {}, this.used || this.usedForTerrain ? this._source.tileID ? r7 = e7.getVisibleUnwrappedCoordinates(this._source.tileID).map((e8) => new t4.Y(e8.canonical.z, e8.wrap, e8.canonical.z, e8.canonical.x, e8.canonical.y)) : (r7 = ue(e7, { tileSize: this.usedForTerrain ? this.tileSize : this._source.tileSize, minzoom: this._source.minzoom, maxzoom: this._source.maxzoom, roundZoom: !this.usedForTerrain && this._source.roundZoom, reparseOverscaled: this._source.reparseOverscaled, terrain: i6, calculateTileZoom: this._source.calculateTileZoom }), this._source.hasTile && (r7 = r7.filter((e8) => this._source.hasTile(e8)))) : r7 = [];
              const o7 = he(e7, this._source), a4 = Math.max(o7 - de.maxOverzooming, this._source.minzoom), s5 = Math.max(o7 + de.maxUnderzooming, this._source.minzoom);
              if (this.usedForTerrain) {
                const e8 = {};
                for (const t5 of r7) if (t5.canonical.z > this._source.minzoom) {
                  const i7 = t5.scaledTo(t5.canonical.z - 1);
                  e8[i7.key] = i7;
                  const r8 = t5.scaledTo(Math.max(this._source.minzoom, Math.min(t5.canonical.z, 5)));
                  e8[r8.key] = r8;
                }
                r7 = r7.concat(Object.values(e8));
              }
              const n6 = 0 === r7.length && !this._updated && this._didEmitContent;
              this._updated = true, n6 && this.fire(new t4.l("data", { sourceDataType: "idle", dataType: "source", sourceId: this.id }));
              const l5 = this._updateRetainedTiles(r7, o7);
              pe(this._source.type) && this._updateCoveredAndRetainedTiles(l5, a4, s5, o7, r7, i6);
              for (const e8 in l5) this._tiles[e8].clearFadeHold();
              const c5 = t4.af(this._tiles, l5);
              for (const e8 of c5) {
                const t5 = this._tiles[e8];
                t5.hasSymbolBuckets && !t5.holdingForFade() ? t5.setHoldDuration(this.map._fadeDuration) : t5.hasSymbolBuckets && !t5.symbolFadeFinished() || this._removeTile(e8);
              }
              this._updateLoadedParentTileCache(), this._updateLoadedSiblingTileCache();
            }
            releaseSymbolFadeTiles() {
              for (const e7 in this._tiles) this._tiles[e7].holdingForFade() && this._removeTile(e7);
            }
            _updateRetainedTiles(e7, t5) {
              var i6;
              const r7 = {}, o7 = {}, a4 = Math.max(t5 - de.maxOverzooming, this._source.minzoom), s5 = Math.max(t5 + de.maxUnderzooming, this._source.minzoom), n6 = {};
              for (const i7 of e7) {
                const e8 = this._addTile(i7);
                r7[i7.key] = i7, e8.hasData() || t5 < this._source.maxzoom && (n6[i7.key] = i7);
              }
              this._retainLoadedChildren(n6, t5, s5, r7);
              for (const s6 of e7) {
                let e8 = this._tiles[s6.key];
                if (e8.hasData()) continue;
                if (t5 + 1 > this._source.maxzoom) {
                  const e9 = s6.children(this._source.maxzoom)[0], t6 = this.getTile(e9);
                  if (t6 && t6.hasData()) {
                    r7[e9.key] = e9;
                    continue;
                  }
                } else {
                  const e9 = s6.children(this._source.maxzoom);
                  if (r7[e9[0].key] && r7[e9[1].key] && r7[e9[2].key] && r7[e9[3].key]) continue;
                }
                let n7 = e8.wasRequested();
                for (let t6 = s6.overscaledZ - 1; t6 >= a4; --t6) {
                  const a5 = s6.scaledTo(t6);
                  if (o7[a5.key]) break;
                  if (o7[a5.key] = true, e8 = this.getTile(a5), !e8 && n7 && (e8 = this._addTile(a5)), e8) {
                    const t7 = e8.hasData();
                    if ((t7 || !(null === (i6 = this.map) || void 0 === i6 ? void 0 : i6.cancelPendingTileRequestsWhileZooming) || n7) && (r7[a5.key] = a5), n7 = e8.wasRequested(), t7) break;
                  }
                }
              }
              return r7;
            }
            _updateLoadedParentTileCache() {
              this._loadedParentTiles = {};
              for (const e7 in this._tiles) {
                const t5 = [];
                let i6, r7 = this._tiles[e7].tileID;
                for (; r7.overscaledZ > 0; ) {
                  if (r7.key in this._loadedParentTiles) {
                    i6 = this._loadedParentTiles[r7.key];
                    break;
                  }
                  t5.push(r7.key);
                  const e8 = r7.scaledTo(r7.overscaledZ - 1);
                  if (i6 = this._getLoadedTile(e8), i6) break;
                  r7 = e8;
                }
                for (const e8 of t5) this._loadedParentTiles[e8] = i6;
              }
            }
            _updateLoadedSiblingTileCache() {
              this._loadedSiblingTiles = {};
              for (const e7 in this._tiles) {
                const t5 = this._tiles[e7].tileID, i6 = this._getLoadedTile(t5);
                this._loadedSiblingTiles[t5.key] = i6;
              }
            }
            _addTile(e7) {
              let i6 = this._tiles[e7.key];
              if (i6) return i6;
              i6 = this._cache.getAndRemove(e7), i6 && (this._setTileReloadTimer(e7.key, i6), i6.tileID = e7, this._state.initializeTileState(i6, this.map ? this.map.painter : null), this._cacheTimers[e7.key] && (clearTimeout(this._cacheTimers[e7.key]), delete this._cacheTimers[e7.key], this._setTileReloadTimer(e7.key, i6)));
              const r7 = i6;
              return i6 || (i6 = new ae(e7, this._source.tileSize * e7.overscaleFactor()), this._loadTile(i6, e7.key, i6.state)), i6.uses++, this._tiles[e7.key] = i6, r7 || this._source.fire(new t4.l("dataloading", { tile: i6, coord: i6.tileID, dataType: "source" })), i6;
            }
            _setTileReloadTimer(e7, t5) {
              e7 in this._timers && (clearTimeout(this._timers[e7]), delete this._timers[e7]);
              const i6 = t5.getExpiryTimeout();
              i6 && (this._timers[e7] = setTimeout(() => {
                this._reloadTile(e7, "expired"), delete this._timers[e7];
              }, i6));
            }
            _removeTile(e7) {
              const t5 = this._tiles[e7];
              t5 && (t5.uses--, delete this._tiles[e7], this._timers[e7] && (clearTimeout(this._timers[e7]), delete this._timers[e7]), t5.uses > 0 || (t5.hasData() && "reloading" !== t5.state ? this._cache.add(t5.tileID, t5, t5.getExpiryTimeout()) : (t5.aborted = true, this._abortTile(t5), this._unloadTile(t5))));
            }
            _dataHandler(e7) {
              const t5 = e7.sourceDataType;
              "source" === e7.dataType && "metadata" === t5 && (this._sourceLoaded = true), this._sourceLoaded && !this._paused && "source" === e7.dataType && "content" === t5 && (this.reload(e7.sourceDataChanged), this.transform && this.update(this.transform, this.terrain), this._didEmitContent = true);
            }
            clearTiles() {
              this._shouldReloadOnResume = false, this._paused = false;
              for (const e7 in this._tiles) this._removeTile(e7);
              this._cache.reset();
            }
            tilesIn(e7, i6, r7) {
              const o7 = [], a4 = this.transform;
              if (!a4) return o7;
              const s5 = r7 ? a4.getCameraQueryGeometry(e7) : e7, n6 = e7.map((e8) => a4.screenPointToMercatorCoordinate(e8, this.terrain)), l5 = s5.map((e8) => a4.screenPointToMercatorCoordinate(e8, this.terrain)), c5 = this.getIds();
              let h4 = 1 / 0, u4 = 1 / 0, d4 = -1 / 0, _4 = -1 / 0;
              for (const e8 of l5) h4 = Math.min(h4, e8.x), u4 = Math.min(u4, e8.y), d4 = Math.max(d4, e8.x), _4 = Math.max(_4, e8.y);
              for (let e8 = 0; e8 < c5.length; e8++) {
                const r8 = this._tiles[c5[e8]];
                if (r8.holdingForFade()) continue;
                const s6 = r8.tileID, p4 = Math.pow(2, a4.zoom - r8.tileID.overscaledZ), m4 = i6 * r8.queryPadding * t4.Z / r8.tileSize / p4, f4 = [s6.getTilePoint(new t4.$(h4, u4)), s6.getTilePoint(new t4.$(d4, _4))];
                if (f4[0].x - m4 < t4.Z && f4[0].y - m4 < t4.Z && f4[1].x + m4 >= 0 && f4[1].y + m4 >= 0) {
                  const e9 = n6.map((e10) => s6.getTilePoint(e10)), t5 = l5.map((e10) => s6.getTilePoint(e10));
                  o7.push({ tile: r8, tileID: s6, queryGeometry: e9, cameraQueryGeometry: t5, scale: p4 });
                }
              }
              return o7;
            }
            getVisibleCoordinates(e7) {
              const t5 = this.getRenderableIds(e7).map((e8) => this._tiles[e8].tileID);
              return this.transform && this.transform.populateCache(t5), t5;
            }
            hasTransition() {
              if (this._source.hasTransition()) return true;
              if (pe(this._source.type)) {
                const e7 = s4.now();
                for (const t5 in this._tiles) if (this._tiles[t5].fadeEndTime >= e7) return true;
              }
              return false;
            }
            setFeatureState(e7, t5, i6) {
              this._state.updateState(e7 = e7 || "_geojsonTileLayer", t5, i6);
            }
            removeFeatureState(e7, t5, i6) {
              this._state.removeFeatureState(e7 = e7 || "_geojsonTileLayer", t5, i6);
            }
            getFeatureState(e7, t5) {
              return this._state.getState(e7 = e7 || "_geojsonTileLayer", t5);
            }
            setDependencies(e7, t5, i6) {
              const r7 = this._tiles[e7];
              r7 && r7.setDependencies(t5, i6);
            }
            reloadTilesForDependencies(e7, t5) {
              for (const i6 in this._tiles) this._tiles[i6].hasDependency(e7, t5) && this._reloadTile(i6, "reloading");
              this._cache.filter((i6) => !i6.hasDependency(e7, t5));
            }
          }
          function _e(e7, t5) {
            const i6 = Math.abs(2 * e7.wrap) - +(e7.wrap < 0), r7 = Math.abs(2 * t5.wrap) - +(t5.wrap < 0);
            return e7.overscaledZ - t5.overscaledZ || r7 - i6 || t5.canonical.y - e7.canonical.y || t5.canonical.x - e7.canonical.x;
          }
          function pe(e7) {
            return "raster" === e7 || "image" === e7 || "video" === e7;
          }
          de.maxOverzooming = 10, de.maxUnderzooming = 3;
          class me {
            constructor(e7, t5) {
              this.reset(e7, t5);
            }
            reset(e7, t5) {
              this.points = e7 || [], this._distances = [0];
              for (let e8 = 1; e8 < this.points.length; e8++) this._distances[e8] = this._distances[e8 - 1] + this.points[e8].dist(this.points[e8 - 1]);
              this.length = this._distances[this._distances.length - 1], this.padding = Math.min(t5 || 0, 0.5 * this.length), this.paddedLength = this.length - 2 * this.padding;
            }
            lerp(e7) {
              if (1 === this.points.length) return this.points[0];
              e7 = t4.ae(e7, 0, 1);
              let i6 = 1, r7 = this._distances[i6];
              const o7 = e7 * this.paddedLength + this.padding;
              for (; r7 < o7 && i6 < this._distances.length; ) r7 = this._distances[++i6];
              const a4 = i6 - 1, s5 = this._distances[a4], n6 = r7 - s5, l5 = n6 > 0 ? (o7 - s5) / n6 : 0;
              return this.points[a4].mult(1 - l5).add(this.points[i6].mult(l5));
            }
          }
          function fe(e7, t5) {
            let i6 = true;
            return "always" === e7 || "never" !== e7 && "never" !== t5 || (i6 = false), i6;
          }
          class ge {
            constructor(e7, t5, i6) {
              const r7 = this.boxCells = [], o7 = this.circleCells = [];
              this.xCellCount = Math.ceil(e7 / i6), this.yCellCount = Math.ceil(t5 / i6);
              for (let e8 = 0; e8 < this.xCellCount * this.yCellCount; e8++) r7.push([]), o7.push([]);
              this.circleKeys = [], this.boxKeys = [], this.bboxes = [], this.circles = [], this.width = e7, this.height = t5, this.xScale = this.xCellCount / e7, this.yScale = this.yCellCount / t5, this.boxUid = 0, this.circleUid = 0;
            }
            keysLength() {
              return this.boxKeys.length + this.circleKeys.length;
            }
            insert(e7, t5, i6, r7, o7) {
              this._forEachCell(t5, i6, r7, o7, this._insertBoxCell, this.boxUid++), this.boxKeys.push(e7), this.bboxes.push(t5), this.bboxes.push(i6), this.bboxes.push(r7), this.bboxes.push(o7);
            }
            insertCircle(e7, t5, i6, r7) {
              this._forEachCell(t5 - r7, i6 - r7, t5 + r7, i6 + r7, this._insertCircleCell, this.circleUid++), this.circleKeys.push(e7), this.circles.push(t5), this.circles.push(i6), this.circles.push(r7);
            }
            _insertBoxCell(e7, t5, i6, r7, o7, a4) {
              this.boxCells[o7].push(a4);
            }
            _insertCircleCell(e7, t5, i6, r7, o7, a4) {
              this.circleCells[o7].push(a4);
            }
            _query(e7, t5, i6, r7, o7, a4, s5) {
              if (i6 < 0 || e7 > this.width || r7 < 0 || t5 > this.height) return [];
              const n6 = [];
              if (e7 <= 0 && t5 <= 0 && this.width <= i6 && this.height <= r7) {
                if (o7) return [{ key: null, x1: e7, y1: t5, x2: i6, y2: r7 }];
                for (let e8 = 0; e8 < this.boxKeys.length; e8++) n6.push({ key: this.boxKeys[e8], x1: this.bboxes[4 * e8], y1: this.bboxes[4 * e8 + 1], x2: this.bboxes[4 * e8 + 2], y2: this.bboxes[4 * e8 + 3] });
                for (let e8 = 0; e8 < this.circleKeys.length; e8++) {
                  const t6 = this.circles[3 * e8], i7 = this.circles[3 * e8 + 1], r8 = this.circles[3 * e8 + 2];
                  n6.push({ key: this.circleKeys[e8], x1: t6 - r8, y1: i7 - r8, x2: t6 + r8, y2: i7 + r8 });
                }
              } else this._forEachCell(e7, t5, i6, r7, this._queryCell, n6, { hitTest: o7, overlapMode: a4, seenUids: { box: {}, circle: {} } }, s5);
              return n6;
            }
            query(e7, t5, i6, r7) {
              return this._query(e7, t5, i6, r7, false, null);
            }
            hitTest(e7, t5, i6, r7, o7, a4) {
              return this._query(e7, t5, i6, r7, true, o7, a4).length > 0;
            }
            hitTestCircle(e7, t5, i6, r7, o7) {
              const a4 = e7 - i6, s5 = e7 + i6, n6 = t5 - i6, l5 = t5 + i6;
              if (s5 < 0 || a4 > this.width || l5 < 0 || n6 > this.height) return false;
              const c5 = [];
              return this._forEachCell(a4, n6, s5, l5, this._queryCellCircle, c5, { hitTest: true, overlapMode: r7, circle: { x: e7, y: t5, radius: i6 }, seenUids: { box: {}, circle: {} } }, o7), c5.length > 0;
            }
            _queryCell(e7, t5, i6, r7, o7, a4, s5, n6) {
              const { seenUids: l5, hitTest: c5, overlapMode: h4 } = s5, u4 = this.boxCells[o7];
              if (null !== u4) {
                const o8 = this.bboxes;
                for (const s6 of u4) if (!l5.box[s6]) {
                  l5.box[s6] = true;
                  const u5 = 4 * s6, d5 = this.boxKeys[s6];
                  if (e7 <= o8[u5 + 2] && t5 <= o8[u5 + 3] && i6 >= o8[u5 + 0] && r7 >= o8[u5 + 1] && (!n6 || n6(d5)) && (!c5 || !fe(h4, d5.overlapMode)) && (a4.push({ key: d5, x1: o8[u5], y1: o8[u5 + 1], x2: o8[u5 + 2], y2: o8[u5 + 3] }), c5)) return true;
                }
              }
              const d4 = this.circleCells[o7];
              if (null !== d4) {
                const o8 = this.circles;
                for (const s6 of d4) if (!l5.circle[s6]) {
                  l5.circle[s6] = true;
                  const u5 = 3 * s6, d5 = this.circleKeys[s6];
                  if (this._circleAndRectCollide(o8[u5], o8[u5 + 1], o8[u5 + 2], e7, t5, i6, r7) && (!n6 || n6(d5)) && (!c5 || !fe(h4, d5.overlapMode))) {
                    const e8 = o8[u5], t6 = o8[u5 + 1], i7 = o8[u5 + 2];
                    if (a4.push({ key: d5, x1: e8 - i7, y1: t6 - i7, x2: e8 + i7, y2: t6 + i7 }), c5) return true;
                  }
                }
              }
              return false;
            }
            _queryCellCircle(e7, t5, i6, r7, o7, a4, s5, n6) {
              const { circle: l5, seenUids: c5, overlapMode: h4 } = s5, u4 = this.boxCells[o7];
              if (null !== u4) {
                const e8 = this.bboxes;
                for (const t6 of u4) if (!c5.box[t6]) {
                  c5.box[t6] = true;
                  const i7 = 4 * t6, r8 = this.boxKeys[t6];
                  if (this._circleAndRectCollide(l5.x, l5.y, l5.radius, e8[i7 + 0], e8[i7 + 1], e8[i7 + 2], e8[i7 + 3]) && (!n6 || n6(r8)) && !fe(h4, r8.overlapMode)) return a4.push(true), true;
                }
              }
              const d4 = this.circleCells[o7];
              if (null !== d4) {
                const e8 = this.circles;
                for (const t6 of d4) if (!c5.circle[t6]) {
                  c5.circle[t6] = true;
                  const i7 = 3 * t6, r8 = this.circleKeys[t6];
                  if (this._circlesCollide(e8[i7], e8[i7 + 1], e8[i7 + 2], l5.x, l5.y, l5.radius) && (!n6 || n6(r8)) && !fe(h4, r8.overlapMode)) return a4.push(true), true;
                }
              }
            }
            _forEachCell(e7, t5, i6, r7, o7, a4, s5, n6) {
              const l5 = this._convertToXCellCoord(e7), c5 = this._convertToYCellCoord(t5), h4 = this._convertToXCellCoord(i6), u4 = this._convertToYCellCoord(r7);
              for (let d4 = l5; d4 <= h4; d4++) for (let l6 = c5; l6 <= u4; l6++) if (o7.call(this, e7, t5, i6, r7, this.xCellCount * l6 + d4, a4, s5, n6)) return;
            }
            _convertToXCellCoord(e7) {
              return Math.max(0, Math.min(this.xCellCount - 1, Math.floor(e7 * this.xScale)));
            }
            _convertToYCellCoord(e7) {
              return Math.max(0, Math.min(this.yCellCount - 1, Math.floor(e7 * this.yScale)));
            }
            _circlesCollide(e7, t5, i6, r7, o7, a4) {
              const s5 = r7 - e7, n6 = o7 - t5, l5 = i6 + a4;
              return l5 * l5 > s5 * s5 + n6 * n6;
            }
            _circleAndRectCollide(e7, t5, i6, r7, o7, a4, s5) {
              const n6 = (a4 - r7) / 2, l5 = Math.abs(e7 - (r7 + n6));
              if (l5 > n6 + i6) return false;
              const c5 = (s5 - o7) / 2, h4 = Math.abs(t5 - (o7 + c5));
              if (h4 > c5 + i6) return false;
              if (l5 <= n6 || h4 <= c5) return true;
              const u4 = l5 - n6, d4 = h4 - c5;
              return u4 * u4 + d4 * d4 <= i6 * i6;
            }
          }
          function ve(e7, i6, o7) {
            const a4 = t4.K();
            if (!e7) {
              const { vecSouth: e8, vecEast: t5 } = be(i6), o8 = r6();
              o8[0] = t5[0], o8[1] = t5[1], o8[2] = e8[0], o8[3] = e8[1], s5 = o8, (d4 = (l5 = (n6 = o8)[0]) * (u4 = n6[3]) - (h4 = n6[2]) * (c5 = n6[1])) && (s5[0] = u4 * (d4 = 1 / d4), s5[1] = -c5 * d4, s5[2] = -h4 * d4, s5[3] = l5 * d4), a4[0] = o8[0], a4[1] = o8[1], a4[4] = o8[2], a4[5] = o8[3];
            }
            var s5, n6, l5, c5, h4, u4, d4;
            return t4.M(a4, a4, [1 / o7, 1 / o7, 1]), a4;
          }
          function xe(e7, i6, r7, o7) {
            if (e7) {
              const e8 = t4.K();
              if (!i6) {
                const { vecSouth: t5, vecEast: i7 } = be(r7);
                e8[0] = i7[0], e8[1] = i7[1], e8[4] = t5[0], e8[5] = t5[1];
              }
              return t4.M(e8, e8, [o7, o7, 1]), e8;
            }
            return r7.pixelsToClipSpaceMatrix;
          }
          function be(e7) {
            const i6 = Math.cos(e7.rollInRadians), r7 = Math.sin(e7.rollInRadians), o7 = Math.cos(e7.pitchInRadians), a4 = Math.cos(e7.bearingInRadians), s5 = Math.sin(e7.bearingInRadians), n6 = t4.ak();
            n6[0] = -a4 * o7 * r7 - s5 * i6, n6[1] = -s5 * o7 * r7 + a4 * i6;
            const l5 = t4.al(n6);
            l5 < 1e-9 ? t4.am(n6) : t4.an(n6, n6, 1 / l5);
            const c5 = t4.ak();
            c5[0] = a4 * o7 * i6 - s5 * r7, c5[1] = s5 * o7 * i6 + a4 * r7;
            const h4 = t4.al(c5);
            return h4 < 1e-9 ? t4.am(c5) : t4.an(c5, c5, 1 / h4), { vecEast: c5, vecSouth: n6 };
          }
          function ye(e7, i6, r7, o7) {
            let a4;
            o7 ? (a4 = [e7, i6, o7(e7, i6), 1], t4.ap(a4, a4, r7)) : (a4 = [e7, i6, 0, 1], Oe(a4, a4, r7));
            const s5 = a4[3];
            return { point: new t4.P(a4[0] / s5, a4[1] / s5), signedDistanceFromCamera: s5, isOccluded: false };
          }
          function we(e7, t5) {
            return 0.5 + e7 / t5 * 0.5;
          }
          function Te(e7, t5) {
            return e7.x >= -t5[0] && e7.x <= t5[0] && e7.y >= -t5[1] && e7.y <= t5[1];
          }
          function Pe(e7, i6, r7, o7, a4, s5, n6, l5, c5, h4, u4, d4, _4) {
            const p4 = r7 ? e7.textSizeData : e7.iconSizeData, m4 = t4.ag(p4, i6.transform.zoom), f4 = [256 / i6.width * 2 + 1, 256 / i6.height * 2 + 1], g4 = r7 ? e7.text.dynamicLayoutVertexArray : e7.icon.dynamicLayoutVertexArray;
            g4.clear();
            const v4 = e7.lineVertexArray, x4 = r7 ? e7.text.placedSymbolArray : e7.icon.placedSymbolArray, b5 = i6.transform.width / i6.transform.height;
            let y4 = false;
            for (let r8 = 0; r8 < x4.length; r8++) {
              const w4 = x4.get(r8);
              if (w4.hidden || w4.writingMode === t4.ah.vertical && !y4) {
                Be(w4.numGlyphs, g4);
                continue;
              }
              y4 = false;
              const T5 = new t4.P(w4.anchorX, w4.anchorY), P4 = { getElevation: _4, pitchedLabelPlaneMatrix: o7, lineVertexArray: v4, pitchWithMap: s5, projectionCache: { projections: {}, offsets: {}, cachedAnchorPoint: void 0, anyProjectionOccluded: false }, transform: i6.transform, tileAnchorPoint: T5, unwrappedTileID: c5, width: h4, height: u4, translation: d4 }, C4 = ze(w4.anchorX, w4.anchorY, P4);
              if (!Te(C4.point, f4)) {
                Be(w4.numGlyphs, g4);
                continue;
              }
              const I4 = we(i6.transform.cameraToCenterDistance, C4.signedDistanceFromCamera), M5 = t4.ai(p4, m4, w4), E4 = s5 ? M5 * i6.transform.getPitchedTextCorrection(w4.anchorX, w4.anchorY, c5) / I4 : M5 * I4, S5 = Me({ projectionContext: P4, pitchedLabelPlaneMatrixInverse: a4, symbol: w4, fontSize: E4, flip: false, keepUpright: n6, glyphOffsetArray: e7.glyphOffsetArray, dynamicLayoutVertexArray: g4, aspectRatio: b5, rotateToLine: l5 });
              y4 = S5.useVertical, (S5.notEnoughRoom || y4 || S5.needsFlipping && Me({ projectionContext: P4, pitchedLabelPlaneMatrixInverse: a4, symbol: w4, fontSize: E4, flip: true, keepUpright: n6, glyphOffsetArray: e7.glyphOffsetArray, dynamicLayoutVertexArray: g4, aspectRatio: b5, rotateToLine: l5 }).notEnoughRoom) && Be(w4.numGlyphs, g4);
            }
            r7 ? e7.text.dynamicLayoutVertexBuffer.updateData(g4) : e7.icon.dynamicLayoutVertexBuffer.updateData(g4);
          }
          function Ce(e7, t5, i6, r7, o7, a4, s5, n6) {
            const l5 = a4.glyphStartIndex + a4.numGlyphs, c5 = a4.lineStartIndex, h4 = a4.lineStartIndex + a4.lineLength, u4 = t5.getoffsetX(a4.glyphStartIndex), d4 = t5.getoffsetX(l5 - 1), _4 = ke(e7 * u4, i6, r7, o7, a4.segment, c5, h4, n6, s5);
            if (!_4) return null;
            const p4 = ke(e7 * d4, i6, r7, o7, a4.segment, c5, h4, n6, s5);
            return p4 ? n6.projectionCache.anyProjectionOccluded ? null : { first: _4, last: p4 } : null;
          }
          function Ie(e7, i6, r7, o7) {
            return e7 === t4.ah.horizontal && Math.abs(r7.y - i6.y) > Math.abs(r7.x - i6.x) * o7 ? { useVertical: true } : (e7 === t4.ah.vertical ? i6.y < r7.y : i6.x > r7.x) ? { needsFlipping: true } : null;
          }
          function Me(e7) {
            const { projectionContext: i6, pitchedLabelPlaneMatrixInverse: r7, symbol: o7, fontSize: a4, flip: s5, keepUpright: n6, glyphOffsetArray: l5, dynamicLayoutVertexArray: c5, aspectRatio: h4, rotateToLine: u4 } = e7, d4 = a4 / 24, _4 = o7.lineOffsetX * d4, p4 = o7.lineOffsetY * d4;
            let m4;
            if (o7.numGlyphs > 1) {
              const e8 = o7.glyphStartIndex + o7.numGlyphs, t5 = o7.lineStartIndex, a5 = o7.lineStartIndex + o7.lineLength, c6 = Ce(d4, l5, _4, p4, s5, o7, u4, i6);
              if (!c6) return { notEnoughRoom: true };
              const f4 = De(c6.first.point.x, c6.first.point.y, i6, r7), g4 = De(c6.last.point.x, c6.last.point.y, i6, r7);
              if (n6 && !s5) {
                const e9 = Ie(o7.writingMode, f4, g4, h4);
                if (e9) return e9;
              }
              m4 = [c6.first];
              for (let r8 = o7.glyphStartIndex + 1; r8 < e8 - 1; r8++) m4.push(ke(d4 * l5.getoffsetX(r8), _4, p4, s5, o7.segment, t5, a5, i6, u4));
              m4.push(c6.last);
            } else {
              if (n6 && !s5) {
                const e9 = Re(i6.tileAnchorPoint.x, i6.tileAnchorPoint.y, i6).point, a5 = o7.lineStartIndex + o7.segment + 1, s6 = new t4.P(i6.lineVertexArray.getx(a5), i6.lineVertexArray.gety(a5)), n7 = Re(s6.x, s6.y, i6), l6 = n7.signedDistanceFromCamera > 0 ? n7.point : Ee(i6.tileAnchorPoint, s6, e9, 1, i6), c6 = De(e9.x, e9.y, i6, r7), u5 = De(l6.x, l6.y, i6, r7), d5 = Ie(o7.writingMode, c6, u5, h4);
                if (d5) return d5;
              }
              const e8 = ke(d4 * l5.getoffsetX(o7.glyphStartIndex), _4, p4, s5, o7.segment, o7.lineStartIndex, o7.lineStartIndex + o7.lineLength, i6, u4);
              if (!e8 || i6.projectionCache.anyProjectionOccluded) return { notEnoughRoom: true };
              m4 = [e8];
            }
            for (const e8 of m4) t4.ao(c5, e8.point, e8.angle);
            return {};
          }
          function Ee(e7, t5, i6, r7, o7) {
            const a4 = e7.add(e7.sub(t5)._unit()), s5 = Re(a4.x, a4.y, o7).point, n6 = i6.sub(s5);
            return i6.add(n6._mult(r7 / n6.mag()));
          }
          function Se(e7, i6, r7) {
            const o7 = i6.projectionCache;
            if (o7.projections[e7]) return o7.projections[e7];
            const a4 = new t4.P(i6.lineVertexArray.getx(e7), i6.lineVertexArray.gety(e7)), s5 = Re(a4.x, a4.y, i6);
            if (s5.signedDistanceFromCamera > 0) return o7.projections[e7] = s5.point, o7.anyProjectionOccluded = o7.anyProjectionOccluded || s5.isOccluded, s5.point;
            const n6 = e7 - r7.direction;
            return Ee(0 === r7.distanceFromAnchor ? i6.tileAnchorPoint : new t4.P(i6.lineVertexArray.getx(n6), i6.lineVertexArray.gety(n6)), a4, r7.previousVertex, r7.absOffsetX - r7.distanceFromAnchor + 1, i6);
          }
          function Re(e7, t5, i6) {
            const r7 = e7 + i6.translation[0], o7 = t5 + i6.translation[1];
            let a4;
            return i6.pitchWithMap ? (a4 = ye(r7, o7, i6.pitchedLabelPlaneMatrix, i6.getElevation), a4.isOccluded = false) : (a4 = i6.transform.projectTileCoordinates(r7, o7, i6.unwrappedTileID, i6.getElevation), a4.point.x = (0.5 * a4.point.x + 0.5) * i6.width, a4.point.y = (0.5 * -a4.point.y + 0.5) * i6.height), a4;
          }
          function De(e7, i6, r7, o7) {
            if (r7.pitchWithMap) {
              const a4 = [e7, i6, 0, 1];
              return t4.ap(a4, a4, o7), r7.transform.projectTileCoordinates(a4[0] / a4[3], a4[1] / a4[3], r7.unwrappedTileID, r7.getElevation).point;
            }
            return { x: e7 / r7.width * 2 - 1, y: i6 / r7.height * 2 - 1 };
          }
          function ze(e7, t5, i6) {
            return i6.transform.projectTileCoordinates(e7, t5, i6.unwrappedTileID, i6.getElevation);
          }
          function Ae(e7, t5, i6) {
            return e7._unit()._perp()._mult(t5 * i6);
          }
          function Le(e7, i6, r7, o7, a4, s5, n6, l5, c5) {
            if (l5.projectionCache.offsets[e7]) return l5.projectionCache.offsets[e7];
            const h4 = r7.add(i6);
            if (e7 + c5.direction < o7 || e7 + c5.direction >= a4) return l5.projectionCache.offsets[e7] = h4, h4;
            const u4 = Se(e7 + c5.direction, l5, c5), d4 = Ae(u4.sub(r7), n6, c5.direction), _4 = r7.add(d4), p4 = u4.add(d4);
            return l5.projectionCache.offsets[e7] = t4.aq(s5, h4, _4, p4) || h4, l5.projectionCache.offsets[e7];
          }
          function ke(e7, t5, i6, r7, o7, a4, s5, n6, l5) {
            const c5 = r7 ? e7 - t5 : e7 + t5;
            let h4 = c5 > 0 ? 1 : -1, u4 = 0;
            r7 && (h4 *= -1, u4 = Math.PI), h4 < 0 && (u4 += Math.PI);
            let d4, _4 = h4 > 0 ? a4 + o7 : a4 + o7 + 1;
            n6.projectionCache.cachedAnchorPoint ? d4 = n6.projectionCache.cachedAnchorPoint : (d4 = Re(n6.tileAnchorPoint.x, n6.tileAnchorPoint.y, n6).point, n6.projectionCache.cachedAnchorPoint = d4);
            let p4, m4, f4 = d4, g4 = d4, v4 = 0, x4 = 0;
            const b5 = Math.abs(c5), y4 = [];
            let w4;
            for (; v4 + x4 <= b5; ) {
              if (_4 += h4, _4 < a4 || _4 >= s5) return null;
              v4 += x4, g4 = f4, m4 = p4;
              const e8 = { absOffsetX: b5, direction: h4, distanceFromAnchor: v4, previousVertex: g4 };
              if (f4 = Se(_4, n6, e8), 0 === i6) y4.push(g4), w4 = f4.sub(g4);
              else {
                let t6;
                const r8 = f4.sub(g4);
                t6 = 0 === r8.mag() ? Ae(Se(_4 + h4, n6, e8).sub(f4), i6, h4) : Ae(r8, i6, h4), m4 || (m4 = g4.add(t6)), p4 = Le(_4, t6, f4, a4, s5, m4, i6, n6, e8), y4.push(m4), w4 = p4.sub(m4);
              }
              x4 = w4.mag();
            }
            const T5 = w4._mult((b5 - v4) / x4)._add(m4 || g4), P4 = u4 + Math.atan2(f4.y - g4.y, f4.x - g4.x);
            return y4.push(T5), { point: T5, angle: l5 ? P4 : 0, path: y4 };
          }
          const Fe = new Float32Array([-1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0]);
          function Be(e7, t5) {
            for (let i6 = 0; i6 < e7; i6++) {
              const e8 = t5.length;
              t5.resize(e8 + 4), t5.float32.set(Fe, 3 * e8);
            }
          }
          function Oe(e7, t5, i6) {
            const r7 = t5[0], o7 = t5[1];
            return e7[0] = i6[0] * r7 + i6[4] * o7 + i6[12], e7[1] = i6[1] * r7 + i6[5] * o7 + i6[13], e7[3] = i6[3] * r7 + i6[7] * o7 + i6[15], e7;
          }
          const je = 100;
          class Ze {
            constructor(e7, t5 = new ge(e7.width + 200, e7.height + 200, 25), i6 = new ge(e7.width + 200, e7.height + 200, 25)) {
              this.transform = e7, this.grid = t5, this.ignoredGrid = i6, this.pitchFactor = Math.cos(e7.pitch * Math.PI / 180) * e7.cameraToCenterDistance, this.screenRightBoundary = e7.width + je, this.screenBottomBoundary = e7.height + je, this.gridRightBoundary = e7.width + 200, this.gridBottomBoundary = e7.height + 200, this.perspectiveRatioCutoff = 0.6;
            }
            placeCollisionBox(e7, t5, i6, r7, o7, a4, s5, n6, l5, c5, h4, u4) {
              const d4 = this.projectAndGetPerspectiveRatio(e7.anchorPointX + n6[0], e7.anchorPointY + n6[1], o7, c5, u4), _4 = i6 * d4.perspectiveRatio;
              let p4;
              if (a4 || s5) p4 = this._projectCollisionBox(e7, _4, r7, o7, a4, s5, n6, d4, c5, h4, u4);
              else {
                const t6 = d4.x + (h4 ? h4.x * _4 : 0), i7 = d4.y + (h4 ? h4.y * _4 : 0);
                p4 = { allPointsOccluded: false, box: [t6 + e7.x1 * _4, i7 + e7.y1 * _4, t6 + e7.x2 * _4, i7 + e7.y2 * _4] };
              }
              const [m4, f4, g4, v4] = p4.box, x4 = a4 ? p4.allPointsOccluded : d4.isOccluded;
              let b5 = x4;
              return b5 || (b5 = d4.perspectiveRatio < this.perspectiveRatioCutoff), b5 || (b5 = !this.isInsideGrid(m4, f4, g4, v4)), b5 || "always" !== t5 && this.grid.hitTest(m4, f4, g4, v4, t5, l5) ? { box: [m4, f4, g4, v4], placeable: false, offscreen: false, occluded: x4 } : { box: [m4, f4, g4, v4], placeable: true, offscreen: this.isOffscreen(m4, f4, g4, v4), occluded: x4 };
            }
            placeCollisionCircles(e7, i6, r7, o7, a4, s5, n6, l5, c5, h4, u4, d4, _4, p4) {
              const m4 = [], f4 = new t4.P(i6.anchorX, i6.anchorY), g4 = this.getPerspectiveRatio(f4.x, f4.y, s5, p4), v4 = (c5 ? a4 * this.transform.getPitchedTextCorrection(i6.anchorX, i6.anchorY, s5) / g4 : a4 * g4) / t4.av, x4 = { getElevation: p4, pitchedLabelPlaneMatrix: n6, lineVertexArray: r7, pitchWithMap: c5, projectionCache: { projections: {}, offsets: {}, cachedAnchorPoint: void 0, anyProjectionOccluded: false }, transform: this.transform, tileAnchorPoint: f4, unwrappedTileID: s5, width: this.transform.width, height: this.transform.height, translation: _4 }, b5 = Ce(v4, o7, i6.lineOffsetX * v4, i6.lineOffsetY * v4, false, i6, false, x4);
              let y4 = false, w4 = false, T5 = true;
              if (b5) {
                const i7 = 0.5 * u4 * g4 + d4, r8 = new t4.P(-100, -100), o8 = new t4.P(this.screenRightBoundary, this.screenBottomBoundary), a5 = new me(), s6 = b5.first, n7 = b5.last;
                let _5 = [];
                for (let e8 = s6.path.length - 1; e8 >= 1; e8--) _5.push(s6.path[e8]);
                for (let e8 = 1; e8 < n7.path.length; e8++) _5.push(n7.path[e8]);
                const p5 = 2.5 * i7;
                if (c5) {
                  const e8 = this.projectPathToScreenSpace(_5, x4);
                  _5 = e8.some((e9) => e9.signedDistanceFromCamera <= 0) ? [] : e8.map((e9) => e9.point);
                }
                let f5 = [];
                if (_5.length > 0) {
                  const e8 = _5[0].clone(), i8 = _5[0].clone();
                  for (let t5 = 1; t5 < _5.length; t5++) e8.x = Math.min(e8.x, _5[t5].x), e8.y = Math.min(e8.y, _5[t5].y), i8.x = Math.max(i8.x, _5[t5].x), i8.y = Math.max(i8.y, _5[t5].y);
                  f5 = e8.x >= r8.x && i8.x <= o8.x && e8.y >= r8.y && i8.y <= o8.y ? [_5] : i8.x < r8.x || e8.x > o8.x || i8.y < r8.y || e8.y > o8.y ? [] : t4.ar([_5], r8.x, r8.y, o8.x, o8.y);
                }
                for (const t5 of f5) {
                  a5.reset(t5, 0.25 * i7);
                  let r9 = 0;
                  r9 = a5.length <= 0.5 * i7 ? 1 : Math.ceil(a5.paddedLength / p5) + 1;
                  for (let t6 = 0; t6 < r9; t6++) {
                    const o9 = t6 / Math.max(r9 - 1, 1), s7 = a5.lerp(o9), n8 = s7.x + je, c6 = s7.y + je;
                    m4.push(n8, c6, i7, 0);
                    const u5 = n8 - i7, d5 = c6 - i7, _6 = n8 + i7, p6 = c6 + i7;
                    if (T5 = T5 && this.isOffscreen(u5, d5, _6, p6), w4 = w4 || this.isInsideGrid(u5, d5, _6, p6), "always" !== e7 && this.grid.hitTestCircle(n8, c6, i7, e7, h4) && (y4 = true, !l5)) return { circles: [], offscreen: false, collisionDetected: y4 };
                  }
                }
              }
              return { circles: !l5 && y4 || !w4 || g4 < this.perspectiveRatioCutoff ? [] : m4, offscreen: T5, collisionDetected: y4 };
            }
            projectPathToScreenSpace(e7, i6) {
              const r7 = function(e8, i7) {
                const r8 = t4.K();
                return t4.aj(r8, i7.pitchedLabelPlaneMatrix), e8.map((e9) => {
                  const t5 = ye(e9.x, e9.y, r8, i7.getElevation), o7 = i7.transform.projectTileCoordinates(t5.point.x, t5.point.y, i7.unwrappedTileID, i7.getElevation);
                  return o7.point.x = (0.5 * o7.point.x + 0.5) * i7.width, o7.point.y = (0.5 * -o7.point.y + 0.5) * i7.height, o7;
                });
              }(e7, i6);
              return function(e8) {
                let t5 = 0, i7 = 0, r8 = 0, o7 = 0;
                for (let a4 = 0; a4 < e8.length; a4++) e8[a4].isOccluded ? (r8 = a4 + 1, o7 = 0) : (o7++, o7 > i7 && (i7 = o7, t5 = r8));
                return e8.slice(t5, t5 + i7);
              }(r7);
            }
            queryRenderedSymbols(e7) {
              if (0 === e7.length || 0 === this.grid.keysLength() && 0 === this.ignoredGrid.keysLength()) return {};
              const i6 = [];
              let r7 = 1 / 0, o7 = 1 / 0, a4 = -1 / 0, s5 = -1 / 0;
              for (const n7 of e7) {
                const e8 = new t4.P(n7.x + je, n7.y + je);
                r7 = Math.min(r7, e8.x), o7 = Math.min(o7, e8.y), a4 = Math.max(a4, e8.x), s5 = Math.max(s5, e8.y), i6.push(e8);
              }
              const n6 = this.grid.query(r7, o7, a4, s5).concat(this.ignoredGrid.query(r7, o7, a4, s5)), l5 = {}, c5 = {};
              for (const e8 of n6) {
                const r8 = e8.key;
                if (void 0 === l5[r8.bucketInstanceId] && (l5[r8.bucketInstanceId] = {}), l5[r8.bucketInstanceId][r8.featureIndex]) continue;
                const o8 = [new t4.P(e8.x1, e8.y1), new t4.P(e8.x2, e8.y1), new t4.P(e8.x2, e8.y2), new t4.P(e8.x1, e8.y2)];
                t4.as(i6, o8) && (l5[r8.bucketInstanceId][r8.featureIndex] = true, void 0 === c5[r8.bucketInstanceId] && (c5[r8.bucketInstanceId] = []), c5[r8.bucketInstanceId].push(r8.featureIndex));
              }
              return c5;
            }
            insertCollisionBox(e7, t5, i6, r7, o7, a4) {
              (i6 ? this.ignoredGrid : this.grid).insert({ bucketInstanceId: r7, featureIndex: o7, collisionGroupID: a4, overlapMode: t5 }, e7[0], e7[1], e7[2], e7[3]);
            }
            insertCollisionCircles(e7, t5, i6, r7, o7, a4) {
              const s5 = i6 ? this.ignoredGrid : this.grid, n6 = { bucketInstanceId: r7, featureIndex: o7, collisionGroupID: a4, overlapMode: t5 };
              for (let t6 = 0; t6 < e7.length; t6 += 4) s5.insertCircle(n6, e7[t6], e7[t6 + 1], e7[t6 + 2]);
            }
            projectAndGetPerspectiveRatio(e7, i6, r7, o7, a4) {
              if (a4) {
                let r8;
                o7 ? (r8 = [e7, i6, o7(e7, i6), 1], t4.ap(r8, r8, a4)) : (r8 = [e7, i6, 0, 1], Oe(r8, r8, a4));
                const s5 = r8[3];
                return { x: (r8[0] / s5 + 1) / 2 * this.transform.width + je, y: (-r8[1] / s5 + 1) / 2 * this.transform.height + je, perspectiveRatio: 0.5 + this.transform.cameraToCenterDistance / s5 * 0.5, isOccluded: false, signedDistanceFromCamera: s5 };
              }
              {
                const t5 = this.transform.projectTileCoordinates(e7, i6, r7, o7);
                return { x: (t5.point.x + 1) / 2 * this.transform.width + je, y: (1 - t5.point.y) / 2 * this.transform.height + je, perspectiveRatio: 0.5 + this.transform.cameraToCenterDistance / t5.signedDistanceFromCamera * 0.5, isOccluded: t5.isOccluded, signedDistanceFromCamera: t5.signedDistanceFromCamera };
              }
            }
            getPerspectiveRatio(e7, t5, i6, r7) {
              const o7 = this.transform.projectTileCoordinates(e7, t5, i6, r7);
              return 0.5 + this.transform.cameraToCenterDistance / o7.signedDistanceFromCamera * 0.5;
            }
            isOffscreen(e7, t5, i6, r7) {
              return i6 < je || e7 >= this.screenRightBoundary || r7 < je || t5 > this.screenBottomBoundary;
            }
            isInsideGrid(e7, t5, i6, r7) {
              return i6 >= 0 && e7 < this.gridRightBoundary && r7 >= 0 && t5 < this.gridBottomBoundary;
            }
            getViewportMatrix() {
              const e7 = t4.at([]);
              return t4.L(e7, e7, [-100, -100, 0]), e7;
            }
            _projectCollisionBox(e7, i6, r7, o7, a4, s5, n6, l5, c5, h4, u4) {
              let d4 = 1, _4 = 0, p4 = 0, m4 = 1;
              const f4 = e7.anchorPointX + n6[0], g4 = e7.anchorPointY + n6[1];
              if (s5 && !a4) {
                const e8 = this.projectAndGetPerspectiveRatio(f4 + 1, g4, o7, c5, u4), t5 = e8.x - l5.x, i7 = Math.atan((e8.y - l5.y) / t5) + (t5 < 0 ? Math.PI : 0), r8 = Math.sin(i7), a5 = Math.cos(i7);
                d4 = a5, _4 = r8, p4 = -r8, m4 = a5;
              } else if (!s5 && a4) {
                const e8 = be(this.transform);
                d4 = e8.vecEast[0], _4 = e8.vecEast[1], p4 = e8.vecSouth[0], m4 = e8.vecSouth[1];
              }
              let v4 = l5.x, x4 = l5.y, b5 = i6;
              a4 && (v4 = f4, x4 = g4, b5 = Math.pow(2, -(this.transform.zoom - r7.overscaledZ)), b5 *= this.transform.getPitchedTextCorrection(f4, g4, o7), h4 || (b5 *= t4.ae(0.5 + l5.signedDistanceFromCamera / this.transform.cameraToCenterDistance * 0.5, 0, 4))), h4 && (v4 += d4 * h4.x * b5 + p4 * h4.y * b5, x4 += _4 * h4.x * b5 + m4 * h4.y * b5);
              const y4 = e7.x1 * b5, w4 = e7.x2 * b5, T5 = (y4 + w4) / 2, P4 = e7.y1 * b5, C4 = e7.y2 * b5, I4 = (P4 + C4) / 2, M5 = [{ offsetX: y4, offsetY: P4 }, { offsetX: T5, offsetY: P4 }, { offsetX: w4, offsetY: P4 }, { offsetX: w4, offsetY: I4 }, { offsetX: w4, offsetY: C4 }, { offsetX: T5, offsetY: C4 }, { offsetX: y4, offsetY: C4 }, { offsetX: y4, offsetY: I4 }];
              let E4 = [];
              for (const { offsetX: e8, offsetY: i7 } of M5) E4.push(new t4.P(v4 + d4 * e8 + p4 * i7, x4 + _4 * e8 + m4 * i7));
              let S5 = false;
              if (a4) {
                const e8 = E4.map((e9) => this.projectAndGetPerspectiveRatio(e9.x, e9.y, o7, c5, u4));
                S5 = e8.some((e9) => !e9.isOccluded), E4 = e8.map((e9) => new t4.P(e9.x, e9.y));
              } else S5 = true;
              return { box: t4.au(E4), allPointsOccluded: !S5 };
            }
          }
          class Ne {
            constructor(e7, t5, i6, r7) {
              this.opacity = e7 ? Math.max(0, Math.min(1, e7.opacity + (e7.placed ? t5 : -t5))) : r7 && i6 ? 1 : 0, this.placed = i6;
            }
            isHidden() {
              return 0 === this.opacity && !this.placed;
            }
          }
          class Ge {
            constructor(e7, t5, i6, r7, o7) {
              this.text = new Ne(e7 ? e7.text : null, t5, i6, o7), this.icon = new Ne(e7 ? e7.icon : null, t5, r7, o7);
            }
            isHidden() {
              return this.text.isHidden() && this.icon.isHidden();
            }
          }
          class Ue {
            constructor(e7, t5, i6) {
              this.text = e7, this.icon = t5, this.skipFade = i6;
            }
          }
          class Ve {
            constructor(e7, t5, i6, r7, o7) {
              this.bucketInstanceId = e7, this.featureIndex = t5, this.sourceLayerIndex = i6, this.bucketIndex = r7, this.tileID = o7;
            }
          }
          class qe {
            constructor(e7) {
              this.crossSourceCollisions = e7, this.maxGroupID = 0, this.collisionGroups = {};
            }
            get(e7) {
              if (this.crossSourceCollisions) return { ID: 0, predicate: null };
              if (!this.collisionGroups[e7]) {
                const t5 = ++this.maxGroupID;
                this.collisionGroups[e7] = { ID: t5, predicate: (e8) => e8.collisionGroupID === t5 };
              }
              return this.collisionGroups[e7];
            }
          }
          function We(e7, i6, r7, o7, a4) {
            const { horizontalAlign: s5, verticalAlign: n6 } = t4.aB(e7);
            return new t4.P(-(s5 - 0.5) * i6 + o7[0] * a4, -(n6 - 0.5) * r7 + o7[1] * a4);
          }
          class $e {
            constructor(e7, t5, i6, r7, o7) {
              this.transform = e7.clone(), this.terrain = t5, this.collisionIndex = new Ze(this.transform), this.placements = {}, this.opacities = {}, this.variableOffsets = {}, this.stale = false, this.commitTime = 0, this.fadeDuration = i6, this.retainedQueryData = {}, this.collisionGroups = new qe(r7), this.collisionCircleArrays = {}, this.collisionBoxArrays = /* @__PURE__ */ new Map(), this.prevPlacement = o7, o7 && (o7.prevPlacement = void 0), this.placedOrientations = {};
            }
            _getTerrainElevationFunc(e7) {
              const t5 = this.terrain;
              return t5 ? (i6, r7) => t5.getElevation(e7, i6, r7) : null;
            }
            getBucketParts(e7, i6, r7, o7) {
              const a4 = r7.getBucket(i6), s5 = r7.latestFeatureIndex;
              if (!a4 || !s5 || i6.id !== a4.layerIds[0]) return;
              const n6 = r7.collisionBoxArray, l5 = a4.layers[0].layout, c5 = a4.layers[0].paint, h4 = Math.pow(2, this.transform.zoom - r7.tileID.overscaledZ), u4 = r7.tileSize / t4.Z, d4 = r7.tileID.toUnwrapped(), _4 = "map" === l5.get("text-rotation-alignment"), p4 = t4.aw(r7, 1, this.transform.zoom), m4 = t4.ax(this.collisionIndex.transform, r7, c5.get("text-translate"), c5.get("text-translate-anchor")), f4 = t4.ax(this.collisionIndex.transform, r7, c5.get("icon-translate"), c5.get("icon-translate-anchor")), g4 = ve(_4, this.transform, p4);
              this.retainedQueryData[a4.bucketInstanceId] = new Ve(a4.bucketInstanceId, s5, a4.sourceLayerIndex, a4.index, r7.tileID);
              const v4 = { bucket: a4, layout: l5, translationText: m4, translationIcon: f4, unwrappedTileID: d4, pitchedLabelPlaneMatrix: g4, scale: h4, textPixelRatio: u4, holdingForFade: r7.holdingForFade(), collisionBoxArray: n6, partiallyEvaluatedTextSize: t4.ag(a4.textSizeData, this.transform.zoom), collisionGroup: this.collisionGroups.get(a4.sourceID) };
              if (o7) for (const t5 of a4.sortKeyRanges) {
                const { sortKey: i7, symbolInstanceStart: r8, symbolInstanceEnd: o8 } = t5;
                e7.push({ sortKey: i7, symbolInstanceStart: r8, symbolInstanceEnd: o8, parameters: v4 });
              }
              else e7.push({ symbolInstanceStart: 0, symbolInstanceEnd: a4.symbolInstances.length, parameters: v4 });
            }
            attemptAnchorPlacement(e7, i6, r7, o7, a4, s5, n6, l5, c5, h4, u4, d4, _4, p4, m4, f4, g4, v4, x4, b5) {
              const y4 = t4.ay[e7.textAnchor], w4 = [e7.textOffset0, e7.textOffset1], T5 = We(y4, r7, o7, w4, a4), P4 = this.collisionIndex.placeCollisionBox(i6, d4, l5, c5, h4, n6, s5, f4, u4.predicate, x4, T5, b5);
              if ((!v4 || this.collisionIndex.placeCollisionBox(v4, d4, l5, c5, h4, n6, s5, g4, u4.predicate, x4, T5, b5).placeable) && P4.placeable) {
                let e8;
                if (this.prevPlacement && this.prevPlacement.variableOffsets[_4.crossTileID] && this.prevPlacement.placements[_4.crossTileID] && this.prevPlacement.placements[_4.crossTileID].text && (e8 = this.prevPlacement.variableOffsets[_4.crossTileID].anchor), 0 === _4.crossTileID) throw new Error("symbolInstance.crossTileID can't be 0");
                return this.variableOffsets[_4.crossTileID] = { textOffset: w4, width: r7, height: o7, anchor: y4, textBoxScale: a4, prevAnchor: e8 }, this.markUsedJustification(p4, y4, _4, m4), p4.allowVerticalPlacement && (this.markUsedOrientation(p4, m4, _4), this.placedOrientations[_4.crossTileID] = m4), { shift: T5, placedGlyphBoxes: P4 };
              }
            }
            placeLayerBucketPart(e7, i6, r7) {
              const { bucket: o7, layout: a4, translationText: s5, translationIcon: n6, unwrappedTileID: l5, pitchedLabelPlaneMatrix: c5, textPixelRatio: h4, holdingForFade: u4, collisionBoxArray: d4, partiallyEvaluatedTextSize: _4, collisionGroup: p4 } = e7.parameters, m4 = a4.get("text-optional"), f4 = a4.get("icon-optional"), g4 = t4.az(a4, "text-overlap", "text-allow-overlap"), v4 = "always" === g4, x4 = t4.az(a4, "icon-overlap", "icon-allow-overlap"), b5 = "always" === x4, y4 = "map" === a4.get("text-rotation-alignment"), w4 = "map" === a4.get("text-pitch-alignment"), T5 = "none" !== a4.get("icon-text-fit"), P4 = "viewport-y" === a4.get("symbol-z-order"), C4 = v4 && (b5 || !o7.hasIconData() || f4), I4 = b5 && (v4 || !o7.hasTextData() || m4);
              !o7.collisionArrays && d4 && o7.deserializeCollisionBoxes(d4);
              const M5 = this.retainedQueryData[o7.bucketInstanceId].tileID, E4 = this._getTerrainElevationFunc(M5), S5 = this.transform.getFastPathSimpleProjectionMatrix(M5), R5 = (e8, d5, b6) => {
                var P5, R6;
                if (i6[e8.crossTileID]) return;
                if (u4) return void (this.placements[e8.crossTileID] = new Ue(false, false, false));
                let D3 = false, z4 = false, A5 = true, L4 = null, k4 = { box: null, placeable: false, offscreen: null, occluded: false }, F3 = { placeable: false }, B5 = null, O3 = null, j4 = null, Z3 = 0, N4 = 0, G3 = 0;
                d5.textFeatureIndex ? Z3 = d5.textFeatureIndex : e8.useRuntimeCollisionCircles && (Z3 = e8.featureIndex), d5.verticalTextFeatureIndex && (N4 = d5.verticalTextFeatureIndex);
                const U4 = d5.textBox;
                if (U4) {
                  const i7 = (i8) => {
                    let r8 = t4.ah.horizontal;
                    if (o7.allowVerticalPlacement && !i8 && this.prevPlacement) {
                      const t5 = this.prevPlacement.placedOrientations[e8.crossTileID];
                      t5 && (this.placedOrientations[e8.crossTileID] = t5, r8 = t5, this.markUsedOrientation(o7, r8, e8));
                    }
                    return r8;
                  }, a5 = (i8, r8) => {
                    if (o7.allowVerticalPlacement && e8.numVerticalGlyphVertices > 0 && d5.verticalTextBox) {
                      for (const e9 of o7.writingModes) if (e9 === t4.ah.vertical ? (k4 = r8(), F3 = k4) : k4 = i8(), k4 && k4.placeable) break;
                    } else k4 = i8();
                  }, c6 = e8.textAnchorOffsetStartIndex, u5 = e8.textAnchorOffsetEndIndex;
                  if (u5 === c6) {
                    const r8 = (t5, i8) => {
                      const r9 = this.collisionIndex.placeCollisionBox(t5, g4, h4, M5, l5, w4, y4, s5, p4.predicate, E4, void 0, S5);
                      return r9 && r9.placeable && (this.markUsedOrientation(o7, i8, e8), this.placedOrientations[e8.crossTileID] = i8), r9;
                    };
                    a5(() => r8(U4, t4.ah.horizontal), () => {
                      const i8 = d5.verticalTextBox;
                      return o7.allowVerticalPlacement && e8.numVerticalGlyphVertices > 0 && i8 ? r8(i8, t4.ah.vertical) : { box: null, offscreen: null };
                    }), i7(k4 && k4.placeable);
                  } else {
                    let _5 = t4.ay[null === (R6 = null === (P5 = this.prevPlacement) || void 0 === P5 ? void 0 : P5.variableOffsets[e8.crossTileID]) || void 0 === R6 ? void 0 : R6.anchor];
                    const m5 = (t5, i8, a6) => {
                      const d6 = t5.x2 - t5.x1, m6 = t5.y2 - t5.y1, f6 = e8.textBoxScale, v5 = T5 && "never" === x4 ? i8 : null;
                      let b7 = null, P6 = "never" === g4 ? 1 : 2, C5 = "never";
                      _5 && P6++;
                      for (let i9 = 0; i9 < P6; i9++) {
                        for (let i10 = c6; i10 < u5; i10++) {
                          const r8 = o7.textAnchorOffsets.get(i10);
                          if (_5 && r8.textAnchor !== _5) continue;
                          const c7 = this.attemptAnchorPlacement(r8, t5, d6, m6, f6, y4, w4, h4, M5, l5, p4, C5, e8, o7, a6, s5, n6, v5, E4);
                          if (c7 && (b7 = c7.placedGlyphBoxes, b7 && b7.placeable)) return D3 = true, L4 = c7.shift, b7;
                        }
                        _5 ? _5 = null : C5 = g4;
                      }
                      return r7 && !b7 && (b7 = { box: this.collisionIndex.placeCollisionBox(U4, "always", h4, M5, l5, w4, y4, s5, p4.predicate, E4, void 0, S5).box, offscreen: false, placeable: false, occluded: false }), b7;
                    };
                    a5(() => m5(U4, d5.iconBox, t4.ah.horizontal), () => {
                      const i8 = d5.verticalTextBox;
                      return o7.allowVerticalPlacement && (!k4 || !k4.placeable) && e8.numVerticalGlyphVertices > 0 && i8 ? m5(i8, d5.verticalIconBox, t4.ah.vertical) : { box: null, occluded: true, offscreen: null };
                    }), k4 && (D3 = k4.placeable, A5 = k4.offscreen);
                    const f5 = i7(k4 && k4.placeable);
                    if (!D3 && this.prevPlacement) {
                      const t5 = this.prevPlacement.variableOffsets[e8.crossTileID];
                      t5 && (this.variableOffsets[e8.crossTileID] = t5, this.markUsedJustification(o7, t5.anchor, e8, f5));
                    }
                  }
                }
                if (B5 = k4, D3 = B5 && B5.placeable, A5 = B5 && B5.offscreen, e8.useRuntimeCollisionCircles) {
                  const i7 = o7.text.placedSymbolArray.get(e8.centerJustifiedTextSymbolIndex), n7 = t4.ai(o7.textSizeData, _4, i7), h5 = a4.get("text-padding");
                  O3 = this.collisionIndex.placeCollisionCircles(g4, i7, o7.lineVertexArray, o7.glyphOffsetArray, n7, l5, c5, r7, w4, p4.predicate, e8.collisionCircleDiameter, h5, s5, E4), O3.circles.length && O3.collisionDetected && !r7 && t4.w("Collisions detected, but collision boxes are not shown"), D3 = v4 || O3.circles.length > 0 && !O3.collisionDetected, A5 = A5 && O3.offscreen;
                }
                if (d5.iconFeatureIndex && (G3 = d5.iconFeatureIndex), d5.iconBox) {
                  const e9 = (e10) => this.collisionIndex.placeCollisionBox(e10, x4, h4, M5, l5, w4, y4, n6, p4.predicate, E4, T5 && L4 ? L4 : void 0, S5);
                  F3 && F3.placeable && d5.verticalIconBox ? (j4 = e9(d5.verticalIconBox), z4 = j4.placeable) : (j4 = e9(d5.iconBox), z4 = j4.placeable), A5 = A5 && j4.offscreen;
                }
                const V3 = m4 || 0 === e8.numHorizontalGlyphVertices && 0 === e8.numVerticalGlyphVertices, q3 = f4 || 0 === e8.numIconVertices;
                V3 || q3 ? q3 ? V3 || (z4 = z4 && D3) : D3 = z4 && D3 : z4 = D3 = z4 && D3;
                const W2 = z4 && j4.placeable;
                if (D3 && B5.placeable && this.collisionIndex.insertCollisionBox(B5.box, g4, a4.get("text-ignore-placement"), o7.bucketInstanceId, F3 && F3.placeable && N4 ? N4 : Z3, p4.ID), W2 && this.collisionIndex.insertCollisionBox(j4.box, x4, a4.get("icon-ignore-placement"), o7.bucketInstanceId, G3, p4.ID), O3 && D3 && this.collisionIndex.insertCollisionCircles(O3.circles, g4, a4.get("text-ignore-placement"), o7.bucketInstanceId, Z3, p4.ID), r7 && this.storeCollisionData(o7.bucketInstanceId, b6, d5, B5, j4, O3), 0 === e8.crossTileID) throw new Error("symbolInstance.crossTileID can't be 0");
                if (0 === o7.bucketInstanceId) throw new Error("bucket.bucketInstanceId can't be 0");
                this.placements[e8.crossTileID] = new Ue((D3 || C4) && !(null == B5 ? void 0 : B5.occluded), (z4 || I4) && !(null == j4 ? void 0 : j4.occluded), A5 || o7.justReloaded), i6[e8.crossTileID] = true;
              };
              if (P4) {
                if (0 !== e7.symbolInstanceStart) throw new Error("bucket.bucketInstanceId should be 0");
                const t5 = o7.getSortedSymbolIndexes(-this.transform.bearingInRadians);
                for (let e8 = t5.length - 1; e8 >= 0; --e8) {
                  const i7 = t5[e8];
                  R5(o7.symbolInstances.get(i7), o7.collisionArrays[i7], i7);
                }
              } else for (let t5 = e7.symbolInstanceStart; t5 < e7.symbolInstanceEnd; t5++) R5(o7.symbolInstances.get(t5), o7.collisionArrays[t5], t5);
              o7.justReloaded = false;
            }
            storeCollisionData(e7, t5, i6, r7, o7, a4) {
              if (i6.textBox || i6.iconBox) {
                let a5, s5;
                this.collisionBoxArrays.has(e7) ? a5 = this.collisionBoxArrays.get(e7) : (a5 = /* @__PURE__ */ new Map(), this.collisionBoxArrays.set(e7, a5)), a5.has(t5) ? s5 = a5.get(t5) : (s5 = { text: null, icon: null }, a5.set(t5, s5)), i6.textBox && (s5.text = r7.box), i6.iconBox && (s5.icon = o7.box);
              }
              if (a4) {
                let t6 = this.collisionCircleArrays[e7];
                void 0 === t6 && (t6 = this.collisionCircleArrays[e7] = []);
                for (let e8 = 0; e8 < a4.circles.length; e8 += 4) t6.push(a4.circles[e8 + 0] - je), t6.push(a4.circles[e8 + 1] - je), t6.push(a4.circles[e8 + 2]), t6.push(a4.collisionDetected ? 1 : 0);
              }
            }
            markUsedJustification(e7, i6, r7, o7) {
              let a4;
              a4 = o7 === t4.ah.vertical ? r7.verticalPlacedTextSymbolIndex : { left: r7.leftJustifiedTextSymbolIndex, center: r7.centerJustifiedTextSymbolIndex, right: r7.rightJustifiedTextSymbolIndex }[t4.aA(i6)];
              const s5 = [r7.leftJustifiedTextSymbolIndex, r7.centerJustifiedTextSymbolIndex, r7.rightJustifiedTextSymbolIndex, r7.verticalPlacedTextSymbolIndex];
              for (const t5 of s5) t5 >= 0 && (e7.text.placedSymbolArray.get(t5).crossTileID = a4 >= 0 && t5 !== a4 ? 0 : r7.crossTileID);
            }
            markUsedOrientation(e7, i6, r7) {
              const o7 = i6 === t4.ah.horizontal || i6 === t4.ah.horizontalOnly ? i6 : 0, a4 = i6 === t4.ah.vertical ? i6 : 0, s5 = [r7.leftJustifiedTextSymbolIndex, r7.centerJustifiedTextSymbolIndex, r7.rightJustifiedTextSymbolIndex];
              for (const t5 of s5) e7.text.placedSymbolArray.get(t5).placedOrientation = o7;
              r7.verticalPlacedTextSymbolIndex && (e7.text.placedSymbolArray.get(r7.verticalPlacedTextSymbolIndex).placedOrientation = a4);
            }
            commit(e7) {
              this.commitTime = e7, this.zoomAtLastRecencyCheck = this.transform.zoom;
              const t5 = this.prevPlacement;
              let i6 = false;
              this.prevZoomAdjustment = t5 ? t5.zoomAdjustment(this.transform.zoom) : 0;
              const r7 = t5 ? t5.symbolFadeChange(e7) : 1, o7 = t5 ? t5.opacities : {}, a4 = t5 ? t5.variableOffsets : {}, s5 = t5 ? t5.placedOrientations : {};
              for (const e8 in this.placements) {
                const t6 = this.placements[e8], a5 = o7[e8];
                a5 ? (this.opacities[e8] = new Ge(a5, r7, t6.text, t6.icon), i6 = i6 || t6.text !== a5.text.placed || t6.icon !== a5.icon.placed) : (this.opacities[e8] = new Ge(null, r7, t6.text, t6.icon, t6.skipFade), i6 = i6 || t6.text || t6.icon);
              }
              for (const e8 in o7) {
                const t6 = o7[e8];
                if (!this.opacities[e8]) {
                  const o8 = new Ge(t6, r7, false, false);
                  o8.isHidden() || (this.opacities[e8] = o8, i6 = i6 || t6.text.placed || t6.icon.placed);
                }
              }
              for (const e8 in a4) this.variableOffsets[e8] || !this.opacities[e8] || this.opacities[e8].isHidden() || (this.variableOffsets[e8] = a4[e8]);
              for (const e8 in s5) this.placedOrientations[e8] || !this.opacities[e8] || this.opacities[e8].isHidden() || (this.placedOrientations[e8] = s5[e8]);
              if (t5 && void 0 === t5.lastPlacementChangeTime) throw new Error("Last placement time for previous placement is not defined");
              i6 ? this.lastPlacementChangeTime = e7 : "number" != typeof this.lastPlacementChangeTime && (this.lastPlacementChangeTime = t5 ? t5.lastPlacementChangeTime : e7);
            }
            updateLayerOpacities(e7, t5) {
              const i6 = {};
              for (const r7 of t5) {
                const t6 = r7.getBucket(e7);
                t6 && r7.latestFeatureIndex && e7.id === t6.layerIds[0] && this.updateBucketOpacities(t6, r7.tileID, i6, r7.collisionBoxArray);
              }
            }
            updateBucketOpacities(e7, i6, r7, o7) {
              e7.hasTextData() && (e7.text.opacityVertexArray.clear(), e7.text.hasVisibleVertices = false), e7.hasIconData() && (e7.icon.opacityVertexArray.clear(), e7.icon.hasVisibleVertices = false), e7.hasIconCollisionBoxData() && e7.iconCollisionBox.collisionVertexArray.clear(), e7.hasTextCollisionBoxData() && e7.textCollisionBox.collisionVertexArray.clear();
              const a4 = e7.layers[0], s5 = a4.layout, n6 = new Ge(null, 0, false, false, true), l5 = s5.get("text-allow-overlap"), c5 = s5.get("icon-allow-overlap"), h4 = a4._unevaluatedLayout.hasValue("text-variable-anchor") || a4._unevaluatedLayout.hasValue("text-variable-anchor-offset"), u4 = "map" === s5.get("text-rotation-alignment"), d4 = "map" === s5.get("text-pitch-alignment"), _4 = "none" !== s5.get("icon-text-fit"), p4 = new Ge(null, 0, l5 && (c5 || !e7.hasIconData() || s5.get("icon-optional")), c5 && (l5 || !e7.hasTextData() || s5.get("text-optional")), true);
              !e7.collisionArrays && o7 && (e7.hasIconCollisionBoxData() || e7.hasTextCollisionBoxData()) && e7.deserializeCollisionBoxes(o7);
              const m4 = (e8, t5, i7) => {
                for (let r8 = 0; r8 < t5 / 4; r8++) e8.opacityVertexArray.emplaceBack(i7);
                e8.hasVisibleVertices = e8.hasVisibleVertices || i7 !== rt;
              }, f4 = this.collisionBoxArrays.get(e7.bucketInstanceId);
              for (let i7 = 0; i7 < e7.symbolInstances.length; i7++) {
                const o8 = e7.symbolInstances.get(i7), { numHorizontalGlyphVertices: a5, numVerticalGlyphVertices: s6, crossTileID: l6 } = o8;
                let c6 = this.opacities[l6];
                r7[l6] ? c6 = n6 : c6 || (c6 = p4, this.opacities[l6] = c6), r7[l6] = true;
                const g4 = o8.numIconVertices > 0, v4 = this.placedOrientations[o8.crossTileID], x4 = v4 === t4.ah.vertical, b5 = v4 === t4.ah.horizontal || v4 === t4.ah.horizontalOnly;
                if (a5 > 0 || s6 > 0) {
                  const t5 = it(c6.text);
                  m4(e7.text, a5, x4 ? rt : t5), m4(e7.text, s6, b5 ? rt : t5);
                  const i8 = c6.text.isHidden();
                  [o8.rightJustifiedTextSymbolIndex, o8.centerJustifiedTextSymbolIndex, o8.leftJustifiedTextSymbolIndex].forEach((t6) => {
                    t6 >= 0 && (e7.text.placedSymbolArray.get(t6).hidden = i8 || x4 ? 1 : 0);
                  }), o8.verticalPlacedTextSymbolIndex >= 0 && (e7.text.placedSymbolArray.get(o8.verticalPlacedTextSymbolIndex).hidden = i8 || b5 ? 1 : 0);
                  const r8 = this.variableOffsets[o8.crossTileID];
                  r8 && this.markUsedJustification(e7, r8.anchor, o8, v4);
                  const n7 = this.placedOrientations[o8.crossTileID];
                  n7 && (this.markUsedJustification(e7, "left", o8, n7), this.markUsedOrientation(e7, n7, o8));
                }
                if (g4) {
                  const t5 = it(c6.icon), i8 = !(_4 && o8.verticalPlacedIconSymbolIndex && x4);
                  o8.placedIconSymbolIndex >= 0 && (m4(e7.icon, o8.numIconVertices, i8 ? t5 : rt), e7.icon.placedSymbolArray.get(o8.placedIconSymbolIndex).hidden = c6.icon.isHidden()), o8.verticalPlacedIconSymbolIndex >= 0 && (m4(e7.icon, o8.numVerticalIconVertices, i8 ? rt : t5), e7.icon.placedSymbolArray.get(o8.verticalPlacedIconSymbolIndex).hidden = c6.icon.isHidden());
                }
                const y4 = f4 && f4.has(i7) ? f4.get(i7) : { text: null, icon: null };
                if (e7.hasIconCollisionBoxData() || e7.hasTextCollisionBoxData()) {
                  const r8 = e7.collisionArrays[i7];
                  if (r8) {
                    let i8 = new t4.P(0, 0);
                    if (r8.textBox || r8.verticalTextBox) {
                      let t5 = true;
                      if (h4) {
                        const e8 = this.variableOffsets[l6];
                        e8 ? (i8 = We(e8.anchor, e8.width, e8.height, e8.textOffset, e8.textBoxScale), u4 && i8._rotate(d4 ? -this.transform.bearingInRadians : this.transform.bearingInRadians)) : t5 = false;
                      }
                      if (r8.textBox || r8.verticalTextBox) {
                        let o9;
                        r8.textBox && (o9 = x4), r8.verticalTextBox && (o9 = b5), He(e7.textCollisionBox.collisionVertexArray, c6.text.placed, !t5 || o9, y4.text, i8.x, i8.y);
                      }
                    }
                    if (r8.iconBox || r8.verticalIconBox) {
                      const t5 = Boolean(!b5 && r8.verticalIconBox);
                      let o9;
                      r8.iconBox && (o9 = t5), r8.verticalIconBox && (o9 = !t5), He(e7.iconCollisionBox.collisionVertexArray, c6.icon.placed, o9, y4.icon, _4 ? i8.x : 0, _4 ? i8.y : 0);
                    }
                  }
                }
              }
              if (e7.sortFeatures(-this.transform.bearingInRadians), this.retainedQueryData[e7.bucketInstanceId] && (this.retainedQueryData[e7.bucketInstanceId].featureSortOrder = e7.featureSortOrder), e7.hasTextData() && e7.text.opacityVertexBuffer && e7.text.opacityVertexBuffer.updateData(e7.text.opacityVertexArray), e7.hasIconData() && e7.icon.opacityVertexBuffer && e7.icon.opacityVertexBuffer.updateData(e7.icon.opacityVertexArray), e7.hasIconCollisionBoxData() && e7.iconCollisionBox.collisionVertexBuffer && e7.iconCollisionBox.collisionVertexBuffer.updateData(e7.iconCollisionBox.collisionVertexArray), e7.hasTextCollisionBoxData() && e7.textCollisionBox.collisionVertexBuffer && e7.textCollisionBox.collisionVertexBuffer.updateData(e7.textCollisionBox.collisionVertexArray), e7.text.opacityVertexArray.length !== e7.text.layoutVertexArray.length / 4) throw new Error(`bucket.text.opacityVertexArray.length (= ${e7.text.opacityVertexArray.length}) !== bucket.text.layoutVertexArray.length (= ${e7.text.layoutVertexArray.length}) / 4`);
              if (e7.icon.opacityVertexArray.length !== e7.icon.layoutVertexArray.length / 4) throw new Error(`bucket.icon.opacityVertexArray.length (= ${e7.icon.opacityVertexArray.length}) !== bucket.icon.layoutVertexArray.length (= ${e7.icon.layoutVertexArray.length}) / 4`);
              e7.bucketInstanceId in this.collisionCircleArrays && (e7.collisionCircleArray = this.collisionCircleArrays[e7.bucketInstanceId], delete this.collisionCircleArrays[e7.bucketInstanceId]);
            }
            symbolFadeChange(e7) {
              return 0 === this.fadeDuration ? 1 : (e7 - this.commitTime) / this.fadeDuration + this.prevZoomAdjustment;
            }
            zoomAdjustment(e7) {
              return Math.max(0, (this.transform.zoom - e7) / 1.5);
            }
            hasTransitions(e7) {
              return this.stale || e7 - this.lastPlacementChangeTime < this.fadeDuration;
            }
            stillRecent(e7, t5) {
              const i6 = this.zoomAtLastRecencyCheck === t5 ? 1 - this.zoomAdjustment(t5) : 1;
              return this.zoomAtLastRecencyCheck = t5, this.commitTime + this.fadeDuration * i6 > e7;
            }
            setStale() {
              this.stale = true;
            }
          }
          function He(e7, t5, i6, r7, o7, a4) {
            r7 && 0 !== r7.length || (r7 = [0, 0, 0, 0]);
            const s5 = r7[0] - je, n6 = r7[1] - je, l5 = r7[2] - je, c5 = r7[3] - je;
            e7.emplaceBack(t5 ? 1 : 0, i6 ? 1 : 0, o7 || 0, a4 || 0, s5, n6), e7.emplaceBack(t5 ? 1 : 0, i6 ? 1 : 0, o7 || 0, a4 || 0, l5, n6), e7.emplaceBack(t5 ? 1 : 0, i6 ? 1 : 0, o7 || 0, a4 || 0, l5, c5), e7.emplaceBack(t5 ? 1 : 0, i6 ? 1 : 0, o7 || 0, a4 || 0, s5, c5);
          }
          const Ke = Math.pow(2, 25), Xe = Math.pow(2, 24), Qe = Math.pow(2, 17), Ye = Math.pow(2, 16), Je = Math.pow(2, 9), et2 = Math.pow(2, 8), tt = Math.pow(2, 1);
          function it(e7) {
            if (0 === e7.opacity && !e7.placed) return 0;
            if (1 === e7.opacity && e7.placed) return 4294967295;
            const t5 = e7.placed ? 1 : 0, i6 = Math.floor(127 * e7.opacity);
            return i6 * Ke + t5 * Xe + i6 * Qe + t5 * Ye + i6 * Je + t5 * et2 + i6 * tt + t5;
          }
          const rt = 0;
          class ot {
            constructor(e7) {
              this._sortAcrossTiles = "viewport-y" !== e7.layout.get("symbol-z-order") && !e7.layout.get("symbol-sort-key").isConstant(), this._currentTileIndex = 0, this._currentPartIndex = 0, this._seenCrossTileIDs = {}, this._bucketParts = [];
            }
            continuePlacement(e7, t5, i6, r7, o7) {
              const a4 = this._bucketParts;
              for (; this._currentTileIndex < e7.length; ) if (t5.getBucketParts(a4, r7, e7[this._currentTileIndex], this._sortAcrossTiles), this._currentTileIndex++, o7()) return true;
              for (this._sortAcrossTiles && (this._sortAcrossTiles = false, a4.sort((e8, t6) => e8.sortKey - t6.sortKey)); this._currentPartIndex < a4.length; ) if (t5.placeLayerBucketPart(a4[this._currentPartIndex], this._seenCrossTileIDs, i6), this._currentPartIndex++, o7()) return true;
              return false;
            }
          }
          class at {
            constructor(e7, t5, i6, r7, o7, a4, s5, n6) {
              this.placement = new $e(e7, t5, a4, s5, n6), this._currentPlacementIndex = i6.length - 1, this._forceFullPlacement = r7, this._showCollisionBoxes = o7, this._done = false;
            }
            isDone() {
              return this._done;
            }
            continuePlacement(e7, t5, i6) {
              const r7 = s4.now(), o7 = () => !this._forceFullPlacement && s4.now() - r7 > 2;
              for (; this._currentPlacementIndex >= 0; ) {
                const r8 = t5[e7[this._currentPlacementIndex]], a4 = this.placement.collisionIndex.transform.zoom;
                if ("symbol" === r8.type && (!r8.minzoom || r8.minzoom <= a4) && (!r8.maxzoom || r8.maxzoom > a4)) {
                  if (this._inProgressLayer || (this._inProgressLayer = new ot(r8)), this._inProgressLayer.continuePlacement(i6[r8.source], this.placement, this._showCollisionBoxes, r8, o7)) return;
                  delete this._inProgressLayer;
                }
                this._currentPlacementIndex--;
              }
              this._done = true;
            }
            commit(e7) {
              return this.placement.commit(e7), this.placement;
            }
          }
          const st = 512 / t4.Z / 2;
          class nt {
            constructor(e7, i6, r7) {
              this.tileID = e7, this.bucketInstanceId = r7, this._symbolsByKey = {};
              const o7 = /* @__PURE__ */ new Map();
              for (let e8 = 0; e8 < i6.length; e8++) {
                const t5 = i6.get(e8), r8 = t5.key, a4 = o7.get(r8);
                a4 ? a4.push(t5) : o7.set(r8, [t5]);
              }
              for (const [e8, i7] of o7) {
                const r8 = { positions: i7.map((e9) => ({ x: Math.floor(e9.anchorX * st), y: Math.floor(e9.anchorY * st) })), crossTileIDs: i7.map((e9) => e9.crossTileID) };
                if (r8.positions.length > 128) {
                  const e9 = new t4.aC(r8.positions.length, 16, Uint16Array);
                  for (const { x: t5, y: i8 } of r8.positions) e9.add(t5, i8);
                  e9.finish(), delete r8.positions, r8.index = e9;
                }
                this._symbolsByKey[e8] = r8;
              }
            }
            getScaledCoordinates(e7, i6) {
              const { x: r7, y: o7, z: a4 } = this.tileID.canonical, { x: s5, y: n6, z: l5 } = i6.canonical, c5 = st / Math.pow(2, l5 - a4), h4 = (n6 * t4.Z + e7.anchorY) * c5, u4 = o7 * t4.Z * st;
              return { x: Math.floor((s5 * t4.Z + e7.anchorX) * c5 - r7 * t4.Z * st), y: Math.floor(h4 - u4) };
            }
            findMatches(e7, t5, i6) {
              const r7 = this.tileID.canonical.z < t5.canonical.z ? 1 : Math.pow(2, this.tileID.canonical.z - t5.canonical.z);
              for (let o7 = 0; o7 < e7.length; o7++) {
                const a4 = e7.get(o7);
                if (a4.crossTileID) continue;
                const s5 = this._symbolsByKey[a4.key];
                if (!s5) continue;
                const n6 = this.getScaledCoordinates(a4, t5);
                if (s5.index) {
                  const e8 = s5.index.range(n6.x - r7, n6.y - r7, n6.x + r7, n6.y + r7).sort();
                  for (const t6 of e8) {
                    const e9 = s5.crossTileIDs[t6];
                    if (!i6[e9]) {
                      i6[e9] = true, a4.crossTileID = e9;
                      break;
                    }
                  }
                } else if (s5.positions) for (let e8 = 0; e8 < s5.positions.length; e8++) {
                  const t6 = s5.positions[e8], o8 = s5.crossTileIDs[e8];
                  if (Math.abs(t6.x - n6.x) <= r7 && Math.abs(t6.y - n6.y) <= r7 && !i6[o8]) {
                    i6[o8] = true, a4.crossTileID = o8;
                    break;
                  }
                }
              }
            }
            getCrossTileIDsLists() {
              return Object.values(this._symbolsByKey).map(({ crossTileIDs: e7 }) => e7);
            }
          }
          class lt {
            constructor() {
              this.maxCrossTileID = 0;
            }
            generate() {
              return ++this.maxCrossTileID;
            }
          }
          class ct {
            constructor() {
              this.indexes = {}, this.usedCrossTileIDs = {}, this.lng = 0;
            }
            handleWrapJump(e7) {
              const t5 = Math.round((e7 - this.lng) / 360);
              if (0 !== t5) for (const e8 in this.indexes) {
                const i6 = this.indexes[e8], r7 = {};
                for (const e9 in i6) {
                  const o7 = i6[e9];
                  o7.tileID = o7.tileID.unwrapTo(o7.tileID.wrap + t5), r7[o7.tileID.key] = o7;
                }
                this.indexes[e8] = r7;
              }
              this.lng = e7;
            }
            addBucket(e7, t5, i6) {
              if (this.indexes[e7.overscaledZ] && this.indexes[e7.overscaledZ][e7.key]) {
                if (this.indexes[e7.overscaledZ][e7.key].bucketInstanceId === t5.bucketInstanceId) return false;
                this.removeBucketCrossTileIDs(e7.overscaledZ, this.indexes[e7.overscaledZ][e7.key]);
              }
              for (let e8 = 0; e8 < t5.symbolInstances.length; e8++) t5.symbolInstances.get(e8).crossTileID = 0;
              this.usedCrossTileIDs[e7.overscaledZ] || (this.usedCrossTileIDs[e7.overscaledZ] = {});
              const r7 = this.usedCrossTileIDs[e7.overscaledZ];
              for (const i7 in this.indexes) {
                const o7 = this.indexes[i7];
                if (Number(i7) > e7.overscaledZ) for (const i8 in o7) {
                  const a4 = o7[i8];
                  a4.tileID.isChildOf(e7) && a4.findMatches(t5.symbolInstances, e7, r7);
                }
                else {
                  const a4 = o7[e7.scaledTo(Number(i7)).key];
                  a4 && a4.findMatches(t5.symbolInstances, e7, r7);
                }
              }
              for (let e8 = 0; e8 < t5.symbolInstances.length; e8++) {
                const o7 = t5.symbolInstances.get(e8);
                o7.crossTileID || (o7.crossTileID = i6.generate(), r7[o7.crossTileID] = true);
              }
              return void 0 === this.indexes[e7.overscaledZ] && (this.indexes[e7.overscaledZ] = {}), this.indexes[e7.overscaledZ][e7.key] = new nt(e7, t5.symbolInstances, t5.bucketInstanceId), true;
            }
            removeBucketCrossTileIDs(e7, t5) {
              for (const i6 of t5.getCrossTileIDsLists()) for (const t6 of i6) delete this.usedCrossTileIDs[e7][t6];
            }
            removeStaleBuckets(e7) {
              let t5 = false;
              for (const i6 in this.indexes) {
                const r7 = this.indexes[i6];
                for (const o7 in r7) e7[r7[o7].bucketInstanceId] || (this.removeBucketCrossTileIDs(i6, r7[o7]), delete r7[o7], t5 = true);
              }
              return t5;
            }
          }
          class ht {
            constructor() {
              this.layerIndexes = {}, this.crossTileIDs = new lt(), this.maxBucketInstanceId = 0, this.bucketsInCurrentPlacement = {};
            }
            addLayer(e7, t5, i6) {
              let r7 = this.layerIndexes[e7.id];
              void 0 === r7 && (r7 = this.layerIndexes[e7.id] = new ct());
              let o7 = false;
              const a4 = {};
              r7.handleWrapJump(i6);
              for (const i7 of t5) {
                const t6 = i7.getBucket(e7);
                t6 && e7.id === t6.layerIds[0] && (t6.bucketInstanceId || (t6.bucketInstanceId = ++this.maxBucketInstanceId), r7.addBucket(i7.tileID, t6, this.crossTileIDs) && (o7 = true), a4[t6.bucketInstanceId] = true);
              }
              return r7.removeStaleBuckets(a4) && (o7 = true), o7;
            }
            pruneUnusedLayers(e7) {
              const t5 = {};
              e7.forEach((e8) => {
                t5[e8] = true;
              });
              for (const e8 in this.layerIndexes) t5[e8] || delete this.layerIndexes[e8];
            }
          }
          var ut = "void main() {fragColor=vec4(1.0);}";
          const dt = { prelude: _t("#ifdef GL_ES\nprecision mediump float;\n#else\n#if !defined(lowp)\n#define lowp\n#endif\n#if !defined(mediump)\n#define mediump\n#endif\n#if !defined(highp)\n#define highp\n#endif\n#endif\nout highp vec4 fragColor;", "#ifdef GL_ES\nprecision highp float;\n#else\n#if !defined(lowp)\n#define lowp\n#endif\n#if !defined(mediump)\n#define mediump\n#endif\n#if !defined(highp)\n#define highp\n#endif\n#endif\nvec2 unpack_float(const float packedValue) {int packedIntValue=int(packedValue);int v0=packedIntValue/256;return vec2(v0,packedIntValue-v0*256);}vec2 unpack_opacity(const float packedOpacity) {int intOpacity=int(packedOpacity)/2;return vec2(float(intOpacity)/127.0,mod(packedOpacity,2.0));}vec4 decode_color(const vec2 encodedColor) {return vec4(unpack_float(encodedColor[0])/255.0,unpack_float(encodedColor[1])/255.0\n);}float unpack_mix_vec2(const vec2 packedValue,const float t) {return mix(packedValue[0],packedValue[1],t);}vec4 unpack_mix_color(const vec4 packedColors,const float t) {vec4 minColor=decode_color(vec2(packedColors[0],packedColors[1]));vec4 maxColor=decode_color(vec2(packedColors[2],packedColors[3]));return mix(minColor,maxColor,t);}vec2 get_pattern_pos(const vec2 pixel_coord_upper,const vec2 pixel_coord_lower,const vec2 pattern_size,const float tile_units_to_pixels,const vec2 pos) {vec2 offset=mod(mod(mod(pixel_coord_upper,pattern_size)*256.0,pattern_size)*256.0+pixel_coord_lower,pattern_size);return (tile_units_to_pixels*pos+offset)/pattern_size;}mat3 rotationMatrixFromAxisAngle(vec3 u,float angle) {float c=cos(angle);float s=sin(angle);float c2=1.0-c;return mat3(u.x*u.x*c2+      c,u.x*u.y*c2-u.z*s,u.x*u.z*c2+u.y*s,u.y*u.x*c2+u.z*s,u.y*u.y*c2+    c,u.y*u.z*c2-u.x*s,u.z*u.x*c2-u.y*s,u.z*u.y*c2+u.x*s,u.z*u.z*c2+    c\n);}\n#ifdef TERRAIN3D\nuniform sampler2D u_terrain;uniform float u_terrain_dim;uniform mat4 u_terrain_matrix;uniform vec4 u_terrain_unpack;uniform float u_terrain_exaggeration;uniform highp sampler2D u_depth;\n#endif\nconst highp vec4 bitSh=vec4(256.*256.*256.,256.*256.,256.,1.);const highp vec4 bitShifts=vec4(1.)/bitSh;highp float unpack(highp vec4 color) {return dot(color,bitShifts);}highp float depthOpacity(vec3 frag) {\n#ifdef TERRAIN3D\nhighp float d=unpack(texture(u_depth,frag.xy*0.5+0.5))+0.0001-frag.z;return 1.0-max(0.0,min(1.0,-d*500.0));\n#else\nreturn 1.0;\n#endif\n}float calculate_visibility(vec4 pos) {\n#ifdef TERRAIN3D\nvec3 frag=pos.xyz/pos.w;highp float d=depthOpacity(frag);if (d > 0.95) return 1.0;return (d+depthOpacity(frag+vec3(0.0,0.01,0.0)))/2.0;\n#else\nreturn 1.0;\n#endif\n}float ele(vec2 pos) {\n#ifdef TERRAIN3D\nvec4 rgb=(texture(u_terrain,pos)*255.0)*u_terrain_unpack;return rgb.r+rgb.g+rgb.b-u_terrain_unpack.a;\n#else\nreturn 0.0;\n#endif\n}float get_elevation(vec2 pos) {\n#ifdef TERRAIN3D\n#ifdef GLOBE\nif ((pos.y <-32767.5) || (pos.y > 32766.5)) {return 0.0;}\n#endif\nvec2 coord=(u_terrain_matrix*vec4(pos,0.0,1.0)).xy*u_terrain_dim+1.0;vec2 f=fract(coord);vec2 c=(floor(coord)+0.5)/(u_terrain_dim+2.0);float d=1.0/(u_terrain_dim+2.0);float tl=ele(c);float tr=ele(c+vec2(d,0.0));float bl=ele(c+vec2(0.0,d));float br=ele(c+vec2(d,d));float elevation=mix(mix(tl,tr,f.x),mix(bl,br,f.x),f.y);return elevation*u_terrain_exaggeration;\n#else\nreturn 0.0;\n#endif\n}const float PI=3.141592653589793;uniform mat4 u_projection_matrix;"), projectionMercator: _t("", "float projectLineThickness(float tileY) {return 1.0;}float projectCircleRadius(float tileY) {return 1.0;}vec4 projectTile(vec2 p) {vec4 result=u_projection_matrix*vec4(p,0.0,1.0);return result;}vec4 projectTile(vec2 p,vec2 rawPos) {vec4 result=u_projection_matrix*vec4(p,0.0,1.0);if (rawPos.y <-32767.5 || rawPos.y > 32766.5) {result.z=-10000000.0;}return result;}vec4 projectTileWithElevation(vec2 posInTile,float elevation) {return u_projection_matrix*vec4(posInTile,elevation,1.0);}vec4 projectTileFor3D(vec2 posInTile,float elevation) {return projectTileWithElevation(posInTile,elevation);}"), projectionGlobe: _t("", "#define GLOBE_RADIUS 6371008.8\nuniform highp vec4 u_projection_tile_mercator_coords;uniform highp vec4 u_projection_clipping_plane;uniform highp float u_projection_transition;uniform mat4 u_projection_fallback_matrix;vec3 globeRotateVector(vec3 vec,vec2 angles) {vec3 axisRight=vec3(vec.z,0.0,-vec.x);vec3 axisUp=cross(axisRight,vec);axisRight=normalize(axisRight);axisUp=normalize(axisUp);vec2 t=tan(angles);return normalize(vec+axisRight*t.x+axisUp*t.y);}mat3 globeGetRotationMatrix(vec3 spherePos) {vec3 axisRight=vec3(spherePos.z,0.0,-spherePos.x);vec3 axisDown=cross(axisRight,spherePos);axisRight=normalize(axisRight);axisDown=normalize(axisDown);return mat3(axisRight,axisDown,spherePos\n);}float circumferenceRatioAtTileY(float tileY) {float mercator_pos_y=u_projection_tile_mercator_coords.y+u_projection_tile_mercator_coords.w*tileY;float spherical_y=2.0*atan(exp(PI-(mercator_pos_y*PI*2.0)))-PI*0.5;return cos(spherical_y);}float projectLineThickness(float tileY) {float thickness=1.0/circumferenceRatioAtTileY(tileY); \nif (u_projection_transition < 0.999) {return mix(1.0,thickness,u_projection_transition);} else {return thickness;}}vec3 projectToSphere(vec2 translatedPos,vec2 rawPos) {vec2 mercator_pos=u_projection_tile_mercator_coords.xy+u_projection_tile_mercator_coords.zw*translatedPos;vec2 spherical;spherical.x=mercator_pos.x*PI*2.0+PI;spherical.y=2.0*atan(exp(PI-(mercator_pos.y*PI*2.0)))-PI*0.5;float len=cos(spherical.y);vec3 pos=vec3(sin(spherical.x)*len,sin(spherical.y),cos(spherical.x)*len\n);if (rawPos.y <-32767.5) {pos=vec3(0.0,1.0,0.0);}if (rawPos.y > 32766.5) {pos=vec3(0.0,-1.0,0.0);}return pos;}vec3 projectToSphere(vec2 posInTile) {return projectToSphere(posInTile,vec2(0.0,0.0));}float globeComputeClippingZ(vec3 spherePos) {return (1.0-(dot(spherePos,u_projection_clipping_plane.xyz)+u_projection_clipping_plane.w));}vec4 interpolateProjection(vec2 posInTile,vec3 spherePos,float elevation) {vec3 elevatedPos=spherePos*(1.0+elevation/GLOBE_RADIUS);vec4 globePosition=u_projection_matrix*vec4(elevatedPos,1.0);globePosition.z=globeComputeClippingZ(elevatedPos)*globePosition.w;if (u_projection_transition > 0.999) {return globePosition;}vec4 flatPosition=u_projection_fallback_matrix*vec4(posInTile,elevation,1.0);const float z_globeness_threshold=0.2;vec4 result=globePosition;result.z=mix(0.0,globePosition.z,clamp((u_projection_transition-z_globeness_threshold)/(1.0-z_globeness_threshold),0.0,1.0));result.xyw=mix(flatPosition.xyw,globePosition.xyw,u_projection_transition);if ((posInTile.y <-32767.5) || (posInTile.y > 32766.5)) {result=globePosition;const float poles_hidden_anim_percentage=0.02;result.z=mix(globePosition.z,100.0,pow(max((1.0-u_projection_transition)/poles_hidden_anim_percentage,0.0),8.0));}return result;}vec4 interpolateProjectionFor3D(vec2 posInTile,vec3 spherePos,float elevation) {vec3 elevatedPos=spherePos*(1.0+elevation/GLOBE_RADIUS);vec4 globePosition=u_projection_matrix*vec4(elevatedPos,1.0);if (u_projection_transition > 0.999) {return globePosition;}vec4 fallbackPosition=u_projection_fallback_matrix*vec4(posInTile,elevation,1.0);return mix(fallbackPosition,globePosition,u_projection_transition);}vec4 projectTile(vec2 posInTile) {return interpolateProjection(posInTile,projectToSphere(posInTile),0.0);}vec4 projectTile(vec2 posInTile,vec2 rawPos) {return interpolateProjection(posInTile,projectToSphere(posInTile,rawPos),0.0);}vec4 projectTileWithElevation(vec2 posInTile,float elevation) {return interpolateProjection(posInTile,projectToSphere(posInTile),elevation);}vec4 projectTileFor3D(vec2 posInTile,float elevation) {vec3 spherePos=projectToSphere(posInTile,posInTile);return interpolateProjectionFor3D(posInTile,spherePos,elevation);}"), background: _t("uniform vec4 u_color;uniform float u_opacity;void main() {fragColor=u_color*u_opacity;\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(1.0);\n#endif\n}", "in vec2 a_pos;void main() {gl_Position=projectTile(a_pos);}"), backgroundPattern: _t("uniform vec2 u_pattern_tl_a;uniform vec2 u_pattern_br_a;uniform vec2 u_pattern_tl_b;uniform vec2 u_pattern_br_b;uniform vec2 u_texsize;uniform float u_mix;uniform float u_opacity;uniform sampler2D u_image;in vec2 v_pos_a;in vec2 v_pos_b;void main() {vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(u_pattern_tl_a/u_texsize,u_pattern_br_a/u_texsize,imagecoord);vec4 color1=texture(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(u_pattern_tl_b/u_texsize,u_pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture(u_image,pos2);fragColor=mix(color1,color2,u_mix)*u_opacity;\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(1.0);\n#endif\n}", "uniform vec2 u_pattern_size_a;uniform vec2 u_pattern_size_b;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_scale_a;uniform float u_scale_b;uniform float u_tile_units_to_pixels;in vec2 a_pos;out vec2 v_pos_a;out vec2 v_pos_b;void main() {gl_Position=projectTile(a_pos);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,u_scale_a*u_pattern_size_a,u_tile_units_to_pixels,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,u_scale_b*u_pattern_size_b,u_tile_units_to_pixels,a_pos);}"), circle: _t("in vec3 v_data;in float v_visibility;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define mediump float radius\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define highp vec4 stroke_color\n#pragma mapbox: define mediump float stroke_width\n#pragma mapbox: define lowp float stroke_opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize mediump float radius\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize highp vec4 stroke_color\n#pragma mapbox: initialize mediump float stroke_width\n#pragma mapbox: initialize lowp float stroke_opacity\nvec2 extrude=v_data.xy;float extrude_length=length(extrude);float antialiased_blur=v_data.z;float opacity_t=smoothstep(0.0,antialiased_blur,extrude_length-1.0);float color_t=stroke_width < 0.01 ? 0.0 : smoothstep(antialiased_blur,0.0,extrude_length-radius/(radius+stroke_width));fragColor=v_visibility*opacity_t*mix(color*opacity,stroke_color*stroke_opacity,color_t);const float epsilon=0.5/255.0;if (fragColor.r < epsilon && fragColor.g < epsilon && fragColor.b < epsilon && fragColor.a < epsilon) {discard;}\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(1.0);\n#endif\n}", "uniform bool u_scale_with_map;uniform bool u_pitch_with_map;uniform vec2 u_extrude_scale;uniform highp float u_globe_extrude_scale;uniform lowp float u_device_pixel_ratio;uniform highp float u_camera_to_center_distance;uniform vec2 u_translate;in vec2 a_pos;out vec3 v_data;out float v_visibility;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define mediump float radius\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define highp vec4 stroke_color\n#pragma mapbox: define mediump float stroke_width\n#pragma mapbox: define lowp float stroke_opacity\nvoid main(void) {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize mediump float radius\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize highp vec4 stroke_color\n#pragma mapbox: initialize mediump float stroke_width\n#pragma mapbox: initialize lowp float stroke_opacity\nvec2 pos_raw=a_pos+32768.0;vec2 extrude=vec2(mod(pos_raw,8.0)/7.0*2.0-1.0);vec2 circle_center=floor(pos_raw/8.0)+u_translate;float ele=get_elevation(circle_center);v_visibility=calculate_visibility(projectTileWithElevation(circle_center,ele));if (u_pitch_with_map) {\n#ifdef GLOBE\nvec3 center_vector=projectToSphere(circle_center);\n#endif\nfloat angle_scale=u_globe_extrude_scale;vec2 corner_position=circle_center;if (u_scale_with_map) {angle_scale*=(radius+stroke_width);corner_position+=extrude*u_extrude_scale*(radius+stroke_width);} else {\n#ifdef GLOBE\nvec4 projected_center=interpolateProjection(circle_center,center_vector,ele);\n#else\nvec4 projected_center=projectTileWithElevation(circle_center,ele);\n#endif\ncorner_position+=extrude*u_extrude_scale*(radius+stroke_width)*(projected_center.w/u_camera_to_center_distance);angle_scale*=(radius+stroke_width)*(projected_center.w/u_camera_to_center_distance);}\n#ifdef GLOBE\nvec2 angles=extrude*angle_scale;vec3 corner_vector=globeRotateVector(center_vector,angles);gl_Position=interpolateProjection(corner_position,corner_vector,ele);\n#else\ngl_Position=projectTileWithElevation(corner_position,ele);\n#endif\n} else {gl_Position=projectTileWithElevation(circle_center,ele);if (gl_Position.z/gl_Position.w > 1.0) {gl_Position.xy=vec2(10000.0);}if (u_scale_with_map) {gl_Position.xy+=extrude*(radius+stroke_width)*u_extrude_scale*u_camera_to_center_distance;} else {gl_Position.xy+=extrude*(radius+stroke_width)*u_extrude_scale*gl_Position.w;}}float antialiasblur=-max(1.0/u_device_pixel_ratio/(radius+stroke_width),blur);v_data=vec3(extrude.x,extrude.y,antialiasblur);}"), clippingMask: _t(ut, "in vec2 a_pos;void main() {gl_Position=projectTile(a_pos);}"), heatmap: _t("uniform highp float u_intensity;in vec2 v_extrude;\n#pragma mapbox: define highp float weight\n#define GAUSS_COEF 0.3989422804014327\nvoid main() {\n#pragma mapbox: initialize highp float weight\nfloat d=-0.5*3.0*3.0*dot(v_extrude,v_extrude);float val=weight*u_intensity*GAUSS_COEF*exp(d);fragColor=vec4(val,1.0,1.0,1.0);\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(1.0);\n#endif\n}", "uniform float u_extrude_scale;uniform float u_opacity;uniform float u_intensity;uniform highp float u_globe_extrude_scale;in vec2 a_pos;out vec2 v_extrude;\n#pragma mapbox: define highp float weight\n#pragma mapbox: define mediump float radius\nconst highp float ZERO=1.0/255.0/16.0;\n#define GAUSS_COEF 0.3989422804014327\nvoid main(void) {\n#pragma mapbox: initialize highp float weight\n#pragma mapbox: initialize mediump float radius\nvec2 pos_raw=a_pos+32768.0;vec2 unscaled_extrude=vec2(mod(pos_raw,8.0)/7.0*2.0-1.0);float S=sqrt(-2.0*log(ZERO/weight/u_intensity/GAUSS_COEF))/3.0;v_extrude=S*unscaled_extrude;vec2 extrude=v_extrude*radius*u_extrude_scale;vec2 circle_center=floor(pos_raw/8.0);\n#ifdef GLOBE\nvec2 angles=v_extrude*radius*u_globe_extrude_scale;vec3 center_vector=projectToSphere(circle_center);vec3 corner_vector=globeRotateVector(center_vector,angles);gl_Position=interpolateProjection(circle_center+extrude,corner_vector,0.0);\n#else\ngl_Position=projectTileFor3D(circle_center+extrude,get_elevation(circle_center));\n#endif\n}"), heatmapTexture: _t("uniform sampler2D u_image;uniform sampler2D u_color_ramp;uniform float u_opacity;in vec2 v_pos;void main() {float t=texture(u_image,v_pos).r;vec4 color=texture(u_color_ramp,vec2(t,0.5));fragColor=color*u_opacity;\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(0.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec2 u_world;in vec2 a_pos;out vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos*u_world,0,1);v_pos.x=a_pos.x;v_pos.y=1.0-a_pos.y;}"), collisionBox: _t("in float v_placed;in float v_notUsed;void main() {float alpha=0.5;fragColor=vec4(1.0,0.0,0.0,1.0)*alpha;if (v_placed > 0.5) {fragColor=vec4(0.0,0.0,1.0,0.5)*alpha;}if (v_notUsed > 0.5) {fragColor*=.1;}}", "in vec2 a_anchor_pos;in vec2 a_placed;in vec2 a_box_real;uniform vec2 u_pixel_extrude_scale;out float v_placed;out float v_notUsed;void main() {gl_Position=projectTileWithElevation(a_anchor_pos,get_elevation(a_anchor_pos));gl_Position.xy=((a_box_real+0.5)*u_pixel_extrude_scale*2.0-1.0)*vec2(1.0,-1.0)*gl_Position.w;if (gl_Position.z/gl_Position.w < 1.1) {gl_Position.z=0.5;}v_placed=a_placed.x;v_notUsed=a_placed.y;}"), collisionCircle: _t("in float v_radius;in vec2 v_extrude;in float v_collision;void main() {float alpha=0.5;float stroke_radius=0.9;float distance_to_center=length(v_extrude);float distance_to_edge=abs(distance_to_center-v_radius);float opacity_t=smoothstep(-stroke_radius,0.0,-distance_to_edge);vec4 color=mix(vec4(0.0,0.0,1.0,0.5),vec4(1.0,0.0,0.0,1.0),v_collision);fragColor=color*alpha*opacity_t;}", "in vec2 a_pos;in float a_radius;in vec2 a_flags;uniform vec2 u_viewport_size;out float v_radius;out vec2 v_extrude;out float v_collision;void main() {float radius=a_radius;float collision=a_flags.x;float vertexIdx=a_flags.y;vec2 quadVertexOffset=vec2(mix(-1.0,1.0,float(vertexIdx >=2.0)),mix(-1.0,1.0,float(vertexIdx >=1.0 && vertexIdx <=2.0)));vec2 quadVertexExtent=quadVertexOffset*radius;float padding_factor=1.2;v_radius=radius;v_extrude=quadVertexExtent*padding_factor;v_collision=collision;gl_Position=vec4((a_pos/u_viewport_size*2.0-1.0)*vec2(1.0,-1.0),0.0,1.0)+vec4(quadVertexExtent*padding_factor/u_viewport_size*2.0,0.0,0.0);}"), debug: _t("uniform highp vec4 u_color;uniform sampler2D u_overlay;in vec2 v_uv;void main() {vec4 overlay_color=texture(u_overlay,v_uv);fragColor=mix(u_color,overlay_color,overlay_color.a);}", "in vec2 a_pos;out vec2 v_uv;uniform float u_overlay_scale;void main() {v_uv=a_pos/8192.0;gl_Position=projectTileWithElevation(a_pos*u_overlay_scale,get_elevation(a_pos));}"), depth: _t(ut, "in vec2 a_pos;void main() {\n#ifdef GLOBE\ngl_Position=projectTileFor3D(a_pos,0.0);\n#else\ngl_Position=u_projection_matrix*vec4(a_pos,0.0,1.0);\n#endif\n}"), fill: _t("#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float opacity\nfragColor=color*opacity;\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(1.0);\n#endif\n}", "uniform vec2 u_fill_translate;in vec2 a_pos;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float opacity\ngl_Position=projectTile(a_pos+u_fill_translate,a_pos);}"), fillOutline: _t("in vec2 v_pos;\n#ifdef GLOBE\nin float v_depth;\n#endif\n#pragma mapbox: define highp vec4 outline_color\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 outline_color\n#pragma mapbox: initialize lowp float opacity\nfloat dist=length(v_pos-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);fragColor=outline_color*(alpha*opacity);\n#ifdef GLOBE\nif (v_depth > 1.0) {discard;}\n#endif\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(1.0);\n#endif\n}", "uniform vec2 u_world;uniform vec2 u_fill_translate;in vec2 a_pos;out vec2 v_pos;\n#ifdef GLOBE\nout float v_depth;\n#endif\n#pragma mapbox: define highp vec4 outline_color\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 outline_color\n#pragma mapbox: initialize lowp float opacity\ngl_Position=projectTile(a_pos+u_fill_translate,a_pos);v_pos=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;\n#ifdef GLOBE\nv_depth=gl_Position.z/gl_Position.w;\n#endif\n}"), fillOutlinePattern: _t("uniform vec2 u_texsize;uniform sampler2D u_image;uniform float u_fade;in vec2 v_pos_a;in vec2 v_pos_b;in vec2 v_pos;\n#ifdef GLOBE\nin float v_depth;\n#endif\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture(u_image,pos2);float dist=length(v_pos-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);fragColor=mix(color1,color2,u_fade)*alpha*opacity;\n#ifdef GLOBE\nif (v_depth > 1.0) {discard;}\n#endif\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(1.0);\n#endif\n}", "uniform vec2 u_world;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform vec3 u_scale;uniform vec2 u_fill_translate;in vec2 a_pos;out vec2 v_pos_a;out vec2 v_pos_b;out vec2 v_pos;\n#ifdef GLOBE\nout float v_depth;\n#endif\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\n#pragma mapbox: define lowp float pixel_ratio_from\n#pragma mapbox: define lowp float pixel_ratio_to\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\n#pragma mapbox: initialize lowp float pixel_ratio_from\n#pragma mapbox: initialize lowp float pixel_ratio_to\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;gl_Position=projectTile(a_pos+u_fill_translate,a_pos);vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileRatio,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileRatio,a_pos);v_pos=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;\n#ifdef GLOBE\nv_depth=gl_Position.z/gl_Position.w;\n#endif\n}"), fillPattern: _t("#ifdef GL_ES\nprecision highp float;\n#endif\nuniform vec2 u_texsize;uniform float u_fade;uniform sampler2D u_image;in vec2 v_pos_a;in vec2 v_pos_b;\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture(u_image,pos2);fragColor=mix(color1,color2,u_fade)*opacity;\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(1.0);\n#endif\n}", "uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform vec3 u_scale;uniform vec2 u_fill_translate;in vec2 a_pos;out vec2 v_pos_a;out vec2 v_pos_b;\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\n#pragma mapbox: define lowp float pixel_ratio_from\n#pragma mapbox: define lowp float pixel_ratio_to\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\n#pragma mapbox: initialize lowp float pixel_ratio_from\n#pragma mapbox: initialize lowp float pixel_ratio_to\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileZoomRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;gl_Position=projectTile(a_pos+u_fill_translate,a_pos);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileZoomRatio,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileZoomRatio,a_pos);}"), fillExtrusion: _t("in vec4 v_color;void main() {fragColor=v_color;\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(1.0);\n#endif\n}", "uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp vec3 u_lightpos_globe;uniform lowp float u_lightintensity;uniform float u_vertical_gradient;uniform lowp float u_opacity;uniform vec2 u_fill_translate;in vec2 a_pos;in vec4 a_normal_ed;\n#ifdef TERRAIN3D\nin vec2 a_centroid;\n#endif\nout vec4 v_color;\n#pragma mapbox: define highp float base\n#pragma mapbox: define highp float height\n#pragma mapbox: define highp vec4 color\nvoid main() {\n#pragma mapbox: initialize highp float base\n#pragma mapbox: initialize highp float height\n#pragma mapbox: initialize highp vec4 color\nvec3 normal=a_normal_ed.xyz;\n#ifdef TERRAIN3D\nfloat height_terrain3d_offset=get_elevation(a_centroid);float base_terrain3d_offset=height_terrain3d_offset-(base > 0.0 ? 0.0 : 10.0);\n#else\nfloat height_terrain3d_offset=0.0;float base_terrain3d_offset=0.0;\n#endif\nbase=max(0.0,base)+base_terrain3d_offset;height=max(0.0,height)+height_terrain3d_offset;float t=mod(normal.x,2.0);float elevation=t > 0.0 ? height : base;vec2 posInTile=a_pos+u_fill_translate;\n#ifdef GLOBE\nvec3 spherePos=projectToSphere(posInTile,a_pos);gl_Position=interpolateProjectionFor3D(posInTile,spherePos,elevation);\n#else\ngl_Position=u_projection_matrix*vec4(posInTile,elevation,1.0);\n#endif\nfloat colorvalue=color.r*0.2126+color.g*0.7152+color.b*0.0722;v_color=vec4(0.0,0.0,0.0,1.0);vec4 ambientlight=vec4(0.03,0.03,0.03,1.0);color+=ambientlight;vec3 normalForLighting=normal/16384.0;float directional=clamp(dot(normalForLighting,u_lightpos),0.0,1.0);\n#ifdef GLOBE\nmat3 rotMatrix=globeGetRotationMatrix(spherePos);normalForLighting=rotMatrix*normalForLighting;directional=mix(directional,clamp(dot(normalForLighting,u_lightpos_globe),0.0,1.0),u_projection_transition);\n#endif\ndirectional=mix((1.0-u_lightintensity),max((1.0-colorvalue+u_lightintensity),1.0),directional);if (normal.y !=0.0) {directional*=((1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),mix(0.7,0.98,1.0-u_lightintensity),1.0)));}v_color.r+=clamp(color.r*directional*u_lightcolor.r,mix(0.0,0.3,1.0-u_lightcolor.r),1.0);v_color.g+=clamp(color.g*directional*u_lightcolor.g,mix(0.0,0.3,1.0-u_lightcolor.g),1.0);v_color.b+=clamp(color.b*directional*u_lightcolor.b,mix(0.0,0.3,1.0-u_lightcolor.b),1.0);v_color*=u_opacity;}"), fillExtrusionPattern: _t("uniform vec2 u_texsize;uniform float u_fade;uniform sampler2D u_image;in vec2 v_pos_a;in vec2 v_pos_b;in vec4 v_lighting;\n#pragma mapbox: define lowp float base\n#pragma mapbox: define lowp float height\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\n#pragma mapbox: define lowp float pixel_ratio_from\n#pragma mapbox: define lowp float pixel_ratio_to\nvoid main() {\n#pragma mapbox: initialize lowp float base\n#pragma mapbox: initialize lowp float height\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\n#pragma mapbox: initialize lowp float pixel_ratio_from\n#pragma mapbox: initialize lowp float pixel_ratio_to\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture(u_image,pos2);vec4 mixedColor=mix(color1,color2,u_fade);fragColor=mixedColor*v_lighting;\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(1.0);\n#endif\n}", "uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_height_factor;uniform vec3 u_scale;uniform float u_vertical_gradient;uniform lowp float u_opacity;uniform vec2 u_fill_translate;uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp vec3 u_lightpos_globe;uniform lowp float u_lightintensity;in vec2 a_pos;in vec4 a_normal_ed;\n#ifdef TERRAIN3D\nin vec2 a_centroid;\n#endif\n#ifdef GLOBE\nout vec3 v_sphere_pos;\n#endif\nout vec2 v_pos_a;out vec2 v_pos_b;out vec4 v_lighting;\n#pragma mapbox: define lowp float base\n#pragma mapbox: define lowp float height\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\n#pragma mapbox: define lowp float pixel_ratio_from\n#pragma mapbox: define lowp float pixel_ratio_to\nvoid main() {\n#pragma mapbox: initialize lowp float base\n#pragma mapbox: initialize lowp float height\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\n#pragma mapbox: initialize lowp float pixel_ratio_from\n#pragma mapbox: initialize lowp float pixel_ratio_to\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec3 normal=a_normal_ed.xyz;float edgedistance=a_normal_ed.w;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;\n#ifdef TERRAIN3D\nfloat height_terrain3d_offset=get_elevation(a_centroid);float base_terrain3d_offset=height_terrain3d_offset-(base > 0.0 ? 0.0 : 10.0);\n#else\nfloat height_terrain3d_offset=0.0;float base_terrain3d_offset=0.0;\n#endif\nbase=max(0.0,base)+base_terrain3d_offset;height=max(0.0,height)+height_terrain3d_offset;float t=mod(normal.x,2.0);float elevation=t > 0.0 ? height : base;vec2 posInTile=a_pos+u_fill_translate;\n#ifdef GLOBE\nvec3 spherePos=projectToSphere(posInTile,a_pos);vec3 elevatedPos=spherePos*(1.0+elevation/GLOBE_RADIUS);v_sphere_pos=elevatedPos;gl_Position=interpolateProjectionFor3D(posInTile,spherePos,elevation);\n#else\ngl_Position=u_projection_matrix*vec4(posInTile,elevation,1.0);\n#endif\nvec2 pos=normal.x==1.0 && normal.y==0.0 && normal.z==16384.0\n? a_pos\n: vec2(edgedistance,elevation*u_height_factor);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileRatio,pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileRatio,pos);v_lighting=vec4(0.0,0.0,0.0,1.0);float directional=clamp(dot(normal/16383.0,u_lightpos),0.0,1.0);directional=mix((1.0-u_lightintensity),max((0.5+u_lightintensity),1.0),directional);if (normal.y !=0.0) {directional*=((1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),mix(0.7,0.98,1.0-u_lightintensity),1.0)));}v_lighting.rgb+=clamp(directional*u_lightcolor,mix(vec3(0.0),vec3(0.3),1.0-u_lightcolor),vec3(1.0));v_lighting*=u_opacity;}"), hillshadePrepare: _t("#ifdef GL_ES\nprecision highp float;\n#endif\nuniform sampler2D u_image;in vec2 v_pos;uniform vec2 u_dimension;uniform float u_zoom;uniform vec4 u_unpack;float getElevation(vec2 coord,float bias) {vec4 data=texture(u_image,coord)*255.0;data.a=-1.0;return dot(data,u_unpack)/4.0;}void main() {vec2 epsilon=1.0/u_dimension;float a=getElevation(v_pos+vec2(-epsilon.x,-epsilon.y),0.0);float b=getElevation(v_pos+vec2(0,-epsilon.y),0.0);float c=getElevation(v_pos+vec2(epsilon.x,-epsilon.y),0.0);float d=getElevation(v_pos+vec2(-epsilon.x,0),0.0);float e=getElevation(v_pos,0.0);float f=getElevation(v_pos+vec2(epsilon.x,0),0.0);float g=getElevation(v_pos+vec2(-epsilon.x,epsilon.y),0.0);float h=getElevation(v_pos+vec2(0,epsilon.y),0.0);float i=getElevation(v_pos+vec2(epsilon.x,epsilon.y),0.0);float exaggerationFactor=u_zoom < 2.0 ? 0.4 : u_zoom < 4.5 ? 0.35 : 0.3;float exaggeration=u_zoom < 15.0 ? (u_zoom-15.0)*exaggerationFactor : 0.0;vec2 deriv=vec2((c+f+f+i)-(a+d+d+g),(g+h+h+i)-(a+b+b+c))/pow(2.0,exaggeration+(19.2562-u_zoom));fragColor=clamp(vec4(deriv.x/2.0+0.5,deriv.y/2.0+0.5,1.0,1.0),0.0,1.0);\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec2 u_dimension;in vec2 a_pos;in vec2 a_texture_pos;out vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);highp vec2 epsilon=1.0/u_dimension;float scale=(u_dimension.x-2.0)/u_dimension.x;v_pos=(a_texture_pos/8192.0)*scale+epsilon;}"), hillshade: _t("uniform sampler2D u_image;in vec2 v_pos;uniform vec2 u_latrange;uniform vec2 u_light;uniform vec4 u_shadow;uniform vec4 u_highlight;uniform vec4 u_accent;\n#define PI 3.141592653589793\nvoid main() {vec4 pixel=texture(u_image,v_pos);vec2 deriv=((pixel.rg*2.0)-1.0);float scaleFactor=cos(radians((u_latrange[0]-u_latrange[1])*(1.0-v_pos.y)+u_latrange[1]));float slope=atan(1.25*length(deriv)/scaleFactor);float aspect=deriv.x !=0.0 ? atan(deriv.y,-deriv.x) : PI/2.0*(deriv.y > 0.0 ? 1.0 :-1.0);float intensity=u_light.x;float azimuth=u_light.y+PI;float base=1.875-intensity*1.75;float maxValue=0.5*PI;float scaledSlope=intensity !=0.5 ? ((pow(base,slope)-1.0)/(pow(base,maxValue)-1.0))*maxValue : slope;float accent=cos(scaledSlope);vec4 accent_color=(1.0-accent)*u_accent*clamp(intensity*2.0,0.0,1.0);float shade=abs(mod((aspect+azimuth)/PI+0.5,2.0)-1.0);vec4 shade_color=mix(u_shadow,u_highlight,shade)*sin(scaledSlope)*clamp(intensity*2.0,0.0,1.0);fragColor=accent_color*(1.0-shade_color.a)+shade_color;\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;in vec2 a_pos;out vec2 v_pos;void main() {gl_Position=projectTile(a_pos,a_pos);v_pos=a_pos/8192.0;if (a_pos.y <-32767.5) {v_pos.y=0.0;}if (a_pos.y > 32766.5) {v_pos.y=1.0;}}"), line: _t("uniform lowp float u_device_pixel_ratio;in vec2 v_width2;in vec2 v_normal;in float v_gamma_scale;\n#ifdef GLOBE\nin float v_depth;\n#endif\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\nfloat dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);fragColor=color*(alpha*opacity);\n#ifdef GLOBE\nif (v_depth > 1.0) {discard;}\n#endif\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(1.0);\n#endif\n}", "\n#define scale 0.015873016\nin vec2 a_pos_normal;in vec4 a_data;uniform vec2 u_translation;uniform mediump float u_ratio;uniform vec2 u_units_to_pixels;uniform lowp float u_device_pixel_ratio;out vec2 v_normal;out vec2 v_width2;out float v_gamma_scale;out highp float v_linesofar;\n#ifdef GLOBE\nout float v_depth;\n#endif\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define mediump float gapwidth\n#pragma mapbox: define lowp float offset\n#pragma mapbox: define mediump float width\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump float gapwidth\n#pragma mapbox: initialize lowp float offset\n#pragma mapbox: initialize mediump float width\nfloat ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;v_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*2.0;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);float adjustedThickness=projectLineThickness(pos.y);vec4 projected_no_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation);vec4 projected_with_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation+dist/u_ratio*adjustedThickness);gl_Position=projected_with_extrude;\n#ifdef GLOBE\nv_depth=gl_Position.z/gl_Position.w;\n#endif\n#ifdef TERRAIN3D\nv_gamma_scale=1.0;\n#else\nfloat extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length((projected_with_extrude.xy-projected_no_extrude.xy)/projected_with_extrude.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;\n#endif\nv_width2=vec2(outset,inset);}"), lineGradient: _t("uniform lowp float u_device_pixel_ratio;uniform sampler2D u_image;in vec2 v_width2;in vec2 v_normal;in float v_gamma_scale;in highp vec2 v_uv;\n#ifdef GLOBE\nin float v_depth;\n#endif\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\nfloat dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);vec4 color=texture(u_image,v_uv);fragColor=color*(alpha*opacity);\n#ifdef GLOBE\nif (v_depth > 1.0) {discard;}\n#endif\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(1.0);\n#endif\n}", "\n#define scale 0.015873016\nin vec2 a_pos_normal;in vec4 a_data;in float a_uv_x;in float a_split_index;uniform vec2 u_translation;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;uniform vec2 u_units_to_pixels;uniform float u_image_height;out vec2 v_normal;out vec2 v_width2;out float v_gamma_scale;out highp vec2 v_uv;\n#ifdef GLOBE\nout float v_depth;\n#endif\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define mediump float gapwidth\n#pragma mapbox: define lowp float offset\n#pragma mapbox: define mediump float width\nvoid main() {\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump float gapwidth\n#pragma mapbox: initialize lowp float offset\n#pragma mapbox: initialize mediump float width\nfloat ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;highp float texel_height=1.0/u_image_height;highp float half_texel_height=0.5*texel_height;v_uv=vec2(a_uv_x,a_split_index*texel_height-half_texel_height);vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);float adjustedThickness=projectLineThickness(pos.y);vec4 projected_no_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation);vec4 projected_with_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation+dist/u_ratio*adjustedThickness);gl_Position=projected_with_extrude;\n#ifdef GLOBE\nv_depth=gl_Position.z/gl_Position.w;\n#endif\n#ifdef TERRAIN3D\nv_gamma_scale=1.0;\n#else\nfloat extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length((projected_with_extrude.xy-projected_no_extrude.xy)/projected_with_extrude.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;\n#endif\nv_width2=vec2(outset,inset);}"), linePattern: _t("#ifdef GL_ES\nprecision highp float;\n#endif\nuniform lowp float u_device_pixel_ratio;uniform vec2 u_texsize;uniform float u_fade;uniform mediump vec3 u_scale;uniform sampler2D u_image;in vec2 v_normal;in vec2 v_width2;in float v_linesofar;in float v_gamma_scale;in float v_width;\n#ifdef GLOBE\nin float v_depth;\n#endif\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\n#pragma mapbox: define lowp float pixel_ratio_from\n#pragma mapbox: define lowp float pixel_ratio_to\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\n#pragma mapbox: initialize lowp float pixel_ratio_from\n#pragma mapbox: initialize lowp float pixel_ratio_to\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileZoomRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;vec2 pattern_size_a=vec2(display_size_a.x*fromScale/tileZoomRatio,display_size_a.y);vec2 pattern_size_b=vec2(display_size_b.x*toScale/tileZoomRatio,display_size_b.y);float aspect_a=display_size_a.y/v_width;float aspect_b=display_size_b.y/v_width;float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);float x_a=mod(v_linesofar/pattern_size_a.x*aspect_a,1.0);float x_b=mod(v_linesofar/pattern_size_b.x*aspect_b,1.0);float y=0.5*v_normal.y+0.5;vec2 texel_size=1.0/u_texsize;vec2 pos_a=mix(pattern_tl_a*texel_size-texel_size,pattern_br_a*texel_size+texel_size,vec2(x_a,y));vec2 pos_b=mix(pattern_tl_b*texel_size-texel_size,pattern_br_b*texel_size+texel_size,vec2(x_b,y));vec4 color=mix(texture(u_image,pos_a),texture(u_image,pos_b),u_fade);fragColor=color*alpha*opacity;\n#ifdef GLOBE\nif (v_depth > 1.0) {discard;}\n#endif\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(1.0);\n#endif\n}", "\n#define scale 0.015873016\n#define LINE_DISTANCE_SCALE 2.0\nin vec2 a_pos_normal;in vec4 a_data;uniform vec2 u_translation;uniform vec2 u_units_to_pixels;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;out vec2 v_normal;out vec2 v_width2;out float v_linesofar;out float v_gamma_scale;out float v_width;\n#ifdef GLOBE\nout float v_depth;\n#endif\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float offset\n#pragma mapbox: define mediump float gapwidth\n#pragma mapbox: define mediump float width\n#pragma mapbox: define lowp float floorwidth\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\n#pragma mapbox: define lowp float pixel_ratio_from\n#pragma mapbox: define lowp float pixel_ratio_to\nvoid main() {\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float offset\n#pragma mapbox: initialize mediump float gapwidth\n#pragma mapbox: initialize mediump float width\n#pragma mapbox: initialize lowp float floorwidth\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\n#pragma mapbox: initialize lowp float pixel_ratio_from\n#pragma mapbox: initialize lowp float pixel_ratio_to\nfloat ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;float a_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*LINE_DISTANCE_SCALE;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);float adjustedThickness=projectLineThickness(pos.y);vec4 projected_no_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation);vec4 projected_with_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation+dist/u_ratio*adjustedThickness);gl_Position=projected_with_extrude;\n#ifdef GLOBE\nv_depth=gl_Position.z/gl_Position.w;\n#endif\n#ifdef TERRAIN3D\nv_gamma_scale=1.0;\n#else\nfloat extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length((projected_with_extrude.xy-projected_no_extrude.xy)/projected_with_extrude.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;\n#endif\nv_linesofar=a_linesofar;v_width2=vec2(outset,inset);v_width=floorwidth;}"), lineSDF: _t("uniform lowp float u_device_pixel_ratio;uniform sampler2D u_image;uniform float u_sdfgamma;uniform float u_mix;in vec2 v_normal;in vec2 v_width2;in vec2 v_tex_a;in vec2 v_tex_b;in float v_gamma_scale;\n#ifdef GLOBE\nin float v_depth;\n#endif\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define mediump float width\n#pragma mapbox: define lowp float floorwidth\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump float width\n#pragma mapbox: initialize lowp float floorwidth\nfloat dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);float sdfdist_a=texture(u_image,v_tex_a).a;float sdfdist_b=texture(u_image,v_tex_b).a;float sdfdist=mix(sdfdist_a,sdfdist_b,u_mix);alpha*=smoothstep(0.5-u_sdfgamma/floorwidth,0.5+u_sdfgamma/floorwidth,sdfdist);fragColor=color*(alpha*opacity);\n#ifdef GLOBE\nif (v_depth > 1.0) {discard;}\n#endif\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(1.0);\n#endif\n}", "\n#define scale 0.015873016\n#define LINE_DISTANCE_SCALE 2.0\nin vec2 a_pos_normal;in vec4 a_data;uniform vec2 u_translation;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;uniform vec2 u_patternscale_a;uniform float u_tex_y_a;uniform vec2 u_patternscale_b;uniform float u_tex_y_b;uniform vec2 u_units_to_pixels;out vec2 v_normal;out vec2 v_width2;out vec2 v_tex_a;out vec2 v_tex_b;out float v_gamma_scale;\n#ifdef GLOBE\nout float v_depth;\n#endif\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define mediump float gapwidth\n#pragma mapbox: define lowp float offset\n#pragma mapbox: define mediump float width\n#pragma mapbox: define lowp float floorwidth\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump float gapwidth\n#pragma mapbox: initialize lowp float offset\n#pragma mapbox: initialize mediump float width\n#pragma mapbox: initialize lowp float floorwidth\nfloat ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;float a_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*LINE_DISTANCE_SCALE;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);float adjustedThickness=projectLineThickness(pos.y);vec4 projected_no_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation);vec4 projected_with_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation+dist/u_ratio*adjustedThickness);gl_Position=projected_with_extrude;\n#ifdef GLOBE\nv_depth=gl_Position.z/gl_Position.w;\n#endif\n#ifdef TERRAIN3D\nv_gamma_scale=1.0;\n#else\nfloat extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length((projected_with_extrude.xy-projected_no_extrude.xy)/projected_with_extrude.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;\n#endif\nv_tex_a=vec2(a_linesofar*u_patternscale_a.x/floorwidth,normal.y*u_patternscale_a.y+u_tex_y_a);v_tex_b=vec2(a_linesofar*u_patternscale_b.x/floorwidth,normal.y*u_patternscale_b.y+u_tex_y_b);v_width2=vec2(outset,inset);}"), raster: _t("uniform float u_fade_t;uniform float u_opacity;uniform sampler2D u_image0;uniform sampler2D u_image1;in vec2 v_pos0;in vec2 v_pos1;uniform float u_brightness_low;uniform float u_brightness_high;uniform float u_saturation_factor;uniform float u_contrast_factor;uniform vec3 u_spin_weights;void main() {vec4 color0=texture(u_image0,v_pos0);vec4 color1=texture(u_image1,v_pos1);if (color0.a > 0.0) {color0.rgb=color0.rgb/color0.a;}if (color1.a > 0.0) {color1.rgb=color1.rgb/color1.a;}vec4 color=mix(color0,color1,u_fade_t);color.a*=u_opacity;vec3 rgb=color.rgb;rgb=vec3(dot(rgb,u_spin_weights.xyz),dot(rgb,u_spin_weights.zxy),dot(rgb,u_spin_weights.yzx));float average=(color.r+color.g+color.b)/3.0;rgb+=(average-rgb)*u_saturation_factor;rgb=(rgb-0.5)*u_contrast_factor+0.5;vec3 u_high_vec=vec3(u_brightness_low,u_brightness_low,u_brightness_low);vec3 u_low_vec=vec3(u_brightness_high,u_brightness_high,u_brightness_high);fragColor=vec4(mix(u_high_vec,u_low_vec,rgb)*color.a,color.a);\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(1.0);\n#endif\n}", "uniform vec2 u_tl_parent;uniform float u_scale_parent;uniform float u_buffer_scale;uniform vec4 u_coords_top;uniform vec4 u_coords_bottom;in vec2 a_pos;out vec2 v_pos0;out vec2 v_pos1;void main() {vec2 fractionalPos=a_pos/8192.0;vec2 position=mix(mix(u_coords_top.xy,u_coords_top.zw,fractionalPos.x),mix(u_coords_bottom.xy,u_coords_bottom.zw,fractionalPos.x),fractionalPos.y);gl_Position=projectTile(position,position);v_pos0=((fractionalPos-0.5)/u_buffer_scale)+0.5;\n#ifdef GLOBE\nif (a_pos.y <-32767.5) {v_pos0.y=0.0;}if (a_pos.y > 32766.5) {v_pos0.y=1.0;}\n#endif\nv_pos1=(v_pos0*u_scale_parent)+u_tl_parent;}"), symbolIcon: _t("uniform sampler2D u_texture;in vec2 v_tex;in float v_fade_opacity;\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\nlowp float alpha=opacity*v_fade_opacity;fragColor=texture(u_texture,v_tex)*alpha;\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(1.0);\n#endif\n}", "in vec4 a_pos_offset;in vec4 a_data;in vec4 a_pixeloffset;in vec3 a_projected_pos;in float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform highp float u_camera_to_center_distance;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform float u_fade_change;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform vec2 u_texsize;uniform bool u_is_along_line;uniform bool u_is_variable_anchor;uniform vec2 u_translation;uniform float u_pitched_scale;out vec2 v_tex;out float v_fade_opacity;\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\nvec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);vec2 a_pxoffset=a_pixeloffset.xy;vec2 a_minFontScale=a_pixeloffset.zw/256.0;float ele=get_elevation(a_pos);highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 translated_a_pos=a_pos+u_translation;vec4 projectedPoint=projectTileWithElevation(translated_a_pos,ele);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?\ncamera_to_anchor_distance/u_camera_to_center_distance :\nu_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=projectTileWithElevation(translated_a_pos+vec2(1,0),ele);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos;if (u_is_along_line || u_is_variable_anchor) {projected_pos=vec4(a_projected_pos.xy,ele,1.0);} else if (u_pitch_with_map) {projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy+u_translation,ele,1.0);} else {projected_pos=u_label_plane_matrix*projectTileWithElevation(a_projected_pos.xy+u_translation,ele);}float z=float(u_pitch_with_map)*projected_pos.z/projected_pos.w;float projectionScaling=1.0;\n#ifdef GLOBE\nif(u_pitch_with_map) {float anchor_pos_tile_y=(u_coord_matrix*vec4(projected_pos.xy/projected_pos.w,z,1.0)).y;projectionScaling=mix(projectionScaling,1.0/circumferenceRatioAtTileY(anchor_pos_tile_y)*u_pitched_scale,u_projection_transition);}\n#endif\nvec4 finalPos=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*max(a_minFontScale,fontScale)+a_pxoffset/16.0)*projectionScaling,z,1.0);if(u_pitch_with_map) {finalPos=projectTileWithElevation(finalPos.xy,finalPos.z);}gl_Position=finalPos;v_tex=a_tex/u_texsize;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float visibility=calculate_visibility(projectedPoint);v_fade_opacity=max(0.0,min(visibility,fade_opacity[0]+fade_change));}"), symbolSDF: _t("#define SDF_PX 8.0\nuniform bool u_is_halo;uniform sampler2D u_texture;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;uniform bool u_is_text;in vec2 v_data0;in vec3 v_data1;\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\nvoid main() {\n#pragma mapbox: initialize highp vec4 fill_color\n#pragma mapbox: initialize highp vec4 halo_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float halo_width\n#pragma mapbox: initialize lowp float halo_blur\nfloat EDGE_GAMMA=0.105/u_device_pixel_ratio;vec2 tex=v_data0.xy;float gamma_scale=v_data1.x;float size=v_data1.y;float fade_opacity=v_data1[2];float fontScale=u_is_text ? size/24.0 : size;lowp vec4 color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float inner_edge=(256.0-64.0)/256.0;if (u_is_halo) {color=halo_color;gamma=(halo_blur*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);inner_edge=inner_edge+gamma*gamma_scale;}lowp float dist=texture(u_texture,tex).a;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(inner_edge-gamma_scaled,inner_edge+gamma_scaled,dist);if (u_is_halo) {lowp float halo_edge=(6.0-halo_width/fontScale)/SDF_PX;alpha=min(smoothstep(halo_edge-gamma_scaled,halo_edge+gamma_scaled,dist),1.0-alpha);}fragColor=color*(alpha*opacity*fade_opacity);\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(1.0);\n#endif\n}", "in vec4 a_pos_offset;in vec4 a_data;in vec4 a_pixeloffset;in vec3 a_projected_pos;in float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform bool u_is_along_line;uniform bool u_is_variable_anchor;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;uniform vec2 u_translation;uniform float u_pitched_scale;out vec2 v_data0;out vec3 v_data1;\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\nvoid main() {\n#pragma mapbox: initialize highp vec4 fill_color\n#pragma mapbox: initialize highp vec4 halo_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float halo_width\n#pragma mapbox: initialize lowp float halo_blur\nvec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);vec2 a_pxoffset=a_pixeloffset.xy;float ele=get_elevation(a_pos);highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 translated_a_pos=a_pos+u_translation;vec4 projectedPoint=projectTileWithElevation(translated_a_pos,ele);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?\ncamera_to_anchor_distance/u_camera_to_center_distance :\nu_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=projectTileWithElevation(translated_a_pos+vec2(1,0),ele);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos;if (u_is_along_line || u_is_variable_anchor) {projected_pos=vec4(a_projected_pos.xy,ele,1.0);} else if (u_pitch_with_map) {projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy+u_translation,ele,1.0);} else {projected_pos=u_label_plane_matrix*projectTileWithElevation(a_projected_pos.xy+u_translation,ele);}float z=float(u_pitch_with_map)*projected_pos.z/projected_pos.w;float projectionScaling=1.0;\n#ifdef GLOBE\nif(u_pitch_with_map) {float anchor_pos_tile_y=(u_coord_matrix*vec4(projected_pos.xy/projected_pos.w,z,1.0)).y;projectionScaling=mix(projectionScaling,1.0/circumferenceRatioAtTileY(anchor_pos_tile_y)*u_pitched_scale,u_projection_transition);}\n#endif\nvec4 finalPos=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*fontScale+a_pxoffset)*projectionScaling,z,1.0);if(u_pitch_with_map) {finalPos=projectTileWithElevation(finalPos.xy,finalPos.z);}float gamma_scale=finalPos.w;gl_Position=finalPos;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float visibility=calculate_visibility(projectedPoint);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float interpolated_fade_opacity=max(0.0,min(visibility,fade_opacity[0]+fade_change));v_data0=a_tex/u_texsize;v_data1=vec3(gamma_scale,size,interpolated_fade_opacity);}"), symbolTextAndIcon: _t("#define SDF_PX 8.0\n#define SDF 1.0\n#define ICON 0.0\nuniform bool u_is_halo;uniform sampler2D u_texture;uniform sampler2D u_texture_icon;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;in vec4 v_data0;in vec4 v_data1;\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\nvoid main() {\n#pragma mapbox: initialize highp vec4 fill_color\n#pragma mapbox: initialize highp vec4 halo_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float halo_width\n#pragma mapbox: initialize lowp float halo_blur\nfloat fade_opacity=v_data1[2];if (v_data1.w==ICON) {vec2 tex_icon=v_data0.zw;lowp float alpha=opacity*fade_opacity;fragColor=texture(u_texture_icon,tex_icon)*alpha;\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(1.0);\n#endif\nreturn;}vec2 tex=v_data0.xy;float EDGE_GAMMA=0.105/u_device_pixel_ratio;float gamma_scale=v_data1.x;float size=v_data1.y;float fontScale=size/24.0;lowp vec4 color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float buff=(256.0-64.0)/256.0;if (u_is_halo) {color=halo_color;gamma=(halo_blur*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);buff=(6.0-halo_width/fontScale)/SDF_PX;}lowp float dist=texture(u_texture,tex).a;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(buff-gamma_scaled,buff+gamma_scaled,dist);fragColor=color*(alpha*opacity*fade_opacity);\n#ifdef OVERDRAW_INSPECTOR\nfragColor=vec4(1.0);\n#endif\n}", "in vec4 a_pos_offset;in vec4 a_data;in vec3 a_projected_pos;in float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;uniform vec2 u_texsize_icon;uniform bool u_is_along_line;uniform bool u_is_variable_anchor;uniform vec2 u_translation;uniform float u_pitched_scale;out vec4 v_data0;out vec4 v_data1;\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\nvoid main() {\n#pragma mapbox: initialize highp vec4 fill_color\n#pragma mapbox: initialize highp vec4 halo_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float halo_width\n#pragma mapbox: initialize lowp float halo_blur\nvec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);float is_sdf=a_size[0]-2.0*a_size_min;float ele=get_elevation(a_pos);highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 translated_a_pos=a_pos+u_translation;vec4 projectedPoint=projectTileWithElevation(translated_a_pos,ele);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?\ncamera_to_anchor_distance/u_camera_to_center_distance :\nu_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=size/24.0;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=projectTileWithElevation(translated_a_pos+vec2(1,0),ele);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos;if (u_is_along_line || u_is_variable_anchor) {projected_pos=vec4(a_projected_pos.xy,ele,1.0);} else if (u_pitch_with_map) {projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy+u_translation,ele,1.0);} else {projected_pos=u_label_plane_matrix*projectTileWithElevation(a_projected_pos.xy+u_translation,ele);}float z=float(u_pitch_with_map)*projected_pos.z/projected_pos.w;float projectionScaling=1.0;\n#ifdef GLOBE\nif(u_pitch_with_map && !u_is_along_line) {float anchor_pos_tile_y=(u_coord_matrix*vec4(projected_pos.xy/projected_pos.w,z,1.0)).y;projectionScaling=mix(projectionScaling,1.0/circumferenceRatioAtTileY(anchor_pos_tile_y)*u_pitched_scale,u_projection_transition);}\n#endif\nvec4 finalPos=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*fontScale)*projectionScaling,z,1.0);if(u_pitch_with_map) {finalPos=projectTileWithElevation(finalPos.xy,finalPos.z);}float gamma_scale=finalPos.w;gl_Position=finalPos;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float visibility=calculate_visibility(projectedPoint);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float interpolated_fade_opacity=max(0.0,min(visibility,fade_opacity[0]+fade_change));v_data0.xy=a_tex/u_texsize;v_data0.zw=a_tex/u_texsize_icon;v_data1=vec4(gamma_scale,size,interpolated_fade_opacity,is_sdf);}"), terrain: _t("uniform sampler2D u_texture;uniform vec4 u_fog_color;uniform vec4 u_horizon_color;uniform float u_fog_ground_blend;uniform float u_fog_ground_blend_opacity;uniform float u_horizon_fog_blend;uniform bool u_is_globe_mode;in vec2 v_texture_pos;in float v_fog_depth;const float gamma=2.2;vec4 gammaToLinear(vec4 color) {return pow(color,vec4(gamma));}vec4 linearToGamma(vec4 color) {return pow(color,vec4(1.0/gamma));}void main() {vec4 surface_color=texture(u_texture,vec2(v_texture_pos.x,1.0-v_texture_pos.y));if (!u_is_globe_mode && v_fog_depth > u_fog_ground_blend) {vec4 surface_color_linear=gammaToLinear(surface_color);float blend_color=smoothstep(0.0,1.0,max((v_fog_depth-u_horizon_fog_blend)/(1.0-u_horizon_fog_blend),0.0));vec4 fog_horizon_color_linear=mix(gammaToLinear(u_fog_color),gammaToLinear(u_horizon_color),blend_color);float factor_fog=max(v_fog_depth-u_fog_ground_blend,0.0)/(1.0-u_fog_ground_blend);fragColor=linearToGamma(mix(surface_color_linear,fog_horizon_color_linear,pow(factor_fog,2.0)*u_fog_ground_blend_opacity));} else {fragColor=surface_color;}}", "in vec3 a_pos3d;uniform mat4 u_fog_matrix;uniform float u_ele_delta;out vec2 v_texture_pos;out float v_fog_depth;void main() {float ele=get_elevation(a_pos3d.xy);float ele_delta=a_pos3d.z==1.0 ? u_ele_delta : 0.0;v_texture_pos=a_pos3d.xy/8192.0;gl_Position=projectTileFor3D(a_pos3d.xy,get_elevation(a_pos3d.xy)-ele_delta);vec4 pos=u_fog_matrix*vec4(a_pos3d.xy,ele,1.0);v_fog_depth=pos.z/pos.w*0.5+0.5;}"), terrainDepth: _t("in float v_depth;const highp vec4 bitSh=vec4(256.*256.*256.,256.*256.,256.,1.);const highp vec4 bitMsk=vec4(0.,vec3(1./256.0));highp vec4 pack(highp float value) {highp vec4 comp=fract(value*bitSh);comp-=comp.xxyz*bitMsk;return comp;}void main() {fragColor=pack(v_depth);}", "in vec3 a_pos3d;uniform float u_ele_delta;out float v_depth;void main() {float ele=get_elevation(a_pos3d.xy);float ele_delta=a_pos3d.z==1.0 ? u_ele_delta : 0.0;gl_Position=projectTileFor3D(a_pos3d.xy,ele-ele_delta);v_depth=gl_Position.z/gl_Position.w;}"), terrainCoords: _t("precision mediump float;uniform sampler2D u_texture;uniform float u_terrain_coords_id;in vec2 v_texture_pos;void main() {vec4 rgba=texture(u_texture,v_texture_pos);fragColor=vec4(rgba.r,rgba.g,rgba.b,u_terrain_coords_id);}", "in vec3 a_pos3d;uniform float u_ele_delta;out vec2 v_texture_pos;void main() {float ele=get_elevation(a_pos3d.xy);float ele_delta=a_pos3d.z==1.0 ? u_ele_delta : 0.0;v_texture_pos=a_pos3d.xy/8192.0;gl_Position=projectTileFor3D(a_pos3d.xy,ele-ele_delta);}"), projectionErrorMeasurement: _t("in vec4 v_output_error_encoded;void main() {fragColor=v_output_error_encoded;}", "in vec2 a_pos;uniform highp float u_input;uniform highp float u_output_expected;out vec4 v_output_error_encoded;void main() {float real_output=2.0*atan(exp(PI-(u_input*PI*2.0)))-PI*0.5;float error=real_output-u_output_expected;float abs_error=abs(error)*128.0;v_output_error_encoded.x=min(floor(abs_error*256.0),255.0)/255.0;abs_error-=v_output_error_encoded.x;v_output_error_encoded.y=min(floor(abs_error*65536.0),255.0)/255.0;abs_error-=v_output_error_encoded.x/255.0;v_output_error_encoded.z=min(floor(abs_error*16777216.0),255.0)/255.0;v_output_error_encoded.w=error >=0.0 ? 1.0 : 0.0;gl_Position=vec4(a_pos,0.0,1.0);}"), atmosphere: _t("in vec3 view_direction;uniform vec3 u_sun_pos;uniform vec3 u_globe_position;uniform float u_globe_radius;uniform float u_atmosphere_blend;/**Shader use from https:*Made some change to adapt to MapLibre Globe geometry*/const float PI=3.141592653589793;const int iSteps=5;const int jSteps=3;/*radius of the planet*/const float EARTH_RADIUS=6371e3;/*radius of the atmosphere*/const float ATMOS_RADIUS=6471e3;vec2 rsi(vec3 r0,vec3 rd,float sr) {float a=dot(rd,rd);float b=2.0*dot(rd,r0);float c=dot(r0,r0)-(sr*sr);float d=(b*b)-4.0*a*c;if (d < 0.0) return vec2(1e5,-1e5);return vec2((-b-sqrt(d))/(2.0*a),(-b+sqrt(d))/(2.0*a));}vec4 atmosphere(vec3 r,vec3 r0,vec3 pSun,float iSun,float rPlanet,float rAtmos,vec3 kRlh,float kMie,float shRlh,float shMie,float g) {pSun=normalize(pSun);r=normalize(r);vec2 p=rsi(r0,r,rAtmos);if (p.x > p.y) {return vec4(0.0,0.0,0.0,1.0);}if (p.x < 0.0) {p.x=0.0;}vec3 pos=r0+r*p.x;vec2 p2=rsi(r0,r,rPlanet);if (p2.x <=p2.y && p2.x > 0.0) {p.y=min(p.y,p2.x);}float iStepSize=(p.y-p.x)/float(iSteps);float iTime=p.x+iStepSize*0.5;vec3 totalRlh=vec3(0,0,0);vec3 totalMie=vec3(0,0,0);float iOdRlh=0.0;float iOdMie=0.0;float mu=dot(r,pSun);float mumu=mu*mu;float gg=g*g;float pRlh=3.0/(16.0*PI)*(1.0+mumu);float pMie=3.0/(8.0*PI)*((1.0-gg)*(mumu+1.0))/(pow(1.0+gg-2.0*mu*g,1.5)*(2.0+gg));for (int i=0; i < iSteps; i++) {vec3 iPos=r0+r*iTime;float iHeight=length(iPos)-rPlanet;float odStepRlh=exp(-iHeight/shRlh)*iStepSize;float odStepMie=exp(-iHeight/shMie)*iStepSize;iOdRlh+=odStepRlh;iOdMie+=odStepMie;float jStepSize=rsi(iPos,pSun,rAtmos).y/float(jSteps);float jTime=jStepSize*0.5;float jOdRlh=0.0;float jOdMie=0.0;for (int j=0; j < jSteps; j++) {vec3 jPos=iPos+pSun*jTime;float jHeight=length(jPos)-rPlanet;jOdRlh+=exp(-jHeight/shRlh)*jStepSize;jOdMie+=exp(-jHeight/shMie)*jStepSize;jTime+=jStepSize;}vec3 attn=exp(-(kMie*(iOdMie+jOdMie)+kRlh*(iOdRlh+jOdRlh)));totalRlh+=odStepRlh*attn;totalMie+=odStepMie*attn;iTime+=iStepSize;}float opacity=exp(-(length(kRlh)*length(totalRlh)+kMie*length(totalMie)));vec3 color=iSun*(pRlh*kRlh*totalRlh+pMie*kMie*totalMie);return vec4(color,opacity);}void main() {vec3 scale_camera_pos=-u_globe_position*EARTH_RADIUS/u_globe_radius;vec4 color=atmosphere(normalize(view_direction),scale_camera_pos,u_sun_pos,22.0,EARTH_RADIUS,ATMOS_RADIUS,vec3(5.5e-6,13.0e-6,22.4e-6),21e-6,8e3,1.2e3,0.758\n);color.rgb=1.0-exp(-1.0*color.rgb);color=pow(color,vec4(1.0/2.2));fragColor=vec4(color.rgb,1.0-color.a)*u_atmosphere_blend;}", "in vec2 a_pos;uniform mat4 u_inv_proj_matrix;out vec3 view_direction;void main() {view_direction=(u_inv_proj_matrix*vec4(a_pos,0.0,1.0)).xyz;gl_Position=vec4(a_pos,0.0,1.0);}"), sky: _t("uniform vec4 u_sky_color;uniform vec4 u_horizon_color;uniform vec2 u_horizon;uniform vec2 u_horizon_normal;uniform float u_sky_horizon_blend;uniform float u_sky_blend;void main() {float x=gl_FragCoord.x;float y=gl_FragCoord.y;float blend=(y-u_horizon.y)*u_horizon_normal.y+(x-u_horizon.x)*u_horizon_normal.x;if (blend > 0.0) {if (blend < u_sky_horizon_blend) {fragColor=mix(u_sky_color,u_horizon_color,pow(1.0-blend/u_sky_horizon_blend,2.0));} else {fragColor=u_sky_color;}}fragColor=mix(fragColor,vec4(vec3(0.0),0.0),u_sky_blend);}", "in vec2 a_pos;void main() {gl_Position=vec4(a_pos,1.0,1.0);}") };
          function _t(e7, t5) {
            const i6 = /#pragma mapbox: ([\w]+) ([\w]+) ([\w]+) ([\w]+)/g, r7 = t5.match(/in ([\w]+) ([\w]+)/g), o7 = e7.match(/uniform ([\w]+) ([\w]+)([\s]*)([\w]*)/g), a4 = t5.match(/uniform ([\w]+) ([\w]+)([\s]*)([\w]*)/g), s5 = a4 ? a4.concat(o7) : o7, n6 = {};
            return { fragmentSource: e7 = e7.replace(i6, (e8, t6, i7, r8, o8) => (n6[o8] = true, "define" === t6 ? `
#ifndef HAS_UNIFORM_u_${o8}
in ${i7} ${r8} ${o8};
#else
uniform ${i7} ${r8} u_${o8};
#endif
` : `
#ifdef HAS_UNIFORM_u_${o8}
    ${i7} ${r8} ${o8} = u_${o8};
#endif
`)), vertexSource: t5 = t5.replace(i6, (e8, t6, i7, r8, o8) => {
              const a5 = "float" === r8 ? "vec2" : "vec4", s6 = o8.match(/color/) ? "color" : a5;
              return n6[o8] ? "define" === t6 ? `
#ifndef HAS_UNIFORM_u_${o8}
uniform lowp float u_${o8}_t;
in ${i7} ${a5} a_${o8};
out ${i7} ${r8} ${o8};
#else
uniform ${i7} ${r8} u_${o8};
#endif
` : "vec4" === s6 ? `
#ifndef HAS_UNIFORM_u_${o8}
    ${o8} = a_${o8};
#else
    ${i7} ${r8} ${o8} = u_${o8};
#endif
` : `
#ifndef HAS_UNIFORM_u_${o8}
    ${o8} = unpack_mix_${s6}(a_${o8}, u_${o8}_t);
#else
    ${i7} ${r8} ${o8} = u_${o8};
#endif
` : "define" === t6 ? `
#ifndef HAS_UNIFORM_u_${o8}
uniform lowp float u_${o8}_t;
in ${i7} ${a5} a_${o8};
#else
uniform ${i7} ${r8} u_${o8};
#endif
` : "vec4" === s6 ? `
#ifndef HAS_UNIFORM_u_${o8}
    ${i7} ${r8} ${o8} = a_${o8};
#else
    ${i7} ${r8} ${o8} = u_${o8};
#endif
` : `
#ifndef HAS_UNIFORM_u_${o8}
    ${i7} ${r8} ${o8} = unpack_mix_${s6}(a_${o8}, u_${o8}_t);
#else
    ${i7} ${r8} ${o8} = u_${o8};
#endif
`;
            }), staticAttributes: r7, staticUniforms: s5 };
          }
          class pt {
            constructor(e7, t5, i6) {
              this.vertexBuffer = e7, this.indexBuffer = t5, this.segments = i6;
            }
            destroy() {
              this.vertexBuffer.destroy(), this.indexBuffer.destroy(), this.segments.destroy(), this.vertexBuffer = null, this.indexBuffer = null, this.segments = null;
            }
          }
          var mt = t4.aD([{ name: "a_pos", type: "Int16", components: 2 }]);
          const ft = "#define PROJECTION_MERCATOR", gt = "mercator";
          class vt {
            constructor() {
              this._cachedMesh = null;
            }
            get name() {
              return "mercator";
            }
            get useSubdivision() {
              return false;
            }
            get shaderVariantName() {
              return gt;
            }
            get shaderDefine() {
              return ft;
            }
            get shaderPreludeCode() {
              return dt.projectionMercator;
            }
            get vertexShaderPreludeCode() {
              return dt.projectionMercator.vertexSource;
            }
            get subdivisionGranularity() {
              return t4.aE.noSubdivision;
            }
            get useGlobeControls() {
              return false;
            }
            get transitionState() {
              return 0;
            }
            get latitudeErrorCorrectionRadians() {
              return 0;
            }
            destroy() {
            }
            updateGPUdependent(e7) {
            }
            getMeshFromTileID(e7, i6, r7, o7, a4) {
              if (this._cachedMesh) return this._cachedMesh;
              const s5 = new t4.aF();
              s5.emplaceBack(0, 0), s5.emplaceBack(t4.Z, 0), s5.emplaceBack(0, t4.Z), s5.emplaceBack(t4.Z, t4.Z);
              const n6 = e7.createVertexBuffer(s5, mt.members), l5 = t4.aG.simpleSegment(0, 0, 4, 2), c5 = new t4.aH();
              c5.emplaceBack(1, 0, 2), c5.emplaceBack(1, 2, 3);
              const h4 = e7.createIndexBuffer(c5);
              return this._cachedMesh = new pt(n6, h4, l5), this._cachedMesh;
            }
            recalculate() {
            }
            hasTransition() {
              return false;
            }
            setErrorQueryLatitudeDegrees(e7) {
            }
          }
          function xt(e7, i6) {
            const r7 = t4.ae(i6.lat, -85.051129, t4.aJ);
            return new t4.P(t4.U(i6.lng) * e7, t4.S(r7) * e7);
          }
          function bt(e7, i6) {
            return new t4.$(i6.x / e7, i6.y / e7).toLngLat();
          }
          function yt(e7) {
            return e7.cameraToCenterDistance * Math.min(0.85 * Math.tan(t4.ad(90 - e7.pitch)), Math.tan(t4.ad(89.25 - e7.pitch)));
          }
          function wt(e7, i6) {
            const r7 = e7.canonical, o7 = i6 / t4.aI(r7.z), a4 = r7.x + Math.pow(2, r7.z) * e7.wrap, s5 = t4.at(new Float64Array(16));
            return t4.L(s5, s5, [a4 * o7, r7.y * o7, 0]), t4.M(s5, s5, [o7 / t4.Z, o7 / t4.Z, 1]), s5;
          }
          function Tt(e7, i6, r7, o7, a4) {
            const s5 = t4.$.fromLngLat(e7, i6), n6 = a4 * t4.aK(1, e7.lat), l5 = n6 * Math.cos(t4.ad(r7)), c5 = Math.sqrt(n6 * n6 - l5 * l5), h4 = c5 * Math.sin(t4.ad(-o7)), u4 = c5 * Math.cos(t4.ad(-o7));
            return new t4.$(s5.x + h4, s5.y + u4, s5.z + l5);
          }
          class Pt {
            constructor(e7 = 0, t5 = 0, i6 = 0, r7 = 0) {
              if (isNaN(e7) || e7 < 0 || isNaN(t5) || t5 < 0 || isNaN(i6) || i6 < 0 || isNaN(r7) || r7 < 0) throw new Error("Invalid value for edge-insets, top, bottom, left and right must all be numbers");
              this.top = e7, this.bottom = t5, this.left = i6, this.right = r7;
            }
            interpolate(e7, i6, r7) {
              return null != i6.top && null != e7.top && (this.top = t4.B.number(e7.top, i6.top, r7)), null != i6.bottom && null != e7.bottom && (this.bottom = t4.B.number(e7.bottom, i6.bottom, r7)), null != i6.left && null != e7.left && (this.left = t4.B.number(e7.left, i6.left, r7)), null != i6.right && null != e7.right && (this.right = t4.B.number(e7.right, i6.right, r7)), this;
            }
            getCenter(e7, i6) {
              const r7 = t4.ae((this.left + e7 - this.right) / 2, 0, e7), o7 = t4.ae((this.top + i6 - this.bottom) / 2, 0, i6);
              return new t4.P(r7, o7);
            }
            equals(e7) {
              return this.top === e7.top && this.bottom === e7.bottom && this.left === e7.left && this.right === e7.right;
            }
            clone() {
              return new Pt(this.top, this.bottom, this.left, this.right);
            }
            toJSON() {
              return { top: this.top, bottom: this.bottom, left: this.left, right: this.right };
            }
          }
          function Ct(e7, t5) {
            if (!e7.renderWorldCopies || e7.lngRange) return;
            const i6 = t5.lng - e7.center.lng;
            t5.lng += i6 > 180 ? -360 : i6 < -180 ? 360 : 0;
          }
          function It(e7) {
            return Math.max(0, Math.floor(e7));
          }
          class Mt {
            constructor(e7, i6, r7, o7, a4, s5) {
              this._callbacks = e7, this._tileSize = 512, this._renderWorldCopies = void 0 === s5 || !!s5, this._minZoom = i6 || 0, this._maxZoom = r7 || 22, this._minPitch = null == o7 ? 0 : o7, this._maxPitch = null == a4 ? 60 : a4, this.setMaxBounds(), this._width = 0, this._height = 0, this._center = new t4.Q(0, 0), this._elevation = 0, this._zoom = 0, this._tileZoom = It(this._zoom), this._scale = t4.aI(this._zoom), this._bearingInRadians = 0, this._fovInRadians = 0.6435011087932844, this._pitchInRadians = 0, this._rollInRadians = 0, this._unmodified = true, this._edgeInsets = new Pt(), this._minElevationForCurrentTile = 0, this._autoCalculateNearFarZ = true;
            }
            apply(e7, i6, r7) {
              this._latRange = e7.latRange, this._lngRange = e7.lngRange, this._width = e7.width, this._height = e7.height, this._center = e7.center, this._elevation = e7.elevation, this._minElevationForCurrentTile = e7.minElevationForCurrentTile, this._zoom = e7.zoom, this._tileZoom = It(this._zoom), this._scale = t4.aI(this._zoom), this._bearingInRadians = e7.bearingInRadians, this._fovInRadians = e7.fovInRadians, this._pitchInRadians = e7.pitchInRadians, this._rollInRadians = e7.rollInRadians, this._unmodified = e7.unmodified, this._edgeInsets = new Pt(e7.padding.top, e7.padding.bottom, e7.padding.left, e7.padding.right), this._minZoom = e7.minZoom, this._maxZoom = e7.maxZoom, this._minPitch = e7.minPitch, this._maxPitch = e7.maxPitch, this._renderWorldCopies = e7.renderWorldCopies, this._cameraToCenterDistance = e7.cameraToCenterDistance, this._nearZ = e7.nearZ, this._farZ = e7.farZ, this._autoCalculateNearFarZ = !r7 && e7.autoCalculateNearFarZ, i6 && this._constrain(), this._calcMatrices();
            }
            get pixelsToClipSpaceMatrix() {
              return this._pixelsToClipSpaceMatrix;
            }
            get clipSpaceToPixelsMatrix() {
              return this._clipSpaceToPixelsMatrix;
            }
            get minElevationForCurrentTile() {
              return this._minElevationForCurrentTile;
            }
            setMinElevationForCurrentTile(e7) {
              this._minElevationForCurrentTile = e7;
            }
            get tileSize() {
              return this._tileSize;
            }
            get tileZoom() {
              return this._tileZoom;
            }
            get scale() {
              return this._scale;
            }
            get width() {
              return this._width;
            }
            get height() {
              return this._height;
            }
            get bearingInRadians() {
              return this._bearingInRadians;
            }
            get lngRange() {
              return this._lngRange;
            }
            get latRange() {
              return this._latRange;
            }
            get pixelsToGLUnits() {
              return this._pixelsToGLUnits;
            }
            get minZoom() {
              return this._minZoom;
            }
            setMinZoom(e7) {
              this._minZoom !== e7 && (this._minZoom = e7, this.setZoom(this.getConstrained(this._center, this.zoom).zoom));
            }
            get maxZoom() {
              return this._maxZoom;
            }
            setMaxZoom(e7) {
              this._maxZoom !== e7 && (this._maxZoom = e7, this.setZoom(this.getConstrained(this._center, this.zoom).zoom));
            }
            get minPitch() {
              return this._minPitch;
            }
            setMinPitch(e7) {
              this._minPitch !== e7 && (this._minPitch = e7, this.setPitch(Math.max(this.pitch, e7)));
            }
            get maxPitch() {
              return this._maxPitch;
            }
            setMaxPitch(e7) {
              this._maxPitch !== e7 && (this._maxPitch = e7, this.setPitch(Math.min(this.pitch, e7)));
            }
            get renderWorldCopies() {
              return this._renderWorldCopies;
            }
            setRenderWorldCopies(e7) {
              void 0 === e7 ? e7 = true : null === e7 && (e7 = false), this._renderWorldCopies = e7;
            }
            get worldSize() {
              return this._tileSize * this._scale;
            }
            get centerOffset() {
              return this.centerPoint._sub(this.size._div(2));
            }
            get size() {
              return new t4.P(this._width, this._height);
            }
            get bearing() {
              return this._bearingInRadians / Math.PI * 180;
            }
            setBearing(e7) {
              const i6 = t4.aL(e7, -180, 180) * Math.PI / 180;
              var o7, a4, s5, n6, l5, c5, h4, u4, d4;
              this._bearingInRadians !== i6 && (this._unmodified = false, this._bearingInRadians = i6, this._calcMatrices(), this._rotationMatrix = r6(), o7 = this._rotationMatrix, s5 = -this._bearingInRadians, n6 = (a4 = this._rotationMatrix)[0], l5 = a4[1], c5 = a4[2], h4 = a4[3], u4 = Math.sin(s5), d4 = Math.cos(s5), o7[0] = n6 * d4 + c5 * u4, o7[1] = l5 * d4 + h4 * u4, o7[2] = n6 * -u4 + c5 * d4, o7[3] = l5 * -u4 + h4 * d4);
            }
            get rotationMatrix() {
              return this._rotationMatrix;
            }
            get pitchInRadians() {
              return this._pitchInRadians;
            }
            get pitch() {
              return this._pitchInRadians / Math.PI * 180;
            }
            setPitch(e7) {
              const i6 = t4.ae(e7, this.minPitch, this.maxPitch) / 180 * Math.PI;
              this._pitchInRadians !== i6 && (this._unmodified = false, this._pitchInRadians = i6, this._calcMatrices());
            }
            get rollInRadians() {
              return this._rollInRadians;
            }
            get roll() {
              return this._rollInRadians / Math.PI * 180;
            }
            setRoll(e7) {
              const t5 = e7 / 180 * Math.PI;
              this._rollInRadians !== t5 && (this._unmodified = false, this._rollInRadians = t5, this._calcMatrices());
            }
            get fovInRadians() {
              return this._fovInRadians;
            }
            get fov() {
              return t4.aM(this._fovInRadians);
            }
            setFov(e7) {
              e7 = t4.ae(e7, 0.1, 150), this.fov !== e7 && (this._unmodified = false, this._fovInRadians = t4.ad(e7), this._calcMatrices());
            }
            get zoom() {
              return this._zoom;
            }
            setZoom(e7) {
              const i6 = this.getConstrained(this._center, e7).zoom;
              this._zoom !== i6 && (this._unmodified = false, this._zoom = i6, this._tileZoom = Math.max(0, Math.floor(i6)), this._scale = t4.aI(i6), this._constrain(), this._calcMatrices());
            }
            get center() {
              return this._center;
            }
            setCenter(e7) {
              e7.lat === this._center.lat && e7.lng === this._center.lng || (this._unmodified = false, this._center = e7, this._constrain(), this._calcMatrices());
            }
            get elevation() {
              return this._elevation;
            }
            setElevation(e7) {
              e7 !== this._elevation && (this._elevation = e7, this._constrain(), this._calcMatrices());
            }
            get padding() {
              return this._edgeInsets.toJSON();
            }
            setPadding(e7) {
              this._edgeInsets.equals(e7) || (this._unmodified = false, this._edgeInsets.interpolate(this._edgeInsets, e7, 1), this._calcMatrices());
            }
            get centerPoint() {
              return this._edgeInsets.getCenter(this._width, this._height);
            }
            get pixelsPerMeter() {
              return this._pixelPerMeter;
            }
            get unmodified() {
              return this._unmodified;
            }
            get cameraToCenterDistance() {
              return this._cameraToCenterDistance;
            }
            get nearZ() {
              return this._nearZ;
            }
            get farZ() {
              return this._farZ;
            }
            get autoCalculateNearFarZ() {
              return this._autoCalculateNearFarZ;
            }
            overrideNearFarZ(e7, t5) {
              this._autoCalculateNearFarZ = false, this._nearZ = e7, this._farZ = t5, this._calcMatrices();
            }
            clearNearFarZOverride() {
              this._autoCalculateNearFarZ = true, this._calcMatrices();
            }
            isPaddingEqual(e7) {
              return this._edgeInsets.equals(e7);
            }
            interpolatePadding(e7, t5, i6) {
              this._unmodified = false, this._edgeInsets.interpolate(e7, t5, i6), this._constrain(), this._calcMatrices();
            }
            resize(e7, t5, i6 = true) {
              this._width = e7, this._height = t5, i6 && this._constrain(), this._calcMatrices();
            }
            getMaxBounds() {
              return this._latRange && 2 === this._latRange.length && this._lngRange && 2 === this._lngRange.length ? new V2([this._lngRange[0], this._latRange[0]], [this._lngRange[1], this._latRange[1]]) : null;
            }
            setMaxBounds(e7) {
              e7 ? (this._lngRange = [e7.getWest(), e7.getEast()], this._latRange = [e7.getSouth(), e7.getNorth()], this._constrain()) : (this._lngRange = null, this._latRange = [-85.051129, t4.aJ]);
            }
            getConstrained(e7, t5) {
              return this._callbacks.getConstrained(e7, t5);
            }
            getCameraQueryGeometry(e7, i6) {
              if (1 === i6.length) return [i6[0], e7];
              {
                let r7 = e7.x, o7 = e7.y, a4 = e7.x, s5 = e7.y;
                for (const e8 of i6) r7 = Math.min(r7, e8.x), o7 = Math.min(o7, e8.y), a4 = Math.max(a4, e8.x), s5 = Math.max(s5, e8.y);
                return [new t4.P(r7, o7), new t4.P(a4, o7), new t4.P(a4, s5), new t4.P(r7, s5), new t4.P(r7, o7)];
              }
            }
            _constrain() {
              if (!this.center || !this._width || !this._height || this._constraining) return;
              this._constraining = true;
              const e7 = this._unmodified, { center: t5, zoom: i6 } = this.getConstrained(this.center, this.zoom);
              this.setCenter(t5), this.setZoom(i6), this._unmodified = e7, this._constraining = false;
            }
            _calcMatrices() {
              if (this._width && this._height) {
                this._pixelsToGLUnits = [2 / this._width, -2 / this._height];
                let e7 = t4.at(new Float64Array(16));
                t4.M(e7, e7, [this._width / 2, -this._height / 2, 1]), t4.L(e7, e7, [1, -1, 0]), this._clipSpaceToPixelsMatrix = e7, e7 = t4.at(new Float64Array(16)), t4.M(e7, e7, [1, -1, 1]), t4.L(e7, e7, [-1, -1, 0]), t4.M(e7, e7, [2 / this._width, 2 / this._height, 1]), this._pixelsToClipSpaceMatrix = e7, this._cameraToCenterDistance = 0.5 / Math.tan(this.fovInRadians / 2) * this._height;
              }
              this._callbacks.calcMatrices();
            }
            calculateCenterFromCameraLngLatAlt(e7, i6, r7, o7) {
              const a4 = void 0 !== r7 ? r7 : this.bearing, s5 = o7 = void 0 !== o7 ? o7 : this.pitch, n6 = t4.$.fromLngLat(e7, i6), l5 = -Math.cos(t4.ad(s5)), c5 = Math.sin(t4.ad(s5)), h4 = c5 * Math.sin(t4.ad(a4)), u4 = -c5 * Math.cos(t4.ad(a4));
              let d4 = this.elevation;
              const _4 = i6 - d4;
              let p4;
              l5 * _4 >= 0 || Math.abs(l5) < 0.1 ? (p4 = 1e4, d4 = i6 + p4 * l5) : p4 = -_4 / l5;
              let m4, f4, g4 = t4.aN(1, n6.y), v4 = 0;
              do {
                if (v4 += 1, v4 > 10) break;
                f4 = p4 / g4, m4 = new t4.$(n6.x + h4 * f4, n6.y + u4 * f4), g4 = 1 / m4.meterInMercatorCoordinateUnits();
              } while (Math.abs(p4 - f4 * g4) > 1e-12);
              return { center: m4.toLngLat(), elevation: d4, zoom: t4.ab(this.height / 2 / Math.tan(this.fovInRadians / 2) / f4 / this.tileSize) };
            }
            recalculateZoomAndCenter(e7) {
              if (this.elevation - e7 == 0) return;
              const i6 = t4.aK(1, this.center.lat) * this.worldSize, r7 = this.cameraToCenterDistance / i6, o7 = t4.$.fromLngLat(this.center, this.elevation), a4 = Tt(this.center, this.elevation, this.pitch, this.bearing, r7);
              this._elevation = e7;
              const s5 = this.calculateCenterFromCameraLngLatAlt(a4.toLngLat(), t4.aN(a4.z, o7.y), this.bearing, this.pitch);
              this._elevation = s5.elevation, this._center = s5.center, this.setZoom(s5.zoom);
            }
            getCameraPoint() {
              const e7 = Math.tan(this.pitchInRadians) * (this.cameraToCenterDistance || 1);
              return this.centerPoint.add(new t4.P(e7 * Math.sin(this.rollInRadians), e7 * Math.cos(this.rollInRadians)));
            }
            getCameraAltitude() {
              return Math.cos(this.pitchInRadians) * this._cameraToCenterDistance / this._pixelPerMeter + this.elevation;
            }
            getCameraLngLat() {
              const e7 = t4.aK(1, this.center.lat) * this.worldSize;
              return Tt(this.center, this.elevation, this.pitch, this.bearing, this.cameraToCenterDistance / e7).toLngLat();
            }
            getMercatorTileCoordinates(e7) {
              if (!e7) return [0, 0, 1, 1];
              const i6 = e7.canonical.z >= 0 ? 1 << e7.canonical.z : Math.pow(2, e7.canonical.z);
              return [e7.canonical.x / i6, e7.canonical.y / i6, 1 / i6 / t4.Z, 1 / i6 / t4.Z];
            }
          }
          class Et {
            constructor(e7, i6) {
              this.min = e7, this.max = i6, this.center = t4.aO([], t4.aP([], this.min, this.max), 0.5);
            }
            quadrant(e7) {
              const i6 = [e7 % 2 == 0, e7 < 2], r7 = t4.aQ(this.min), o7 = t4.aQ(this.max);
              for (let e8 = 0; e8 < i6.length; e8++) r7[e8] = i6[e8] ? this.min[e8] : this.center[e8], o7[e8] = i6[e8] ? this.center[e8] : this.max[e8];
              return o7[2] = this.max[2], new Et(r7, o7);
            }
            distanceX(e7) {
              return Math.max(Math.min(this.max[0], e7[0]), this.min[0]) - e7[0];
            }
            distanceY(e7) {
              return Math.max(Math.min(this.max[1], e7[1]), this.min[1]) - e7[1];
            }
            intersectsFrustum(e7) {
              let t5 = true;
              for (let i6 = 0; i6 < e7.planes.length; i6++) {
                const r7 = this.intersectsPlane(e7.planes[i6]);
                if (0 === r7) return 0;
                1 === r7 && (t5 = false);
              }
              return t5 ? 2 : e7.aabb.min[0] > this.max[0] || e7.aabb.min[1] > this.max[1] || e7.aabb.min[2] > this.max[2] || e7.aabb.max[0] < this.min[0] || e7.aabb.max[1] < this.min[1] || e7.aabb.max[2] < this.min[2] ? 0 : 1;
            }
            intersectsPlane(e7) {
              let t5 = e7[3], i6 = e7[3];
              for (let r7 = 0; r7 < 3; r7++) e7[r7] > 0 ? (t5 += e7[r7] * this.min[r7], i6 += e7[r7] * this.max[r7]) : (i6 += e7[r7] * this.min[r7], t5 += e7[r7] * this.max[r7]);
              return t5 >= 0 ? 2 : i6 < 0 ? 0 : 1;
            }
          }
          class St {
            distanceToTile2d(e7, t5, i6, r7) {
              const o7 = r7.distanceX([e7, t5]), a4 = r7.distanceY([e7, t5]);
              return Math.hypot(o7, a4);
            }
            getWrap(e7, t5, i6) {
              return i6;
            }
            getTileAABB(e7, i6, r7, o7) {
              var a4, s5;
              let n6 = r7, l5 = r7;
              if (o7.terrain) {
                const c6 = new t4.Y(e7.z, i6, e7.z, e7.x, e7.y), h4 = o7.terrain.getMinMaxElevation(c6);
                n6 = null !== (a4 = h4.minElevation) && void 0 !== a4 ? a4 : r7, l5 = null !== (s5 = h4.maxElevation) && void 0 !== s5 ? s5 : r7;
              }
              const c5 = 1 << e7.z;
              return new Et([i6 + e7.x / c5, e7.y / c5, n6], [i6 + (e7.x + 1) / c5, (e7.y + 1) / c5, l5]);
            }
            allowVariableZoom(e7, i6) {
              const r7 = e7.fov * (Math.abs(Math.cos(e7.rollInRadians)) * e7.height + Math.abs(Math.sin(e7.rollInRadians)) * e7.width) / e7.height, o7 = t4.ae(78.5 - r7 / 2, 0, 60);
              return !!i6.terrain || e7.pitch > o7;
            }
            allowWorldCopies() {
              return true;
            }
            recalculateCache() {
            }
          }
          class Rt {
            constructor(e7, t5, i6) {
              this.points = e7, this.planes = t5, this.aabb = i6;
            }
            static fromInvProjectionMatrix(e7, i6 = 1, r7 = 0) {
              const o7 = Math.pow(2, r7), a4 = [[-1, 1, -1, 1], [1, 1, -1, 1], [1, -1, -1, 1], [-1, -1, -1, 1], [-1, 1, 1, 1], [1, 1, 1, 1], [1, -1, 1, 1], [-1, -1, 1, 1]].map((r8) => {
                const a5 = 1 / (r8 = t4.ap([], r8, e7))[3] / i6 * o7;
                return t4.aR(r8, r8, [a5, a5, 1 / r8[3], a5]);
              }), s5 = [[0, 1, 2], [6, 5, 4], [0, 3, 7], [2, 1, 5], [3, 2, 6], [0, 4, 5]].map((e8) => {
                const i7 = t4.aS([], a4[e8[0]], a4[e8[1]]), r8 = t4.aS([], a4[e8[2]], a4[e8[1]]), o8 = t4.aT([], t4.aU([], i7, r8)), s6 = -t4.aV(o8, a4[e8[1]]);
                return o8.concat(s6);
              }), n6 = [Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY], l5 = [Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY];
              for (const e8 of a4) for (let t5 = 0; t5 < 3; t5++) n6[t5] = Math.min(n6[t5], e8[t5]), l5[t5] = Math.max(l5[t5], e8[t5]);
              return new Rt(a4, s5, new Et(n6, l5));
            }
          }
          class Dt {
            get pixelsToClipSpaceMatrix() {
              return this._helper.pixelsToClipSpaceMatrix;
            }
            get clipSpaceToPixelsMatrix() {
              return this._helper.clipSpaceToPixelsMatrix;
            }
            get pixelsToGLUnits() {
              return this._helper.pixelsToGLUnits;
            }
            get centerOffset() {
              return this._helper.centerOffset;
            }
            get size() {
              return this._helper.size;
            }
            get rotationMatrix() {
              return this._helper.rotationMatrix;
            }
            get centerPoint() {
              return this._helper.centerPoint;
            }
            get pixelsPerMeter() {
              return this._helper.pixelsPerMeter;
            }
            setMinZoom(e7) {
              this._helper.setMinZoom(e7);
            }
            setMaxZoom(e7) {
              this._helper.setMaxZoom(e7);
            }
            setMinPitch(e7) {
              this._helper.setMinPitch(e7);
            }
            setMaxPitch(e7) {
              this._helper.setMaxPitch(e7);
            }
            setRenderWorldCopies(e7) {
              this._helper.setRenderWorldCopies(e7);
            }
            setBearing(e7) {
              this._helper.setBearing(e7);
            }
            setPitch(e7) {
              this._helper.setPitch(e7);
            }
            setRoll(e7) {
              this._helper.setRoll(e7);
            }
            setFov(e7) {
              this._helper.setFov(e7);
            }
            setZoom(e7) {
              this._helper.setZoom(e7);
            }
            setCenter(e7) {
              this._helper.setCenter(e7);
            }
            setElevation(e7) {
              this._helper.setElevation(e7);
            }
            setMinElevationForCurrentTile(e7) {
              this._helper.setMinElevationForCurrentTile(e7);
            }
            setPadding(e7) {
              this._helper.setPadding(e7);
            }
            interpolatePadding(e7, t5, i6) {
              return this._helper.interpolatePadding(e7, t5, i6);
            }
            isPaddingEqual(e7) {
              return this._helper.isPaddingEqual(e7);
            }
            resize(e7, t5, i6 = true) {
              this._helper.resize(e7, t5, i6);
            }
            getMaxBounds() {
              return this._helper.getMaxBounds();
            }
            setMaxBounds(e7) {
              this._helper.setMaxBounds(e7);
            }
            overrideNearFarZ(e7, t5) {
              this._helper.overrideNearFarZ(e7, t5);
            }
            clearNearFarZOverride() {
              this._helper.clearNearFarZOverride();
            }
            getCameraQueryGeometry(e7) {
              return this._helper.getCameraQueryGeometry(this.getCameraPoint(), e7);
            }
            get tileSize() {
              return this._helper.tileSize;
            }
            get tileZoom() {
              return this._helper.tileZoom;
            }
            get scale() {
              return this._helper.scale;
            }
            get worldSize() {
              return this._helper.worldSize;
            }
            get width() {
              return this._helper.width;
            }
            get height() {
              return this._helper.height;
            }
            get lngRange() {
              return this._helper.lngRange;
            }
            get latRange() {
              return this._helper.latRange;
            }
            get minZoom() {
              return this._helper.minZoom;
            }
            get maxZoom() {
              return this._helper.maxZoom;
            }
            get zoom() {
              return this._helper.zoom;
            }
            get center() {
              return this._helper.center;
            }
            get minPitch() {
              return this._helper.minPitch;
            }
            get maxPitch() {
              return this._helper.maxPitch;
            }
            get pitch() {
              return this._helper.pitch;
            }
            get pitchInRadians() {
              return this._helper.pitchInRadians;
            }
            get roll() {
              return this._helper.roll;
            }
            get rollInRadians() {
              return this._helper.rollInRadians;
            }
            get bearing() {
              return this._helper.bearing;
            }
            get bearingInRadians() {
              return this._helper.bearingInRadians;
            }
            get fov() {
              return this._helper.fov;
            }
            get fovInRadians() {
              return this._helper.fovInRadians;
            }
            get elevation() {
              return this._helper.elevation;
            }
            get minElevationForCurrentTile() {
              return this._helper.minElevationForCurrentTile;
            }
            get padding() {
              return this._helper.padding;
            }
            get unmodified() {
              return this._helper.unmodified;
            }
            get renderWorldCopies() {
              return this._helper.renderWorldCopies;
            }
            get cameraToCenterDistance() {
              return this._helper.cameraToCenterDistance;
            }
            get nearZ() {
              return this._helper.nearZ;
            }
            get farZ() {
              return this._helper.farZ;
            }
            get autoCalculateNearFarZ() {
              return this._helper.autoCalculateNearFarZ;
            }
            setTransitionState(e7, t5) {
            }
            constructor(e7, t5, i6, r7, o7) {
              this._posMatrixCache = /* @__PURE__ */ new Map(), this._alignedPosMatrixCache = /* @__PURE__ */ new Map(), this._fogMatrixCacheF32 = /* @__PURE__ */ new Map(), this._helper = new Mt({ calcMatrices: () => {
                this._calcMatrices();
              }, getConstrained: (e8, t6) => this.getConstrained(e8, t6) }, e7, t5, i6, r7, o7), this._coveringTilesDetailsProvider = new St();
            }
            clone() {
              const e7 = new Dt();
              return e7.apply(this), e7;
            }
            apply(e7, t5, i6) {
              this._helper.apply(e7, t5, i6);
            }
            get cameraPosition() {
              return this._cameraPosition;
            }
            get projectionMatrix() {
              return this._projectionMatrix;
            }
            get modelViewProjectionMatrix() {
              return this._viewProjMatrix;
            }
            get inverseProjectionMatrix() {
              return this._invProjMatrix;
            }
            get mercatorMatrix() {
              return this._mercatorMatrix;
            }
            getVisibleUnwrappedCoordinates(e7) {
              const i6 = [new t4.aW(0, e7)];
              if (this._helper._renderWorldCopies) {
                const r7 = this.screenPointToMercatorCoordinate(new t4.P(0, 0)), o7 = this.screenPointToMercatorCoordinate(new t4.P(this._helper._width, 0)), a4 = this.screenPointToMercatorCoordinate(new t4.P(this._helper._width, this._helper._height)), s5 = this.screenPointToMercatorCoordinate(new t4.P(0, this._helper._height)), n6 = Math.floor(Math.min(r7.x, o7.x, a4.x, s5.x)), l5 = Math.floor(Math.max(r7.x, o7.x, a4.x, s5.x)), c5 = 1;
                for (let r8 = n6 - c5; r8 <= l5 + c5; r8++) 0 !== r8 && i6.push(new t4.aW(r8, e7));
              }
              return i6;
            }
            getCameraFrustum() {
              return Rt.fromInvProjectionMatrix(this._invViewProjMatrix, this.worldSize);
            }
            getClippingPlane() {
              return null;
            }
            getCoveringTilesDetailsProvider() {
              return this._coveringTilesDetailsProvider;
            }
            recalculateZoomAndCenter(e7) {
              const t5 = this.screenPointToLocation(this.centerPoint, e7), i6 = e7 ? e7.getElevationForLngLatZoom(t5, this._helper._tileZoom) : 0;
              this._helper.recalculateZoomAndCenter(i6);
            }
            setLocationAtPoint(e7, i6) {
              const r7 = t4.aK(this.elevation, this.center.lat), o7 = this.screenPointToMercatorCoordinateAtZ(i6, r7), a4 = this.screenPointToMercatorCoordinateAtZ(this.centerPoint, r7), s5 = t4.$.fromLngLat(e7), n6 = new t4.$(s5.x - (o7.x - a4.x), s5.y - (o7.y - a4.y));
              this.setCenter(null == n6 ? void 0 : n6.toLngLat()), this._helper._renderWorldCopies && this.setCenter(this.center.wrap());
            }
            locationToScreenPoint(e7, i6) {
              return i6 ? this.coordinatePoint(t4.$.fromLngLat(e7), i6.getElevationForLngLatZoom(e7, this._helper._tileZoom), this._pixelMatrix3D) : this.coordinatePoint(t4.$.fromLngLat(e7));
            }
            screenPointToLocation(e7, t5) {
              var i6;
              return null === (i6 = this.screenPointToMercatorCoordinate(e7, t5)) || void 0 === i6 ? void 0 : i6.toLngLat();
            }
            screenPointToMercatorCoordinate(e7, t5) {
              if (t5) {
                const i6 = t5.pointCoordinate(e7);
                if (null != i6) return i6;
              }
              return this.screenPointToMercatorCoordinateAtZ(e7);
            }
            screenPointToMercatorCoordinateAtZ(e7, i6) {
              const r7 = i6 || 0, o7 = [e7.x, e7.y, 0, 1], a4 = [e7.x, e7.y, 1, 1];
              t4.ap(o7, o7, this._pixelMatrixInverse), t4.ap(a4, a4, this._pixelMatrixInverse);
              const s5 = o7[3], n6 = a4[3], l5 = o7[1] / s5, c5 = a4[1] / n6, h4 = o7[2] / s5, u4 = a4[2] / n6, d4 = h4 === u4 ? 0 : (r7 - h4) / (u4 - h4);
              return new t4.$(t4.B.number(o7[0] / s5, a4[0] / n6, d4) / this.worldSize, t4.B.number(l5, c5, d4) / this.worldSize, r7);
            }
            coordinatePoint(e7, i6 = 0, r7 = this._pixelMatrix) {
              const o7 = [e7.x * this.worldSize, e7.y * this.worldSize, i6, 1];
              return t4.ap(o7, o7, r7), new t4.P(o7[0] / o7[3], o7[1] / o7[3]);
            }
            getBounds() {
              const e7 = Math.max(0, this._helper._height / 2 - yt(this));
              return new V2().extend(this.screenPointToLocation(new t4.P(0, e7))).extend(this.screenPointToLocation(new t4.P(this._helper._width, e7))).extend(this.screenPointToLocation(new t4.P(this._helper._width, this._helper._height))).extend(this.screenPointToLocation(new t4.P(0, this._helper._height)));
            }
            isPointOnMapSurface(e7, t5) {
              return t5 ? null != t5.pointCoordinate(e7) : e7.y > this.height / 2 - yt(this);
            }
            calculatePosMatrix(e7, i6 = false, r7) {
              var o7;
              const a4 = null !== (o7 = e7.key) && void 0 !== o7 ? o7 : t4.aX(e7.wrap, e7.canonical.z, e7.canonical.z, e7.canonical.x, e7.canonical.y), s5 = i6 ? this._alignedPosMatrixCache : this._posMatrixCache;
              if (s5.has(a4)) {
                const e8 = s5.get(a4);
                return r7 ? e8.f32 : e8.f64;
              }
              const n6 = wt(e7, this.worldSize);
              t4.N(n6, i6 ? this._alignedProjMatrix : this._viewProjMatrix, n6);
              const l5 = { f64: n6, f32: new Float32Array(n6) };
              return s5.set(a4, l5), r7 ? l5.f32 : l5.f64;
            }
            calculateFogMatrix(e7) {
              const i6 = e7.key, r7 = this._fogMatrixCacheF32;
              if (r7.has(i6)) return r7.get(i6);
              const o7 = wt(e7, this.worldSize);
              return t4.N(o7, this._fogMatrix, o7), r7.set(i6, new Float32Array(o7)), r7.get(i6);
            }
            getConstrained(e7, i6) {
              i6 = t4.ae(+i6, this.minZoom, this.maxZoom);
              const r7 = { center: new t4.Q(e7.lng, e7.lat), zoom: i6 };
              let o7 = this._helper._lngRange;
              this._helper._renderWorldCopies || null !== o7 || (o7 = [-179.9999999999, 180 - 1e-10]);
              const a4 = this.tileSize * t4.aI(r7.zoom);
              let s5 = 0, n6 = a4, l5 = 0, c5 = a4, h4 = 0, u4 = 0;
              const { x: d4, y: _4 } = this.size;
              if (this._helper._latRange) {
                const e8 = this._helper._latRange;
                s5 = t4.S(e8[1]) * a4, n6 = t4.S(e8[0]) * a4, n6 - s5 < _4 && (h4 = _4 / (n6 - s5));
              }
              o7 && (l5 = t4.aL(t4.U(o7[0]) * a4, 0, a4), c5 = t4.aL(t4.U(o7[1]) * a4, 0, a4), c5 < l5 && (c5 += a4), c5 - l5 < d4 && (u4 = d4 / (c5 - l5)));
              const { x: p4, y: m4 } = xt(a4, e7);
              let f4, g4;
              const v4 = Math.max(u4 || 0, h4 || 0);
              if (v4) {
                const e8 = new t4.P(u4 ? (c5 + l5) / 2 : p4, h4 ? (n6 + s5) / 2 : m4);
                return r7.center = bt(a4, e8).wrap(), r7.zoom += t4.ab(v4), r7;
              }
              if (this._helper._latRange) {
                const e8 = _4 / 2;
                m4 - e8 < s5 && (g4 = s5 + e8), m4 + e8 > n6 && (g4 = n6 - e8);
              }
              if (o7) {
                const e8 = (l5 + c5) / 2;
                let i7 = p4;
                this._helper._renderWorldCopies && (i7 = t4.aL(p4, e8 - a4 / 2, e8 + a4 / 2));
                const r8 = d4 / 2;
                i7 - r8 < l5 && (f4 = l5 + r8), i7 + r8 > c5 && (f4 = c5 - r8);
              }
              if (void 0 !== f4 || void 0 !== g4) {
                const e8 = new t4.P(null != f4 ? f4 : p4, null != g4 ? g4 : m4);
                r7.center = bt(a4, e8).wrap();
              }
              return r7;
            }
            calculateCenterFromCameraLngLatAlt(e7, t5, i6, r7) {
              return this._helper.calculateCenterFromCameraLngLatAlt(e7, t5, i6, r7);
            }
            _calculateNearFarZIfNeeded(e7, i6, r7) {
              if (!this._helper.autoCalculateNearFarZ) return;
              const o7 = Math.min(this.elevation, this.minElevationForCurrentTile, this.getCameraAltitude() - 100), a4 = e7 - o7 * this._helper._pixelPerMeter / Math.cos(i6), s5 = o7 < 0 ? a4 : e7, n6 = Math.PI / 2 + this.pitchInRadians, l5 = t4.ad(this.fov) * (Math.abs(Math.cos(t4.ad(this.roll))) * this.height + Math.abs(Math.sin(t4.ad(this.roll))) * this.width) / this.height * (0.5 + r7.y / this.height), c5 = Math.sin(l5) * s5 / Math.sin(t4.ae(Math.PI - n6 - l5, 0.01, Math.PI - 0.01)), h4 = yt(this), u4 = Math.atan(h4 / this._helper.cameraToCenterDistance), d4 = t4.ad(0.75), _4 = u4 > d4 ? 2 * u4 * (0.5 + r7.y / (2 * h4)) : d4, p4 = Math.sin(_4) * s5 / Math.sin(t4.ae(Math.PI - n6 - _4, 0.01, Math.PI - 0.01)), m4 = Math.min(c5, p4);
              this._helper._farZ = 1.01 * (Math.cos(Math.PI / 2 - i6) * m4 + s5), this._helper._nearZ = this._helper._height / 50;
            }
            _calcMatrices() {
              if (!this._helper._height) return;
              const e7 = this.centerOffset, i6 = xt(this.worldSize, this.center), r7 = i6.x, o7 = i6.y;
              this._helper._pixelPerMeter = t4.aK(1, this.center.lat) * this.worldSize;
              const a4 = t4.ad(Math.min(this.pitch, 89.25)), s5 = Math.max(this._helper.cameraToCenterDistance / 2, this._helper.cameraToCenterDistance + this._helper._elevation * this._helper._pixelPerMeter / Math.cos(a4));
              let n6;
              this._calculateNearFarZIfNeeded(s5, a4, e7), n6 = new Float64Array(16), t4.aY(n6, this.fovInRadians, this._helper._width / this._helper._height, this._helper._nearZ, this._helper._farZ), this._invProjMatrix = new Float64Array(16), t4.aj(this._invProjMatrix, n6), n6[8] = 2 * -e7.x / this._helper._width, n6[9] = 2 * e7.y / this._helper._height, this._projectionMatrix = t4.aZ(n6), t4.M(n6, n6, [1, -1, 1]), t4.L(n6, n6, [0, 0, -this._helper.cameraToCenterDistance]), t4.a_(n6, n6, -this.rollInRadians), t4.a$(n6, n6, this.pitchInRadians), t4.a_(n6, n6, -this.bearingInRadians), t4.L(n6, n6, [-r7, -o7, 0]), this._mercatorMatrix = t4.M([], n6, [this.worldSize, this.worldSize, this.worldSize]), t4.M(n6, n6, [1, 1, this._helper._pixelPerMeter]), this._pixelMatrix = t4.N(new Float64Array(16), this.clipSpaceToPixelsMatrix, n6), t4.L(n6, n6, [0, 0, -this.elevation]), this._viewProjMatrix = n6, this._invViewProjMatrix = t4.aj([], n6);
              const l5 = [0, 0, -1, 1];
              t4.ap(l5, l5, this._invViewProjMatrix), this._cameraPosition = [l5[0] / l5[3], l5[1] / l5[3], l5[2] / l5[3]], this._fogMatrix = new Float64Array(16), t4.aY(this._fogMatrix, this.fovInRadians, this.width / this.height, s5, this._helper._farZ), this._fogMatrix[8] = 2 * -e7.x / this.width, this._fogMatrix[9] = 2 * e7.y / this.height, t4.M(this._fogMatrix, this._fogMatrix, [1, -1, 1]), t4.L(this._fogMatrix, this._fogMatrix, [0, 0, -this.cameraToCenterDistance]), t4.a_(this._fogMatrix, this._fogMatrix, -this.rollInRadians), t4.a$(this._fogMatrix, this._fogMatrix, this.pitchInRadians), t4.a_(this._fogMatrix, this._fogMatrix, -this.bearingInRadians), t4.L(this._fogMatrix, this._fogMatrix, [-r7, -o7, 0]), t4.M(this._fogMatrix, this._fogMatrix, [1, 1, this._helper._pixelPerMeter]), t4.L(this._fogMatrix, this._fogMatrix, [0, 0, -this.elevation]), this._pixelMatrix3D = t4.N(new Float64Array(16), this.clipSpaceToPixelsMatrix, n6);
              const c5 = this._helper._width % 2 / 2, h4 = this._helper._height % 2 / 2, u4 = Math.cos(this.bearingInRadians), d4 = Math.sin(-this.bearingInRadians), _4 = r7 - Math.round(r7) + u4 * c5 + d4 * h4, p4 = o7 - Math.round(o7) + u4 * h4 + d4 * c5, m4 = new Float64Array(n6);
              if (t4.L(m4, m4, [_4 > 0.5 ? _4 - 1 : _4, p4 > 0.5 ? p4 - 1 : p4, 0]), this._alignedProjMatrix = m4, n6 = t4.aj(new Float64Array(16), this._pixelMatrix), !n6) throw new Error("failed to invert matrix");
              this._pixelMatrixInverse = n6, this._clearMatrixCaches();
            }
            _clearMatrixCaches() {
              this._posMatrixCache.clear(), this._alignedPosMatrixCache.clear(), this._fogMatrixCacheF32.clear();
            }
            maxPitchScaleFactor() {
              if (!this._pixelMatrixInverse) return 1;
              const e7 = this.screenPointToMercatorCoordinate(new t4.P(0, 0)), i6 = [e7.x * this.worldSize, e7.y * this.worldSize, 0, 1];
              return t4.ap(i6, i6, this._pixelMatrix)[3] / this._helper.cameraToCenterDistance;
            }
            getCameraPoint() {
              return this._helper.getCameraPoint();
            }
            getCameraAltitude() {
              return this._helper.getCameraAltitude();
            }
            getCameraLngLat() {
              const e7 = t4.aK(1, this.center.lat) * this.worldSize;
              return Tt(this.center, this.elevation, this.pitch, this.bearing, this._helper.cameraToCenterDistance / e7).toLngLat();
            }
            lngLatToCameraDepth(e7, i6) {
              const r7 = t4.$.fromLngLat(e7), o7 = [r7.x * this.worldSize, r7.y * this.worldSize, i6, 1];
              return t4.ap(o7, o7, this._viewProjMatrix), o7[2] / o7[3];
            }
            getProjectionData(e7) {
              const { overscaledTileID: i6, aligned: r7, applyTerrainMatrix: o7 } = e7, a4 = this._helper.getMercatorTileCoordinates(i6), s5 = i6 ? this.calculatePosMatrix(i6, r7, true) : null;
              let n6;
              return n6 = i6 && i6.terrainRttPosMatrix32f && o7 ? i6.terrainRttPosMatrix32f : s5 || t4.b0(), { mainMatrix: n6, tileMercatorCoords: a4, clippingPlane: [0, 0, 0, 0], projectionTransition: 0, fallbackMatrix: n6 };
            }
            isLocationOccluded(e7) {
              return false;
            }
            getPixelScale() {
              return 1;
            }
            getCircleRadiusCorrection() {
              return 1;
            }
            getPitchedTextCorrection(e7, t5, i6) {
              return 1;
            }
            transformLightDirection(e7) {
              return t4.aQ(e7);
            }
            getRayDirectionFromPixel(e7) {
              throw new Error("Not implemented.");
            }
            projectTileCoordinates(e7, i6, r7, o7) {
              const a4 = this.calculatePosMatrix(r7);
              let s5;
              o7 ? (s5 = [e7, i6, o7(e7, i6), 1], t4.ap(s5, s5, a4)) : (s5 = [e7, i6, 0, 1], Oe(s5, s5, a4));
              const n6 = s5[3];
              return { point: new t4.P(s5[0] / n6, s5[1] / n6), signedDistanceFromCamera: n6, isOccluded: false };
            }
            populateCache(e7) {
              for (const t5 of e7) this.calculatePosMatrix(t5);
            }
            getMatrixForModel(e7, i6) {
              const r7 = t4.$.fromLngLat(e7, i6), o7 = r7.meterInMercatorCoordinateUnits(), a4 = t4.b1();
              return t4.L(a4, a4, [r7.x, r7.y, r7.z]), t4.a_(a4, a4, Math.PI), t4.a$(a4, a4, Math.PI / 2), t4.M(a4, a4, [-o7, o7, o7]), a4;
            }
            getProjectionDataForCustomLayer(e7 = true) {
              const i6 = new t4.Y(0, 0, 0, 0, 0), r7 = this.getProjectionData({ overscaledTileID: i6, applyGlobeMatrix: e7 }), o7 = wt(i6, this.worldSize);
              t4.N(o7, this._viewProjMatrix, o7), r7.tileMercatorCoords = [0, 0, 1, 1];
              const a4 = [t4.Z, t4.Z, this.worldSize / this._helper.pixelsPerMeter], s5 = t4.b2();
              return t4.M(s5, o7, a4), r7.fallbackMatrix = s5, r7.mainMatrix = s5, r7;
            }
            getFastPathSimpleProjectionMatrix(e7) {
              return this.calculatePosMatrix(e7);
            }
          }
          function zt() {
            t4.w("Map cannot fit within canvas with the given bounds, padding, and/or offset.");
          }
          function At(e7) {
            if (e7.useSlerp) if (e7.k < 1) {
              const i6 = t4.b3(e7.startEulerAngles.roll, e7.startEulerAngles.pitch, e7.startEulerAngles.bearing), r7 = t4.b3(e7.endEulerAngles.roll, e7.endEulerAngles.pitch, e7.endEulerAngles.bearing), o7 = new Float64Array(4);
              t4.b4(o7, i6, r7, e7.k);
              const a4 = t4.b5(o7);
              e7.tr.setRoll(a4.roll), e7.tr.setPitch(a4.pitch), e7.tr.setBearing(a4.bearing);
            } else e7.tr.setRoll(e7.endEulerAngles.roll), e7.tr.setPitch(e7.endEulerAngles.pitch), e7.tr.setBearing(e7.endEulerAngles.bearing);
            else e7.tr.setRoll(t4.B.number(e7.startEulerAngles.roll, e7.endEulerAngles.roll, e7.k)), e7.tr.setPitch(t4.B.number(e7.startEulerAngles.pitch, e7.endEulerAngles.pitch, e7.k)), e7.tr.setBearing(t4.B.number(e7.startEulerAngles.bearing, e7.endEulerAngles.bearing, e7.k));
          }
          function Lt(e7, i6, r7, o7, a4) {
            const s5 = a4.padding, n6 = xt(a4.worldSize, r7.getNorthWest()), l5 = xt(a4.worldSize, r7.getNorthEast()), c5 = xt(a4.worldSize, r7.getSouthEast()), h4 = xt(a4.worldSize, r7.getSouthWest()), u4 = t4.ad(-o7), d4 = n6.rotate(u4), _4 = l5.rotate(u4), p4 = c5.rotate(u4), m4 = h4.rotate(u4), f4 = new t4.P(Math.max(d4.x, _4.x, m4.x, p4.x), Math.max(d4.y, _4.y, m4.y, p4.y)), g4 = new t4.P(Math.min(d4.x, _4.x, m4.x, p4.x), Math.min(d4.y, _4.y, m4.y, p4.y)), v4 = f4.sub(g4), x4 = (a4.width - (s5.left + s5.right + i6.left + i6.right)) / v4.x, b5 = (a4.height - (s5.top + s5.bottom + i6.top + i6.bottom)) / v4.y;
            if (b5 < 0 || x4 < 0) return void zt();
            const y4 = Math.min(t4.ab(a4.scale * Math.min(x4, b5)), e7.maxZoom), w4 = t4.P.convert(e7.offset), T5 = new t4.P((i6.left - i6.right) / 2, (i6.top - i6.bottom) / 2).rotate(t4.ad(o7)), P4 = w4.add(T5).mult(a4.scale / t4.aI(y4));
            return { center: bt(a4.worldSize, n6.add(c5).div(2).sub(P4)), zoom: y4, bearing: o7 };
          }
          class kt {
            get useGlobeControls() {
              return false;
            }
            handlePanInertia(e7, t5) {
              return { easingOffset: e7, easingCenter: t5.center };
            }
            handleMapControlsRollPitchBearingZoom(e7, t5) {
              e7.bearingDelta && t5.setBearing(t5.bearing + e7.bearingDelta), e7.pitchDelta && t5.setPitch(t5.pitch + e7.pitchDelta), e7.rollDelta && t5.setRoll(t5.roll + e7.rollDelta), e7.zoomDelta && t5.setZoom(t5.zoom + e7.zoomDelta);
            }
            handleMapControlsPan(e7, t5, i6) {
              e7.around.distSqr(t5.centerPoint) < 0.01 || t5.setLocationAtPoint(i6, e7.around);
            }
            cameraForBoxAndBearing(e7, t5, i6, r7, o7) {
              return Lt(e7, t5, i6, r7, o7);
            }
            handleJumpToCenterZoom(e7, i6) {
              e7.zoom !== (void 0 !== i6.zoom ? +i6.zoom : e7.zoom) && e7.setZoom(+i6.zoom), void 0 !== i6.center && e7.setCenter(t4.Q.convert(i6.center));
            }
            handleEaseTo(e7, i6) {
              const r7 = e7.zoom, o7 = e7.padding, a4 = { roll: e7.roll, pitch: e7.pitch, bearing: e7.bearing }, s5 = { roll: void 0 === i6.roll ? e7.roll : i6.roll, pitch: void 0 === i6.pitch ? e7.pitch : i6.pitch, bearing: void 0 === i6.bearing ? e7.bearing : i6.bearing }, n6 = void 0 !== i6.zoom, l5 = !e7.isPaddingEqual(i6.padding);
              let c5 = false;
              const h4 = n6 ? +i6.zoom : e7.zoom;
              let u4 = e7.centerPoint.add(i6.offsetAsPoint);
              const d4 = e7.screenPointToLocation(u4), { center: _4, zoom: p4 } = e7.getConstrained(t4.Q.convert(i6.center || d4), null != h4 ? h4 : r7);
              Ct(e7, _4);
              const m4 = xt(e7.worldSize, d4), f4 = xt(e7.worldSize, _4).sub(m4), g4 = t4.aI(p4 - r7);
              return c5 = p4 !== r7, { easeFunc: (n7) => {
                if (c5 && e7.setZoom(t4.B.number(r7, p4, n7)), t4.b6(a4, s5) || At({ startEulerAngles: a4, endEulerAngles: s5, tr: e7, k: n7, useSlerp: a4.roll != s5.roll }), l5 && (e7.interpolatePadding(o7, i6.padding, n7), u4 = e7.centerPoint.add(i6.offsetAsPoint)), i6.around) e7.setLocationAtPoint(i6.around, i6.aroundPoint);
                else {
                  const i7 = t4.aI(e7.zoom - r7), o8 = p4 > r7 ? Math.min(2, g4) : Math.max(0.5, g4), a5 = Math.pow(o8, 1 - n7), s6 = bt(e7.worldSize, m4.add(f4.mult(n7 * a5)).mult(i7));
                  e7.setLocationAtPoint(e7.renderWorldCopies ? s6.wrap() : s6, u4);
                }
              }, isZooming: c5, elevationCenter: _4 };
            }
            handleFlyTo(e7, i6) {
              const r7 = void 0 !== i6.zoom, o7 = e7.zoom, a4 = e7.getConstrained(t4.Q.convert(i6.center || i6.locationAtOffset), r7 ? +i6.zoom : o7), s5 = a4.center, n6 = a4.zoom;
              Ct(e7, s5);
              const l5 = xt(e7.worldSize, i6.locationAtOffset), c5 = xt(e7.worldSize, s5).sub(l5), h4 = c5.mag(), u4 = t4.aI(n6 - o7);
              let d4;
              if (void 0 !== i6.minZoom) {
                const r8 = Math.min(+i6.minZoom, o7, n6), a5 = e7.getConstrained(s5, r8).zoom;
                d4 = t4.aI(a5 - o7);
              }
              return { easeFunc: (i7, r8, a5, h5) => {
                e7.setZoom(1 === i7 ? n6 : o7 + t4.ab(r8));
                const u5 = 1 === i7 ? s5 : bt(e7.worldSize, l5.add(c5.mult(a5)).mult(r8));
                e7.setLocationAtPoint(e7.renderWorldCopies ? u5.wrap() : u5, h5);
              }, scaleOfZoom: u4, targetCenter: s5, scaleOfMinZoom: d4, pixelPathLength: h4 };
            }
          }
          class Ft {
            constructor(e7, t5, i6) {
              this.blendFunction = e7, this.blendColor = t5, this.mask = i6;
            }
          }
          Ft.Replace = [1, 0], Ft.disabled = new Ft(Ft.Replace, t4.b7.transparent, [false, false, false, false]), Ft.unblended = new Ft(Ft.Replace, t4.b7.transparent, [true, true, true, true]), Ft.alphaBlended = new Ft([1, 771], t4.b7.transparent, [true, true, true, true]);
          const Bt = 2305;
          class Ot {
            constructor(e7, t5, i6) {
              this.enable = e7, this.mode = t5, this.frontFace = i6;
            }
          }
          Ot.disabled = new Ot(false, 1029, Bt), Ot.backCCW = new Ot(true, 1029, Bt), Ot.frontCCW = new Ot(true, 1028, Bt);
          class jt {
            constructor(e7, t5, i6) {
              this.func = e7, this.mask = t5, this.range = i6;
            }
          }
          jt.ReadOnly = false, jt.ReadWrite = true, jt.disabled = new jt(519, jt.ReadOnly, [0, 1]);
          const Zt = 7680;
          class Nt {
            constructor(e7, t5, i6, r7, o7, a4) {
              this.test = e7, this.ref = t5, this.mask = i6, this.fail = r7, this.depthFail = o7, this.pass = a4;
            }
          }
          Nt.disabled = new Nt({ func: 519, mask: 0 }, 0, 0, Zt, Zt, Zt);
          const Gt = /* @__PURE__ */ new WeakMap();
          function Ut(e7) {
            var t5;
            if (Gt.has(e7)) return Gt.get(e7);
            {
              const i6 = null === (t5 = e7.getParameter(e7.VERSION)) || void 0 === t5 ? void 0 : t5.startsWith("WebGL 2.0");
              return Gt.set(e7, i6), i6;
            }
          }
          class Vt {
            get awaitingQuery() {
              return !!this._readbackQueue;
            }
            constructor(e7) {
              this._readbackWaitFrames = 4, this._measureWaitFrames = 6, this._texWidth = 1, this._texHeight = 1, this._measuredError = 0, this._updateCount = 0, this._lastReadbackFrame = -1e3, this._readbackQueue = null, this._cachedRenderContext = e7;
              const i6 = e7.context, r7 = i6.gl;
              this._texFormat = r7.RGBA, this._texType = r7.UNSIGNED_BYTE;
              const o7 = new t4.aF();
              o7.emplaceBack(-1, -1), o7.emplaceBack(2, -1), o7.emplaceBack(-1, 2);
              const a4 = new t4.aH();
              a4.emplaceBack(0, 1, 2), this._fullscreenTriangle = new pt(i6.createVertexBuffer(o7, mt.members), i6.createIndexBuffer(a4), t4.aG.simpleSegment(0, 0, o7.length, a4.length)), this._resultBuffer = new Uint8Array(4), i6.activeTexture.set(r7.TEXTURE1);
              const s5 = r7.createTexture();
              r7.bindTexture(r7.TEXTURE_2D, s5), r7.texParameteri(r7.TEXTURE_2D, r7.TEXTURE_WRAP_S, r7.CLAMP_TO_EDGE), r7.texParameteri(r7.TEXTURE_2D, r7.TEXTURE_WRAP_T, r7.CLAMP_TO_EDGE), r7.texParameteri(r7.TEXTURE_2D, r7.TEXTURE_MIN_FILTER, r7.NEAREST), r7.texParameteri(r7.TEXTURE_2D, r7.TEXTURE_MAG_FILTER, r7.NEAREST), r7.texImage2D(r7.TEXTURE_2D, 0, this._texFormat, this._texWidth, this._texHeight, 0, this._texFormat, this._texType, null), this._fbo = i6.createFramebuffer(this._texWidth, this._texHeight, false, false), this._fbo.colorAttachment.set(s5), Ut(r7) && (this._pbo = r7.createBuffer(), r7.bindBuffer(r7.PIXEL_PACK_BUFFER, this._pbo), r7.bufferData(r7.PIXEL_PACK_BUFFER, 4, r7.STREAM_READ), r7.bindBuffer(r7.PIXEL_PACK_BUFFER, null));
            }
            destroy() {
              const e7 = this._cachedRenderContext.context.gl;
              this._fullscreenTriangle.destroy(), this._fbo.destroy(), e7.deleteBuffer(this._pbo), this._fullscreenTriangle = null, this._fbo = null, this._pbo = null, this._resultBuffer = null;
            }
            updateErrorLoop(e7, t5) {
              const i6 = this._updateCount;
              return this._readbackQueue ? i6 >= this._readbackQueue.frameNumberIssued + this._readbackWaitFrames && this._tryReadback() : i6 >= this._lastReadbackFrame + this._measureWaitFrames && this._renderErrorTexture(e7, t5), this._updateCount++, this._measuredError;
            }
            _bindFramebuffer() {
              const e7 = this._cachedRenderContext.context, t5 = e7.gl;
              e7.activeTexture.set(t5.TEXTURE1), t5.bindTexture(t5.TEXTURE_2D, this._fbo.colorAttachment.get()), e7.bindFramebuffer.set(this._fbo.framebuffer);
            }
            _renderErrorTexture(e7, i6) {
              const r7 = this._cachedRenderContext.context, o7 = r7.gl;
              if (this._bindFramebuffer(), r7.viewport.set([0, 0, this._texWidth, this._texHeight]), r7.clear({ color: t4.b7.transparent }), this._cachedRenderContext.useProgram("projectionErrorMeasurement").draw(r7, o7.TRIANGLES, jt.disabled, Nt.disabled, Ft.unblended, Ot.disabled, /* @__PURE__ */ ((e8, t5) => ({ u_input: e8, u_output_expected: t5 }))(e7, i6), null, null, "$clipping", this._fullscreenTriangle.vertexBuffer, this._fullscreenTriangle.indexBuffer, this._fullscreenTriangle.segments), this._pbo && Ut(o7)) {
                o7.bindBuffer(o7.PIXEL_PACK_BUFFER, this._pbo), o7.readBuffer(o7.COLOR_ATTACHMENT0), o7.readPixels(0, 0, this._texWidth, this._texHeight, this._texFormat, this._texType, 0), o7.bindBuffer(o7.PIXEL_PACK_BUFFER, null);
                const e8 = o7.fenceSync(o7.SYNC_GPU_COMMANDS_COMPLETE, 0);
                o7.flush(), this._readbackQueue = { frameNumberIssued: this._updateCount, sync: e8 };
              } else this._readbackQueue = { frameNumberIssued: this._updateCount, sync: null };
            }
            _tryReadback() {
              const e7 = this._cachedRenderContext.context.gl;
              if (this._pbo && this._readbackQueue && Ut(e7)) {
                const i6 = e7.clientWaitSync(this._readbackQueue.sync, 0, 0);
                if (i6 === e7.WAIT_FAILED) return t4.w("WebGL2 clientWaitSync failed."), this._readbackQueue = null, void (this._lastReadbackFrame = this._updateCount);
                if (i6 === e7.TIMEOUT_EXPIRED) return;
                e7.bindBuffer(e7.PIXEL_PACK_BUFFER, this._pbo), e7.getBufferSubData(e7.PIXEL_PACK_BUFFER, 0, this._resultBuffer, 0, 4), e7.bindBuffer(e7.PIXEL_PACK_BUFFER, null);
              } else this._bindFramebuffer(), e7.readPixels(0, 0, this._texWidth, this._texHeight, this._texFormat, this._texType, this._resultBuffer);
              this._readbackQueue = null, this._measuredError = Vt._parseRGBA8float(this._resultBuffer), this._lastReadbackFrame = this._updateCount;
            }
            static _parseRGBA8float(e7) {
              let t5 = 0;
              return t5 += e7[0] / 256, t5 += e7[1] / 65536, t5 += e7[2] / 16777216, e7[3] < 127 && (t5 = -t5), t5 / 128;
            }
          }
          const qt = t4.Z / 128;
          function Wt(e7, i6) {
            const r7 = void 0 !== e7.granularity ? Math.max(e7.granularity, 1) : 1, o7 = r7 + (e7.generateBorders ? 2 : 0), a4 = r7 + (e7.extendToNorthPole || e7.generateBorders ? 1 : 0) + (e7.extendToSouthPole || e7.generateBorders ? 1 : 0), s5 = o7 + 1, n6 = a4 + 1, l5 = e7.generateBorders ? -1 : 0, c5 = e7.generateBorders || e7.extendToNorthPole ? -1 : 0, h4 = r7 + (e7.generateBorders ? 1 : 0), u4 = r7 + (e7.generateBorders || e7.extendToSouthPole ? 1 : 0), d4 = s5 * n6, _4 = o7 * a4 * 6, p4 = s5 * n6 > 65536;
            if (p4 && "16bit" === i6) throw new Error("Granularity is too large and meshes would not fit inside 16 bit vertex indices.");
            const m4 = p4 || "32bit" === i6, f4 = new Int16Array(2 * d4);
            let g4 = 0;
            for (let i7 = c5; i7 <= u4; i7++) for (let o8 = l5; o8 <= h4; o8++) {
              let a5 = o8 / r7 * t4.Z;
              -1 === o8 && (a5 = -64), o8 === r7 + 1 && (a5 = t4.Z + qt);
              let s6 = i7 / r7 * t4.Z;
              -1 === i7 && (s6 = e7.extendToNorthPole ? t4.b9 : -64), i7 === r7 + 1 && (s6 = e7.extendToSouthPole ? t4.ba : t4.Z + qt), f4[g4++] = a5, f4[g4++] = s6;
            }
            const v4 = m4 ? new Uint32Array(_4) : new Uint16Array(_4);
            let x4 = 0;
            for (let e8 = 0; e8 < a4; e8++) for (let t5 = 0; t5 < o7; t5++) {
              const i7 = t5 + 1 + e8 * s5, r8 = t5 + (e8 + 1) * s5, o8 = t5 + 1 + (e8 + 1) * s5;
              v4[x4++] = t5 + e8 * s5, v4[x4++] = r8, v4[x4++] = i7, v4[x4++] = i7, v4[x4++] = r8, v4[x4++] = o8;
            }
            return { vertices: f4.buffer.slice(0), indices: v4.buffer.slice(0), uses32bitIndices: m4 };
          }
          const $t = new t4.aE({ fill: new t4.bb(128, 2), line: new t4.bb(512, 0), tile: new t4.bb(128, 32), stencil: new t4.bb(128, 1), circle: 3 });
          class Ht {
            constructor() {
              this._tileMeshCache = {}, this._errorCorrectionUsable = 0, this._errorMeasurementLastValue = 0, this._errorCorrectionPreviousValue = 0, this._errorMeasurementLastChangeTime = -1e3;
            }
            get name() {
              return "vertical-perspective";
            }
            get transitionState() {
              return 1;
            }
            get useSubdivision() {
              return true;
            }
            get shaderVariantName() {
              return "globe";
            }
            get shaderDefine() {
              return "#define GLOBE";
            }
            get shaderPreludeCode() {
              return dt.projectionGlobe;
            }
            get vertexShaderPreludeCode() {
              return dt.projectionMercator.vertexSource;
            }
            get subdivisionGranularity() {
              return $t;
            }
            get useGlobeControls() {
              return true;
            }
            get latitudeErrorCorrectionRadians() {
              return this._errorCorrectionUsable;
            }
            destroy() {
              this._errorMeasurement && this._errorMeasurement.destroy();
            }
            updateGPUdependent(e7) {
              this._errorMeasurement || (this._errorMeasurement = new Vt(e7));
              const i6 = t4.S(this._errorQueryLatitudeDegrees), r7 = 2 * Math.atan(Math.exp(Math.PI - i6 * Math.PI * 2)) - 0.5 * Math.PI, o7 = this._errorMeasurement.updateErrorLoop(i6, r7), a4 = s4.now();
              o7 !== this._errorMeasurementLastValue && (this._errorCorrectionPreviousValue = this._errorCorrectionUsable, this._errorMeasurementLastValue = o7, this._errorMeasurementLastChangeTime = a4);
              const n6 = Math.min(Math.max((a4 - this._errorMeasurementLastChangeTime) / 1e3 / 0.5, 0), 1);
              this._errorCorrectionUsable = t4.bc(this._errorCorrectionPreviousValue, -this._errorMeasurementLastValue, t4.bd(n6));
            }
            _getMeshKey(e7) {
              return `${e7.granularity.toString(36)}_${e7.generateBorders ? "b" : ""}${e7.extendToNorthPole ? "n" : ""}${e7.extendToSouthPole ? "s" : ""}`;
            }
            getMeshFromTileID(e7, t5, i6, r7, o7) {
              const a4 = ("stencil" === o7 ? $t.stencil : $t.tile).getGranularityForZoomLevel(t5.z);
              return this._getMesh(e7, { granularity: a4, generateBorders: i6, extendToNorthPole: 0 === t5.y && r7, extendToSouthPole: t5.y === (1 << t5.z) - 1 && r7 });
            }
            _getMesh(e7, i6) {
              const r7 = this._getMeshKey(i6);
              if (r7 in this._tileMeshCache) return this._tileMeshCache[r7];
              const o7 = function(e8, i7) {
                const r8 = Wt(i7, "16bit"), o8 = t4.aF.deserialize({ arrayBuffer: r8.vertices, length: r8.vertices.byteLength / 2 / 2 }), a4 = t4.aH.deserialize({ arrayBuffer: r8.indices, length: r8.indices.byteLength / 2 / 3 });
                return new pt(e8.createVertexBuffer(o8, mt.members), e8.createIndexBuffer(a4), t4.aG.simpleSegment(0, 0, o8.length, a4.length));
              }(e7, i6);
              return this._tileMeshCache[r7] = o7, o7;
            }
            recalculate(e7) {
            }
            hasTransition() {
              const e7 = s4.now();
              let t5 = false;
              return t5 = t5 || (e7 - this._errorMeasurementLastChangeTime) / 1e3 < 0.7, t5 = t5 || this._errorMeasurement && this._errorMeasurement.awaitingQuery, t5;
            }
            setErrorQueryLatitudeDegrees(e7) {
              this._errorQueryLatitudeDegrees = e7;
            }
          }
          const Kt = new t4.r({ type: new t4.D(t4.v.projection.type) });
          class Xt extends t4.E {
            constructor(e7) {
              super(), this._transitionable = new t4.T(Kt), this.setProjection(e7), this._transitioning = this._transitionable.untransitioned(), this.recalculate(new t4.C(0)), this._mercatorProjection = new vt(), this._verticalPerspectiveProjection = new Ht();
            }
            get transitionState() {
              const e7 = this.properties.get("type");
              if ("string" == typeof e7 && "mercator" === e7) return 0;
              if ("string" == typeof e7 && "vertical-perspective" === e7) return 1;
              if (e7 instanceof t4.be) {
                if ("vertical-perspective" === e7.from && "mercator" === e7.to) return 1 - e7.transition;
                if ("mercator" === e7.from && "vertical-perspective" === e7.to) return e7.transition;
              }
              return 1;
            }
            get useGlobeRendering() {
              return this.transitionState > 0;
            }
            get latitudeErrorCorrectionRadians() {
              return this._verticalPerspectiveProjection.latitudeErrorCorrectionRadians;
            }
            get currentProjection() {
              return this.useGlobeRendering ? this._verticalPerspectiveProjection : this._mercatorProjection;
            }
            get name() {
              return "globe";
            }
            get useSubdivision() {
              return this.currentProjection.useSubdivision;
            }
            get shaderVariantName() {
              return this.currentProjection.shaderVariantName;
            }
            get shaderDefine() {
              return this.currentProjection.shaderDefine;
            }
            get shaderPreludeCode() {
              return this.currentProjection.shaderPreludeCode;
            }
            get vertexShaderPreludeCode() {
              return this.currentProjection.vertexShaderPreludeCode;
            }
            get subdivisionGranularity() {
              return this.currentProjection.subdivisionGranularity;
            }
            get useGlobeControls() {
              return this.transitionState > 0;
            }
            destroy() {
              this._mercatorProjection.destroy(), this._verticalPerspectiveProjection.destroy();
            }
            updateGPUdependent(e7) {
              this._mercatorProjection.updateGPUdependent(e7), this._verticalPerspectiveProjection.updateGPUdependent(e7);
            }
            getMeshFromTileID(e7, t5, i6, r7, o7) {
              return this.currentProjection.getMeshFromTileID(e7, t5, i6, r7, o7);
            }
            setProjection(e7) {
              this._transitionable.setValue("type", (null == e7 ? void 0 : e7.type) || "mercator");
            }
            updateTransitions(e7) {
              this._transitioning = this._transitionable.transitioned(e7, this._transitioning);
            }
            hasTransition() {
              return this._transitioning.hasTransition() || this.currentProjection.hasTransition();
            }
            recalculate(e7) {
              this.properties = this._transitioning.possiblyEvaluate(e7);
            }
            setErrorQueryLatitudeDegrees(e7) {
              this._verticalPerspectiveProjection.setErrorQueryLatitudeDegrees(e7), this._mercatorProjection.setErrorQueryLatitudeDegrees(e7);
            }
          }
          function Qt(e7) {
            const t5 = ei(e7.worldSize, e7.center.lat);
            return 2 * Math.PI * t5;
          }
          function Yt(e7, i6, r7, o7, a4) {
            const s5 = 1 / (1 << a4), n6 = i6 / t4.Z * s5 + o7 * s5, l5 = t4.bg((e7 / t4.Z * s5 + r7 * s5) * Math.PI * 2 + Math.PI, 2 * Math.PI), c5 = 2 * Math.atan(Math.exp(Math.PI - n6 * Math.PI * 2)) - 0.5 * Math.PI, h4 = Math.cos(c5), u4 = new Float64Array(3);
            return u4[0] = Math.sin(l5) * h4, u4[1] = Math.sin(c5), u4[2] = Math.cos(l5) * h4, u4;
          }
          function Jt(e7) {
            return function(e8, t5) {
              const i6 = Math.cos(t5), r7 = new Float64Array(3);
              return r7[0] = Math.sin(e8) * i6, r7[1] = Math.sin(t5), r7[2] = Math.cos(e8) * i6, r7;
            }(e7.lng * Math.PI / 180, e7.lat * Math.PI / 180);
          }
          function ei(e7, t5) {
            return e7 / (2 * Math.PI) / Math.cos(t5 * Math.PI / 180);
          }
          function ti(e7) {
            const i6 = Math.asin(e7[1]) / Math.PI * 180, r7 = Math.sqrt(e7[0] * e7[0] + e7[2] * e7[2]);
            if (r7 > 1e-6) {
              const o7 = e7[0] / r7, a4 = Math.acos(e7[2] / r7), s5 = (o7 > 0 ? a4 : -a4) / Math.PI * 180;
              return new t4.Q(t4.aL(s5, -180, 180), i6);
            }
            return new t4.Q(0, i6);
          }
          function ii(e7) {
            return Math.cos(e7 * Math.PI / 180);
          }
          function ri(e7, i6) {
            const r7 = ii(e7), o7 = ii(i6);
            return t4.ab(o7 / r7);
          }
          function oi(e7, i6) {
            const r7 = e7.rotate(i6.bearingInRadians), o7 = i6.zoom + ri(i6.center.lat, 0), a4 = t4.bc(1 / ii(i6.center.lat), 1 / ii(Math.min(Math.abs(i6.center.lat), 60)), t4.bf(o7, 7, 3, 0, 1)), s5 = 360 / Qt({ worldSize: i6.worldSize, center: { lat: i6.center.lat } });
            return new t4.Q(i6.center.lng - r7.x * s5 * a4, t4.ae(i6.center.lat + r7.y * s5, -85.051129, t4.aJ));
          }
          function ai(e7) {
            const t5 = 0.5 * e7, i6 = Math.sin(t5), r7 = Math.cos(t5);
            return Math.log(i6 + r7) - Math.log(r7 - i6);
          }
          function si(e7, i6, r7, o7) {
            const a4 = e7.lat + r7 * o7;
            if (Math.abs(r7) > 1) {
              const s5 = (Math.sign(e7.lat + r7) !== Math.sign(e7.lat) ? -Math.abs(e7.lat) : Math.abs(e7.lat)) * Math.PI / 180, n6 = Math.abs(e7.lat + r7) * Math.PI / 180, l5 = ai(s5 + o7 * (n6 - s5)), c5 = ai(s5), h4 = ai(n6);
              return new t4.Q(e7.lng + i6 * ((l5 - c5) / (h4 - c5)), a4);
            }
            return new t4.Q(e7.lng + i6 * o7, a4);
          }
          class ni {
            constructor(e7) {
              this._cachePrevious = /* @__PURE__ */ new Map(), this._cache = /* @__PURE__ */ new Map(), this._hadAnyChanges = false, this._aabbFactory = e7;
            }
            recalculateCache() {
              if (!this._hadAnyChanges) return;
              const e7 = this._cachePrevious;
              this._cachePrevious = this._cache, this._cache = e7, this._cache.clear(), this._hadAnyChanges = false;
            }
            getTileAABB(e7, t5, i6, r7) {
              const o7 = `${e7.z}_${e7.x}_${e7.y}`, a4 = this._cache.get(o7);
              if (a4) return a4;
              const s5 = this._cachePrevious.get(o7);
              if (s5) return this._cache.set(o7, s5), s5;
              const n6 = this._aabbFactory(e7, t5, i6, r7);
              return this._cache.set(o7, n6), this._hadAnyChanges = true, n6;
            }
          }
          function li(e7, t5, i6) {
            const r7 = e7 - t5;
            return r7 < 0 ? -r7 : Math.max(0, r7 - i6);
          }
          function ci(e7, t5, i6, r7, o7) {
            const a4 = e7 - i6;
            let s5;
            return s5 = a4 < 0 ? Math.min(-a4, 1 + a4 - o7) : a4 > 1 ? Math.min(Math.max(a4 - o7, 0), 1 - a4) : 0, Math.max(s5, li(t5, r7, o7));
          }
          class hi {
            constructor() {
              this._aabbCache = new ni(this._computeTileAABB);
            }
            recalculateCache() {
              this._aabbCache.recalculateCache();
            }
            distanceToTile2d(e7, t5, i6, r7) {
              const o7 = 1 << i6.z, a4 = 1 / o7, s5 = i6.x / o7, n6 = i6.y / o7;
              let l5 = 2;
              return l5 = Math.min(l5, ci(e7, t5, s5, n6, a4)), l5 = Math.min(l5, ci(e7, t5, s5 + 0.5, -n6 - a4, a4)), l5 = Math.min(l5, ci(e7, t5, s5 + 0.5, 2 - n6 - a4, a4)), l5;
            }
            getWrap(e7, t5, i6) {
              const r7 = 1 << t5.z, o7 = 1 / r7, a4 = t5.x / r7, s5 = li(e7.x, a4, o7), n6 = li(e7.x, a4 - 1, o7), l5 = li(e7.x, a4 + 1, o7), c5 = Math.min(s5, n6, l5);
              return c5 === l5 ? 1 : c5 === n6 ? -1 : 0;
            }
            allowVariableZoom(e7, t5) {
              return he(e7, t5) > 4;
            }
            allowWorldCopies() {
              return false;
            }
            getTileAABB(e7, t5, i6, r7) {
              return this._aabbCache.getTileAABB(e7, t5, i6, r7);
            }
            _computeTileAABB(e7, i6, r7, o7) {
              if (e7.z <= 0) return new Et([-1, -1, -1], [1, 1, 1]);
              if (1 === e7.z) return new Et([0 === e7.x ? -1 : 0, 0 === e7.y ? 0 : -1, -1], [0 === e7.x ? 0 : 1, 0 === e7.y ? 1 : 0, 1]);
              {
                const i7 = [Yt(0, 0, e7.x, e7.y, e7.z), Yt(t4.Z, 0, e7.x, e7.y, e7.z), Yt(t4.Z, t4.Z, e7.x, e7.y, e7.z), Yt(0, t4.Z, e7.x, e7.y, e7.z)], r8 = [1, 1, 1], o8 = [-1, -1, -1];
                for (const e8 of i7) for (let t5 = 0; t5 < 3; t5++) r8[t5] = Math.min(r8[t5], e8[t5]), o8[t5] = Math.max(o8[t5], e8[t5]);
                if (0 === e7.y || e7.y === (1 << e7.z) - 1) {
                  const t5 = [0, 0 === e7.y ? 1 : -1, 0];
                  for (let e8 = 0; e8 < 3; e8++) r8[e8] = Math.min(r8[e8], t5[e8]), o8[e8] = Math.max(o8[e8], t5[e8]);
                }
                return new Et(r8, o8);
              }
            }
          }
          class ui {
            get pixelsToClipSpaceMatrix() {
              return this._helper.pixelsToClipSpaceMatrix;
            }
            get clipSpaceToPixelsMatrix() {
              return this._helper.clipSpaceToPixelsMatrix;
            }
            get pixelsToGLUnits() {
              return this._helper.pixelsToGLUnits;
            }
            get centerOffset() {
              return this._helper.centerOffset;
            }
            get size() {
              return this._helper.size;
            }
            get rotationMatrix() {
              return this._helper.rotationMatrix;
            }
            get centerPoint() {
              return this._helper.centerPoint;
            }
            get pixelsPerMeter() {
              return this._helper.pixelsPerMeter;
            }
            setMinZoom(e7) {
              this._helper.setMinZoom(e7);
            }
            setMaxZoom(e7) {
              this._helper.setMaxZoom(e7);
            }
            setMinPitch(e7) {
              this._helper.setMinPitch(e7);
            }
            setMaxPitch(e7) {
              this._helper.setMaxPitch(e7);
            }
            setRenderWorldCopies(e7) {
              this._helper.setRenderWorldCopies(e7);
            }
            setBearing(e7) {
              this._helper.setBearing(e7);
            }
            setPitch(e7) {
              this._helper.setPitch(e7);
            }
            setRoll(e7) {
              this._helper.setRoll(e7);
            }
            setFov(e7) {
              this._helper.setFov(e7);
            }
            setZoom(e7) {
              this._helper.setZoom(e7);
            }
            setCenter(e7) {
              this._helper.setCenter(e7);
            }
            setElevation(e7) {
              this._helper.setElevation(e7);
            }
            setMinElevationForCurrentTile(e7) {
              this._helper.setMinElevationForCurrentTile(e7);
            }
            setPadding(e7) {
              this._helper.setPadding(e7);
            }
            interpolatePadding(e7, t5, i6) {
              return this._helper.interpolatePadding(e7, t5, i6);
            }
            isPaddingEqual(e7) {
              return this._helper.isPaddingEqual(e7);
            }
            resize(e7, t5) {
              this._helper.resize(e7, t5);
            }
            getMaxBounds() {
              return this._helper.getMaxBounds();
            }
            setMaxBounds(e7) {
              this._helper.setMaxBounds(e7);
            }
            overrideNearFarZ(e7, t5) {
              this._helper.overrideNearFarZ(e7, t5);
            }
            clearNearFarZOverride() {
              this._helper.clearNearFarZOverride();
            }
            getCameraQueryGeometry(e7) {
              return this._helper.getCameraQueryGeometry(this.getCameraPoint(), e7);
            }
            get tileSize() {
              return this._helper.tileSize;
            }
            get tileZoom() {
              return this._helper.tileZoom;
            }
            get scale() {
              return this._helper.scale;
            }
            get worldSize() {
              return this._helper.worldSize;
            }
            get width() {
              return this._helper.width;
            }
            get height() {
              return this._helper.height;
            }
            get lngRange() {
              return this._helper.lngRange;
            }
            get latRange() {
              return this._helper.latRange;
            }
            get minZoom() {
              return this._helper.minZoom;
            }
            get maxZoom() {
              return this._helper.maxZoom;
            }
            get zoom() {
              return this._helper.zoom;
            }
            get center() {
              return this._helper.center;
            }
            get minPitch() {
              return this._helper.minPitch;
            }
            get maxPitch() {
              return this._helper.maxPitch;
            }
            get pitch() {
              return this._helper.pitch;
            }
            get pitchInRadians() {
              return this._helper.pitchInRadians;
            }
            get roll() {
              return this._helper.roll;
            }
            get rollInRadians() {
              return this._helper.rollInRadians;
            }
            get bearing() {
              return this._helper.bearing;
            }
            get bearingInRadians() {
              return this._helper.bearingInRadians;
            }
            get fov() {
              return this._helper.fov;
            }
            get fovInRadians() {
              return this._helper.fovInRadians;
            }
            get elevation() {
              return this._helper.elevation;
            }
            get minElevationForCurrentTile() {
              return this._helper.minElevationForCurrentTile;
            }
            get padding() {
              return this._helper.padding;
            }
            get unmodified() {
              return this._helper.unmodified;
            }
            get renderWorldCopies() {
              return this._helper.renderWorldCopies;
            }
            get nearZ() {
              return this._helper.nearZ;
            }
            get farZ() {
              return this._helper.farZ;
            }
            get autoCalculateNearFarZ() {
              return this._helper.autoCalculateNearFarZ;
            }
            setTransitionState(e7) {
            }
            constructor() {
              this._cachedClippingPlane = t4.bh(), this._projectionMatrix = t4.b1(), this._globeViewProjMatrix32f = t4.b0(), this._globeViewProjMatrixNoCorrection = t4.b1(), this._globeViewProjMatrixNoCorrectionInverted = t4.b1(), this._globeProjMatrixInverted = t4.b1(), this._cameraPosition = t4.bi(), this._globeLatitudeErrorCorrectionRadians = 0, this._helper = new Mt({ calcMatrices: () => {
                this._calcMatrices();
              }, getConstrained: (e7, t5) => this.getConstrained(e7, t5) }), this._coveringTilesDetailsProvider = new hi();
            }
            clone() {
              const e7 = new ui();
              return e7.apply(this), e7;
            }
            apply(e7, t5) {
              this._globeLatitudeErrorCorrectionRadians = t5 || 0, this._helper.apply(e7);
            }
            get projectionMatrix() {
              return this._projectionMatrix;
            }
            get modelViewProjectionMatrix() {
              return this._globeViewProjMatrixNoCorrection;
            }
            get inverseProjectionMatrix() {
              return this._globeProjMatrixInverted;
            }
            get cameraPosition() {
              const e7 = t4.bi();
              return e7[0] = this._cameraPosition[0], e7[1] = this._cameraPosition[1], e7[2] = this._cameraPosition[2], e7;
            }
            get cameraToCenterDistance() {
              return this._helper.cameraToCenterDistance;
            }
            getProjectionData(e7) {
              const { overscaledTileID: t5, applyGlobeMatrix: i6 } = e7, r7 = this._helper.getMercatorTileCoordinates(t5);
              return { mainMatrix: this._globeViewProjMatrix32f, tileMercatorCoords: r7, clippingPlane: this._cachedClippingPlane, projectionTransition: i6 ? 1 : 0, fallbackMatrix: this._globeViewProjMatrix32f };
            }
            _computeClippingPlane(e7) {
              const i6 = this.pitchInRadians, r7 = this.cameraToCenterDistance / e7, o7 = Math.sin(i6) * r7, a4 = Math.cos(i6) * r7 + 1, s5 = 1 / Math.sqrt(o7 * o7 + a4 * a4) * 1;
              let n6 = -o7, l5 = a4;
              const c5 = Math.sqrt(n6 * n6 + l5 * l5);
              n6 /= c5, l5 /= c5;
              const h4 = [0, n6, l5];
              return t4.bj(h4, h4, [0, 0, 0], -this.bearingInRadians), t4.bk(h4, h4, [0, 0, 0], -1 * this.center.lat * Math.PI / 180), t4.bl(h4, h4, [0, 0, 0], this.center.lng * Math.PI / 180), t4.aO(h4, h4, 0.25), [...h4, 0.25 * -s5];
            }
            isLocationOccluded(e7) {
              return !this.isSurfacePointVisible(Jt(e7));
            }
            transformLightDirection(e7) {
              const i6 = this._helper._center.lng * Math.PI / 180, r7 = this._helper._center.lat * Math.PI / 180, o7 = Math.cos(r7), a4 = [Math.sin(i6) * o7, Math.sin(r7), Math.cos(i6) * o7], s5 = [a4[2], 0, -a4[0]], n6 = [0, 0, 0];
              t4.aU(n6, s5, a4), t4.aT(s5, s5), t4.aT(n6, n6);
              const l5 = [0, 0, 0];
              return t4.aT(l5, [s5[0] * e7[0] + n6[0] * e7[1] + a4[0] * e7[2], s5[1] * e7[0] + n6[1] * e7[1] + a4[1] * e7[2], s5[2] * e7[0] + n6[2] * e7[1] + a4[2] * e7[2]]), l5;
            }
            getPixelScale() {
              return 1 / Math.cos(this._helper._center.lat * Math.PI / 180);
            }
            getCircleRadiusCorrection() {
              return Math.cos(this._helper._center.lat * Math.PI / 180);
            }
            getPitchedTextCorrection(e7, i6, r7) {
              const o7 = function(e8, i7, r8) {
                const o8 = 1 / (1 << r8.z);
                return new t4.$(e8 / t4.Z * o8 + r8.x * o8, i7 / t4.Z * o8 + r8.y * o8);
              }(e7, i6, r7.canonical), a4 = (s5 = o7.y, [t4.bg(o7.x * Math.PI * 2 + Math.PI, 2 * Math.PI), 2 * Math.atan(Math.exp(Math.PI - s5 * Math.PI * 2)) - 0.5 * Math.PI]);
              var s5;
              return this.getCircleRadiusCorrection() / Math.cos(a4[1]);
            }
            projectTileCoordinates(e7, i6, r7, o7) {
              const a4 = r7.canonical, s5 = Yt(e7, i6, a4.x, a4.y, a4.z), n6 = 1 + (o7 ? o7(e7, i6) : 0) / t4.br, l5 = [s5[0] * n6, s5[1] * n6, s5[2] * n6, 1];
              t4.ap(l5, l5, this._globeViewProjMatrixNoCorrection);
              const c5 = this._cachedClippingPlane, h4 = c5[0] * s5[0] + c5[1] * s5[1] + c5[2] * s5[2] + c5[3] < 0;
              return { point: new t4.P(l5[0] / l5[3], l5[1] / l5[3]), signedDistanceFromCamera: l5[3], isOccluded: h4 };
            }
            _calcMatrices() {
              if (!this._helper._width || !this._helper._height) return;
              const e7 = ei(this.worldSize, this.center.lat), i6 = t4.b2(), r7 = t4.b2();
              this._helper.autoCalculateNearFarZ && (this._helper._nearZ = 0.5, this._helper._farZ = this.cameraToCenterDistance + 2 * e7), t4.aY(i6, this.fovInRadians, this.width / this.height, this._helper._nearZ, this._helper._farZ);
              const o7 = this.centerOffset;
              i6[8] = 2 * -o7.x / this._helper._width, i6[9] = 2 * o7.y / this._helper._height, this._projectionMatrix = t4.aZ(i6), this._globeProjMatrixInverted = t4.b2(), t4.aj(this._globeProjMatrixInverted, i6), t4.L(i6, i6, [0, 0, -this.cameraToCenterDistance]), t4.a_(i6, i6, this.rollInRadians), t4.a$(i6, i6, -this.pitchInRadians), t4.a_(i6, i6, this.bearingInRadians), t4.L(i6, i6, [0, 0, -e7]);
              const a4 = t4.bi();
              a4[0] = e7, a4[1] = e7, a4[2] = e7, t4.a$(r7, i6, this.center.lat * Math.PI / 180), t4.bm(r7, r7, -this.center.lng * Math.PI / 180), t4.M(r7, r7, a4), this._globeViewProjMatrixNoCorrection = r7, t4.a$(i6, i6, this.center.lat * Math.PI / 180 - this._globeLatitudeErrorCorrectionRadians), t4.bm(i6, i6, -this.center.lng * Math.PI / 180), t4.M(i6, i6, a4), this._globeViewProjMatrix32f = new Float32Array(i6), this._globeViewProjMatrixNoCorrectionInverted = t4.b2(), t4.aj(this._globeViewProjMatrixNoCorrectionInverted, r7);
              const s5 = t4.bi();
              this._cameraPosition = t4.bi(), this._cameraPosition[2] = this.cameraToCenterDistance / e7, t4.bj(this._cameraPosition, this._cameraPosition, s5, -this.rollInRadians), t4.bk(this._cameraPosition, this._cameraPosition, s5, this.pitchInRadians), t4.bj(this._cameraPosition, this._cameraPosition, s5, -this.bearingInRadians), t4.aP(this._cameraPosition, this._cameraPosition, [0, 0, 1]), t4.bk(this._cameraPosition, this._cameraPosition, s5, -this.center.lat * Math.PI / 180), t4.bl(this._cameraPosition, this._cameraPosition, s5, this.center.lng * Math.PI / 180), this._cachedClippingPlane = this._computeClippingPlane(e7);
              const n6 = t4.aZ(this._globeViewProjMatrixNoCorrectionInverted);
              t4.M(n6, n6, [1, 1, -1]), this._cachedFrustum = Rt.fromInvProjectionMatrix(n6);
            }
            calculateFogMatrix(e7) {
              t4.w("calculateFogMatrix is not supported on globe projection.");
              const i6 = t4.b2();
              return t4.at(i6), i6;
            }
            getVisibleUnwrappedCoordinates(e7) {
              return [new t4.aW(0, e7)];
            }
            getCameraFrustum() {
              return this._cachedFrustum;
            }
            getClippingPlane() {
              return this._cachedClippingPlane;
            }
            getCoveringTilesDetailsProvider() {
              return this._coveringTilesDetailsProvider;
            }
            recalculateZoomAndCenter(e7) {
              e7 && t4.w("terrain is not fully supported on vertical perspective projection."), this._helper.recalculateZoomAndCenter(0);
            }
            maxPitchScaleFactor() {
              return 1;
            }
            getCameraPoint() {
              return this._helper.getCameraPoint();
            }
            getCameraAltitude() {
              return this._helper.getCameraAltitude();
            }
            getCameraLngLat() {
              return this._helper.getCameraLngLat();
            }
            lngLatToCameraDepth(e7, i6) {
              if (!this._globeViewProjMatrixNoCorrection) return 1;
              const r7 = Jt(e7);
              t4.aO(r7, r7, 1 + i6 / t4.br);
              const o7 = t4.bh();
              return t4.ap(o7, [r7[0], r7[1], r7[2], 1], this._globeViewProjMatrixNoCorrection), o7[2] / o7[3];
            }
            populateCache(e7) {
            }
            getBounds() {
              const e7 = 0.5 * this.width, i6 = 0.5 * this.height, r7 = [new t4.P(0, 0), new t4.P(e7, 0), new t4.P(this.width, 0), new t4.P(this.width, i6), new t4.P(this.width, this.height), new t4.P(e7, this.height), new t4.P(0, this.height), new t4.P(0, i6)], o7 = [];
              for (const e8 of r7) o7.push(this.unprojectScreenPoint(e8));
              let a4 = 0, s5 = 0, n6 = 0, l5 = 0;
              const c5 = this.center;
              for (const e8 of o7) {
                const i7 = t4.bn(c5.lng, e8.lng), r8 = t4.bn(c5.lat, e8.lat);
                i7 < s5 && (s5 = i7), i7 > a4 && (a4 = i7), r8 < l5 && (l5 = r8), r8 > n6 && (n6 = r8);
              }
              const h4 = [c5.lng + s5, c5.lat + l5, c5.lng + a4, c5.lat + n6];
              return this.isSurfacePointOnScreen([0, 1, 0]) && (h4[3] = 90, h4[0] = -180, h4[2] = 180), this.isSurfacePointOnScreen([0, -1, 0]) && (h4[1] = -90, h4[0] = -180, h4[2] = 180), new V2(h4);
            }
            getConstrained(e7, i6) {
              const r7 = t4.ae(e7.lat, -85.051129, t4.aJ), o7 = t4.ae(+i6, this.minZoom + ri(0, r7), this.maxZoom);
              return { center: new t4.Q(e7.lng, r7), zoom: o7 };
            }
            calculateCenterFromCameraLngLatAlt(e7, t5, i6, r7) {
              return this._helper.calculateCenterFromCameraLngLatAlt(e7, t5, i6, r7);
            }
            setLocationAtPoint(e7, i6) {
              const r7 = Jt(this.unprojectScreenPoint(i6)), o7 = Jt(e7), a4 = t4.bi();
              t4.bo(a4);
              const s5 = t4.bi();
              t4.bl(s5, r7, a4, -this.center.lng * Math.PI / 180), t4.bk(s5, s5, a4, this.center.lat * Math.PI / 180);
              const n6 = o7[0] * o7[0] + o7[2] * o7[2], l5 = s5[0] * s5[0];
              if (n6 < l5) return;
              const c5 = Math.sqrt(n6 - l5), h4 = -c5, u4 = t4.bp(o7[0], o7[2], s5[0], c5), d4 = t4.bp(o7[0], o7[2], s5[0], h4), _4 = t4.bi();
              t4.bl(_4, o7, a4, -u4);
              const p4 = t4.bp(_4[1], _4[2], s5[1], s5[2]), m4 = t4.bi();
              t4.bl(m4, o7, a4, -d4);
              const f4 = t4.bp(m4[1], m4[2], s5[1], s5[2]), g4 = 0.5 * Math.PI, v4 = p4 >= -g4 && p4 <= g4, x4 = f4 >= -g4 && f4 <= g4;
              let b5, y4;
              if (v4 && x4) {
                const e8 = this.center.lng * Math.PI / 180, i7 = this.center.lat * Math.PI / 180;
                t4.bs(u4, e8) + t4.bs(p4, i7) < t4.bs(d4, e8) + t4.bs(f4, i7) ? (b5 = u4, y4 = p4) : (b5 = d4, y4 = f4);
              } else if (v4) b5 = u4, y4 = p4;
              else {
                if (!x4) return;
                b5 = d4, y4 = f4;
              }
              const w4 = b5 / Math.PI * 180, T5 = y4 / Math.PI * 180, P4 = this.center.lat;
              this.setCenter(new t4.Q(w4, t4.ae(T5, -90, 90))), this.setZoom(this.zoom + ri(P4, this.center.lat));
            }
            locationToScreenPoint(e7, i6) {
              const r7 = Jt(e7);
              if (i6) {
                const o7 = i6.getElevationForLngLatZoom(e7, this._helper._tileZoom);
                t4.aO(r7, r7, 1 + o7 / t4.br);
              }
              return this._projectSurfacePointToScreen(r7);
            }
            _projectSurfacePointToScreen(e7) {
              const i6 = t4.bh();
              return t4.ap(i6, [...e7, 1], this._globeViewProjMatrixNoCorrection), i6[0] /= i6[3], i6[1] /= i6[3], new t4.P((0.5 * i6[0] + 0.5) * this.width, (0.5 * -i6[1] + 0.5) * this.height);
            }
            screenPointToMercatorCoordinate(e7, i6) {
              if (i6) {
                const t5 = i6.pointCoordinate(e7);
                if (t5) return t5;
              }
              return t4.$.fromLngLat(this.unprojectScreenPoint(e7));
            }
            screenPointToLocation(e7, t5) {
              var i6;
              return null === (i6 = this.screenPointToMercatorCoordinate(e7, t5)) || void 0 === i6 ? void 0 : i6.toLngLat();
            }
            isPointOnMapSurface(e7, t5) {
              const i6 = this._cameraPosition, r7 = this.getRayDirectionFromPixel(e7);
              return !!this.rayPlanetIntersection(i6, r7);
            }
            getRayDirectionFromPixel(e7) {
              const i6 = t4.bh();
              i6[0] = e7.x / this.width * 2 - 1, i6[1] = -1 * (e7.y / this.height * 2 - 1), i6[2] = 1, i6[3] = 1, t4.ap(i6, i6, this._globeViewProjMatrixNoCorrectionInverted), i6[0] /= i6[3], i6[1] /= i6[3], i6[2] /= i6[3];
              const r7 = t4.bi();
              r7[0] = i6[0] - this._cameraPosition[0], r7[1] = i6[1] - this._cameraPosition[1], r7[2] = i6[2] - this._cameraPosition[2];
              const o7 = t4.bi();
              return t4.aT(o7, r7), o7;
            }
            isSurfacePointVisible(e7) {
              const t5 = this._cachedClippingPlane;
              return t5[0] * e7[0] + t5[1] * e7[1] + t5[2] * e7[2] + t5[3] >= 0;
            }
            isSurfacePointOnScreen(e7) {
              if (!this.isSurfacePointVisible(e7)) return false;
              const i6 = t4.bh();
              return t4.ap(i6, [...e7, 1], this._globeViewProjMatrixNoCorrection), i6[0] /= i6[3], i6[1] /= i6[3], i6[2] /= i6[3], i6[0] > -1 && i6[0] < 1 && i6[1] > -1 && i6[1] < 1 && i6[2] > -1 && i6[2] < 1;
            }
            rayPlanetIntersection(e7, i6) {
              const r7 = t4.aV(e7, i6), o7 = t4.bi(), a4 = t4.bi();
              t4.aO(a4, i6, r7), t4.aS(o7, e7, a4);
              const s5 = 1 - t4.aV(o7, o7);
              if (s5 < 0) return null;
              const n6 = t4.aV(e7, e7) - 1, l5 = -r7 + (r7 < 0 ? 1 : -1) * Math.sqrt(s5), c5 = n6 / l5, h4 = l5;
              return { tMin: Math.min(c5, h4), tMax: Math.max(c5, h4) };
            }
            unprojectScreenPoint(e7) {
              const i6 = this._cameraPosition, r7 = this.getRayDirectionFromPixel(e7), o7 = this.rayPlanetIntersection(i6, r7);
              if (o7) {
                const e8 = t4.bi();
                t4.aP(e8, i6, [r7[0] * o7.tMin, r7[1] * o7.tMin, r7[2] * o7.tMin]);
                const a5 = t4.bi();
                return t4.aT(a5, e8), ti(a5);
              }
              const a4 = this._cachedClippingPlane[0] * r7[0] + this._cachedClippingPlane[1] * r7[1] + this._cachedClippingPlane[2] * r7[2], s5 = -t4.bq(this._cachedClippingPlane, i6) / a4, n6 = t4.bi();
              if (s5 > 0) t4.aP(n6, i6, [r7[0] * s5, r7[1] * s5, r7[2] * s5]);
              else {
                const e8 = t4.bi();
                t4.aP(e8, i6, [2 * r7[0], 2 * r7[1], 2 * r7[2]]);
                const o8 = t4.bq(this._cachedClippingPlane, e8);
                t4.aS(n6, e8, [this._cachedClippingPlane[0] * o8, this._cachedClippingPlane[1] * o8, this._cachedClippingPlane[2] * o8]);
              }
              const l5 = t4.bi();
              return t4.aT(l5, n6), ti(l5);
            }
            getMatrixForModel(e7, i6) {
              const r7 = t4.Q.convert(e7), o7 = 1 / t4.br, a4 = t4.b1();
              return t4.bm(a4, a4, r7.lng / 180 * Math.PI), t4.a$(a4, a4, -r7.lat / 180 * Math.PI), t4.L(a4, a4, [0, 0, 1 + i6 / t4.br]), t4.a$(a4, a4, 0.5 * Math.PI), t4.M(a4, a4, [o7, o7, o7]), a4;
            }
            getProjectionDataForCustomLayer(e7 = true) {
              const i6 = this.getProjectionData({ overscaledTileID: new t4.Y(0, 0, 0, 0, 0), applyGlobeMatrix: e7 });
              return i6.tileMercatorCoords = [0, 0, 1, 1], i6;
            }
            getFastPathSimpleProjectionMatrix(e7) {
            }
          }
          class di {
            get pixelsToClipSpaceMatrix() {
              return this._helper.pixelsToClipSpaceMatrix;
            }
            get clipSpaceToPixelsMatrix() {
              return this._helper.clipSpaceToPixelsMatrix;
            }
            get pixelsToGLUnits() {
              return this._helper.pixelsToGLUnits;
            }
            get centerOffset() {
              return this._helper.centerOffset;
            }
            get size() {
              return this._helper.size;
            }
            get rotationMatrix() {
              return this._helper.rotationMatrix;
            }
            get centerPoint() {
              return this._helper.centerPoint;
            }
            get pixelsPerMeter() {
              return this._helper.pixelsPerMeter;
            }
            setMinZoom(e7) {
              this._helper.setMinZoom(e7);
            }
            setMaxZoom(e7) {
              this._helper.setMaxZoom(e7);
            }
            setMinPitch(e7) {
              this._helper.setMinPitch(e7);
            }
            setMaxPitch(e7) {
              this._helper.setMaxPitch(e7);
            }
            setRenderWorldCopies(e7) {
              this._helper.setRenderWorldCopies(e7);
            }
            setBearing(e7) {
              this._helper.setBearing(e7);
            }
            setPitch(e7) {
              this._helper.setPitch(e7);
            }
            setRoll(e7) {
              this._helper.setRoll(e7);
            }
            setFov(e7) {
              this._helper.setFov(e7);
            }
            setZoom(e7) {
              this._helper.setZoom(e7);
            }
            setCenter(e7) {
              this._helper.setCenter(e7);
            }
            setElevation(e7) {
              this._helper.setElevation(e7);
            }
            setMinElevationForCurrentTile(e7) {
              this._helper.setMinElevationForCurrentTile(e7);
            }
            setPadding(e7) {
              this._helper.setPadding(e7);
            }
            interpolatePadding(e7, t5, i6) {
              return this._helper.interpolatePadding(e7, t5, i6);
            }
            isPaddingEqual(e7) {
              return this._helper.isPaddingEqual(e7);
            }
            resize(e7, t5, i6 = true) {
              this._helper.resize(e7, t5, i6);
            }
            getMaxBounds() {
              return this._helper.getMaxBounds();
            }
            setMaxBounds(e7) {
              this._helper.setMaxBounds(e7);
            }
            overrideNearFarZ(e7, t5) {
              this._helper.overrideNearFarZ(e7, t5);
            }
            clearNearFarZOverride() {
              this._helper.clearNearFarZOverride();
            }
            getCameraQueryGeometry(e7) {
              return this._helper.getCameraQueryGeometry(this.getCameraPoint(), e7);
            }
            get tileSize() {
              return this._helper.tileSize;
            }
            get tileZoom() {
              return this._helper.tileZoom;
            }
            get scale() {
              return this._helper.scale;
            }
            get worldSize() {
              return this._helper.worldSize;
            }
            get width() {
              return this._helper.width;
            }
            get height() {
              return this._helper.height;
            }
            get lngRange() {
              return this._helper.lngRange;
            }
            get latRange() {
              return this._helper.latRange;
            }
            get minZoom() {
              return this._helper.minZoom;
            }
            get maxZoom() {
              return this._helper.maxZoom;
            }
            get zoom() {
              return this._helper.zoom;
            }
            get center() {
              return this._helper.center;
            }
            get minPitch() {
              return this._helper.minPitch;
            }
            get maxPitch() {
              return this._helper.maxPitch;
            }
            get pitch() {
              return this._helper.pitch;
            }
            get pitchInRadians() {
              return this._helper.pitchInRadians;
            }
            get roll() {
              return this._helper.roll;
            }
            get rollInRadians() {
              return this._helper.rollInRadians;
            }
            get bearing() {
              return this._helper.bearing;
            }
            get bearingInRadians() {
              return this._helper.bearingInRadians;
            }
            get fov() {
              return this._helper.fov;
            }
            get fovInRadians() {
              return this._helper.fovInRadians;
            }
            get elevation() {
              return this._helper.elevation;
            }
            get minElevationForCurrentTile() {
              return this._helper.minElevationForCurrentTile;
            }
            get padding() {
              return this._helper.padding;
            }
            get unmodified() {
              return this._helper.unmodified;
            }
            get renderWorldCopies() {
              return this._helper.renderWorldCopies;
            }
            get cameraToCenterDistance() {
              return this._helper.cameraToCenterDistance;
            }
            get nearZ() {
              return this._helper.nearZ;
            }
            get farZ() {
              return this._helper.farZ;
            }
            get autoCalculateNearFarZ() {
              return this._helper.autoCalculateNearFarZ;
            }
            get isGlobeRendering() {
              return this._globeness > 0;
            }
            setTransitionState(e7, t5) {
              this._globeness = e7, this._globeLatitudeErrorCorrectionRadians = t5, this._calcMatrices(), this._verticalPerspectiveTransform.getCoveringTilesDetailsProvider().recalculateCache(), this._mercatorTransform.getCoveringTilesDetailsProvider().recalculateCache();
            }
            get currentTransform() {
              return this.isGlobeRendering ? this._verticalPerspectiveTransform : this._mercatorTransform;
            }
            constructor() {
              this._globeLatitudeErrorCorrectionRadians = 0, this._globeness = 1, this._helper = new Mt({ calcMatrices: () => {
                this._calcMatrices();
              }, getConstrained: (e7, t5) => this.getConstrained(e7, t5) }), this._globeness = 1, this._mercatorTransform = new Dt(), this._verticalPerspectiveTransform = new ui();
            }
            clone() {
              const e7 = new di();
              return e7._globeness = this._globeness, e7._globeLatitudeErrorCorrectionRadians = this._globeLatitudeErrorCorrectionRadians, e7.apply(this), e7;
            }
            apply(e7) {
              this._helper.apply(e7), this._mercatorTransform.apply(this), this._verticalPerspectiveTransform.apply(this, this._globeLatitudeErrorCorrectionRadians);
            }
            get projectionMatrix() {
              return this.currentTransform.projectionMatrix;
            }
            get modelViewProjectionMatrix() {
              return this.currentTransform.modelViewProjectionMatrix;
            }
            get inverseProjectionMatrix() {
              return this.currentTransform.inverseProjectionMatrix;
            }
            get cameraPosition() {
              return this.currentTransform.cameraPosition;
            }
            getProjectionData(e7) {
              const t5 = this._mercatorTransform.getProjectionData(e7), i6 = this._verticalPerspectiveTransform.getProjectionData(e7);
              return { mainMatrix: this.isGlobeRendering ? i6.mainMatrix : t5.mainMatrix, clippingPlane: i6.clippingPlane, tileMercatorCoords: i6.tileMercatorCoords, projectionTransition: e7.applyGlobeMatrix ? this._globeness : 0, fallbackMatrix: t5.fallbackMatrix };
            }
            isLocationOccluded(e7) {
              return this.currentTransform.isLocationOccluded(e7);
            }
            transformLightDirection(e7) {
              return this.currentTransform.transformLightDirection(e7);
            }
            getPixelScale() {
              return t4.bc(this._mercatorTransform.getPixelScale(), this._verticalPerspectiveTransform.getPixelScale(), this._globeness);
            }
            getCircleRadiusCorrection() {
              return t4.bc(this._mercatorTransform.getCircleRadiusCorrection(), this._verticalPerspectiveTransform.getCircleRadiusCorrection(), this._globeness);
            }
            getPitchedTextCorrection(e7, i6, r7) {
              const o7 = this._mercatorTransform.getPitchedTextCorrection(e7, i6, r7), a4 = this._verticalPerspectiveTransform.getPitchedTextCorrection(e7, i6, r7);
              return t4.bc(o7, a4, this._globeness);
            }
            projectTileCoordinates(e7, t5, i6, r7) {
              return this.currentTransform.projectTileCoordinates(e7, t5, i6, r7);
            }
            _calcMatrices() {
              this._helper._width && this._helper._height && (this._verticalPerspectiveTransform.apply(this, this._globeLatitudeErrorCorrectionRadians), this._helper._nearZ = this._verticalPerspectiveTransform.nearZ, this._helper._farZ = this._verticalPerspectiveTransform.farZ, this._mercatorTransform.apply(this, true, this.isGlobeRendering), this._helper._nearZ = this._mercatorTransform.nearZ, this._helper._farZ = this._mercatorTransform.farZ);
            }
            calculateFogMatrix(e7) {
              return this.currentTransform.calculateFogMatrix(e7);
            }
            getVisibleUnwrappedCoordinates(e7) {
              return this.currentTransform.getVisibleUnwrappedCoordinates(e7);
            }
            getCameraFrustum() {
              return this.currentTransform.getCameraFrustum();
            }
            getClippingPlane() {
              return this.currentTransform.getClippingPlane();
            }
            getCoveringTilesDetailsProvider() {
              return this.currentTransform.getCoveringTilesDetailsProvider();
            }
            recalculateZoomAndCenter(e7) {
              this._mercatorTransform.recalculateZoomAndCenter(e7), this._verticalPerspectiveTransform.recalculateZoomAndCenter(e7);
            }
            maxPitchScaleFactor() {
              return this._mercatorTransform.maxPitchScaleFactor();
            }
            getCameraPoint() {
              return this._helper.getCameraPoint();
            }
            getCameraAltitude() {
              return this._helper.getCameraAltitude();
            }
            getCameraLngLat() {
              return this._helper.getCameraLngLat();
            }
            lngLatToCameraDepth(e7, t5) {
              return this.currentTransform.lngLatToCameraDepth(e7, t5);
            }
            populateCache(e7) {
              this._mercatorTransform.populateCache(e7), this._verticalPerspectiveTransform.populateCache(e7);
            }
            getBounds() {
              return this.currentTransform.getBounds();
            }
            getConstrained(e7, t5) {
              return this.currentTransform.getConstrained(e7, t5);
            }
            calculateCenterFromCameraLngLatAlt(e7, t5, i6, r7) {
              return this._helper.calculateCenterFromCameraLngLatAlt(e7, t5, i6, r7);
            }
            setLocationAtPoint(e7, t5) {
              if (!this.isGlobeRendering) return this._mercatorTransform.setLocationAtPoint(e7, t5), void this.apply(this._mercatorTransform);
              this._verticalPerspectiveTransform.setLocationAtPoint(e7, t5), this.apply(this._verticalPerspectiveTransform);
            }
            locationToScreenPoint(e7, t5) {
              return this.currentTransform.locationToScreenPoint(e7, t5);
            }
            screenPointToMercatorCoordinate(e7, t5) {
              return this.currentTransform.screenPointToMercatorCoordinate(e7, t5);
            }
            screenPointToLocation(e7, t5) {
              return this.currentTransform.screenPointToLocation(e7, t5);
            }
            isPointOnMapSurface(e7, t5) {
              return this.currentTransform.isPointOnMapSurface(e7, t5);
            }
            getRayDirectionFromPixel(e7) {
              return this._verticalPerspectiveTransform.getRayDirectionFromPixel(e7);
            }
            getMatrixForModel(e7, t5) {
              return this.currentTransform.getMatrixForModel(e7, t5);
            }
            getProjectionDataForCustomLayer(e7 = true) {
              const t5 = this._mercatorTransform.getProjectionDataForCustomLayer(e7);
              if (!this.isGlobeRendering) return t5;
              const i6 = this._verticalPerspectiveTransform.getProjectionDataForCustomLayer(e7);
              return i6.fallbackMatrix = t5.mainMatrix, i6;
            }
            getFastPathSimpleProjectionMatrix(e7) {
              return this.currentTransform.getFastPathSimpleProjectionMatrix(e7);
            }
          }
          class _i {
            get useGlobeControls() {
              return true;
            }
            handlePanInertia(e7, i6) {
              const r7 = oi(e7, i6);
              return Math.abs(r7.lng - i6.center.lng) > 180 && (r7.lng = i6.center.lng + 179.5 * Math.sign(r7.lng - i6.center.lng)), { easingCenter: r7, easingOffset: new t4.P(0, 0) };
            }
            handleMapControlsRollPitchBearingZoom(e7, i6) {
              const r7 = e7.around, o7 = i6.screenPointToLocation(r7);
              e7.bearingDelta && i6.setBearing(i6.bearing + e7.bearingDelta), e7.pitchDelta && i6.setPitch(i6.pitch + e7.pitchDelta), e7.rollDelta && i6.setRoll(i6.roll + e7.rollDelta);
              const a4 = i6.zoom;
              e7.zoomDelta && i6.setZoom(i6.zoom + e7.zoomDelta);
              const s5 = i6.zoom - a4;
              if (0 === s5) return;
              const n6 = t4.bn(i6.center.lng, o7.lng), l5 = n6 / (Math.abs(n6 / 180) + 1), c5 = t4.bn(i6.center.lat, o7.lat), h4 = i6.getRayDirectionFromPixel(r7), u4 = i6.cameraPosition, d4 = -1 * t4.aV(u4, h4), _4 = t4.bi();
              t4.aP(_4, u4, [h4[0] * d4, h4[1] * d4, h4[2] * d4]);
              const p4 = t4.bt(_4) - 1, m4 = Math.exp(0.5 * -Math.max(p4 - 0.3, 0)), f4 = ei(i6.worldSize, i6.center.lat) / Math.min(i6.width, i6.height), g4 = t4.bf(f4, 0.9, 0.5, 1, 0.25), v4 = (1 - t4.aI(-s5)) * Math.min(m4, g4), x4 = i6.center.lat, b5 = i6.zoom, y4 = new t4.Q(i6.center.lng + l5 * v4, t4.ae(i6.center.lat + c5 * v4, -85.051129, t4.aJ));
              i6.setLocationAtPoint(o7, r7);
              const w4 = i6.center, T5 = t4.bf(Math.abs(n6), 45, 85, 0, 1), P4 = t4.bf(f4, 0.75, 0.35, 0, 1), C4 = Math.pow(Math.max(T5, P4), 0.25), I4 = t4.bn(w4.lng, y4.lng), M5 = t4.bn(w4.lat, y4.lat);
              i6.setCenter(new t4.Q(w4.lng + I4 * C4, w4.lat + M5 * C4).wrap()), i6.setZoom(b5 + ri(x4, i6.center.lat));
            }
            handleMapControlsPan(e7, t5, i6) {
              if (!e7.panDelta) return;
              const r7 = t5.center.lat, o7 = t5.zoom;
              t5.setCenter(oi(e7.panDelta, t5).wrap()), t5.setZoom(o7 + ri(r7, t5.center.lat));
            }
            cameraForBoxAndBearing(e7, i6, r7, o7, a4) {
              const s5 = Lt(e7, i6, r7, o7, a4), n6 = i6.left / a4.width * 2 - 1, l5 = (a4.width - i6.right) / a4.width * 2 - 1, c5 = i6.top / a4.height * -2 + 1, h4 = (a4.height - i6.bottom) / a4.height * -2 + 1, u4 = t4.bn(r7.getWest(), r7.getEast()) < 0, d4 = u4 ? r7.getEast() : r7.getWest(), _4 = u4 ? r7.getWest() : r7.getEast(), p4 = Math.max(r7.getNorth(), r7.getSouth()), m4 = Math.min(r7.getNorth(), r7.getSouth()), f4 = d4 + 0.5 * t4.bn(d4, _4), g4 = p4 + 0.5 * t4.bn(p4, m4), v4 = a4.clone();
              v4.setCenter(s5.center), v4.setBearing(s5.bearing), v4.setPitch(0), v4.setRoll(0), v4.setZoom(s5.zoom);
              const x4 = v4.modelViewProjectionMatrix, b5 = [Jt(r7.getNorthWest()), Jt(r7.getNorthEast()), Jt(r7.getSouthWest()), Jt(r7.getSouthEast()), Jt(new t4.Q(_4, g4)), Jt(new t4.Q(d4, g4)), Jt(new t4.Q(f4, p4)), Jt(new t4.Q(f4, m4))], y4 = Jt(s5.center);
              let w4 = Number.POSITIVE_INFINITY;
              for (const e8 of b5) n6 < 0 && (w4 = _i.getLesserNonNegativeNonNull(w4, _i.solveVectorScale(e8, y4, x4, "x", n6))), l5 > 0 && (w4 = _i.getLesserNonNegativeNonNull(w4, _i.solveVectorScale(e8, y4, x4, "x", l5))), c5 > 0 && (w4 = _i.getLesserNonNegativeNonNull(w4, _i.solveVectorScale(e8, y4, x4, "y", c5))), h4 < 0 && (w4 = _i.getLesserNonNegativeNonNull(w4, _i.solveVectorScale(e8, y4, x4, "y", h4)));
              if (Number.isFinite(w4) && 0 !== w4) return s5.zoom = v4.zoom + t4.ab(w4), s5;
              zt();
            }
            handleJumpToCenterZoom(e7, i6) {
              const r7 = e7.center.lat, o7 = e7.getConstrained(i6.center ? t4.Q.convert(i6.center) : e7.center, e7.zoom).center;
              e7.setCenter(o7.wrap());
              const a4 = void 0 !== i6.zoom ? +i6.zoom : e7.zoom + ri(r7, o7.lat);
              e7.zoom !== a4 && e7.setZoom(a4);
            }
            handleEaseTo(e7, i6) {
              const r7 = e7.zoom, o7 = e7.center, a4 = e7.padding, s5 = { roll: e7.roll, pitch: e7.pitch, bearing: e7.bearing }, n6 = { roll: void 0 === i6.roll ? e7.roll : i6.roll, pitch: void 0 === i6.pitch ? e7.pitch : i6.pitch, bearing: void 0 === i6.bearing ? e7.bearing : i6.bearing }, l5 = void 0 !== i6.zoom, c5 = !e7.isPaddingEqual(i6.padding);
              let h4 = false;
              const u4 = i6.center ? t4.Q.convert(i6.center) : o7, d4 = e7.getConstrained(u4, r7).center;
              Ct(e7, d4);
              const _4 = e7.clone();
              _4.setCenter(d4), _4.setZoom(l5 ? +i6.zoom : r7 + ri(o7.lat, u4.lat)), _4.setBearing(i6.bearing);
              const p4 = new t4.P(t4.ae(e7.centerPoint.x + i6.offsetAsPoint.x, 0, e7.width), t4.ae(e7.centerPoint.y + i6.offsetAsPoint.y, 0, e7.height));
              _4.setLocationAtPoint(d4, p4);
              const m4 = (i6.offset && i6.offsetAsPoint.mag()) > 0 ? _4.center : d4, f4 = l5 ? +i6.zoom : r7 + ri(o7.lat, m4.lat), g4 = r7 + ri(o7.lat, 0), v4 = f4 + ri(m4.lat, 0), x4 = t4.bn(o7.lng, m4.lng), b5 = t4.bn(o7.lat, m4.lat), y4 = t4.aI(v4 - g4);
              return h4 = f4 !== r7, { easeFunc: (r8) => {
                if (t4.b6(s5, n6) || At({ startEulerAngles: s5, endEulerAngles: n6, tr: e7, k: r8, useSlerp: s5.roll != n6.roll }), c5 && e7.interpolatePadding(a4, i6.padding, r8), i6.around) t4.w("Easing around a point is not supported under globe projection."), e7.setLocationAtPoint(i6.around, i6.aroundPoint);
                else {
                  const t5 = v4 > g4 ? Math.min(2, y4) : Math.max(0.5, y4), i7 = Math.pow(t5, 1 - r8), a5 = si(o7, x4, b5, r8 * i7);
                  e7.setCenter(a5.wrap());
                }
                if (h4) {
                  const i7 = t4.B.number(g4, v4, r8) + ri(0, e7.center.lat);
                  e7.setZoom(i7);
                }
              }, isZooming: h4, elevationCenter: m4 };
            }
            handleFlyTo(e7, i6) {
              const r7 = void 0 !== i6.zoom, o7 = e7.center, a4 = e7.zoom, s5 = e7.padding, n6 = !e7.isPaddingEqual(i6.padding), l5 = e7.getConstrained(t4.Q.convert(i6.center || i6.locationAtOffset), a4).center, c5 = r7 ? +i6.zoom : e7.zoom + ri(e7.center.lat, l5.lat), h4 = e7.clone();
              h4.setCenter(l5), h4.setZoom(c5), h4.setBearing(i6.bearing);
              const u4 = new t4.P(t4.ae(e7.centerPoint.x + i6.offsetAsPoint.x, 0, e7.width), t4.ae(e7.centerPoint.y + i6.offsetAsPoint.y, 0, e7.height));
              h4.setLocationAtPoint(l5, u4);
              const d4 = h4.center;
              Ct(e7, d4);
              const _4 = function(e8, i7, r8) {
                const o8 = Jt(i7), a5 = Jt(r8), s6 = t4.aV(o8, a5), n7 = Math.acos(s6), l6 = Qt(e8);
                return n7 / (2 * Math.PI) * l6;
              }(e7, o7, d4), p4 = a4 + ri(o7.lat, 0), m4 = c5 + ri(d4.lat, 0), f4 = t4.aI(m4 - p4);
              let g4;
              if ("number" == typeof i6.minZoom) {
                const r8 = +i6.minZoom + ri(d4.lat, 0), o8 = Math.min(r8, p4, m4) + ri(0, d4.lat), a5 = e7.getConstrained(d4, o8).zoom + ri(d4.lat, 0);
                g4 = t4.aI(a5 - p4);
              }
              const v4 = t4.bn(o7.lng, d4.lng), x4 = t4.bn(o7.lat, d4.lat);
              return { easeFunc: (r8, a5, l6, h5) => {
                const u5 = si(o7, v4, x4, l6);
                n6 && e7.interpolatePadding(s5, i6.padding, r8);
                const _5 = 1 === r8 ? d4 : u5;
                e7.setCenter(_5.wrap());
                const m5 = p4 + t4.ab(a5);
                e7.setZoom(1 === r8 ? c5 : m5 + ri(0, _5.lat));
              }, scaleOfZoom: f4, targetCenter: d4, scaleOfMinZoom: g4, pixelPathLength: _4 };
            }
            static solveVectorScale(e7, t5, i6, r7, o7) {
              const a4 = "x" === r7 ? [i6[0], i6[4], i6[8], i6[12]] : [i6[1], i6[5], i6[9], i6[13]], s5 = [i6[3], i6[7], i6[11], i6[15]], n6 = e7[0] * a4[0] + e7[1] * a4[1] + e7[2] * a4[2], l5 = e7[0] * s5[0] + e7[1] * s5[1] + e7[2] * s5[2], c5 = t5[0] * a4[0] + t5[1] * a4[1] + t5[2] * a4[2], h4 = t5[0] * s5[0] + t5[1] * s5[1] + t5[2] * s5[2];
              return c5 + o7 * l5 === n6 + o7 * h4 || s5[3] * (n6 - c5) + a4[3] * (h4 - l5) + n6 * h4 == c5 * l5 ? null : (c5 + a4[3] - o7 * h4 - o7 * s5[3]) / (c5 - n6 - o7 * h4 + o7 * l5);
            }
            static getLesserNonNegativeNonNull(e7, t5) {
              return null !== t5 && t5 >= 0 && t5 < e7 ? t5 : e7;
            }
          }
          class pi {
            constructor(e7) {
              this._globe = e7, this._mercatorCameraHelper = new kt(), this._verticalPerspectiveCameraHelper = new _i();
            }
            get useGlobeControls() {
              return this._globe.useGlobeRendering;
            }
            get currentHelper() {
              return this.useGlobeControls ? this._verticalPerspectiveCameraHelper : this._mercatorCameraHelper;
            }
            handlePanInertia(e7, t5) {
              return this.currentHelper.handlePanInertia(e7, t5);
            }
            handleMapControlsRollPitchBearingZoom(e7, t5) {
              return this.currentHelper.handleMapControlsRollPitchBearingZoom(e7, t5);
            }
            handleMapControlsPan(e7, t5, i6) {
              this.currentHelper.handleMapControlsPan(e7, t5, i6);
            }
            cameraForBoxAndBearing(e7, t5, i6, r7, o7) {
              return this.currentHelper.cameraForBoxAndBearing(e7, t5, i6, r7, o7);
            }
            handleJumpToCenterZoom(e7, t5) {
              this.currentHelper.handleJumpToCenterZoom(e7, t5);
            }
            handleEaseTo(e7, t5) {
              return this.currentHelper.handleEaseTo(e7, t5);
            }
            handleFlyTo(e7, t5) {
              return this.currentHelper.handleFlyTo(e7, t5);
            }
          }
          const mi = (e7, i6) => t4.x(e7, i6 && i6.filter((e8) => "source.canvas" !== e8.identifier)), fi = t4.bu();
          class gi extends t4.E {
            constructor(e7, i6 = {}) {
              super(), this._rtlPluginLoaded = () => {
                for (const e8 in this.sourceCaches) {
                  const t5 = this.sourceCaches[e8].getSource().type;
                  "vector" !== t5 && "geojson" !== t5 || this.sourceCaches[e8].reload();
                }
              }, this.map = e7, this.dispatcher = new B4(F2(), e7._getMapId()), this.dispatcher.registerMessageHandler("GG", (e8, t5) => this.getGlyphs(e8, t5)), this.dispatcher.registerMessageHandler("GI", (e8, t5) => this.getImages(e8, t5)), this.imageManager = new b4(), this.imageManager.setEventedParent(this), this.glyphManager = new P3(e7._requestManager, i6.localIdeographFontFamily), this.lineAtlas = new R4(256, 512), this.crossTileSymbolIndex = new ht(), this._spritesImagesIds = {}, this._layers = {}, this._order = [], this.sourceCaches = {}, this.zoomHistory = new t4.bv(), this._loaded = false, this._availableImages = [], this._resetUpdates(), this.dispatcher.broadcast("SR", t4.bw()), oe().on(te, this._rtlPluginLoaded), this.on("data", (e8) => {
                if ("source" !== e8.dataType || "metadata" !== e8.sourceDataType) return;
                const t5 = this.sourceCaches[e8.sourceId];
                if (!t5) return;
                const i7 = t5.getSource();
                if (i7 && i7.vectorLayerIds) for (const e9 in this._layers) {
                  const t6 = this._layers[e9];
                  t6.source === i7.id && this._validateLayer(t6);
                }
              });
            }
            loadURL(e7, i6 = {}, r7) {
              this.fire(new t4.l("dataloading", { dataType: "style" })), i6.validate = "boolean" != typeof i6.validate || i6.validate;
              const o7 = this.map._requestManager.transformRequest(e7, "Style");
              this._loadStyleRequest = new AbortController();
              const a4 = this._loadStyleRequest;
              t4.j(o7, this._loadStyleRequest).then((e8) => {
                this._loadStyleRequest = null, this._load(e8.data, i6, r7);
              }).catch((e8) => {
                this._loadStyleRequest = null, e8 && !a4.signal.aborted && this.fire(new t4.k(e8));
              });
            }
            loadJSON(e7, i6 = {}, r7) {
              this.fire(new t4.l("dataloading", { dataType: "style" })), this._frameRequest = new AbortController(), s4.frameAsync(this._frameRequest).then(() => {
                this._frameRequest = null, i6.validate = false !== i6.validate, this._load(e7, i6, r7);
              }).catch(() => {
              });
            }
            loadEmpty() {
              this.fire(new t4.l("dataloading", { dataType: "style" })), this._load(fi, { validate: false });
            }
            _load(e7, i6, r7) {
              var o7, a4;
              const s5 = i6.transformStyle ? i6.transformStyle(r7, e7) : e7;
              if (!i6.validate || !mi(this, t4.y(s5))) {
                this._loaded = true, this.stylesheet = s5;
                for (const e8 in s5.sources) this.addSource(e8, s5.sources[e8], { validate: false });
                s5.sprite ? this._loadSprite(s5.sprite) : this.imageManager.setLoaded(true), this.glyphManager.setURL(s5.glyphs), this._createLayers(), this.light = new M4(this.stylesheet.light), this._setProjectionInternal((null === (o7 = this.stylesheet.projection) || void 0 === o7 ? void 0 : o7.type) || "mercator"), this.sky = new S4(this.stylesheet.sky), this.map.setTerrain(null !== (a4 = this.stylesheet.terrain) && void 0 !== a4 ? a4 : null), this.fire(new t4.l("data", { dataType: "style" })), this.fire(new t4.l("style.load"));
              }
            }
            _createLayers() {
              const e7 = t4.bx(this.stylesheet.layers);
              this.dispatcher.broadcast("SL", e7), this._order = e7.map((e8) => e8.id), this._layers = {}, this._serializedLayers = null;
              for (const i6 of e7) {
                const e8 = t4.by(i6);
                e8.setEventedParent(this, { layer: { id: i6.id } }), this._layers[i6.id] = e8;
              }
            }
            _loadSprite(e7, i6 = false, r7 = void 0) {
              let o7;
              this.imageManager.setLoaded(false), this._spriteRequest = new AbortController(), function(e8, i7, r8, o8) {
                return t4._(this, void 0, void 0, function* () {
                  const a4 = f3(e8), n6 = r8 > 1 ? "@2x" : "", l5 = {}, c5 = {};
                  for (const { id: e9, url: r9 } of a4) {
                    const a5 = i7.transformRequest(g3(r9, n6, ".json"), "SpriteJSON");
                    l5[e9] = t4.j(a5, o8);
                    const s5 = i7.transformRequest(g3(r9, n6, ".png"), "SpriteImage");
                    c5[e9] = p3.getImage(s5, o8);
                  }
                  return yield Promise.all([...Object.values(l5), ...Object.values(c5)]), function(e9, i8) {
                    return t4._(this, void 0, void 0, function* () {
                      const t5 = {};
                      for (const r9 in e9) {
                        t5[r9] = {};
                        const o9 = s4.getImageCanvasContext((yield i8[r9]).data), a5 = (yield e9[r9]).data;
                        for (const e10 in a5) {
                          const { width: i9, height: s5, x: n7, y: l6, sdf: c6, pixelRatio: h4, stretchX: u4, stretchY: d4, content: _4, textFitWidth: p4, textFitHeight: m4 } = a5[e10];
                          t5[r9][e10] = { data: null, pixelRatio: h4, sdf: c6, stretchX: u4, stretchY: d4, content: _4, textFitWidth: p4, textFitHeight: m4, spriteData: { width: i9, height: s5, x: n7, y: l6, context: o9 } };
                        }
                      }
                      return t5;
                    });
                  }(l5, c5);
                });
              }(e7, this.map._requestManager, this.map.getPixelRatio(), this._spriteRequest).then((e8) => {
                if (this._spriteRequest = null, e8) for (const t5 in e8) {
                  this._spritesImagesIds[t5] = [];
                  const r8 = this._spritesImagesIds[t5] ? this._spritesImagesIds[t5].filter((t6) => !(t6 in e8)) : [];
                  for (const e9 of r8) this.imageManager.removeImage(e9), this._changedImages[e9] = true;
                  for (const r9 in e8[t5]) {
                    const o8 = "default" === t5 ? r9 : `${t5}:${r9}`;
                    this._spritesImagesIds[t5].push(o8), o8 in this.imageManager.images ? this.imageManager.updateImage(o8, e8[t5][r9], false) : this.imageManager.addImage(o8, e8[t5][r9]), i6 && (this._changedImages[o8] = true);
                  }
                }
              }).catch((e8) => {
                this._spriteRequest = null, o7 = e8, this.fire(new t4.k(o7));
              }).finally(() => {
                this.imageManager.setLoaded(true), this._availableImages = this.imageManager.listImages(), i6 && (this._changed = true), this.dispatcher.broadcast("SI", this._availableImages), this.fire(new t4.l("data", { dataType: "style" })), r7 && r7(o7);
              });
            }
            _unloadSprite() {
              for (const e7 of Object.values(this._spritesImagesIds).flat()) this.imageManager.removeImage(e7), this._changedImages[e7] = true;
              this._spritesImagesIds = {}, this._availableImages = this.imageManager.listImages(), this._changed = true, this.dispatcher.broadcast("SI", this._availableImages), this.fire(new t4.l("data", { dataType: "style" }));
            }
            _validateLayer(e7) {
              const i6 = this.sourceCaches[e7.source];
              if (!i6) return;
              const r7 = e7.sourceLayer;
              if (!r7) return;
              const o7 = i6.getSource();
              ("geojson" === o7.type || o7.vectorLayerIds && -1 === o7.vectorLayerIds.indexOf(r7)) && this.fire(new t4.k(new Error(`Source layer "${r7}" does not exist on source "${o7.id}" as specified by style layer "${e7.id}".`)));
            }
            loaded() {
              if (!this._loaded) return false;
              if (Object.keys(this._updatedSources).length) return false;
              for (const e7 in this.sourceCaches) if (!this.sourceCaches[e7].loaded()) return false;
              return !!this.imageManager.isLoaded();
            }
            _serializeByIds(e7, i6 = false) {
              const r7 = this._serializedAllLayers();
              if (!e7 || 0 === e7.length) return Object.values(i6 ? t4.bz(r7) : r7);
              const o7 = [];
              for (const a4 of e7) if (r7[a4]) {
                const e8 = i6 ? t4.bz(r7[a4]) : r7[a4];
                o7.push(e8);
              }
              return o7;
            }
            _serializedAllLayers() {
              let e7 = this._serializedLayers;
              if (e7) return e7;
              e7 = this._serializedLayers = {};
              const t5 = Object.keys(this._layers);
              for (const i6 of t5) {
                const t6 = this._layers[i6];
                "custom" !== t6.type && (e7[i6] = t6.serialize());
              }
              return e7;
            }
            hasTransitions() {
              var e7, t5, i6;
              if (null === (e7 = this.light) || void 0 === e7 ? void 0 : e7.hasTransition()) return true;
              if (null === (t5 = this.sky) || void 0 === t5 ? void 0 : t5.hasTransition()) return true;
              if (null === (i6 = this.projection) || void 0 === i6 ? void 0 : i6.hasTransition()) return true;
              for (const e8 in this.sourceCaches) if (this.sourceCaches[e8].hasTransition()) return true;
              for (const e8 in this._layers) if (this._layers[e8].hasTransition()) return true;
              return false;
            }
            _checkLoaded() {
              if (!this._loaded) throw new Error("Style is not done loading.");
            }
            update(e7) {
              if (!this._loaded) return;
              const i6 = this._changed;
              if (i6) {
                const t5 = Object.keys(this._updatedLayers), i7 = Object.keys(this._removedLayers);
                (t5.length || i7.length) && this._updateWorkerLayers(t5, i7);
                for (const e8 in this._updatedSources) {
                  const t6 = this._updatedSources[e8];
                  if ("reload" === t6) this._reloadSource(e8);
                  else {
                    if ("clear" !== t6) throw new Error(`Invalid action ${t6}`);
                    this._clearSource(e8);
                  }
                }
                this._updateTilesForChangedImages(), this._updateTilesForChangedGlyphs();
                for (const t6 in this._updatedPaintProps) this._layers[t6].updateTransitions(e7);
                this.light.updateTransitions(e7), this.sky.updateTransitions(e7), this._resetUpdates();
              }
              const r7 = {};
              for (const e8 in this.sourceCaches) {
                const t5 = this.sourceCaches[e8];
                r7[e8] = t5.used, t5.used = false;
              }
              for (const t5 of this._order) {
                const i7 = this._layers[t5];
                i7.recalculate(e7, this._availableImages), !i7.isHidden(e7.zoom) && i7.source && (this.sourceCaches[i7.source].used = true);
              }
              for (const e8 in r7) {
                const i7 = this.sourceCaches[e8];
                !!r7[e8] != !!i7.used && i7.fire(new t4.l("data", { sourceDataType: "visibility", dataType: "source", sourceId: e8 }));
              }
              this.light.recalculate(e7), this.sky.recalculate(e7), this.projection.recalculate(e7), this.z = e7.zoom, i6 && this.fire(new t4.l("data", { dataType: "style" }));
            }
            _updateTilesForChangedImages() {
              const e7 = Object.keys(this._changedImages);
              if (e7.length) {
                for (const t5 in this.sourceCaches) this.sourceCaches[t5].reloadTilesForDependencies(["icons", "patterns"], e7);
                this._changedImages = {};
              }
            }
            _updateTilesForChangedGlyphs() {
              if (this._glyphsDidChange) {
                for (const e7 in this.sourceCaches) this.sourceCaches[e7].reloadTilesForDependencies(["glyphs"], [""]);
                this._glyphsDidChange = false;
              }
            }
            _updateWorkerLayers(e7, t5) {
              this.dispatcher.broadcast("UL", { layers: this._serializeByIds(e7, false), removedIds: t5 });
            }
            _resetUpdates() {
              this._changed = false, this._updatedLayers = {}, this._removedLayers = {}, this._updatedSources = {}, this._updatedPaintProps = {}, this._changedImages = {}, this._glyphsDidChange = false;
            }
            setState(e7, i6 = {}) {
              var r7;
              this._checkLoaded();
              const o7 = this.serialize();
              if (e7 = i6.transformStyle ? i6.transformStyle(o7, e7) : e7, (null === (r7 = i6.validate) || void 0 === r7 || r7) && mi(this, t4.y(e7))) return false;
              (e7 = t4.bz(e7)).layers = t4.bx(e7.layers);
              const a4 = t4.bA(o7, e7), s5 = this._getOperationsToPerform(a4);
              if (s5.unimplemented.length > 0) throw new Error(`Unimplemented: ${s5.unimplemented.join(", ")}.`);
              if (0 === s5.operations.length) return false;
              for (const e8 of s5.operations) e8();
              return this.stylesheet = e7, this._serializedLayers = null, true;
            }
            _getOperationsToPerform(e7) {
              const t5 = [], i6 = [];
              for (const r7 of e7) switch (r7.command) {
                case "setCenter":
                case "setZoom":
                case "setBearing":
                case "setPitch":
                case "setRoll":
                  continue;
                case "addLayer":
                  t5.push(() => this.addLayer.apply(this, r7.args));
                  break;
                case "removeLayer":
                  t5.push(() => this.removeLayer.apply(this, r7.args));
                  break;
                case "setPaintProperty":
                  t5.push(() => this.setPaintProperty.apply(this, r7.args));
                  break;
                case "setLayoutProperty":
                  t5.push(() => this.setLayoutProperty.apply(this, r7.args));
                  break;
                case "setFilter":
                  t5.push(() => this.setFilter.apply(this, r7.args));
                  break;
                case "addSource":
                  t5.push(() => this.addSource.apply(this, r7.args));
                  break;
                case "removeSource":
                  t5.push(() => this.removeSource.apply(this, r7.args));
                  break;
                case "setLayerZoomRange":
                  t5.push(() => this.setLayerZoomRange.apply(this, r7.args));
                  break;
                case "setLight":
                  t5.push(() => this.setLight.apply(this, r7.args));
                  break;
                case "setGeoJSONSourceData":
                  t5.push(() => this.setGeoJSONSourceData.apply(this, r7.args));
                  break;
                case "setGlyphs":
                  t5.push(() => this.setGlyphs.apply(this, r7.args));
                  break;
                case "setSprite":
                  t5.push(() => this.setSprite.apply(this, r7.args));
                  break;
                case "setTerrain":
                  t5.push(() => this.map.setTerrain.apply(this, r7.args));
                  break;
                case "setSky":
                  t5.push(() => this.setSky.apply(this, r7.args));
                  break;
                case "setProjection":
                  this.setProjection.apply(this, r7.args);
                  break;
                case "setTransition":
                  t5.push(() => {
                  });
                  break;
                default:
                  i6.push(r7.command);
              }
              return { operations: t5, unimplemented: i6 };
            }
            addImage(e7, i6) {
              if (this.getImage(e7)) return this.fire(new t4.k(new Error(`An image named "${e7}" already exists.`)));
              this.imageManager.addImage(e7, i6), this._afterImageUpdated(e7);
            }
            updateImage(e7, t5) {
              this.imageManager.updateImage(e7, t5);
            }
            getImage(e7) {
              return this.imageManager.getImage(e7);
            }
            removeImage(e7) {
              if (!this.getImage(e7)) return this.fire(new t4.k(new Error(`An image named "${e7}" does not exist.`)));
              this.imageManager.removeImage(e7), this._afterImageUpdated(e7);
            }
            _afterImageUpdated(e7) {
              this._availableImages = this.imageManager.listImages(), this._changedImages[e7] = true, this._changed = true, this.dispatcher.broadcast("SI", this._availableImages), this.fire(new t4.l("data", { dataType: "style" }));
            }
            listImages() {
              return this._checkLoaded(), this.imageManager.listImages();
            }
            addSource(e7, i6, r7 = {}) {
              if (this._checkLoaded(), void 0 !== this.sourceCaches[e7]) throw new Error(`Source "${e7}" already exists.`);
              if (!i6.type) throw new Error(`The type property must be defined, but only the following properties were given: ${Object.keys(i6).join(", ")}.`);
              if (["vector", "raster", "geojson", "video", "image"].indexOf(i6.type) >= 0 && this._validate(t4.y.source, `sources.${e7}`, i6, null, r7)) return;
              this.map && this.map._collectResourceTiming && (i6.collectResourceTiming = true);
              const o7 = this.sourceCaches[e7] = new de(e7, i6, this.dispatcher);
              o7.style = this, o7.setEventedParent(this, () => ({ isSourceLoaded: o7.loaded(), source: o7.serialize(), sourceId: e7 })), o7.onAdd(this.map), this._changed = true;
            }
            removeSource(e7) {
              if (this._checkLoaded(), void 0 === this.sourceCaches[e7]) throw new Error("There is no source with this ID");
              for (const i7 in this._layers) if (this._layers[i7].source === e7) return this.fire(new t4.k(new Error(`Source "${e7}" cannot be removed while layer "${i7}" is using it.`)));
              const i6 = this.sourceCaches[e7];
              delete this.sourceCaches[e7], delete this._updatedSources[e7], i6.fire(new t4.l("data", { sourceDataType: "metadata", dataType: "source", sourceId: e7 })), i6.setEventedParent(null), i6.onRemove(this.map), this._changed = true;
            }
            setGeoJSONSourceData(e7, t5) {
              if (this._checkLoaded(), void 0 === this.sourceCaches[e7]) throw new Error(`There is no source with this ID=${e7}`);
              const i6 = this.sourceCaches[e7].getSource();
              if ("geojson" !== i6.type) throw new Error(`geojsonSource.type is ${i6.type}, which is !== 'geojson`);
              i6.setData(t5), this._changed = true;
            }
            getSource(e7) {
              return this.sourceCaches[e7] && this.sourceCaches[e7].getSource();
            }
            addLayer(e7, i6, r7 = {}) {
              this._checkLoaded();
              const o7 = e7.id;
              if (this.getLayer(o7)) return void this.fire(new t4.k(new Error(`Layer "${o7}" already exists on this map.`)));
              let a4;
              if ("custom" === e7.type) {
                if (mi(this, t4.bB(e7))) return;
                a4 = t4.by(e7);
              } else {
                if ("source" in e7 && "object" == typeof e7.source && (this.addSource(o7, e7.source), e7 = t4.bz(e7), e7 = t4.e(e7, { source: o7 })), this._validate(t4.y.layer, `layers.${o7}`, e7, { arrayIndex: -1 }, r7)) return;
                a4 = t4.by(e7), this._validateLayer(a4), a4.setEventedParent(this, { layer: { id: o7 } });
              }
              const s5 = i6 ? this._order.indexOf(i6) : this._order.length;
              if (i6 && -1 === s5) this.fire(new t4.k(new Error(`Cannot add layer "${o7}" before non-existing layer "${i6}".`)));
              else {
                if (this._order.splice(s5, 0, o7), this._layerOrderChanged = true, this._layers[o7] = a4, this._removedLayers[o7] && a4.source && "custom" !== a4.type) {
                  const e8 = this._removedLayers[o7];
                  delete this._removedLayers[o7], e8.type !== a4.type ? this._updatedSources[a4.source] = "clear" : (this._updatedSources[a4.source] = "reload", this.sourceCaches[a4.source].pause());
                }
                this._updateLayer(a4), a4.onAdd && a4.onAdd(this.map);
              }
            }
            moveLayer(e7, i6) {
              if (this._checkLoaded(), this._changed = true, !this._layers[e7]) return void this.fire(new t4.k(new Error(`The layer '${e7}' does not exist in the map's style and cannot be moved.`)));
              if (e7 === i6) return;
              const r7 = this._order.indexOf(e7);
              this._order.splice(r7, 1);
              const o7 = i6 ? this._order.indexOf(i6) : this._order.length;
              i6 && -1 === o7 ? this.fire(new t4.k(new Error(`Cannot move layer "${e7}" before non-existing layer "${i6}".`))) : (this._order.splice(o7, 0, e7), this._layerOrderChanged = true);
            }
            removeLayer(e7) {
              this._checkLoaded();
              const i6 = this._layers[e7];
              if (!i6) return void this.fire(new t4.k(new Error(`Cannot remove non-existing layer "${e7}".`)));
              i6.setEventedParent(null);
              const r7 = this._order.indexOf(e7);
              this._order.splice(r7, 1), this._layerOrderChanged = true, this._changed = true, this._removedLayers[e7] = i6, delete this._layers[e7], this._serializedLayers && delete this._serializedLayers[e7], delete this._updatedLayers[e7], delete this._updatedPaintProps[e7], i6.onRemove && i6.onRemove(this.map);
            }
            getLayer(e7) {
              return this._layers[e7];
            }
            getLayersOrder() {
              return [...this._order];
            }
            hasLayer(e7) {
              return e7 in this._layers;
            }
            setLayerZoomRange(e7, i6, r7) {
              this._checkLoaded();
              const o7 = this.getLayer(e7);
              o7 ? o7.minzoom === i6 && o7.maxzoom === r7 || (null != i6 && (o7.minzoom = i6), null != r7 && (o7.maxzoom = r7), this._updateLayer(o7)) : this.fire(new t4.k(new Error(`Cannot set the zoom range of non-existing layer "${e7}".`)));
            }
            setFilter(e7, i6, r7 = {}) {
              this._checkLoaded();
              const o7 = this.getLayer(e7);
              if (o7) {
                if (!t4.bC(o7.filter, i6)) return null == i6 ? (o7.filter = void 0, void this._updateLayer(o7)) : void (this._validate(t4.y.filter, `layers.${o7.id}.filter`, i6, null, r7) || (o7.filter = t4.bz(i6), this._updateLayer(o7)));
              } else this.fire(new t4.k(new Error(`Cannot filter non-existing layer "${e7}".`)));
            }
            getFilter(e7) {
              return t4.bz(this.getLayer(e7).filter);
            }
            setLayoutProperty(e7, i6, r7, o7 = {}) {
              this._checkLoaded();
              const a4 = this.getLayer(e7);
              a4 ? t4.bC(a4.getLayoutProperty(i6), r7) || (a4.setLayoutProperty(i6, r7, o7), this._updateLayer(a4)) : this.fire(new t4.k(new Error(`Cannot style non-existing layer "${e7}".`)));
            }
            getLayoutProperty(e7, i6) {
              const r7 = this.getLayer(e7);
              if (r7) return r7.getLayoutProperty(i6);
              this.fire(new t4.k(new Error(`Cannot get style of non-existing layer "${e7}".`)));
            }
            setPaintProperty(e7, i6, r7, o7 = {}) {
              this._checkLoaded();
              const a4 = this.getLayer(e7);
              a4 ? t4.bC(a4.getPaintProperty(i6), r7) || (a4.setPaintProperty(i6, r7, o7) && this._updateLayer(a4), this._changed = true, this._updatedPaintProps[e7] = true, this._serializedLayers = null) : this.fire(new t4.k(new Error(`Cannot style non-existing layer "${e7}".`)));
            }
            getPaintProperty(e7, t5) {
              return this.getLayer(e7).getPaintProperty(t5);
            }
            setFeatureState(e7, i6) {
              this._checkLoaded();
              const r7 = e7.source, o7 = e7.sourceLayer, a4 = this.sourceCaches[r7];
              if (void 0 === a4) return void this.fire(new t4.k(new Error(`The source '${r7}' does not exist in the map's style.`)));
              const s5 = a4.getSource().type;
              "geojson" === s5 && o7 ? this.fire(new t4.k(new Error("GeoJSON sources cannot have a sourceLayer parameter."))) : "vector" !== s5 || o7 ? (void 0 === e7.id && this.fire(new t4.k(new Error("The feature id parameter must be provided."))), a4.setFeatureState(o7, e7.id, i6)) : this.fire(new t4.k(new Error("The sourceLayer parameter must be provided for vector source types.")));
            }
            removeFeatureState(e7, i6) {
              this._checkLoaded();
              const r7 = e7.source, o7 = this.sourceCaches[r7];
              if (void 0 === o7) return void this.fire(new t4.k(new Error(`The source '${r7}' does not exist in the map's style.`)));
              const a4 = o7.getSource().type, s5 = "vector" === a4 ? e7.sourceLayer : void 0;
              "vector" !== a4 || s5 ? i6 && "string" != typeof e7.id && "number" != typeof e7.id ? this.fire(new t4.k(new Error("A feature id is required to remove its specific state property."))) : o7.removeFeatureState(s5, e7.id, i6) : this.fire(new t4.k(new Error("The sourceLayer parameter must be provided for vector source types.")));
            }
            getFeatureState(e7) {
              this._checkLoaded();
              const i6 = e7.source, r7 = e7.sourceLayer, o7 = this.sourceCaches[i6];
              if (void 0 !== o7) return "vector" !== o7.getSource().type || r7 ? (void 0 === e7.id && this.fire(new t4.k(new Error("The feature id parameter must be provided."))), o7.getFeatureState(r7, e7.id)) : void this.fire(new t4.k(new Error("The sourceLayer parameter must be provided for vector source types.")));
              this.fire(new t4.k(new Error(`The source '${i6}' does not exist in the map's style.`)));
            }
            getTransition() {
              return t4.e({ duration: 300, delay: 0 }, this.stylesheet && this.stylesheet.transition);
            }
            serialize() {
              if (!this._loaded) return;
              const e7 = t4.bD(this.sourceCaches, (e8) => e8.serialize()), i6 = this._serializeByIds(this._order, true), r7 = this.map.getTerrain() || void 0, o7 = this.stylesheet;
              return t4.bE({ version: o7.version, name: o7.name, metadata: o7.metadata, light: o7.light, sky: o7.sky, center: o7.center, zoom: o7.zoom, bearing: o7.bearing, pitch: o7.pitch, sprite: o7.sprite, glyphs: o7.glyphs, transition: o7.transition, projection: o7.projection, sources: e7, layers: i6, terrain: r7 }, (e8) => void 0 !== e8);
            }
            _updateLayer(e7) {
              this._updatedLayers[e7.id] = true, e7.source && !this._updatedSources[e7.source] && "raster" !== this.sourceCaches[e7.source].getSource().type && (this._updatedSources[e7.source] = "reload", this.sourceCaches[e7.source].pause()), this._serializedLayers = null, this._changed = true;
            }
            _flattenAndSortRenderedFeatures(e7) {
              const t5 = (e8) => "fill-extrusion" === this._layers[e8].type, i6 = {}, r7 = [];
              for (let o8 = this._order.length - 1; o8 >= 0; o8--) {
                const a4 = this._order[o8];
                if (t5(a4)) {
                  i6[a4] = o8;
                  for (const t6 of e7) {
                    const e8 = t6[a4];
                    if (e8) for (const t7 of e8) r7.push(t7);
                  }
                }
              }
              r7.sort((e8, t6) => t6.intersectionZ - e8.intersectionZ);
              const o7 = [];
              for (let a4 = this._order.length - 1; a4 >= 0; a4--) {
                const s5 = this._order[a4];
                if (t5(s5)) for (let e8 = r7.length - 1; e8 >= 0; e8--) {
                  const t6 = r7[e8].feature;
                  if (i6[t6.layer.id] < a4) break;
                  o7.push(t6), r7.pop();
                }
                else for (const t6 of e7) {
                  const e8 = t6[s5];
                  if (e8) for (const t7 of e8) o7.push(t7.feature);
                }
              }
              return o7;
            }
            queryRenderedFeatures(e7, i6, r7) {
              i6 && i6.filter && this._validate(t4.y.filter, "queryRenderedFeatures.filter", i6.filter, null, i6);
              const o7 = {};
              if (i6 && i6.layers) {
                if (!(Array.isArray(i6.layers) || i6.layers instanceof Set)) return this.fire(new t4.k(new Error("parameters.layers must be an Array or a Set of strings"))), [];
                for (const e8 of i6.layers) {
                  const i7 = this._layers[e8];
                  if (!i7) return this.fire(new t4.k(new Error(`The layer '${e8}' does not exist in the map's style and cannot be queried for features.`))), [];
                  o7[i7.source] = true;
                }
              }
              const a4 = [];
              i6.availableImages = this._availableImages;
              const s5 = this._serializedAllLayers(), n6 = i6.layers instanceof Set ? i6.layers : Array.isArray(i6.layers) ? new Set(i6.layers) : null, l5 = Object.assign(Object.assign({}, i6), { layers: n6 });
              for (const t5 in this.sourceCaches) i6.layers && !o7[t5] || a4.push(Z2(this.sourceCaches[t5], this._layers, s5, e7, l5, r7, this.map.terrain ? (e8, t6, i7) => this.map.terrain.getElevation(e8, t6, i7) : void 0));
              return this.placement && a4.push(function(e8, t5, i7, r8, o8, a5, s6) {
                const n7 = {}, l6 = a5.queryRenderedSymbols(r8), c5 = [];
                for (const e9 of Object.keys(l6).map(Number)) c5.push(s6[e9]);
                c5.sort(N3);
                for (const i8 of c5) {
                  const r9 = i8.featureIndex.lookupSymbolFeatures(l6[i8.bucketInstanceId], t5, i8.bucketIndex, i8.sourceLayerIndex, o8.filter, o8.layers, o8.availableImages, e8);
                  for (const e9 in r9) {
                    const t6 = n7[e9] = n7[e9] || [], o9 = r9[e9];
                    o9.sort((e10, t7) => {
                      const r10 = i8.featureSortOrder;
                      if (r10) {
                        const i9 = r10.indexOf(e10.featureIndex);
                        return r10.indexOf(t7.featureIndex) - i9;
                      }
                      return t7.featureIndex - e10.featureIndex;
                    });
                    for (const e10 of o9) t6.push(e10);
                  }
                }
                return function(e9, t6, i8) {
                  for (const r9 in e9) for (const o9 of e9[r9]) G2(o9, i8[t6[r9].source]);
                  return e9;
                }(n7, e8, i7);
              }(this._layers, s5, this.sourceCaches, e7, l5, this.placement.collisionIndex, this.placement.retainedQueryData)), this._flattenAndSortRenderedFeatures(a4);
            }
            querySourceFeatures(e7, i6) {
              i6 && i6.filter && this._validate(t4.y.filter, "querySourceFeatures.filter", i6.filter, null, i6);
              const r7 = this.sourceCaches[e7];
              return r7 ? function(e8, t5) {
                const i7 = e8.getRenderableIds().map((t6) => e8.getTileByID(t6)), r8 = [], o7 = {};
                for (let e9 = 0; e9 < i7.length; e9++) {
                  const a4 = i7[e9], s5 = a4.tileID.canonical.key;
                  o7[s5] || (o7[s5] = true, a4.querySourceFeatures(r8, t5));
                }
                return r8;
              }(r7, i6) : [];
            }
            getLight() {
              return this.light.getLight();
            }
            setLight(e7, i6 = {}) {
              this._checkLoaded();
              const r7 = this.light.getLight();
              let o7 = false;
              for (const i7 in e7) if (!t4.bC(e7[i7], r7[i7])) {
                o7 = true;
                break;
              }
              if (!o7) return;
              const a4 = { now: s4.now(), transition: t4.e({ duration: 300, delay: 0 }, this.stylesheet.transition) };
              this.light.setLight(e7, i6), this.light.updateTransitions(a4);
            }
            getProjection() {
              var e7;
              return null === (e7 = this.stylesheet) || void 0 === e7 ? void 0 : e7.projection;
            }
            setProjection(e7) {
              if (this._checkLoaded(), this.projection) {
                if (this.projection.name === e7.type) return;
                this.projection.destroy(), delete this.projection;
              }
              this.stylesheet.projection = e7, this._setProjectionInternal(e7.type);
            }
            getSky() {
              var e7;
              return null === (e7 = this.stylesheet) || void 0 === e7 ? void 0 : e7.sky;
            }
            setSky(e7, i6 = {}) {
              this._checkLoaded();
              const r7 = this.getSky();
              let o7 = false;
              if (!e7 && !r7) return;
              if (e7 && !r7) o7 = true;
              else if (!e7 && r7) o7 = true;
              else for (const i7 in e7) if (!t4.bC(e7[i7], r7[i7])) {
                o7 = true;
                break;
              }
              if (!o7) return;
              const a4 = { now: s4.now(), transition: t4.e({ duration: 300, delay: 0 }, this.stylesheet.transition) };
              this.stylesheet.sky = e7, this.sky.setSky(e7, i6), this.sky.updateTransitions(a4);
            }
            _setProjectionInternal(e7) {
              const i6 = function(e8) {
                if (Array.isArray(e8)) {
                  const t5 = new Xt({ type: e8 });
                  return { projection: t5, transform: new di(), cameraHelper: new pi(t5) };
                }
                switch (e8) {
                  case "mercator":
                    return { projection: new vt(), transform: new Dt(), cameraHelper: new kt() };
                  case "globe": {
                    const e9 = new Xt({ type: ["interpolate", ["linear"], ["zoom"], 11, "vertical-perspective", 12, "mercator"] });
                    return { projection: e9, transform: new di(), cameraHelper: new pi(e9) };
                  }
                  case "vertical-perspective":
                    return { projection: new Ht(), transform: new ui(), cameraHelper: new _i() };
                  default:
                    return t4.w(`Unknown projection name: ${e8}. Falling back to mercator projection.`), { projection: new vt(), transform: new Dt(), cameraHelper: new kt() };
                }
              }(e7);
              this.projection = i6.projection, this.map.migrateProjection(i6.transform, i6.cameraHelper);
              for (const e8 in this.sourceCaches) this.sourceCaches[e8].reload();
            }
            _validate(e7, i6, r7, o7, a4 = {}) {
              return (!a4 || false !== a4.validate) && mi(this, e7.call(t4.y, t4.e({ key: i6, style: this.serialize(), value: r7, styleSpec: t4.v }, o7)));
            }
            _remove(e7 = true) {
              this._frameRequest && (this._frameRequest.abort(), this._frameRequest = null), this._loadStyleRequest && (this._loadStyleRequest.abort(), this._loadStyleRequest = null), this._spriteRequest && (this._spriteRequest.abort(), this._spriteRequest = null), oe().off(te, this._rtlPluginLoaded);
              for (const e8 in this._layers) this._layers[e8].setEventedParent(null);
              for (const e8 in this.sourceCaches) {
                const t5 = this.sourceCaches[e8];
                t5.setEventedParent(null), t5.onRemove(this.map);
              }
              this.imageManager.setEventedParent(null), this.setEventedParent(null), e7 && this.dispatcher.broadcast("RM", void 0), this.dispatcher.remove(e7);
            }
            _clearSource(e7) {
              this.sourceCaches[e7].clearTiles();
            }
            _reloadSource(e7) {
              this.sourceCaches[e7].resume(), this.sourceCaches[e7].reload();
            }
            _updateSources(e7) {
              for (const t5 in this.sourceCaches) this.sourceCaches[t5].update(e7, this.map.terrain);
            }
            _generateCollisionBoxes() {
              for (const e7 in this.sourceCaches) this._reloadSource(e7);
            }
            _updatePlacement(e7, t5, i6, r7, o7 = false) {
              let a4 = false, n6 = false;
              const l5 = {};
              for (const t6 of this._order) {
                const i7 = this._layers[t6];
                if ("symbol" !== i7.type) continue;
                if (!l5[i7.source]) {
                  const e8 = this.sourceCaches[i7.source];
                  l5[i7.source] = e8.getRenderableIds(true).map((t7) => e8.getTileByID(t7)).sort((e9, t7) => t7.tileID.overscaledZ - e9.tileID.overscaledZ || (e9.tileID.isLessThan(t7.tileID) ? -1 : 1));
                }
                const r8 = this.crossTileSymbolIndex.addLayer(i7, l5[i7.source], e7.center.lng);
                a4 = a4 || r8;
              }
              if (this.crossTileSymbolIndex.pruneUnusedLayers(this._order), ((o7 = o7 || this._layerOrderChanged || 0 === i6) || !this.pauseablePlacement || this.pauseablePlacement.isDone() && !this.placement.stillRecent(s4.now(), e7.zoom)) && (this.pauseablePlacement = new at(e7, this.map.terrain, this._order, o7, t5, i6, r7, this.placement), this._layerOrderChanged = false), this.pauseablePlacement.isDone() ? this.placement.setStale() : (this.pauseablePlacement.continuePlacement(this._order, this._layers, l5), this.pauseablePlacement.isDone() && (this.placement = this.pauseablePlacement.commit(s4.now()), n6 = true), a4 && this.pauseablePlacement.placement.setStale()), n6 || a4) for (const e8 of this._order) {
                const t6 = this._layers[e8];
                "symbol" === t6.type && this.placement.updateLayerOpacities(t6, l5[t6.source]);
              }
              return !this.pauseablePlacement.isDone() || this.placement.hasTransitions(s4.now());
            }
            _releaseSymbolFadeTiles() {
              for (const e7 in this.sourceCaches) this.sourceCaches[e7].releaseSymbolFadeTiles();
            }
            getImages(e7, i6) {
              return t4._(this, void 0, void 0, function* () {
                const e8 = yield this.imageManager.getImages(i6.icons);
                this._updateTilesForChangedImages();
                const t5 = this.sourceCaches[i6.source];
                return t5 && t5.setDependencies(i6.tileID.key, i6.type, i6.icons), e8;
              });
            }
            getGlyphs(e7, i6) {
              return t4._(this, void 0, void 0, function* () {
                const e8 = yield this.glyphManager.getGlyphs(i6.stacks), t5 = this.sourceCaches[i6.source];
                return t5 && t5.setDependencies(i6.tileID.key, i6.type, [""]), e8;
              });
            }
            getGlyphsUrl() {
              return this.stylesheet.glyphs || null;
            }
            setGlyphs(e7, i6 = {}) {
              this._checkLoaded(), e7 && this._validate(t4.y.glyphs, "glyphs", e7, null, i6) || (this._glyphsDidChange = true, this.stylesheet.glyphs = e7, this.glyphManager.entries = {}, this.glyphManager.setURL(e7));
            }
            addSprite(e7, i6, r7 = {}, o7) {
              this._checkLoaded();
              const a4 = [{ id: e7, url: i6 }], s5 = [...f3(this.stylesheet.sprite), ...a4];
              this._validate(t4.y.sprite, "sprite", s5, null, r7) || (this.stylesheet.sprite = s5, this._loadSprite(a4, true, o7));
            }
            removeSprite(e7) {
              this._checkLoaded();
              const i6 = f3(this.stylesheet.sprite);
              if (i6.find((t5) => t5.id === e7)) {
                if (this._spritesImagesIds[e7]) for (const t5 of this._spritesImagesIds[e7]) this.imageManager.removeImage(t5), this._changedImages[t5] = true;
                i6.splice(i6.findIndex((t5) => t5.id === e7), 1), this.stylesheet.sprite = i6.length > 0 ? i6 : void 0, delete this._spritesImagesIds[e7], this._availableImages = this.imageManager.listImages(), this._changed = true, this.dispatcher.broadcast("SI", this._availableImages), this.fire(new t4.l("data", { dataType: "style" }));
              } else this.fire(new t4.k(new Error(`Sprite "${e7}" doesn't exists on this map.`)));
            }
            getSprite() {
              return f3(this.stylesheet.sprite);
            }
            setSprite(e7, i6 = {}, r7) {
              this._checkLoaded(), e7 && this._validate(t4.y.sprite, "sprite", e7, null, i6) || (this.stylesheet.sprite = e7, e7 ? this._loadSprite(e7, true, r7) : (this._unloadSprite(), r7 && r7(null)));
            }
          }
          var vi = t4.aD([{ name: "a_pos", type: "Int16", components: 2 }, { name: "a_texture_pos", type: "Int16", components: 2 }]);
          class xi {
            constructor() {
              this.boundProgram = null, this.boundLayoutVertexBuffer = null, this.boundPaintVertexBuffers = [], this.boundIndexBuffer = null, this.boundVertexOffset = null, this.boundDynamicVertexBuffer = null, this.vao = null;
            }
            bind(e7, t5, i6, r7, o7, a4, s5, n6, l5) {
              this.context = e7;
              let c5 = this.boundPaintVertexBuffers.length !== r7.length;
              for (let e8 = 0; !c5 && e8 < r7.length; e8++) this.boundPaintVertexBuffers[e8] !== r7[e8] && (c5 = true);
              !this.vao || this.boundProgram !== t5 || this.boundLayoutVertexBuffer !== i6 || c5 || this.boundIndexBuffer !== o7 || this.boundVertexOffset !== a4 || this.boundDynamicVertexBuffer !== s5 || this.boundDynamicVertexBuffer2 !== n6 || this.boundDynamicVertexBuffer3 !== l5 ? this.freshBind(t5, i6, r7, o7, a4, s5, n6, l5) : (e7.bindVertexArray.set(this.vao), s5 && s5.bind(), o7 && o7.dynamicDraw && o7.bind(), n6 && n6.bind(), l5 && l5.bind());
            }
            freshBind(e7, t5, i6, r7, o7, a4, s5, n6) {
              const l5 = e7.numAttributes, c5 = this.context, h4 = c5.gl;
              this.vao && this.destroy(), this.vao = c5.createVertexArray(), c5.bindVertexArray.set(this.vao), this.boundProgram = e7, this.boundLayoutVertexBuffer = t5, this.boundPaintVertexBuffers = i6, this.boundIndexBuffer = r7, this.boundVertexOffset = o7, this.boundDynamicVertexBuffer = a4, this.boundDynamicVertexBuffer2 = s5, this.boundDynamicVertexBuffer3 = n6, t5.enableAttributes(h4, e7);
              for (const t6 of i6) t6.enableAttributes(h4, e7);
              a4 && a4.enableAttributes(h4, e7), s5 && s5.enableAttributes(h4, e7), n6 && n6.enableAttributes(h4, e7), t5.bind(), t5.setVertexAttribPointers(h4, e7, o7);
              for (const t6 of i6) t6.bind(), t6.setVertexAttribPointers(h4, e7, o7);
              a4 && (a4.bind(), a4.setVertexAttribPointers(h4, e7, o7)), r7 && r7.bind(), s5 && (s5.bind(), s5.setVertexAttribPointers(h4, e7, o7)), n6 && (n6.bind(), n6.setVertexAttribPointers(h4, e7, o7)), c5.currentNumAttributes = l5;
            }
            destroy() {
              this.vao && (this.context.deleteVertexArray(this.vao), this.vao = null);
            }
          }
          const bi = (e7, i6, r7, o7, a4) => ({ u_texture: 0, u_ele_delta: e7, u_fog_matrix: i6, u_fog_color: r7 ? r7.properties.get("fog-color") : t4.b7.white, u_fog_ground_blend: r7 ? r7.properties.get("fog-ground-blend") : 1, u_fog_ground_blend_opacity: a4 ? 0 : r7 ? r7.calculateFogBlendOpacity(o7) : 0, u_horizon_color: r7 ? r7.properties.get("horizon-color") : t4.b7.white, u_horizon_fog_blend: r7 ? r7.properties.get("horizon-fog-blend") : 1, u_is_globe_mode: a4 ? 1 : 0 }), yi = { mainMatrix: "u_projection_matrix", tileMercatorCoords: "u_projection_tile_mercator_coords", clippingPlane: "u_projection_clipping_plane", projectionTransition: "u_projection_transition", fallbackMatrix: "u_projection_fallback_matrix" };
          function wi(e7) {
            const t5 = [];
            for (let i6 = 0; i6 < e7.length; i6++) {
              if (null === e7[i6]) continue;
              const r7 = e7[i6].split(" ");
              t5.push(r7.pop());
            }
            return t5;
          }
          class Ti {
            constructor(e7, i6, r7, o7, a4, s5, n6, l5) {
              const c5 = e7.gl;
              this.program = c5.createProgram();
              const h4 = wi(i6.staticAttributes), u4 = r7 ? r7.getBinderAttributes() : [], d4 = h4.concat(u4), _4 = dt.prelude.staticUniforms ? wi(dt.prelude.staticUniforms) : [], p4 = n6.staticUniforms ? wi(n6.staticUniforms) : [], m4 = i6.staticUniforms ? wi(i6.staticUniforms) : [], f4 = r7 ? r7.getBinderUniforms() : [], g4 = _4.concat(p4).concat(m4).concat(f4), v4 = [];
              for (const e8 of g4) v4.indexOf(e8) < 0 && v4.push(e8);
              const x4 = r7 ? r7.defines() : [];
              Ut(c5) && x4.unshift("#version 300 es"), a4 && x4.push("#define OVERDRAW_INSPECTOR;"), s5 && x4.push("#define TERRAIN3D;"), l5 && x4.push(l5);
              let b5 = x4.concat(dt.prelude.fragmentSource, n6.fragmentSource, i6.fragmentSource).join("\n"), y4 = x4.concat(dt.prelude.vertexSource, n6.vertexSource, i6.vertexSource).join("\n");
              Ut(c5) || (b5 = function(e8) {
                return e8.replace(/\bin\s/g, "varying ").replace("out highp vec4 fragColor;", "").replace(/fragColor/g, "gl_FragColor").replace(/texture\(/g, "texture2D(");
              }(b5), y4 = function(e8) {
                return e8.replace(/\bin\s/g, "attribute ").replace(/\bout\s/g, "varying ").replace(/texture\(/g, "texture2D(");
              }(y4));
              const w4 = c5.createShader(c5.FRAGMENT_SHADER);
              if (c5.isContextLost()) return void (this.failedToCreate = true);
              if (c5.shaderSource(w4, b5), c5.compileShader(w4), !c5.getShaderParameter(w4, c5.COMPILE_STATUS)) throw new Error(`Could not compile fragment shader: ${c5.getShaderInfoLog(w4)}`);
              c5.attachShader(this.program, w4);
              const T5 = c5.createShader(c5.VERTEX_SHADER);
              if (c5.isContextLost()) return void (this.failedToCreate = true);
              if (c5.shaderSource(T5, y4), c5.compileShader(T5), !c5.getShaderParameter(T5, c5.COMPILE_STATUS)) throw new Error(`Could not compile vertex shader: ${c5.getShaderInfoLog(T5)}`);
              c5.attachShader(this.program, T5), this.attributes = {};
              const P4 = {};
              this.numAttributes = d4.length;
              for (let e8 = 0; e8 < this.numAttributes; e8++) d4[e8] && (c5.bindAttribLocation(this.program, e8, d4[e8]), this.attributes[d4[e8]] = e8);
              if (c5.linkProgram(this.program), !c5.getProgramParameter(this.program, c5.LINK_STATUS)) throw new Error(`Program failed to link: ${c5.getProgramInfoLog(this.program)}`);
              c5.deleteShader(T5), c5.deleteShader(w4);
              for (let e8 = 0; e8 < v4.length; e8++) {
                const t5 = v4[e8];
                if (t5 && !P4[t5]) {
                  const e9 = c5.getUniformLocation(this.program, t5);
                  e9 && (P4[t5] = e9);
                }
              }
              this.fixedUniforms = o7(e7, P4), this.terrainUniforms = ((e8, i7) => ({ u_depth: new t4.bF(e8, i7.u_depth), u_terrain: new t4.bF(e8, i7.u_terrain), u_terrain_dim: new t4.b8(e8, i7.u_terrain_dim), u_terrain_matrix: new t4.bH(e8, i7.u_terrain_matrix), u_terrain_unpack: new t4.bI(e8, i7.u_terrain_unpack), u_terrain_exaggeration: new t4.b8(e8, i7.u_terrain_exaggeration) }))(e7, P4), this.projectionUniforms = ((e8, i7) => ({ u_projection_matrix: new t4.bH(e8, i7.u_projection_matrix), u_projection_tile_mercator_coords: new t4.bI(e8, i7.u_projection_tile_mercator_coords), u_projection_clipping_plane: new t4.bI(e8, i7.u_projection_clipping_plane), u_projection_transition: new t4.b8(e8, i7.u_projection_transition), u_projection_fallback_matrix: new t4.bH(e8, i7.u_projection_fallback_matrix) }))(e7, P4), this.binderUniforms = r7 ? r7.getUniforms(e7, P4) : [];
            }
            draw(e7, t5, i6, r7, o7, a4, s5, n6, l5, c5, h4, u4, d4, _4, p4, m4, f4, g4, v4) {
              const x4 = e7.gl;
              if (this.failedToCreate) return;
              if (e7.program.set(this.program), e7.setDepthMode(i6), e7.setStencilMode(r7), e7.setColorMode(o7), e7.setCullFace(a4), n6) {
                e7.activeTexture.set(x4.TEXTURE2), x4.bindTexture(x4.TEXTURE_2D, n6.depthTexture), e7.activeTexture.set(x4.TEXTURE3), x4.bindTexture(x4.TEXTURE_2D, n6.texture);
                for (const e8 in this.terrainUniforms) this.terrainUniforms[e8].set(n6[e8]);
              }
              if (l5) for (const e8 in l5) this.projectionUniforms[yi[e8]].set(l5[e8]);
              if (s5) for (const e8 in this.fixedUniforms) this.fixedUniforms[e8].set(s5[e8]);
              m4 && m4.setUniforms(e7, this.binderUniforms, _4, { zoom: p4 });
              let b5 = 0;
              switch (t5) {
                case x4.LINES:
                  b5 = 2;
                  break;
                case x4.TRIANGLES:
                  b5 = 3;
                  break;
                case x4.LINE_STRIP:
                  b5 = 1;
              }
              for (const i7 of d4.get()) {
                const r8 = i7.vaos || (i7.vaos = {});
                (r8[c5] || (r8[c5] = new xi())).bind(e7, this, h4, m4 ? m4.getPaintVertexBuffers() : [], u4, i7.vertexOffset, f4, g4, v4), x4.drawElements(t5, i7.primitiveLength * b5, x4.UNSIGNED_SHORT, i7.primitiveOffset * b5 * 2);
              }
            }
          }
          function Pi(e7, i6, r7) {
            const o7 = 1 / t4.aw(r7, 1, i6.transform.tileZoom), a4 = Math.pow(2, r7.tileID.overscaledZ), s5 = r7.tileSize * Math.pow(2, i6.transform.tileZoom) / a4, n6 = s5 * (r7.tileID.canonical.x + r7.tileID.wrap * a4), l5 = s5 * r7.tileID.canonical.y;
            return { u_image: 0, u_texsize: r7.imageAtlasTexture.size, u_scale: [o7, e7.fromScale, e7.toScale], u_fade: e7.t, u_pixel_coord_upper: [n6 >> 16, l5 >> 16], u_pixel_coord_lower: [65535 & n6, 65535 & l5] };
          }
          const Ci = (e7, i6, r7, o7) => {
            const a4 = e7.style.light, s5 = a4.properties.get("position"), n6 = [s5.x, s5.y, s5.z], l5 = t4.bL();
            "viewport" === a4.properties.get("anchor") && t4.bM(l5, e7.transform.bearingInRadians), t4.bN(n6, n6, l5);
            const c5 = e7.transform.transformLightDirection(n6), h4 = a4.properties.get("color");
            return { u_lightpos: n6, u_lightpos_globe: c5, u_lightintensity: a4.properties.get("intensity"), u_lightcolor: [h4.r, h4.g, h4.b], u_vertical_gradient: +i6, u_opacity: r7, u_fill_translate: o7 };
          }, Ii = (e7, i6, r7, o7, a4, s5, n6) => t4.e(Ci(e7, i6, r7, o7), Pi(s5, e7, n6), { u_height_factor: -Math.pow(2, a4.overscaledZ) / n6.tileSize / 8 }), Mi = (e7, i6, r7, o7) => t4.e(Pi(i6, e7, r7), { u_fill_translate: o7 }), Ei = (e7, t5) => ({ u_world: e7, u_fill_translate: t5 }), Si = (e7, i6, r7, o7, a4) => t4.e(Mi(e7, i6, r7, a4), { u_world: o7 }), Ri = (e7, i6, r7, o7, a4) => {
            const s5 = e7.transform;
            let n6, l5, c5 = 0;
            if ("map" === r7.paint.get("circle-pitch-alignment")) {
              const e8 = t4.aw(i6, 1, s5.zoom);
              n6 = true, l5 = [e8, e8], c5 = e8 / (t4.Z * Math.pow(2, i6.tileID.overscaledZ)) * 2 * Math.PI * a4;
            } else n6 = false, l5 = s5.pixelsToGLUnits;
            return { u_camera_to_center_distance: s5.cameraToCenterDistance, u_scale_with_map: +("map" === r7.paint.get("circle-pitch-scale")), u_pitch_with_map: +n6, u_device_pixel_ratio: e7.pixelRatio, u_extrude_scale: l5, u_globe_extrude_scale: c5, u_translate: o7 };
          }, Di = (e7) => ({ u_pixel_extrude_scale: [1 / e7.width, 1 / e7.height] }), zi = (e7) => ({ u_viewport_size: [e7.width, e7.height] }), Ai = (e7, t5 = 1) => ({ u_color: e7, u_overlay: 0, u_overlay_scale: t5 }), Li = (e7, i6, r7, o7) => {
            const a4 = t4.aw(e7, 1, i6) / (t4.Z * Math.pow(2, e7.tileID.overscaledZ)) * 2 * Math.PI * o7;
            return { u_extrude_scale: t4.aw(e7, 1, i6), u_intensity: r7, u_globe_extrude_scale: a4 };
          }, ki = (e7, i6, r7, o7) => {
            const a4 = t4.K();
            t4.bO(a4, 0, e7.width, e7.height, 0, 0, 1);
            const s5 = e7.context.gl;
            return { u_matrix: a4, u_world: [s5.drawingBufferWidth, s5.drawingBufferHeight], u_image: r7, u_color_ramp: o7, u_opacity: i6.paint.get("heatmap-opacity") };
          }, Fi = (e7, t5, i6) => {
            const r7 = i6.paint.get("hillshade-shadow-color"), o7 = i6.paint.get("hillshade-highlight-color"), a4 = i6.paint.get("hillshade-accent-color");
            let s5 = i6.paint.get("hillshade-illumination-direction") * (Math.PI / 180);
            return "viewport" === i6.paint.get("hillshade-illumination-anchor") && (s5 += e7.transform.bearingInRadians), { u_image: 0, u_latrange: Oi(0, t5.tileID), u_light: [i6.paint.get("hillshade-exaggeration"), s5], u_shadow: r7, u_highlight: o7, u_accent: a4 };
          }, Bi = (e7, i6) => {
            const r7 = i6.stride, o7 = t4.K();
            return t4.bO(o7, 0, t4.Z, -8192, 0, 0, 1), t4.L(o7, o7, [0, -8192, 0]), { u_matrix: o7, u_image: 1, u_dimension: [r7, r7], u_zoom: e7.overscaledZ, u_unpack: i6.getUnpackVector() };
          };
          function Oi(e7, i6) {
            const r7 = Math.pow(2, i6.canonical.z), o7 = i6.canonical.y;
            return [new t4.$(0, o7 / r7).toLngLat().lat, new t4.$(0, (o7 + 1) / r7).toLngLat().lat];
          }
          const ji = (e7, i6, r7, o7) => {
            const a4 = e7.transform;
            return { u_translation: Vi(e7, i6, r7), u_ratio: o7 / t4.aw(i6, 1, a4.zoom), u_device_pixel_ratio: e7.pixelRatio, u_units_to_pixels: [1 / a4.pixelsToGLUnits[0], 1 / a4.pixelsToGLUnits[1]] };
          }, Zi = (e7, i6, r7, o7, a4) => t4.e(ji(e7, i6, r7, o7), { u_image: 0, u_image_height: a4 }), Ni = (e7, i6, r7, o7, a4) => {
            const s5 = e7.transform, n6 = Ui(i6, s5);
            return { u_translation: Vi(e7, i6, r7), u_texsize: i6.imageAtlasTexture.size, u_ratio: o7 / t4.aw(i6, 1, s5.zoom), u_device_pixel_ratio: e7.pixelRatio, u_image: 0, u_scale: [n6, a4.fromScale, a4.toScale], u_fade: a4.t, u_units_to_pixels: [1 / s5.pixelsToGLUnits[0], 1 / s5.pixelsToGLUnits[1]] };
          }, Gi = (e7, i6, r7, o7, a4, s5) => {
            const n6 = e7.lineAtlas, l5 = Ui(i6, e7.transform), c5 = "round" === r7.layout.get("line-cap"), h4 = n6.getDash(a4.from, c5), u4 = n6.getDash(a4.to, c5), d4 = h4.width * s5.fromScale, _4 = u4.width * s5.toScale;
            return t4.e(ji(e7, i6, r7, o7), { u_patternscale_a: [l5 / d4, -h4.height / 2], u_patternscale_b: [l5 / _4, -u4.height / 2], u_sdfgamma: n6.width / (256 * Math.min(d4, _4) * e7.pixelRatio) / 2, u_image: 0, u_tex_y_a: h4.y, u_tex_y_b: u4.y, u_mix: s5.t });
          };
          function Ui(e7, i6) {
            return 1 / t4.aw(e7, 1, i6.tileZoom);
          }
          function Vi(e7, i6, r7) {
            return t4.ax(e7.transform, i6, r7.paint.get("line-translate"), r7.paint.get("line-translate-anchor"));
          }
          const qi = (e7, t5, i6, r7, o7) => {
            return { u_tl_parent: e7, u_scale_parent: t5, u_buffer_scale: 1, u_fade_t: i6.mix, u_opacity: i6.opacity * r7.paint.get("raster-opacity"), u_image0: 0, u_image1: 1, u_brightness_low: r7.paint.get("raster-brightness-min"), u_brightness_high: r7.paint.get("raster-brightness-max"), u_saturation_factor: (s5 = r7.paint.get("raster-saturation"), s5 > 0 ? 1 - 1 / (1.001 - s5) : -s5), u_contrast_factor: (a4 = r7.paint.get("raster-contrast"), a4 > 0 ? 1 / (1 - a4) : 1 + a4), u_spin_weights: Wi(r7.paint.get("raster-hue-rotate")), u_coords_top: [o7[0].x, o7[0].y, o7[1].x, o7[1].y], u_coords_bottom: [o7[3].x, o7[3].y, o7[2].x, o7[2].y] };
            var a4, s5;
          };
          function Wi(e7) {
            e7 *= Math.PI / 180;
            const t5 = Math.sin(e7), i6 = Math.cos(e7);
            return [(2 * i6 + 1) / 3, (-Math.sqrt(3) * t5 - i6 + 1) / 3, (Math.sqrt(3) * t5 - i6 + 1) / 3];
          }
          const $i = (e7, t5, i6, r7, o7, a4, s5, n6, l5, c5, h4, u4, d4) => {
            const _4 = s5.transform;
            return { u_is_size_zoom_constant: +("constant" === e7 || "source" === e7), u_is_size_feature_constant: +("constant" === e7 || "camera" === e7), u_size_t: t5 ? t5.uSizeT : 0, u_size: t5 ? t5.uSize : 0, u_camera_to_center_distance: _4.cameraToCenterDistance, u_pitch: _4.pitch / 360 * 2 * Math.PI, u_rotate_symbol: +i6, u_aspect_ratio: _4.width / _4.height, u_fade_change: s5.options.fadeDuration ? s5.symbolFadeChange : 1, u_label_plane_matrix: n6, u_coord_matrix: l5, u_is_text: +h4, u_pitch_with_map: +r7, u_is_along_line: o7, u_is_variable_anchor: a4, u_texsize: u4, u_texture: 0, u_translation: c5, u_pitched_scale: d4 };
          }, Hi = (e7, i6, r7, o7, a4, s5, n6, l5, c5, h4, u4, d4, _4, p4) => {
            const m4 = n6.transform;
            return t4.e($i(e7, i6, r7, o7, a4, s5, n6, l5, c5, h4, u4, d4, p4), { u_gamma_scale: o7 ? Math.cos(m4.pitch * Math.PI / 180) * m4.cameraToCenterDistance : 1, u_device_pixel_ratio: n6.pixelRatio, u_is_halo: 1 });
          }, Ki = (e7, i6, r7, o7, a4, s5, n6, l5, c5, h4, u4, d4, _4) => t4.e(Hi(e7, i6, r7, o7, a4, s5, n6, l5, c5, h4, true, u4, 0, _4), { u_texsize_icon: d4, u_texture_icon: 1 }), Xi = (e7, t5) => ({ u_opacity: e7, u_color: t5 }), Qi = (e7, i6, r7, o7, a4) => t4.e(function(e8, i7, r8, o8) {
            const a5 = r8.imageManager.getPattern(e8.from.toString()), s5 = r8.imageManager.getPattern(e8.to.toString()), { width: n6, height: l5 } = r8.imageManager.getPixelSize(), c5 = Math.pow(2, o8.tileID.overscaledZ), h4 = o8.tileSize * Math.pow(2, r8.transform.tileZoom) / c5, u4 = h4 * (o8.tileID.canonical.x + o8.tileID.wrap * c5), d4 = h4 * o8.tileID.canonical.y;
            return { u_image: 0, u_pattern_tl_a: a5.tl, u_pattern_br_a: a5.br, u_pattern_tl_b: s5.tl, u_pattern_br_b: s5.br, u_texsize: [n6, l5], u_mix: i7.t, u_pattern_size_a: a5.displaySize, u_pattern_size_b: s5.displaySize, u_scale_a: i7.fromScale, u_scale_b: i7.toScale, u_tile_units_to_pixels: 1 / t4.aw(o8, 1, r8.transform.tileZoom), u_pixel_coord_upper: [u4 >> 16, d4 >> 16], u_pixel_coord_lower: [65535 & u4, 65535 & d4] };
          }(r7, a4, i6, o7), { u_opacity: e7 }), Yi = (e7, t5) => {
          }, Ji = { fillExtrusion: (e7, i6) => ({ u_lightpos: new t4.bJ(e7, i6.u_lightpos), u_lightpos_globe: new t4.bJ(e7, i6.u_lightpos_globe), u_lightintensity: new t4.b8(e7, i6.u_lightintensity), u_lightcolor: new t4.bJ(e7, i6.u_lightcolor), u_vertical_gradient: new t4.b8(e7, i6.u_vertical_gradient), u_opacity: new t4.b8(e7, i6.u_opacity), u_fill_translate: new t4.bK(e7, i6.u_fill_translate) }), fillExtrusionPattern: (e7, i6) => ({ u_lightpos: new t4.bJ(e7, i6.u_lightpos), u_lightpos_globe: new t4.bJ(e7, i6.u_lightpos_globe), u_lightintensity: new t4.b8(e7, i6.u_lightintensity), u_lightcolor: new t4.bJ(e7, i6.u_lightcolor), u_vertical_gradient: new t4.b8(e7, i6.u_vertical_gradient), u_height_factor: new t4.b8(e7, i6.u_height_factor), u_opacity: new t4.b8(e7, i6.u_opacity), u_fill_translate: new t4.bK(e7, i6.u_fill_translate), u_image: new t4.bF(e7, i6.u_image), u_texsize: new t4.bK(e7, i6.u_texsize), u_pixel_coord_upper: new t4.bK(e7, i6.u_pixel_coord_upper), u_pixel_coord_lower: new t4.bK(e7, i6.u_pixel_coord_lower), u_scale: new t4.bJ(e7, i6.u_scale), u_fade: new t4.b8(e7, i6.u_fade) }), fill: (e7, i6) => ({ u_fill_translate: new t4.bK(e7, i6.u_fill_translate) }), fillPattern: (e7, i6) => ({ u_image: new t4.bF(e7, i6.u_image), u_texsize: new t4.bK(e7, i6.u_texsize), u_pixel_coord_upper: new t4.bK(e7, i6.u_pixel_coord_upper), u_pixel_coord_lower: new t4.bK(e7, i6.u_pixel_coord_lower), u_scale: new t4.bJ(e7, i6.u_scale), u_fade: new t4.b8(e7, i6.u_fade), u_fill_translate: new t4.bK(e7, i6.u_fill_translate) }), fillOutline: (e7, i6) => ({ u_world: new t4.bK(e7, i6.u_world), u_fill_translate: new t4.bK(e7, i6.u_fill_translate) }), fillOutlinePattern: (e7, i6) => ({ u_world: new t4.bK(e7, i6.u_world), u_image: new t4.bF(e7, i6.u_image), u_texsize: new t4.bK(e7, i6.u_texsize), u_pixel_coord_upper: new t4.bK(e7, i6.u_pixel_coord_upper), u_pixel_coord_lower: new t4.bK(e7, i6.u_pixel_coord_lower), u_scale: new t4.bJ(e7, i6.u_scale), u_fade: new t4.b8(e7, i6.u_fade), u_fill_translate: new t4.bK(e7, i6.u_fill_translate) }), circle: (e7, i6) => ({ u_camera_to_center_distance: new t4.b8(e7, i6.u_camera_to_center_distance), u_scale_with_map: new t4.bF(e7, i6.u_scale_with_map), u_pitch_with_map: new t4.bF(e7, i6.u_pitch_with_map), u_extrude_scale: new t4.bK(e7, i6.u_extrude_scale), u_device_pixel_ratio: new t4.b8(e7, i6.u_device_pixel_ratio), u_globe_extrude_scale: new t4.b8(e7, i6.u_globe_extrude_scale), u_translate: new t4.bK(e7, i6.u_translate) }), collisionBox: (e7, i6) => ({ u_pixel_extrude_scale: new t4.bK(e7, i6.u_pixel_extrude_scale) }), collisionCircle: (e7, i6) => ({ u_viewport_size: new t4.bK(e7, i6.u_viewport_size) }), debug: (e7, i6) => ({ u_color: new t4.bG(e7, i6.u_color), u_overlay: new t4.bF(e7, i6.u_overlay), u_overlay_scale: new t4.b8(e7, i6.u_overlay_scale) }), depth: Yi, clippingMask: Yi, heatmap: (e7, i6) => ({ u_extrude_scale: new t4.b8(e7, i6.u_extrude_scale), u_intensity: new t4.b8(e7, i6.u_intensity), u_globe_extrude_scale: new t4.b8(e7, i6.u_globe_extrude_scale) }), heatmapTexture: (e7, i6) => ({ u_matrix: new t4.bH(e7, i6.u_matrix), u_world: new t4.bK(e7, i6.u_world), u_image: new t4.bF(e7, i6.u_image), u_color_ramp: new t4.bF(e7, i6.u_color_ramp), u_opacity: new t4.b8(e7, i6.u_opacity) }), hillshade: (e7, i6) => ({ u_image: new t4.bF(e7, i6.u_image), u_latrange: new t4.bK(e7, i6.u_latrange), u_light: new t4.bK(e7, i6.u_light), u_shadow: new t4.bG(e7, i6.u_shadow), u_highlight: new t4.bG(e7, i6.u_highlight), u_accent: new t4.bG(e7, i6.u_accent) }), hillshadePrepare: (e7, i6) => ({ u_matrix: new t4.bH(e7, i6.u_matrix), u_image: new t4.bF(e7, i6.u_image), u_dimension: new t4.bK(e7, i6.u_dimension), u_zoom: new t4.b8(e7, i6.u_zoom), u_unpack: new t4.bI(e7, i6.u_unpack) }), line: (e7, i6) => ({ u_translation: new t4.bK(e7, i6.u_translation), u_ratio: new t4.b8(e7, i6.u_ratio), u_device_pixel_ratio: new t4.b8(e7, i6.u_device_pixel_ratio), u_units_to_pixels: new t4.bK(e7, i6.u_units_to_pixels) }), lineGradient: (e7, i6) => ({ u_translation: new t4.bK(e7, i6.u_translation), u_ratio: new t4.b8(e7, i6.u_ratio), u_device_pixel_ratio: new t4.b8(e7, i6.u_device_pixel_ratio), u_units_to_pixels: new t4.bK(e7, i6.u_units_to_pixels), u_image: new t4.bF(e7, i6.u_image), u_image_height: new t4.b8(e7, i6.u_image_height) }), linePattern: (e7, i6) => ({ u_translation: new t4.bK(e7, i6.u_translation), u_texsize: new t4.bK(e7, i6.u_texsize), u_ratio: new t4.b8(e7, i6.u_ratio), u_device_pixel_ratio: new t4.b8(e7, i6.u_device_pixel_ratio), u_image: new t4.bF(e7, i6.u_image), u_units_to_pixels: new t4.bK(e7, i6.u_units_to_pixels), u_scale: new t4.bJ(e7, i6.u_scale), u_fade: new t4.b8(e7, i6.u_fade) }), lineSDF: (e7, i6) => ({ u_translation: new t4.bK(e7, i6.u_translation), u_ratio: new t4.b8(e7, i6.u_ratio), u_device_pixel_ratio: new t4.b8(e7, i6.u_device_pixel_ratio), u_units_to_pixels: new t4.bK(e7, i6.u_units_to_pixels), u_patternscale_a: new t4.bK(e7, i6.u_patternscale_a), u_patternscale_b: new t4.bK(e7, i6.u_patternscale_b), u_sdfgamma: new t4.b8(e7, i6.u_sdfgamma), u_image: new t4.bF(e7, i6.u_image), u_tex_y_a: new t4.b8(e7, i6.u_tex_y_a), u_tex_y_b: new t4.b8(e7, i6.u_tex_y_b), u_mix: new t4.b8(e7, i6.u_mix) }), raster: (e7, i6) => ({ u_tl_parent: new t4.bK(e7, i6.u_tl_parent), u_scale_parent: new t4.b8(e7, i6.u_scale_parent), u_buffer_scale: new t4.b8(e7, i6.u_buffer_scale), u_fade_t: new t4.b8(e7, i6.u_fade_t), u_opacity: new t4.b8(e7, i6.u_opacity), u_image0: new t4.bF(e7, i6.u_image0), u_image1: new t4.bF(e7, i6.u_image1), u_brightness_low: new t4.b8(e7, i6.u_brightness_low), u_brightness_high: new t4.b8(e7, i6.u_brightness_high), u_saturation_factor: new t4.b8(e7, i6.u_saturation_factor), u_contrast_factor: new t4.b8(e7, i6.u_contrast_factor), u_spin_weights: new t4.bJ(e7, i6.u_spin_weights), u_coords_top: new t4.bI(e7, i6.u_coords_top), u_coords_bottom: new t4.bI(e7, i6.u_coords_bottom) }), symbolIcon: (e7, i6) => ({ u_is_size_zoom_constant: new t4.bF(e7, i6.u_is_size_zoom_constant), u_is_size_feature_constant: new t4.bF(e7, i6.u_is_size_feature_constant), u_size_t: new t4.b8(e7, i6.u_size_t), u_size: new t4.b8(e7, i6.u_size), u_camera_to_center_distance: new t4.b8(e7, i6.u_camera_to_center_distance), u_pitch: new t4.b8(e7, i6.u_pitch), u_rotate_symbol: new t4.bF(e7, i6.u_rotate_symbol), u_aspect_ratio: new t4.b8(e7, i6.u_aspect_ratio), u_fade_change: new t4.b8(e7, i6.u_fade_change), u_label_plane_matrix: new t4.bH(e7, i6.u_label_plane_matrix), u_coord_matrix: new t4.bH(e7, i6.u_coord_matrix), u_is_text: new t4.bF(e7, i6.u_is_text), u_pitch_with_map: new t4.bF(e7, i6.u_pitch_with_map), u_is_along_line: new t4.bF(e7, i6.u_is_along_line), u_is_variable_anchor: new t4.bF(e7, i6.u_is_variable_anchor), u_texsize: new t4.bK(e7, i6.u_texsize), u_texture: new t4.bF(e7, i6.u_texture), u_translation: new t4.bK(e7, i6.u_translation), u_pitched_scale: new t4.b8(e7, i6.u_pitched_scale) }), symbolSDF: (e7, i6) => ({ u_is_size_zoom_constant: new t4.bF(e7, i6.u_is_size_zoom_constant), u_is_size_feature_constant: new t4.bF(e7, i6.u_is_size_feature_constant), u_size_t: new t4.b8(e7, i6.u_size_t), u_size: new t4.b8(e7, i6.u_size), u_camera_to_center_distance: new t4.b8(e7, i6.u_camera_to_center_distance), u_pitch: new t4.b8(e7, i6.u_pitch), u_rotate_symbol: new t4.bF(e7, i6.u_rotate_symbol), u_aspect_ratio: new t4.b8(e7, i6.u_aspect_ratio), u_fade_change: new t4.b8(e7, i6.u_fade_change), u_label_plane_matrix: new t4.bH(e7, i6.u_label_plane_matrix), u_coord_matrix: new t4.bH(e7, i6.u_coord_matrix), u_is_text: new t4.bF(e7, i6.u_is_text), u_pitch_with_map: new t4.bF(e7, i6.u_pitch_with_map), u_is_along_line: new t4.bF(e7, i6.u_is_along_line), u_is_variable_anchor: new t4.bF(e7, i6.u_is_variable_anchor), u_texsize: new t4.bK(e7, i6.u_texsize), u_texture: new t4.bF(e7, i6.u_texture), u_gamma_scale: new t4.b8(e7, i6.u_gamma_scale), u_device_pixel_ratio: new t4.b8(e7, i6.u_device_pixel_ratio), u_is_halo: new t4.bF(e7, i6.u_is_halo), u_translation: new t4.bK(e7, i6.u_translation), u_pitched_scale: new t4.b8(e7, i6.u_pitched_scale) }), symbolTextAndIcon: (e7, i6) => ({ u_is_size_zoom_constant: new t4.bF(e7, i6.u_is_size_zoom_constant), u_is_size_feature_constant: new t4.bF(e7, i6.u_is_size_feature_constant), u_size_t: new t4.b8(e7, i6.u_size_t), u_size: new t4.b8(e7, i6.u_size), u_camera_to_center_distance: new t4.b8(e7, i6.u_camera_to_center_distance), u_pitch: new t4.b8(e7, i6.u_pitch), u_rotate_symbol: new t4.bF(e7, i6.u_rotate_symbol), u_aspect_ratio: new t4.b8(e7, i6.u_aspect_ratio), u_fade_change: new t4.b8(e7, i6.u_fade_change), u_label_plane_matrix: new t4.bH(e7, i6.u_label_plane_matrix), u_coord_matrix: new t4.bH(e7, i6.u_coord_matrix), u_is_text: new t4.bF(e7, i6.u_is_text), u_pitch_with_map: new t4.bF(e7, i6.u_pitch_with_map), u_is_along_line: new t4.bF(e7, i6.u_is_along_line), u_is_variable_anchor: new t4.bF(e7, i6.u_is_variable_anchor), u_texsize: new t4.bK(e7, i6.u_texsize), u_texsize_icon: new t4.bK(e7, i6.u_texsize_icon), u_texture: new t4.bF(e7, i6.u_texture), u_texture_icon: new t4.bF(e7, i6.u_texture_icon), u_gamma_scale: new t4.b8(e7, i6.u_gamma_scale), u_device_pixel_ratio: new t4.b8(e7, i6.u_device_pixel_ratio), u_is_halo: new t4.bF(e7, i6.u_is_halo), u_translation: new t4.bK(e7, i6.u_translation), u_pitched_scale: new t4.b8(e7, i6.u_pitched_scale) }), background: (e7, i6) => ({ u_opacity: new t4.b8(e7, i6.u_opacity), u_color: new t4.bG(e7, i6.u_color) }), backgroundPattern: (e7, i6) => ({ u_opacity: new t4.b8(e7, i6.u_opacity), u_image: new t4.bF(e7, i6.u_image), u_pattern_tl_a: new t4.bK(e7, i6.u_pattern_tl_a), u_pattern_br_a: new t4.bK(e7, i6.u_pattern_br_a), u_pattern_tl_b: new t4.bK(e7, i6.u_pattern_tl_b), u_pattern_br_b: new t4.bK(e7, i6.u_pattern_br_b), u_texsize: new t4.bK(e7, i6.u_texsize), u_mix: new t4.b8(e7, i6.u_mix), u_pattern_size_a: new t4.bK(e7, i6.u_pattern_size_a), u_pattern_size_b: new t4.bK(e7, i6.u_pattern_size_b), u_scale_a: new t4.b8(e7, i6.u_scale_a), u_scale_b: new t4.b8(e7, i6.u_scale_b), u_pixel_coord_upper: new t4.bK(e7, i6.u_pixel_coord_upper), u_pixel_coord_lower: new t4.bK(e7, i6.u_pixel_coord_lower), u_tile_units_to_pixels: new t4.b8(e7, i6.u_tile_units_to_pixels) }), terrain: (e7, i6) => ({ u_texture: new t4.bF(e7, i6.u_texture), u_ele_delta: new t4.b8(e7, i6.u_ele_delta), u_fog_matrix: new t4.bH(e7, i6.u_fog_matrix), u_fog_color: new t4.bG(e7, i6.u_fog_color), u_fog_ground_blend: new t4.b8(e7, i6.u_fog_ground_blend), u_fog_ground_blend_opacity: new t4.b8(e7, i6.u_fog_ground_blend_opacity), u_horizon_color: new t4.bG(e7, i6.u_horizon_color), u_horizon_fog_blend: new t4.b8(e7, i6.u_horizon_fog_blend), u_is_globe_mode: new t4.b8(e7, i6.u_is_globe_mode) }), terrainDepth: (e7, i6) => ({ u_ele_delta: new t4.b8(e7, i6.u_ele_delta) }), terrainCoords: (e7, i6) => ({ u_texture: new t4.bF(e7, i6.u_texture), u_terrain_coords_id: new t4.b8(e7, i6.u_terrain_coords_id), u_ele_delta: new t4.b8(e7, i6.u_ele_delta) }), projectionErrorMeasurement: (e7, i6) => ({ u_input: new t4.b8(e7, i6.u_input), u_output_expected: new t4.b8(e7, i6.u_output_expected) }), atmosphere: (e7, i6) => ({ u_sun_pos: new t4.bJ(e7, i6.u_sun_pos), u_atmosphere_blend: new t4.b8(e7, i6.u_atmosphere_blend), u_globe_position: new t4.bJ(e7, i6.u_globe_position), u_globe_radius: new t4.b8(e7, i6.u_globe_radius), u_inv_proj_matrix: new t4.bH(e7, i6.u_inv_proj_matrix) }), sky: (e7, i6) => ({ u_sky_color: new t4.bG(e7, i6.u_sky_color), u_horizon_color: new t4.bG(e7, i6.u_horizon_color), u_horizon: new t4.bK(e7, i6.u_horizon), u_horizon_normal: new t4.bK(e7, i6.u_horizon_normal), u_sky_horizon_blend: new t4.b8(e7, i6.u_sky_horizon_blend), u_sky_blend: new t4.b8(e7, i6.u_sky_blend) }) };
          class er {
            constructor(e7, t5, i6) {
              this.context = e7;
              const r7 = e7.gl;
              this.buffer = r7.createBuffer(), this.dynamicDraw = Boolean(i6), this.context.unbindVAO(), e7.bindElementBuffer.set(this.buffer), r7.bufferData(r7.ELEMENT_ARRAY_BUFFER, t5.arrayBuffer, this.dynamicDraw ? r7.DYNAMIC_DRAW : r7.STATIC_DRAW), this.dynamicDraw || delete t5.arrayBuffer;
            }
            bind() {
              this.context.bindElementBuffer.set(this.buffer);
            }
            updateData(e7) {
              const t5 = this.context.gl;
              if (!this.dynamicDraw) throw new Error("Attempted to update data while not in dynamic mode.");
              this.context.unbindVAO(), this.bind(), t5.bufferSubData(t5.ELEMENT_ARRAY_BUFFER, 0, e7.arrayBuffer);
            }
            destroy() {
              this.buffer && (this.context.gl.deleteBuffer(this.buffer), delete this.buffer);
            }
          }
          const tr = { Int8: "BYTE", Uint8: "UNSIGNED_BYTE", Int16: "SHORT", Uint16: "UNSIGNED_SHORT", Int32: "INT", Uint32: "UNSIGNED_INT", Float32: "FLOAT" };
          class ir {
            constructor(e7, t5, i6, r7) {
              this.length = t5.length, this.attributes = i6, this.itemSize = t5.bytesPerElement, this.dynamicDraw = r7, this.context = e7;
              const o7 = e7.gl;
              this.buffer = o7.createBuffer(), e7.bindVertexBuffer.set(this.buffer), o7.bufferData(o7.ARRAY_BUFFER, t5.arrayBuffer, this.dynamicDraw ? o7.DYNAMIC_DRAW : o7.STATIC_DRAW), this.dynamicDraw || delete t5.arrayBuffer;
            }
            bind() {
              this.context.bindVertexBuffer.set(this.buffer);
            }
            updateData(e7) {
              if (e7.length !== this.length) throw new Error(`Length of new data is ${e7.length}, which doesn't match current length of ${this.length}`);
              const t5 = this.context.gl;
              this.bind(), t5.bufferSubData(t5.ARRAY_BUFFER, 0, e7.arrayBuffer);
            }
            enableAttributes(e7, t5) {
              for (let i6 = 0; i6 < this.attributes.length; i6++) {
                const r7 = t5.attributes[this.attributes[i6].name];
                void 0 !== r7 && e7.enableVertexAttribArray(r7);
              }
            }
            setVertexAttribPointers(e7, t5, i6) {
              for (let r7 = 0; r7 < this.attributes.length; r7++) {
                const o7 = this.attributes[r7], a4 = t5.attributes[o7.name];
                void 0 !== a4 && e7.vertexAttribPointer(a4, o7.components, e7[tr[o7.type]], false, this.itemSize, o7.offset + this.itemSize * (i6 || 0));
              }
            }
            destroy() {
              this.buffer && (this.context.gl.deleteBuffer(this.buffer), delete this.buffer);
            }
          }
          class rr {
            constructor(e7) {
              this.gl = e7.gl, this.default = this.getDefault(), this.current = this.default, this.dirty = false;
            }
            get() {
              return this.current;
            }
            set(e7) {
            }
            getDefault() {
              return this.default;
            }
            setDefault() {
              this.set(this.default);
            }
          }
          class or extends rr {
            getDefault() {
              return t4.b7.transparent;
            }
            set(e7) {
              const t5 = this.current;
              (e7.r !== t5.r || e7.g !== t5.g || e7.b !== t5.b || e7.a !== t5.a || this.dirty) && (this.gl.clearColor(e7.r, e7.g, e7.b, e7.a), this.current = e7, this.dirty = false);
            }
          }
          class ar extends rr {
            getDefault() {
              return 1;
            }
            set(e7) {
              (e7 !== this.current || this.dirty) && (this.gl.clearDepth(e7), this.current = e7, this.dirty = false);
            }
          }
          class sr extends rr {
            getDefault() {
              return 0;
            }
            set(e7) {
              (e7 !== this.current || this.dirty) && (this.gl.clearStencil(e7), this.current = e7, this.dirty = false);
            }
          }
          class nr extends rr {
            getDefault() {
              return [true, true, true, true];
            }
            set(e7) {
              const t5 = this.current;
              (e7[0] !== t5[0] || e7[1] !== t5[1] || e7[2] !== t5[2] || e7[3] !== t5[3] || this.dirty) && (this.gl.colorMask(e7[0], e7[1], e7[2], e7[3]), this.current = e7, this.dirty = false);
            }
          }
          class lr extends rr {
            getDefault() {
              return true;
            }
            set(e7) {
              (e7 !== this.current || this.dirty) && (this.gl.depthMask(e7), this.current = e7, this.dirty = false);
            }
          }
          class cr extends rr {
            getDefault() {
              return 255;
            }
            set(e7) {
              (e7 !== this.current || this.dirty) && (this.gl.stencilMask(e7), this.current = e7, this.dirty = false);
            }
          }
          class hr extends rr {
            getDefault() {
              return { func: this.gl.ALWAYS, ref: 0, mask: 255 };
            }
            set(e7) {
              const t5 = this.current;
              (e7.func !== t5.func || e7.ref !== t5.ref || e7.mask !== t5.mask || this.dirty) && (this.gl.stencilFunc(e7.func, e7.ref, e7.mask), this.current = e7, this.dirty = false);
            }
          }
          class ur extends rr {
            getDefault() {
              const e7 = this.gl;
              return [e7.KEEP, e7.KEEP, e7.KEEP];
            }
            set(e7) {
              const t5 = this.current;
              (e7[0] !== t5[0] || e7[1] !== t5[1] || e7[2] !== t5[2] || this.dirty) && (this.gl.stencilOp(e7[0], e7[1], e7[2]), this.current = e7, this.dirty = false);
            }
          }
          class dr extends rr {
            getDefault() {
              return false;
            }
            set(e7) {
              if (e7 === this.current && !this.dirty) return;
              const t5 = this.gl;
              e7 ? t5.enable(t5.STENCIL_TEST) : t5.disable(t5.STENCIL_TEST), this.current = e7, this.dirty = false;
            }
          }
          class _r extends rr {
            getDefault() {
              return [0, 1];
            }
            set(e7) {
              const t5 = this.current;
              (e7[0] !== t5[0] || e7[1] !== t5[1] || this.dirty) && (this.gl.depthRange(e7[0], e7[1]), this.current = e7, this.dirty = false);
            }
          }
          class pr extends rr {
            getDefault() {
              return false;
            }
            set(e7) {
              if (e7 === this.current && !this.dirty) return;
              const t5 = this.gl;
              e7 ? t5.enable(t5.DEPTH_TEST) : t5.disable(t5.DEPTH_TEST), this.current = e7, this.dirty = false;
            }
          }
          class mr extends rr {
            getDefault() {
              return this.gl.LESS;
            }
            set(e7) {
              (e7 !== this.current || this.dirty) && (this.gl.depthFunc(e7), this.current = e7, this.dirty = false);
            }
          }
          class fr extends rr {
            getDefault() {
              return false;
            }
            set(e7) {
              if (e7 === this.current && !this.dirty) return;
              const t5 = this.gl;
              e7 ? t5.enable(t5.BLEND) : t5.disable(t5.BLEND), this.current = e7, this.dirty = false;
            }
          }
          class gr extends rr {
            getDefault() {
              const e7 = this.gl;
              return [e7.ONE, e7.ZERO];
            }
            set(e7) {
              const t5 = this.current;
              (e7[0] !== t5[0] || e7[1] !== t5[1] || this.dirty) && (this.gl.blendFunc(e7[0], e7[1]), this.current = e7, this.dirty = false);
            }
          }
          class vr extends rr {
            getDefault() {
              return t4.b7.transparent;
            }
            set(e7) {
              const t5 = this.current;
              (e7.r !== t5.r || e7.g !== t5.g || e7.b !== t5.b || e7.a !== t5.a || this.dirty) && (this.gl.blendColor(e7.r, e7.g, e7.b, e7.a), this.current = e7, this.dirty = false);
            }
          }
          class xr extends rr {
            getDefault() {
              return this.gl.FUNC_ADD;
            }
            set(e7) {
              (e7 !== this.current || this.dirty) && (this.gl.blendEquation(e7), this.current = e7, this.dirty = false);
            }
          }
          class br extends rr {
            getDefault() {
              return false;
            }
            set(e7) {
              if (e7 === this.current && !this.dirty) return;
              const t5 = this.gl;
              e7 ? t5.enable(t5.CULL_FACE) : t5.disable(t5.CULL_FACE), this.current = e7, this.dirty = false;
            }
          }
          class yr extends rr {
            getDefault() {
              return this.gl.BACK;
            }
            set(e7) {
              (e7 !== this.current || this.dirty) && (this.gl.cullFace(e7), this.current = e7, this.dirty = false);
            }
          }
          class wr extends rr {
            getDefault() {
              return this.gl.CCW;
            }
            set(e7) {
              (e7 !== this.current || this.dirty) && (this.gl.frontFace(e7), this.current = e7, this.dirty = false);
            }
          }
          class Tr extends rr {
            getDefault() {
              return null;
            }
            set(e7) {
              (e7 !== this.current || this.dirty) && (this.gl.useProgram(e7), this.current = e7, this.dirty = false);
            }
          }
          class Pr extends rr {
            getDefault() {
              return this.gl.TEXTURE0;
            }
            set(e7) {
              (e7 !== this.current || this.dirty) && (this.gl.activeTexture(e7), this.current = e7, this.dirty = false);
            }
          }
          class Cr extends rr {
            getDefault() {
              const e7 = this.gl;
              return [0, 0, e7.drawingBufferWidth, e7.drawingBufferHeight];
            }
            set(e7) {
              const t5 = this.current;
              (e7[0] !== t5[0] || e7[1] !== t5[1] || e7[2] !== t5[2] || e7[3] !== t5[3] || this.dirty) && (this.gl.viewport(e7[0], e7[1], e7[2], e7[3]), this.current = e7, this.dirty = false);
            }
          }
          class Ir extends rr {
            getDefault() {
              return null;
            }
            set(e7) {
              if (e7 === this.current && !this.dirty) return;
              const t5 = this.gl;
              t5.bindFramebuffer(t5.FRAMEBUFFER, e7), this.current = e7, this.dirty = false;
            }
          }
          class Mr extends rr {
            getDefault() {
              return null;
            }
            set(e7) {
              if (e7 === this.current && !this.dirty) return;
              const t5 = this.gl;
              t5.bindRenderbuffer(t5.RENDERBUFFER, e7), this.current = e7, this.dirty = false;
            }
          }
          class Er extends rr {
            getDefault() {
              return null;
            }
            set(e7) {
              if (e7 === this.current && !this.dirty) return;
              const t5 = this.gl;
              t5.bindTexture(t5.TEXTURE_2D, e7), this.current = e7, this.dirty = false;
            }
          }
          class Sr extends rr {
            getDefault() {
              return null;
            }
            set(e7) {
              if (e7 === this.current && !this.dirty) return;
              const t5 = this.gl;
              t5.bindBuffer(t5.ARRAY_BUFFER, e7), this.current = e7, this.dirty = false;
            }
          }
          class Rr extends rr {
            getDefault() {
              return null;
            }
            set(e7) {
              const t5 = this.gl;
              t5.bindBuffer(t5.ELEMENT_ARRAY_BUFFER, e7), this.current = e7, this.dirty = false;
            }
          }
          class Dr extends rr {
            getDefault() {
              return null;
            }
            set(e7) {
              var t5;
              if (e7 === this.current && !this.dirty) return;
              const i6 = this.gl;
              Ut(i6) ? i6.bindVertexArray(e7) : null === (t5 = i6.getExtension("OES_vertex_array_object")) || void 0 === t5 || t5.bindVertexArrayOES(e7), this.current = e7, this.dirty = false;
            }
          }
          class zr extends rr {
            getDefault() {
              return 4;
            }
            set(e7) {
              if (e7 === this.current && !this.dirty) return;
              const t5 = this.gl;
              t5.pixelStorei(t5.UNPACK_ALIGNMENT, e7), this.current = e7, this.dirty = false;
            }
          }
          class Ar extends rr {
            getDefault() {
              return false;
            }
            set(e7) {
              if (e7 === this.current && !this.dirty) return;
              const t5 = this.gl;
              t5.pixelStorei(t5.UNPACK_PREMULTIPLY_ALPHA_WEBGL, e7), this.current = e7, this.dirty = false;
            }
          }
          class Lr extends rr {
            getDefault() {
              return false;
            }
            set(e7) {
              if (e7 === this.current && !this.dirty) return;
              const t5 = this.gl;
              t5.pixelStorei(t5.UNPACK_FLIP_Y_WEBGL, e7), this.current = e7, this.dirty = false;
            }
          }
          class kr extends rr {
            constructor(e7, t5) {
              super(e7), this.context = e7, this.parent = t5;
            }
            getDefault() {
              return null;
            }
          }
          class Fr extends kr {
            setDirty() {
              this.dirty = true;
            }
            set(e7) {
              if (e7 === this.current && !this.dirty) return;
              this.context.bindFramebuffer.set(this.parent);
              const t5 = this.gl;
              t5.framebufferTexture2D(t5.FRAMEBUFFER, t5.COLOR_ATTACHMENT0, t5.TEXTURE_2D, e7, 0), this.current = e7, this.dirty = false;
            }
          }
          class Br extends kr {
            set(e7) {
              if (e7 === this.current && !this.dirty) return;
              this.context.bindFramebuffer.set(this.parent);
              const t5 = this.gl;
              t5.framebufferRenderbuffer(t5.FRAMEBUFFER, t5.DEPTH_ATTACHMENT, t5.RENDERBUFFER, e7), this.current = e7, this.dirty = false;
            }
          }
          class Or extends kr {
            set(e7) {
              if (e7 === this.current && !this.dirty) return;
              this.context.bindFramebuffer.set(this.parent);
              const t5 = this.gl;
              t5.framebufferRenderbuffer(t5.FRAMEBUFFER, t5.DEPTH_STENCIL_ATTACHMENT, t5.RENDERBUFFER, e7), this.current = e7, this.dirty = false;
            }
          }
          const jr = "Framebuffer is not complete";
          class Zr {
            constructor(e7, t5, i6, r7, o7) {
              this.context = e7, this.width = t5, this.height = i6;
              const a4 = e7.gl, s5 = this.framebuffer = a4.createFramebuffer();
              if (this.colorAttachment = new Fr(e7, s5), r7) this.depthAttachment = o7 ? new Or(e7, s5) : new Br(e7, s5);
              else if (o7) throw new Error("Stencil cannot be set without depth");
              if (a4.checkFramebufferStatus(a4.FRAMEBUFFER) !== a4.FRAMEBUFFER_COMPLETE) throw new Error(jr);
            }
            destroy() {
              const e7 = this.context.gl, t5 = this.colorAttachment.get();
              if (t5 && e7.deleteTexture(t5), this.depthAttachment) {
                const t6 = this.depthAttachment.get();
                t6 && e7.deleteRenderbuffer(t6);
              }
              e7.deleteFramebuffer(this.framebuffer);
            }
          }
          class Nr {
            constructor(e7) {
              var t5, i6;
              if (this.gl = e7, this.clearColor = new or(this), this.clearDepth = new ar(this), this.clearStencil = new sr(this), this.colorMask = new nr(this), this.depthMask = new lr(this), this.stencilMask = new cr(this), this.stencilFunc = new hr(this), this.stencilOp = new ur(this), this.stencilTest = new dr(this), this.depthRange = new _r(this), this.depthTest = new pr(this), this.depthFunc = new mr(this), this.blend = new fr(this), this.blendFunc = new gr(this), this.blendColor = new vr(this), this.blendEquation = new xr(this), this.cullFace = new br(this), this.cullFaceSide = new yr(this), this.frontFace = new wr(this), this.program = new Tr(this), this.activeTexture = new Pr(this), this.viewport = new Cr(this), this.bindFramebuffer = new Ir(this), this.bindRenderbuffer = new Mr(this), this.bindTexture = new Er(this), this.bindVertexBuffer = new Sr(this), this.bindElementBuffer = new Rr(this), this.bindVertexArray = new Dr(this), this.pixelStoreUnpack = new zr(this), this.pixelStoreUnpackPremultiplyAlpha = new Ar(this), this.pixelStoreUnpackFlipY = new Lr(this), this.extTextureFilterAnisotropic = e7.getExtension("EXT_texture_filter_anisotropic") || e7.getExtension("MOZ_EXT_texture_filter_anisotropic") || e7.getExtension("WEBKIT_EXT_texture_filter_anisotropic"), this.extTextureFilterAnisotropic && (this.extTextureFilterAnisotropicMax = e7.getParameter(this.extTextureFilterAnisotropic.MAX_TEXTURE_MAX_ANISOTROPY_EXT)), this.maxTextureSize = e7.getParameter(e7.MAX_TEXTURE_SIZE), Ut(e7)) {
                this.HALF_FLOAT = e7.HALF_FLOAT;
                const r7 = e7.getExtension("EXT_color_buffer_half_float");
                this.RGBA16F = null !== (t5 = e7.RGBA16F) && void 0 !== t5 ? t5 : null == r7 ? void 0 : r7.RGBA16F_EXT, this.RGB16F = null !== (i6 = e7.RGB16F) && void 0 !== i6 ? i6 : null == r7 ? void 0 : r7.RGB16F_EXT, e7.getExtension("EXT_color_buffer_float");
              } else {
                e7.getExtension("EXT_color_buffer_half_float"), e7.getExtension("OES_texture_half_float_linear");
                const t6 = e7.getExtension("OES_texture_half_float");
                this.HALF_FLOAT = null == t6 ? void 0 : t6.HALF_FLOAT_OES;
              }
            }
            setDefault() {
              this.unbindVAO(), this.clearColor.setDefault(), this.clearDepth.setDefault(), this.clearStencil.setDefault(), this.colorMask.setDefault(), this.depthMask.setDefault(), this.stencilMask.setDefault(), this.stencilFunc.setDefault(), this.stencilOp.setDefault(), this.stencilTest.setDefault(), this.depthRange.setDefault(), this.depthTest.setDefault(), this.depthFunc.setDefault(), this.blend.setDefault(), this.blendFunc.setDefault(), this.blendColor.setDefault(), this.blendEquation.setDefault(), this.cullFace.setDefault(), this.cullFaceSide.setDefault(), this.frontFace.setDefault(), this.program.setDefault(), this.activeTexture.setDefault(), this.bindFramebuffer.setDefault(), this.pixelStoreUnpack.setDefault(), this.pixelStoreUnpackPremultiplyAlpha.setDefault(), this.pixelStoreUnpackFlipY.setDefault();
            }
            setDirty() {
              this.clearColor.dirty = true, this.clearDepth.dirty = true, this.clearStencil.dirty = true, this.colorMask.dirty = true, this.depthMask.dirty = true, this.stencilMask.dirty = true, this.stencilFunc.dirty = true, this.stencilOp.dirty = true, this.stencilTest.dirty = true, this.depthRange.dirty = true, this.depthTest.dirty = true, this.depthFunc.dirty = true, this.blend.dirty = true, this.blendFunc.dirty = true, this.blendColor.dirty = true, this.blendEquation.dirty = true, this.cullFace.dirty = true, this.cullFaceSide.dirty = true, this.frontFace.dirty = true, this.program.dirty = true, this.activeTexture.dirty = true, this.viewport.dirty = true, this.bindFramebuffer.dirty = true, this.bindRenderbuffer.dirty = true, this.bindTexture.dirty = true, this.bindVertexBuffer.dirty = true, this.bindElementBuffer.dirty = true, this.bindVertexArray.dirty = true, this.pixelStoreUnpack.dirty = true, this.pixelStoreUnpackPremultiplyAlpha.dirty = true, this.pixelStoreUnpackFlipY.dirty = true;
            }
            createIndexBuffer(e7, t5) {
              return new er(this, e7, t5);
            }
            createVertexBuffer(e7, t5, i6) {
              return new ir(this, e7, t5, i6);
            }
            createRenderbuffer(e7, t5, i6) {
              const r7 = this.gl, o7 = r7.createRenderbuffer();
              return this.bindRenderbuffer.set(o7), r7.renderbufferStorage(r7.RENDERBUFFER, e7, t5, i6), this.bindRenderbuffer.set(null), o7;
            }
            createFramebuffer(e7, t5, i6, r7) {
              return new Zr(this, e7, t5, i6, r7);
            }
            clear({ color: e7, depth: t5, stencil: i6 }) {
              const r7 = this.gl;
              let o7 = 0;
              e7 && (o7 |= r7.COLOR_BUFFER_BIT, this.clearColor.set(e7), this.colorMask.set([true, true, true, true])), void 0 !== t5 && (o7 |= r7.DEPTH_BUFFER_BIT, this.depthRange.set([0, 1]), this.clearDepth.set(t5), this.depthMask.set(true)), void 0 !== i6 && (o7 |= r7.STENCIL_BUFFER_BIT, this.clearStencil.set(i6), this.stencilMask.set(255)), r7.clear(o7);
            }
            setCullFace(e7) {
              false === e7.enable ? this.cullFace.set(false) : (this.cullFace.set(true), this.cullFaceSide.set(e7.mode), this.frontFace.set(e7.frontFace));
            }
            setDepthMode(e7) {
              e7.func !== this.gl.ALWAYS || e7.mask ? (this.depthTest.set(true), this.depthFunc.set(e7.func), this.depthMask.set(e7.mask), this.depthRange.set(e7.range)) : this.depthTest.set(false);
            }
            setStencilMode(e7) {
              e7.test.func !== this.gl.ALWAYS || e7.mask ? (this.stencilTest.set(true), this.stencilMask.set(e7.mask), this.stencilOp.set([e7.fail, e7.depthFail, e7.pass]), this.stencilFunc.set({ func: e7.test.func, ref: e7.ref, mask: e7.test.mask })) : this.stencilTest.set(false);
            }
            setColorMode(e7) {
              t4.bC(e7.blendFunction, Ft.Replace) ? this.blend.set(false) : (this.blend.set(true), this.blendFunc.set(e7.blendFunction), this.blendColor.set(e7.blendColor)), this.colorMask.set(e7.mask);
            }
            createVertexArray() {
              var e7;
              return Ut(this.gl) ? this.gl.createVertexArray() : null === (e7 = this.gl.getExtension("OES_vertex_array_object")) || void 0 === e7 ? void 0 : e7.createVertexArrayOES();
            }
            deleteVertexArray(e7) {
              var t5;
              return Ut(this.gl) ? this.gl.deleteVertexArray(e7) : null === (t5 = this.gl.getExtension("OES_vertex_array_object")) || void 0 === t5 ? void 0 : t5.deleteVertexArrayOES(e7);
            }
            unbindVAO() {
              this.bindVertexArray.set(null);
            }
          }
          let Gr;
          function Ur(e7, i6, r7, o7, a4) {
            const s5 = e7.context, n6 = e7.transform, l5 = s5.gl, c5 = e7.useProgram("collisionBox"), h4 = [];
            let u4 = 0, d4 = 0;
            for (let t5 = 0; t5 < o7.length; t5++) {
              const _5 = o7[t5], p5 = i6.getTile(_5).getBucket(r7);
              if (!p5) continue;
              const m5 = a4 ? p5.textCollisionBox : p5.iconCollisionBox, f5 = p5.collisionCircleArray;
              f5.length > 0 && (h4.push({ circleArray: f5, circleOffset: d4, coord: _5 }), u4 += f5.length / 4, d4 = u4), m5 && c5.draw(s5, l5.LINES, jt.disabled, Nt.disabled, e7.colorModeForRenderPass(), Ot.disabled, Di(e7.transform), e7.style.map.terrain && e7.style.map.terrain.getTerrainData(_5), n6.getProjectionData({ overscaledTileID: _5, applyGlobeMatrix: true, applyTerrainMatrix: true }), r7.id, m5.layoutVertexBuffer, m5.indexBuffer, m5.segments, null, e7.transform.zoom, null, null, m5.collisionVertexBuffer);
            }
            if (!a4 || !h4.length) return;
            const _4 = e7.useProgram("collisionCircle"), p4 = new t4.bP();
            p4.resize(4 * u4), p4._trim();
            let m4 = 0;
            for (const e8 of h4) for (let t5 = 0; t5 < e8.circleArray.length / 4; t5++) {
              const i7 = 4 * t5, r8 = e8.circleArray[i7 + 0], o8 = e8.circleArray[i7 + 1], a5 = e8.circleArray[i7 + 2], s6 = e8.circleArray[i7 + 3];
              p4.emplace(m4++, r8, o8, a5, s6, 0), p4.emplace(m4++, r8, o8, a5, s6, 1), p4.emplace(m4++, r8, o8, a5, s6, 2), p4.emplace(m4++, r8, o8, a5, s6, 3);
            }
            (!Gr || Gr.length < 2 * u4) && (Gr = function(e8) {
              const i7 = 2 * e8, r8 = new t4.bR();
              r8.resize(i7), r8._trim();
              for (let e9 = 0; e9 < i7; e9++) {
                const t5 = 6 * e9;
                r8.uint16[t5 + 0] = 4 * e9 + 0, r8.uint16[t5 + 1] = 4 * e9 + 1, r8.uint16[t5 + 2] = 4 * e9 + 2, r8.uint16[t5 + 3] = 4 * e9 + 2, r8.uint16[t5 + 4] = 4 * e9 + 3, r8.uint16[t5 + 5] = 4 * e9 + 0;
              }
              return r8;
            }(u4));
            const f4 = s5.createIndexBuffer(Gr, true), g4 = s5.createVertexBuffer(p4, t4.bQ.members, true);
            for (const i7 of h4) {
              const o8 = zi(e7.transform);
              _4.draw(s5, l5.TRIANGLES, jt.disabled, Nt.disabled, e7.colorModeForRenderPass(), Ot.disabled, o8, e7.style.map.terrain && e7.style.map.terrain.getTerrainData(i7.coord), null, r7.id, g4, f4, t4.aG.simpleSegment(0, 2 * i7.circleOffset, i7.circleArray.length, i7.circleArray.length / 2), null, e7.transform.zoom, null, null, null);
            }
            g4.destroy(), f4.destroy();
          }
          const Vr = t4.at(new Float32Array(16));
          function qr(e7, i6, r7, o7, a4, s5) {
            const { horizontalAlign: n6, verticalAlign: l5 } = t4.aB(e7);
            return new t4.P((-(n6 - 0.5) * i6 / a4 + o7[0]) * s5, (-(l5 - 0.5) * r7 / a4 + o7[1]) * s5);
          }
          function Wr(e7, i6, r7, o7, a4, s5) {
            const n6 = i6.tileAnchorPoint.add(new t4.P(i6.translation[0], i6.translation[1]));
            if (i6.pitchWithMap) {
              let e8 = o7.mult(s5);
              r7 || (e8 = e8.rotate(-a4));
              const t5 = n6.add(e8);
              return ye(t5.x, t5.y, i6.pitchedLabelPlaneMatrix, i6.getElevation).point;
            }
            if (r7) {
              const t5 = Re(i6.tileAnchorPoint.x + 1, i6.tileAnchorPoint.y, i6).point.sub(e7), r8 = Math.atan(t5.y / t5.x) + (t5.x < 0 ? Math.PI : 0);
              return e7.add(o7.rotate(r8));
            }
            return e7.add(o7);
          }
          function $r(e7, i6, r7, o7, a4, s5, n6, l5, c5, h4, u4, d4) {
            const _4 = e7.text.placedSymbolArray, p4 = e7.text.dynamicLayoutVertexArray, m4 = e7.icon.dynamicLayoutVertexArray, f4 = {};
            p4.clear();
            for (let m5 = 0; m5 < _4.length; m5++) {
              const g4 = _4.get(m5), v4 = g4.hidden || !g4.crossTileID || e7.allowVerticalPlacement && !g4.placedOrientation ? null : o7[g4.crossTileID];
              if (v4) {
                const o8 = new t4.P(g4.anchorX, g4.anchorY), _5 = { getElevation: d4, width: a4.width, height: a4.height, pitchedLabelPlaneMatrix: s5, pitchWithMap: r7, transform: a4, tileAnchorPoint: o8, translation: h4, unwrappedTileID: u4 }, m6 = r7 ? ze(o8.x, o8.y, _5) : Re(o8.x, o8.y, _5), x4 = we(a4.cameraToCenterDistance, m6.signedDistanceFromCamera);
                let b5 = t4.ai(e7.textSizeData, l5, g4) * x4 / t4.av;
                r7 && (b5 *= e7.tilePixelRatio / n6);
                const { width: y4, height: w4, anchor: T5, textOffset: P4, textBoxScale: C4 } = v4, I4 = qr(T5, y4, w4, P4, C4, b5), M5 = a4.getPitchedTextCorrection(o8.x + h4[0], o8.y + h4[1], u4), E4 = Wr(m6.point, _5, i6, I4, -a4.bearingInRadians, M5), S5 = e7.allowVerticalPlacement && g4.placedOrientation === t4.ah.vertical ? Math.PI / 2 : 0;
                for (let e8 = 0; e8 < g4.numGlyphs; e8++) t4.ao(p4, E4, S5);
                c5 && g4.associatedIconIndex >= 0 && (f4[g4.associatedIconIndex] = { shiftedAnchor: E4, angle: S5 });
              } else Be(g4.numGlyphs, p4);
            }
            if (c5) {
              m4.clear();
              const i7 = e7.icon.placedSymbolArray;
              for (let e8 = 0; e8 < i7.length; e8++) {
                const r8 = i7.get(e8);
                if (r8.hidden) Be(r8.numGlyphs, m4);
                else {
                  const i8 = f4[e8];
                  if (i8) for (let e9 = 0; e9 < r8.numGlyphs; e9++) t4.ao(m4, i8.shiftedAnchor, i8.angle);
                  else Be(r8.numGlyphs, m4);
                }
              }
              e7.icon.dynamicLayoutVertexBuffer.updateData(m4);
            }
            e7.text.dynamicLayoutVertexBuffer.updateData(p4);
          }
          function Hr(e7, t5, i6) {
            return i6.iconsInText && t5 ? "symbolTextAndIcon" : e7 ? "symbolSDF" : "symbolIcon";
          }
          function Kr(e7, i6, r7, o7, a4, s5, n6, l5, c5, h4, u4, d4, _4) {
            const p4 = e7.context, m4 = p4.gl, f4 = e7.transform, g4 = "map" === l5, v4 = "map" === c5, x4 = "viewport" !== l5 && "point" !== r7.layout.get("symbol-placement"), b5 = g4 && !v4 && !x4, y4 = !r7.layout.get("symbol-sort-key").isConstant();
            let w4 = false;
            const T5 = e7.getDepthModeForSublayer(0, jt.ReadOnly), P4 = r7._unevaluatedLayout.hasValue("text-variable-anchor") || r7._unevaluatedLayout.hasValue("text-variable-anchor-offset"), C4 = [], I4 = f4.getCircleRadiusCorrection();
            for (const l6 of o7) {
              const o8 = i6.getTile(l6), c6 = o8.getBucket(r7);
              if (!c6) continue;
              const u5 = a4 ? c6.text : c6.icon;
              if (!u5 || !u5.segments.get().length || !u5.hasVisibleVertices) continue;
              const d5 = u5.programConfigurations.get(r7.id), p5 = a4 || c6.sdfIcons, T6 = a4 ? c6.textSizeData : c6.iconSizeData, M5 = v4 || 0 !== f4.pitch, E4 = e7.useProgram(Hr(p5, a4, c6), d5), S5 = t4.ag(T6, f4.zoom), R5 = e7.style.map.terrain && e7.style.map.terrain.getTerrainData(l6);
              let D3, z4, A5, L4, k4 = [0, 0], F3 = null;
              if (a4) z4 = o8.glyphAtlasTexture, A5 = m4.LINEAR, D3 = o8.glyphAtlasTexture.size, c6.iconsInText && (k4 = o8.imageAtlasTexture.size, F3 = o8.imageAtlasTexture, L4 = M5 || e7.options.rotating || e7.options.zooming || "composite" === T6.kind || "camera" === T6.kind ? m4.LINEAR : m4.NEAREST);
              else {
                const t5 = 1 !== r7.layout.get("icon-size").constantOr(0) || c6.iconsNeedLinear;
                z4 = o8.imageAtlasTexture, A5 = p5 || e7.options.rotating || e7.options.zooming || t5 || M5 ? m4.LINEAR : m4.NEAREST, D3 = o8.imageAtlasTexture.size;
              }
              const B5 = t4.aw(o8, 1, e7.transform.zoom), O3 = ve(g4, e7.transform, B5), j4 = t4.K();
              t4.aj(j4, O3);
              const Z3 = xe(v4, g4, e7.transform, B5), N4 = t4.ax(f4, o8, s5, n6), G3 = f4.getProjectionData({ overscaledTileID: l6, applyGlobeMatrix: !_4, applyTerrainMatrix: true }), U4 = P4 && c6.hasTextData(), V3 = "none" !== r7.layout.get("icon-text-fit") && U4 && c6.hasIconData();
              if (x4) {
                const t5 = e7.style.map.terrain ? (t6, i8) => e7.style.map.terrain.getElevation(l6, t6, i8) : null, i7 = "map" === r7.layout.get("text-rotation-alignment");
                Pe(c6, e7, a4, O3, j4, v4, h4, i7, l6.toUnwrapped(), f4.width, f4.height, N4, t5);
              }
              const q3 = a4 && P4 || V3, W2 = x4 || q3 ? Vr : v4 ? O3 : e7.transform.clipSpaceToPixelsMatrix, $3 = p5 && 0 !== r7.paint.get(a4 ? "text-halo-width" : "icon-halo-width").constantOr(1);
              let H5;
              H5 = p5 ? c6.iconsInText ? Ki(T6.kind, S5, b5, v4, x4, q3, e7, W2, Z3, N4, D3, k4, I4) : Hi(T6.kind, S5, b5, v4, x4, q3, e7, W2, Z3, N4, a4, D3, 0, I4) : $i(T6.kind, S5, b5, v4, x4, q3, e7, W2, Z3, N4, a4, D3, I4);
              const K3 = { program: E4, buffers: u5, uniformValues: H5, projectionData: G3, atlasTexture: z4, atlasTextureIcon: F3, atlasInterpolation: A5, atlasInterpolationIcon: L4, isSDF: p5, hasHalo: $3 };
              if (y4 && c6.canOverlap) {
                w4 = true;
                const e8 = u5.segments.get();
                for (const i7 of e8) C4.push({ segments: new t4.aG([i7]), sortKey: i7.sortKey, state: K3, terrainData: R5 });
              } else C4.push({ segments: u5.segments, sortKey: 0, state: K3, terrainData: R5 });
            }
            w4 && C4.sort((e8, t5) => e8.sortKey - t5.sortKey);
            for (const t5 of C4) {
              const i7 = t5.state;
              if (p4.activeTexture.set(m4.TEXTURE0), i7.atlasTexture.bind(i7.atlasInterpolation, m4.CLAMP_TO_EDGE), i7.atlasTextureIcon && (p4.activeTexture.set(m4.TEXTURE1), i7.atlasTextureIcon && i7.atlasTextureIcon.bind(i7.atlasInterpolationIcon, m4.CLAMP_TO_EDGE)), i7.isSDF) {
                const o8 = i7.uniformValues;
                i7.hasHalo && (o8.u_is_halo = 1, Xr(i7.buffers, t5.segments, r7, e7, i7.program, T5, u4, d4, o8, i7.projectionData, t5.terrainData)), o8.u_is_halo = 0;
              }
              Xr(i7.buffers, t5.segments, r7, e7, i7.program, T5, u4, d4, i7.uniformValues, i7.projectionData, t5.terrainData);
            }
          }
          function Xr(e7, t5, i6, r7, o7, a4, s5, n6, l5, c5, h4) {
            const u4 = r7.context;
            o7.draw(u4, u4.gl.TRIANGLES, a4, s5, n6, Ot.backCCW, l5, h4, c5, i6.id, e7.layoutVertexBuffer, e7.indexBuffer, t5, i6.paint, r7.transform.zoom, e7.programConfigurations.get(i6.id), e7.dynamicLayoutVertexBuffer, e7.opacityVertexBuffer);
          }
          function Qr(e7, i6, r7, o7, a4) {
            const s5 = e7.context, n6 = s5.gl, l5 = Nt.disabled, c5 = new Ft([n6.ONE, n6.ONE], t4.b7.transparent, [true, true, true, true]), h4 = i6.getBucket(r7);
            if (!h4) return;
            const u4 = o7.key;
            let d4 = r7.heatmapFbos.get(u4);
            d4 || (d4 = Jr(s5, i6.tileSize, i6.tileSize), r7.heatmapFbos.set(u4, d4)), s5.bindFramebuffer.set(d4.framebuffer), s5.viewport.set([0, 0, i6.tileSize, i6.tileSize]), s5.clear({ color: t4.b7.transparent });
            const _4 = h4.programConfigurations.get(r7.id), p4 = e7.useProgram("heatmap", _4, !a4), m4 = e7.transform.getProjectionData({ overscaledTileID: i6.tileID, applyGlobeMatrix: true, applyTerrainMatrix: true }), f4 = e7.style.map.terrain.getTerrainData(o7);
            p4.draw(s5, n6.TRIANGLES, jt.disabled, l5, c5, Ot.disabled, Li(i6, e7.transform.zoom, r7.paint.get("heatmap-intensity"), 1), f4, m4, r7.id, h4.layoutVertexBuffer, h4.indexBuffer, h4.segments, r7.paint, e7.transform.zoom, _4);
          }
          function Yr(e7, t5, i6, r7, o7) {
            const a4 = e7.context, s5 = a4.gl, n6 = e7.transform;
            a4.setColorMode(e7.colorModeForRenderPass());
            const l5 = eo(a4, t5), c5 = i6.key, h4 = t5.heatmapFbos.get(c5);
            if (!h4) return;
            a4.activeTexture.set(s5.TEXTURE0), s5.bindTexture(s5.TEXTURE_2D, h4.colorAttachment.get()), a4.activeTexture.set(s5.TEXTURE1), l5.bind(s5.LINEAR, s5.CLAMP_TO_EDGE);
            const u4 = n6.getProjectionData({ overscaledTileID: i6, applyTerrainMatrix: o7, applyGlobeMatrix: !r7 });
            e7.useProgram("heatmapTexture").draw(a4, s5.TRIANGLES, jt.disabled, Nt.disabled, e7.colorModeForRenderPass(), Ot.disabled, ki(e7, t5, 0, 1), null, u4, t5.id, e7.rasterBoundsBuffer, e7.quadTriangleIndexBuffer, e7.rasterBoundsSegments, t5.paint, n6.zoom), h4.destroy(), t5.heatmapFbos.delete(c5);
          }
          function Jr(e7, t5, i6) {
            var r7, o7;
            const a4 = e7.gl, s5 = a4.createTexture();
            a4.bindTexture(a4.TEXTURE_2D, s5), a4.texParameteri(a4.TEXTURE_2D, a4.TEXTURE_WRAP_S, a4.CLAMP_TO_EDGE), a4.texParameteri(a4.TEXTURE_2D, a4.TEXTURE_WRAP_T, a4.CLAMP_TO_EDGE), a4.texParameteri(a4.TEXTURE_2D, a4.TEXTURE_MIN_FILTER, a4.LINEAR), a4.texParameteri(a4.TEXTURE_2D, a4.TEXTURE_MAG_FILTER, a4.LINEAR);
            const n6 = null !== (r7 = e7.HALF_FLOAT) && void 0 !== r7 ? r7 : a4.UNSIGNED_BYTE, l5 = null !== (o7 = e7.RGBA16F) && void 0 !== o7 ? o7 : a4.RGBA;
            a4.texImage2D(a4.TEXTURE_2D, 0, l5, t5, i6, 0, a4.RGBA, n6, null);
            const c5 = e7.createFramebuffer(t5, i6, false, false);
            return c5.colorAttachment.set(s5), c5;
          }
          function eo(e7, t5) {
            return t5.colorRampTexture || (t5.colorRampTexture = new v3(e7, t5.colorRamp, e7.gl.RGBA)), t5.colorRampTexture;
          }
          function to(e7, t5, i6, r7, o7) {
            if (!i6 || !r7 || !r7.imageAtlas) return;
            const a4 = r7.imageAtlas.patternPositions;
            let s5 = a4[i6.to.toString()], n6 = a4[i6.from.toString()];
            if (!s5 && n6 && (s5 = n6), !n6 && s5 && (n6 = s5), !s5 || !n6) {
              const e8 = o7.getPaintProperty(t5);
              s5 = a4[e8], n6 = a4[e8];
            }
            s5 && n6 && e7.setConstantPatternPositions(s5, n6);
          }
          function io(e7, i6, r7, o7, a4, s5, n6, l5) {
            const c5 = e7.context.gl, h4 = "fill-pattern", u4 = r7.paint.get(h4), d4 = u4 && u4.constantOr(1), _4 = r7.getCrossfadeParameters();
            let p4, m4, f4, g4, v4;
            const x4 = e7.transform, b5 = r7.paint.get("fill-translate"), y4 = r7.paint.get("fill-translate-anchor");
            n6 ? (m4 = d4 && !r7.getPaintProperty("fill-outline-color") ? "fillOutlinePattern" : "fillOutline", p4 = c5.LINES) : (m4 = d4 ? "fillPattern" : "fill", p4 = c5.TRIANGLES);
            const w4 = u4.constantOr(null);
            for (const u5 of o7) {
              const T5 = i6.getTile(u5);
              if (d4 && !T5.patternsLoaded()) continue;
              const P4 = T5.getBucket(r7);
              if (!P4) continue;
              const C4 = P4.programConfigurations.get(r7.id), I4 = e7.useProgram(m4, C4), M5 = e7.style.map.terrain && e7.style.map.terrain.getTerrainData(u5);
              d4 && (e7.context.activeTexture.set(c5.TEXTURE0), T5.imageAtlasTexture.bind(c5.LINEAR, c5.CLAMP_TO_EDGE), C4.updatePaintBuffers(_4)), to(C4, h4, w4, T5, r7);
              const E4 = x4.getProjectionData({ overscaledTileID: u5, applyGlobeMatrix: !l5, applyTerrainMatrix: true }), S5 = t4.ax(x4, T5, b5, y4);
              if (n6) {
                g4 = P4.indexBuffer2, v4 = P4.segments2;
                const t5 = [c5.drawingBufferWidth, c5.drawingBufferHeight];
                f4 = "fillOutlinePattern" === m4 && d4 ? Si(e7, _4, T5, t5, S5) : Ei(t5, S5);
              } else g4 = P4.indexBuffer, v4 = P4.segments, f4 = d4 ? Mi(e7, _4, T5, S5) : { u_fill_translate: S5 };
              let R5;
              if ("translucent" === e7.renderPass && l5) {
                const [t5] = e7.getStencilConfigForOverlapAndUpdateStencilID(o7);
                R5 = t5[u5.overscaledZ];
              } else R5 = e7.stencilModeForClipping(u5);
              I4.draw(e7.context, p4, a4, R5, s5, Ot.backCCW, f4, M5, E4, r7.id, P4.layoutVertexBuffer, g4, v4, r7.paint, e7.transform.zoom, C4);
            }
          }
          function ro(e7, i6, r7, o7, a4, s5, n6, l5) {
            const c5 = e7.context, h4 = c5.gl, u4 = "fill-extrusion-pattern", d4 = r7.paint.get(u4), _4 = d4.constantOr(1), p4 = r7.getCrossfadeParameters(), m4 = r7.paint.get("fill-extrusion-opacity"), f4 = d4.constantOr(null), g4 = e7.transform;
            for (const d5 of o7) {
              const o8 = i6.getTile(d5), v4 = o8.getBucket(r7);
              if (!v4) continue;
              const x4 = e7.style.map.terrain && e7.style.map.terrain.getTerrainData(d5), b5 = v4.programConfigurations.get(r7.id), y4 = e7.useProgram(_4 ? "fillExtrusionPattern" : "fillExtrusion", b5);
              _4 && (e7.context.activeTexture.set(h4.TEXTURE0), o8.imageAtlasTexture.bind(h4.LINEAR, h4.CLAMP_TO_EDGE), b5.updatePaintBuffers(p4));
              const w4 = g4.getProjectionData({ overscaledTileID: d5, applyGlobeMatrix: !l5, applyTerrainMatrix: true });
              to(b5, u4, f4, o8, r7);
              const T5 = t4.ax(g4, o8, r7.paint.get("fill-extrusion-translate"), r7.paint.get("fill-extrusion-translate-anchor")), P4 = r7.paint.get("fill-extrusion-vertical-gradient"), C4 = _4 ? Ii(e7, P4, m4, T5, d5, p4, o8) : Ci(e7, P4, m4, T5);
              y4.draw(c5, c5.gl.TRIANGLES, a4, s5, n6, Ot.backCCW, C4, x4, w4, r7.id, v4.layoutVertexBuffer, v4.indexBuffer, v4.segments, r7.paint, e7.transform.zoom, b5, e7.style.map.terrain && v4.centroidVertexBuffer);
            }
          }
          function oo(e7, t5, i6, r7, o7, a4, s5, n6, l5) {
            var c5;
            const h4 = e7.style.projection, u4 = e7.context, d4 = e7.transform, _4 = u4.gl, p4 = e7.useProgram("hillshade"), m4 = !e7.options.moving;
            for (const f4 of r7) {
              const r8 = t5.getTile(f4), g4 = r8.fbo;
              if (!g4) continue;
              const v4 = h4.getMeshFromTileID(u4, f4.canonical, n6, true, "raster"), x4 = null === (c5 = e7.style.map.terrain) || void 0 === c5 ? void 0 : c5.getTerrainData(f4);
              u4.activeTexture.set(_4.TEXTURE0), _4.bindTexture(_4.TEXTURE_2D, g4.colorAttachment.get());
              const b5 = d4.getProjectionData({ overscaledTileID: f4, aligned: m4, applyGlobeMatrix: !l5, applyTerrainMatrix: true });
              p4.draw(u4, _4.TRIANGLES, a4, o7[f4.overscaledZ], s5, Ot.backCCW, Fi(e7, r8, i6), x4, b5, i6.id, v4.vertexBuffer, v4.indexBuffer, v4.segments);
            }
          }
          const ao = [new t4.P(0, 0), new t4.P(t4.Z, 0), new t4.P(t4.Z, t4.Z), new t4.P(0, t4.Z)];
          function so(e7, t5, i6, r7, o7, a4, s5, n6, l5 = false, c5 = false) {
            const h4 = r7[r7.length - 1].overscaledZ, u4 = e7.context, d4 = u4.gl, _4 = e7.useProgram("raster"), p4 = e7.transform, m4 = e7.style.projection, f4 = e7.colorModeForRenderPass(), g4 = !e7.options.moving;
            for (const v4 of r7) {
              const r8 = e7.getDepthModeForSublayer(v4.overscaledZ - h4, 1 === i6.paint.get("raster-opacity") ? jt.ReadWrite : jt.ReadOnly, d4.LESS), x4 = t5.getTile(v4);
              x4.registerFadeDuration(i6.paint.get("raster-fade-duration"));
              const b5 = t5.findLoadedParent(v4, 0), y4 = t5.findLoadedSibling(v4), w4 = no(x4, b5 || y4 || null, t5, i6, e7.transform, e7.style.map.terrain);
              let T5, P4;
              const C4 = "nearest" === i6.paint.get("raster-resampling") ? d4.NEAREST : d4.LINEAR;
              u4.activeTexture.set(d4.TEXTURE0), x4.texture.bind(C4, d4.CLAMP_TO_EDGE, d4.LINEAR_MIPMAP_NEAREST), u4.activeTexture.set(d4.TEXTURE1), b5 ? (b5.texture.bind(C4, d4.CLAMP_TO_EDGE, d4.LINEAR_MIPMAP_NEAREST), T5 = Math.pow(2, b5.tileID.overscaledZ - x4.tileID.overscaledZ), P4 = [x4.tileID.canonical.x * T5 % 1, x4.tileID.canonical.y * T5 % 1]) : x4.texture.bind(C4, d4.CLAMP_TO_EDGE, d4.LINEAR_MIPMAP_NEAREST), x4.texture.useMipmap && u4.extTextureFilterAnisotropic && e7.transform.pitch > 20 && d4.texParameterf(d4.TEXTURE_2D, u4.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, u4.extTextureFilterAnisotropicMax);
              const I4 = e7.style.map.terrain && e7.style.map.terrain.getTerrainData(v4), M5 = p4.getProjectionData({ overscaledTileID: v4, aligned: g4, applyGlobeMatrix: !c5, applyTerrainMatrix: true }), E4 = qi(P4 || [0, 0], T5 || 1, w4, i6, n6), S5 = m4.getMeshFromTileID(u4, v4.canonical, a4, s5, "raster");
              _4.draw(u4, d4.TRIANGLES, r8, o7 ? o7[v4.overscaledZ] : Nt.disabled, f4, l5 ? Ot.frontCCW : Ot.backCCW, E4, I4, M5, i6.id, S5.vertexBuffer, S5.indexBuffer, S5.segments);
            }
          }
          function no(e7, i6, r7, o7, a4, n6) {
            const l5 = o7.paint.get("raster-fade-duration");
            if (!n6 && l5 > 0) {
              const o8 = s4.now(), n7 = (o8 - e7.timeAdded) / l5, c5 = i6 ? (o8 - i6.timeAdded) / l5 : -1, h4 = r7.getSource(), u4 = he(a4, { tileSize: h4.tileSize, roundZoom: h4.roundZoom }), d4 = !i6 || Math.abs(i6.tileID.overscaledZ - u4) > Math.abs(e7.tileID.overscaledZ - u4), _4 = d4 && e7.refreshedUponExpiration ? 1 : t4.ae(d4 ? n7 : 1 - c5, 0, 1);
              return e7.refreshedUponExpiration && n7 >= 1 && (e7.refreshedUponExpiration = false), i6 ? { opacity: 1, mix: 1 - _4 } : { opacity: _4, mix: 0 };
            }
            return { opacity: 1, mix: 0 };
          }
          const lo = new t4.b7(1, 0, 0, 1), co = new t4.b7(0, 1, 0, 1), ho = new t4.b7(0, 0, 1, 1), uo = new t4.b7(1, 0, 1, 1), _o = new t4.b7(0, 1, 1, 1);
          function po(e7, t5, i6, r7) {
            fo(e7, 0, t5 + i6 / 2, e7.transform.width, i6, r7);
          }
          function mo(e7, t5, i6, r7) {
            fo(e7, t5 - i6 / 2, 0, i6, e7.transform.height, r7);
          }
          function fo(e7, t5, i6, r7, o7, a4) {
            const s5 = e7.context, n6 = s5.gl;
            n6.enable(n6.SCISSOR_TEST), n6.scissor(t5 * e7.pixelRatio, i6 * e7.pixelRatio, r7 * e7.pixelRatio, o7 * e7.pixelRatio), s5.clear({ color: a4 }), n6.disable(n6.SCISSOR_TEST);
          }
          function go(e7, i6, r7) {
            const o7 = e7.context, a4 = o7.gl, s5 = e7.useProgram("debug"), n6 = jt.disabled, l5 = Nt.disabled, c5 = e7.colorModeForRenderPass(), h4 = "$debug", u4 = e7.style.map.terrain && e7.style.map.terrain.getTerrainData(r7);
            o7.activeTexture.set(a4.TEXTURE0);
            const d4 = i6.getTileByID(r7.key).latestRawTileData, _4 = Math.floor((d4 && d4.byteLength || 0) / 1024), p4 = i6.getTile(r7).tileSize, m4 = 512 / Math.min(p4, 512) * (r7.overscaledZ / e7.transform.zoom) * 0.5;
            let f4 = r7.canonical.toString();
            r7.overscaledZ !== r7.canonical.z && (f4 += ` => ${r7.overscaledZ}`), function(e8, t5) {
              e8.initDebugOverlayCanvas();
              const i7 = e8.debugOverlayCanvas, r8 = e8.context.gl, o8 = e8.debugOverlayCanvas.getContext("2d");
              o8.clearRect(0, 0, i7.width, i7.height), o8.shadowColor = "white", o8.shadowBlur = 2, o8.lineWidth = 1.5, o8.strokeStyle = "white", o8.textBaseline = "top", o8.font = "bold 36px Open Sans, sans-serif", o8.fillText(t5, 5, 5), o8.strokeText(t5, 5, 5), e8.debugOverlayTexture.update(i7), e8.debugOverlayTexture.bind(r8.LINEAR, r8.CLAMP_TO_EDGE);
            }(e7, `${f4} ${_4}kB`);
            const g4 = e7.transform.getProjectionData({ overscaledTileID: r7, applyGlobeMatrix: true, applyTerrainMatrix: true });
            s5.draw(o7, a4.TRIANGLES, n6, l5, Ft.alphaBlended, Ot.disabled, Ai(t4.b7.transparent, m4), null, g4, h4, e7.debugBuffer, e7.quadTriangleIndexBuffer, e7.debugSegments), s5.draw(o7, a4.LINE_STRIP, n6, l5, c5, Ot.disabled, Ai(t4.b7.red), u4, g4, h4, e7.debugBuffer, e7.tileBorderIndexBuffer, e7.debugSegments);
          }
          function vo(e7, t5, i6, r7) {
            const { isRenderingGlobe: o7 } = r7, a4 = e7.context, s5 = a4.gl, n6 = e7.transform, l5 = e7.colorModeForRenderPass(), c5 = e7.getDepthModeFor3D(), h4 = e7.useProgram("terrain");
            a4.bindFramebuffer.set(null), a4.viewport.set([0, 0, e7.width, e7.height]);
            for (const r8 of i6) {
              const i7 = t5.getTerrainMesh(r8.tileID), u4 = e7.renderToTexture.getTexture(r8), d4 = t5.getTerrainData(r8.tileID);
              a4.activeTexture.set(s5.TEXTURE0), s5.bindTexture(s5.TEXTURE_2D, u4.texture);
              const _4 = t5.getMeshFrameDelta(n6.zoom), p4 = n6.calculateFogMatrix(r8.tileID.toUnwrapped()), m4 = bi(_4, p4, e7.style.sky, n6.pitch, o7), f4 = n6.getProjectionData({ overscaledTileID: r8.tileID, applyTerrainMatrix: false, applyGlobeMatrix: true });
              h4.draw(a4, s5.TRIANGLES, c5, Nt.disabled, l5, Ot.backCCW, m4, d4, f4, "terrain", i7.vertexBuffer, i7.indexBuffer, i7.segments);
            }
          }
          function xo(e7, i6) {
            if (!i6.mesh) {
              const r7 = new t4.aF();
              r7.emplaceBack(-1, -1), r7.emplaceBack(1, -1), r7.emplaceBack(1, 1), r7.emplaceBack(-1, 1);
              const o7 = new t4.aH();
              o7.emplaceBack(0, 1, 2), o7.emplaceBack(0, 2, 3), i6.mesh = new pt(e7.createVertexBuffer(r7, mt.members), e7.createIndexBuffer(o7), t4.aG.simpleSegment(0, 0, r7.length, o7.length));
            }
            return i6.mesh;
          }
          class bo {
            constructor(e7, i6) {
              this.context = new Nr(e7), this.transform = i6, this._tileTextures = {}, this.terrainFacilitator = { dirty: true, matrix: t4.at(new Float64Array(16)), renderTime: 0 }, this.setup(), this.numSublayers = de.maxUnderzooming + de.maxOverzooming + 1, this.depthEpsilon = 1 / Math.pow(2, 16), this.crossTileSymbolIndex = new ht();
            }
            resize(e7, t5, i6) {
              if (this.width = Math.floor(e7 * i6), this.height = Math.floor(t5 * i6), this.pixelRatio = i6, this.context.viewport.set([0, 0, this.width, this.height]), this.style) for (const e8 of this.style._order) this.style._layers[e8].resize();
            }
            setup() {
              const e7 = this.context, i6 = new t4.aF();
              i6.emplaceBack(0, 0), i6.emplaceBack(t4.Z, 0), i6.emplaceBack(0, t4.Z), i6.emplaceBack(t4.Z, t4.Z), this.tileExtentBuffer = e7.createVertexBuffer(i6, mt.members), this.tileExtentSegments = t4.aG.simpleSegment(0, 0, 4, 2);
              const r7 = new t4.aF();
              r7.emplaceBack(0, 0), r7.emplaceBack(t4.Z, 0), r7.emplaceBack(0, t4.Z), r7.emplaceBack(t4.Z, t4.Z), this.debugBuffer = e7.createVertexBuffer(r7, mt.members), this.debugSegments = t4.aG.simpleSegment(0, 0, 4, 5);
              const o7 = new t4.bW();
              o7.emplaceBack(0, 0, 0, 0), o7.emplaceBack(t4.Z, 0, t4.Z, 0), o7.emplaceBack(0, t4.Z, 0, t4.Z), o7.emplaceBack(t4.Z, t4.Z, t4.Z, t4.Z), this.rasterBoundsBuffer = e7.createVertexBuffer(o7, vi.members), this.rasterBoundsSegments = t4.aG.simpleSegment(0, 0, 4, 2);
              const a4 = new t4.aF();
              a4.emplaceBack(0, 0), a4.emplaceBack(t4.Z, 0), a4.emplaceBack(0, t4.Z), a4.emplaceBack(t4.Z, t4.Z), this.rasterBoundsBufferPosOnly = e7.createVertexBuffer(a4, mt.members), this.rasterBoundsSegmentsPosOnly = t4.aG.simpleSegment(0, 0, 4, 5);
              const s5 = new t4.aF();
              s5.emplaceBack(0, 0), s5.emplaceBack(1, 0), s5.emplaceBack(0, 1), s5.emplaceBack(1, 1), this.viewportBuffer = e7.createVertexBuffer(s5, mt.members), this.viewportSegments = t4.aG.simpleSegment(0, 0, 4, 2);
              const n6 = new t4.bX();
              n6.emplaceBack(0), n6.emplaceBack(1), n6.emplaceBack(3), n6.emplaceBack(2), n6.emplaceBack(0), this.tileBorderIndexBuffer = e7.createIndexBuffer(n6);
              const l5 = new t4.aH();
              l5.emplaceBack(1, 0, 2), l5.emplaceBack(1, 2, 3), this.quadTriangleIndexBuffer = e7.createIndexBuffer(l5);
              const c5 = this.context.gl;
              this.stencilClearMode = new Nt({ func: c5.ALWAYS, mask: 0 }, 0, 255, c5.ZERO, c5.ZERO, c5.ZERO), this.tileExtentMesh = new pt(this.tileExtentBuffer, this.quadTriangleIndexBuffer, this.tileExtentSegments);
            }
            clearStencil() {
              const e7 = this.context, i6 = e7.gl;
              this.nextStencilID = 1, this.currentStencilSource = void 0;
              const r7 = t4.K();
              t4.bO(r7, 0, this.width, this.height, 0, 0, 1), t4.M(r7, r7, [i6.drawingBufferWidth, i6.drawingBufferHeight, 0]);
              const o7 = { mainMatrix: r7, tileMercatorCoords: [0, 0, 1, 1], clippingPlane: [0, 0, 0, 0], projectionTransition: 0, fallbackMatrix: r7 };
              this.useProgram("clippingMask", null, true).draw(e7, i6.TRIANGLES, jt.disabled, this.stencilClearMode, Ft.disabled, Ot.disabled, null, null, o7, "$clipping", this.viewportBuffer, this.quadTriangleIndexBuffer, this.viewportSegments);
            }
            _renderTileClippingMasks(e7, t5, i6) {
              if (this.currentStencilSource === e7.source || !e7.isTileClipped() || !t5 || !t5.length) return;
              this.currentStencilSource = e7.source, this.nextStencilID + t5.length > 256 && this.clearStencil();
              const r7 = this.context;
              r7.setColorMode(Ft.disabled), r7.setDepthMode(jt.disabled);
              const o7 = {};
              for (const e8 of t5) o7[e8.key] = this.nextStencilID++;
              this._renderTileMasks(o7, t5, i6, true), this._renderTileMasks(o7, t5, i6, false), this._tileClippingMaskIDs = o7;
            }
            _renderTileMasks(e7, t5, i6, r7) {
              const o7 = this.context, a4 = o7.gl, s5 = this.style.projection, n6 = this.transform, l5 = this.useProgram("clippingMask");
              for (const c5 of t5) {
                const t6 = e7[c5.key], h4 = this.style.map.terrain && this.style.map.terrain.getTerrainData(c5), u4 = s5.getMeshFromTileID(this.context, c5.canonical, r7, true, "stencil"), d4 = n6.getProjectionData({ overscaledTileID: c5, applyGlobeMatrix: true, applyTerrainMatrix: true });
                l5.draw(o7, a4.TRIANGLES, jt.disabled, new Nt({ func: a4.ALWAYS, mask: 0 }, t6, 255, a4.KEEP, a4.KEEP, a4.REPLACE), Ft.disabled, i6 ? Ot.disabled : Ot.backCCW, null, h4, d4, "$clipping", u4.vertexBuffer, u4.indexBuffer, u4.segments);
              }
            }
            _renderTilesDepthBuffer() {
              const e7 = this.context, t5 = e7.gl, i6 = this.style.projection, r7 = this.transform, o7 = this.useProgram("depth"), a4 = this.getDepthModeFor3D(), s5 = ue(r7, { tileSize: r7.tileSize });
              for (const n6 of s5) {
                const s6 = this.style.map.terrain && this.style.map.terrain.getTerrainData(n6), l5 = i6.getMeshFromTileID(this.context, n6.canonical, true, true, "raster"), c5 = r7.getProjectionData({ overscaledTileID: n6, applyGlobeMatrix: true, applyTerrainMatrix: true });
                o7.draw(e7, t5.TRIANGLES, a4, Nt.disabled, Ft.disabled, Ot.backCCW, null, s6, c5, "$clipping", l5.vertexBuffer, l5.indexBuffer, l5.segments);
              }
            }
            stencilModeFor3D() {
              this.currentStencilSource = void 0, this.nextStencilID + 1 > 256 && this.clearStencil();
              const e7 = this.nextStencilID++, t5 = this.context.gl;
              return new Nt({ func: t5.NOTEQUAL, mask: 255 }, e7, 255, t5.KEEP, t5.KEEP, t5.REPLACE);
            }
            stencilModeForClipping(e7) {
              const t5 = this.context.gl;
              return new Nt({ func: t5.EQUAL, mask: 255 }, this._tileClippingMaskIDs[e7.key], 0, t5.KEEP, t5.KEEP, t5.REPLACE);
            }
            getStencilConfigForOverlapAndUpdateStencilID(e7) {
              const t5 = this.context.gl, i6 = e7.sort((e8, t6) => t6.overscaledZ - e8.overscaledZ), r7 = i6[i6.length - 1].overscaledZ, o7 = i6[0].overscaledZ - r7 + 1;
              if (o7 > 1) {
                this.currentStencilSource = void 0, this.nextStencilID + o7 > 256 && this.clearStencil();
                const e8 = {};
                for (let i7 = 0; i7 < o7; i7++) e8[i7 + r7] = new Nt({ func: t5.GEQUAL, mask: 255 }, i7 + this.nextStencilID, 255, t5.KEEP, t5.KEEP, t5.REPLACE);
                return this.nextStencilID += o7, [e8, i6];
              }
              return [{ [r7]: Nt.disabled }, i6];
            }
            stencilConfigForOverlapTwoPass(e7) {
              const t5 = this.context.gl, i6 = e7.sort((e8, t6) => t6.overscaledZ - e8.overscaledZ), r7 = i6[i6.length - 1].overscaledZ, o7 = i6[0].overscaledZ - r7 + 1;
              if (this.clearStencil(), o7 > 1) {
                const e8 = {}, a4 = {};
                for (let i7 = 0; i7 < o7; i7++) e8[i7 + r7] = new Nt({ func: t5.GREATER, mask: 255 }, o7 + 1 + i7, 255, t5.KEEP, t5.KEEP, t5.REPLACE), a4[i7 + r7] = new Nt({ func: t5.GREATER, mask: 255 }, 1 + i7, 255, t5.KEEP, t5.KEEP, t5.REPLACE);
                return this.nextStencilID = 2 * o7 + 1, [e8, a4, i6];
              }
              return this.nextStencilID = 3, [{ [r7]: new Nt({ func: t5.GREATER, mask: 255 }, 2, 255, t5.KEEP, t5.KEEP, t5.REPLACE) }, { [r7]: new Nt({ func: t5.GREATER, mask: 255 }, 1, 255, t5.KEEP, t5.KEEP, t5.REPLACE) }, i6];
            }
            colorModeForRenderPass() {
              const e7 = this.context.gl;
              if (this._showOverdrawInspector) {
                const i6 = 1 / 8;
                return new Ft([e7.CONSTANT_COLOR, e7.ONE], new t4.b7(i6, i6, i6, 0), [true, true, true, true]);
              }
              return "opaque" === this.renderPass ? Ft.unblended : Ft.alphaBlended;
            }
            getDepthModeForSublayer(e7, t5, i6) {
              if (!this.opaquePassEnabledForLayer()) return jt.disabled;
              const r7 = 1 - ((1 + this.currentLayer) * this.numSublayers + e7) * this.depthEpsilon;
              return new jt(i6 || this.context.gl.LEQUAL, t5, [r7, r7]);
            }
            getDepthModeFor3D() {
              return new jt(this.context.gl.LEQUAL, jt.ReadWrite, this.depthRangeFor3D);
            }
            opaquePassEnabledForLayer() {
              return this.currentLayer < this.opaquePassCutoff;
            }
            render(e7, i6) {
              var r7, o7;
              this.style = e7, this.options = i6, this.lineAtlas = e7.lineAtlas, this.imageManager = e7.imageManager, this.glyphManager = e7.glyphManager, this.symbolFadeChange = e7.placement.symbolFadeChange(s4.now()), this.imageManager.beginFrame();
              const a4 = this.style._order, n6 = this.style.sourceCaches, l5 = {}, c5 = {}, h4 = {}, u4 = { isRenderingToTexture: false, isRenderingGlobe: (null === (r7 = e7.projection) || void 0 === r7 ? void 0 : r7.transitionState) > 0 };
              for (const e8 in n6) {
                const t5 = n6[e8];
                t5.used && t5.prepare(this.context), l5[e8] = t5.getVisibleCoordinates(false), c5[e8] = l5[e8].slice().reverse(), h4[e8] = t5.getVisibleCoordinates(true).reverse();
              }
              this.opaquePassCutoff = 1 / 0;
              for (let e8 = 0; e8 < a4.length; e8++) if (this.style._layers[a4[e8]].is3D()) {
                this.opaquePassCutoff = e8;
                break;
              }
              this.maybeDrawDepthAndCoords(false), this.renderToTexture && (this.renderToTexture.prepareForRender(this.style, this.transform.zoom), this.opaquePassCutoff = 0), this.renderPass = "offscreen";
              for (const e8 of a4) {
                const t5 = this.style._layers[e8];
                if (!t5.hasOffscreenPass() || t5.isHidden(this.transform.zoom)) continue;
                const i7 = c5[t5.source];
                ("custom" === t5.type || i7.length) && this.renderLayer(this, n6[t5.source], t5, i7, u4);
              }
              if (null === (o7 = this.style.projection) || void 0 === o7 || o7.updateGPUdependent({ context: this.context, useProgram: (e8) => this.useProgram(e8) }), this.context.viewport.set([0, 0, this.width, this.height]), this.context.bindFramebuffer.set(null), this.context.clear({ color: i6.showOverdrawInspector ? t4.b7.black : t4.b7.transparent, depth: 1 }), this.clearStencil(), this.style.sky && function(e8, t5) {
                const i7 = e8.context, r8 = i7.gl, o8 = ((e9, t6, i8) => {
                  const r9 = Math.cos(t6.rollInRadians), o9 = Math.sin(t6.rollInRadians), a6 = yt(t6), s6 = t6.getProjectionData({ overscaledTileID: null, applyGlobeMatrix: true, applyTerrainMatrix: true }).projectionTransition;
                  return { u_sky_color: e9.properties.get("sky-color"), u_horizon_color: e9.properties.get("horizon-color"), u_horizon: [(t6.width / 2 - a6 * o9) * i8, (t6.height / 2 + a6 * r9) * i8], u_horizon_normal: [-o9, r9], u_sky_horizon_blend: e9.properties.get("sky-horizon-blend") * t6.height / 2 * i8, u_sky_blend: s6 };
                })(t5, e8.style.map.transform, e8.pixelRatio), a5 = new jt(r8.LEQUAL, jt.ReadWrite, [0, 1]), s5 = Nt.disabled, n7 = e8.colorModeForRenderPass(), l6 = e8.useProgram("sky"), c6 = xo(i7, t5);
                l6.draw(i7, r8.TRIANGLES, a5, s5, n7, Ot.disabled, o8, null, void 0, "sky", c6.vertexBuffer, c6.indexBuffer, c6.segments);
              }(this, this.style.sky), this._showOverdrawInspector = i6.showOverdrawInspector, this.depthRangeFor3D = [0, 1 - (e7._order.length + 2) * this.numSublayers * this.depthEpsilon], !this.renderToTexture) for (this.renderPass = "opaque", this.currentLayer = a4.length - 1; this.currentLayer >= 0; this.currentLayer--) {
                const e8 = this.style._layers[a4[this.currentLayer]], t5 = n6[e8.source], i7 = l5[e8.source];
                this._renderTileClippingMasks(e8, i7, false), this.renderLayer(this, t5, e8, i7, u4);
              }
              this.renderPass = "translucent";
              let d4 = false;
              for (this.currentLayer = 0; this.currentLayer < a4.length; this.currentLayer++) {
                const e8 = this.style._layers[a4[this.currentLayer]], t5 = n6[e8.source];
                if (this.renderToTexture && this.renderToTexture.renderLayer(e8, u4)) continue;
                this.opaquePassEnabledForLayer() || d4 || (d4 = true, u4.isRenderingGlobe && !this.style.map.terrain && this._renderTilesDepthBuffer());
                const i7 = ("symbol" === e8.type ? h4 : c5)[e8.source];
                this._renderTileClippingMasks(e8, l5[e8.source], false), this.renderLayer(this, t5, e8, i7, u4);
              }
              if (u4.isRenderingGlobe && function(e8, i7, r8) {
                const o8 = e8.context, a5 = o8.gl, s5 = e8.useProgram("atmosphere"), n7 = new jt(a5.LEQUAL, jt.ReadOnly, [0, 1]), l6 = e8.transform, c6 = function(e9, i8) {
                  const r9 = e9.properties.get("position"), o9 = [-r9.x, -r9.y, -r9.z], a6 = t4.at(new Float64Array(16));
                  return "map" === e9.properties.get("anchor") && (t4.a_(a6, a6, i8.rollInRadians), t4.a$(a6, a6, -i8.pitchInRadians), t4.a_(a6, a6, i8.bearingInRadians), t4.a$(a6, a6, i8.center.lat * Math.PI / 180), t4.bm(a6, a6, -i8.center.lng * Math.PI / 180)), t4.bV(o9, o9, a6), o9;
                }(r8, e8.transform), h5 = l6.getProjectionData({ overscaledTileID: null, applyGlobeMatrix: true, applyTerrainMatrix: true }), u5 = i7.properties.get("atmosphere-blend") * h5.projectionTransition;
                if (0 === u5) return;
                const d5 = ei(l6.worldSize, l6.center.lat), _4 = l6.inverseProjectionMatrix, p4 = new Float64Array(4);
                p4[3] = 1, t4.ap(p4, p4, l6.modelViewProjectionMatrix), p4[0] /= p4[3], p4[1] /= p4[3], p4[2] /= p4[3], p4[3] = 1, t4.ap(p4, p4, _4), p4[0] /= p4[3], p4[1] /= p4[3], p4[2] /= p4[3], p4[3] = 1;
                const m4 = /* @__PURE__ */ ((e9, t5, i8, r9, o9) => ({ u_sun_pos: e9, u_atmosphere_blend: t5, u_globe_position: i8, u_globe_radius: r9, u_inv_proj_matrix: o9 }))(c6, u5, [p4[0], p4[1], p4[2]], d5, _4), f4 = xo(o8, i7);
                s5.draw(o8, a5.TRIANGLES, n7, Nt.disabled, Ft.alphaBlended, Ot.disabled, m4, null, null, "atmosphere", f4.vertexBuffer, f4.indexBuffer, f4.segments);
              }(this, this.style.sky, this.style.light), this.options.showTileBoundaries) {
                const e8 = function(e9, t5) {
                  let i7 = null;
                  const r8 = Object.values(e9._layers).flatMap((i8) => i8.source && !i8.isHidden(t5) ? [e9.sourceCaches[i8.source]] : []), o8 = r8.filter((e10) => "vector" === e10.getSource().type), a5 = r8.filter((e10) => "vector" !== e10.getSource().type), s5 = (e10) => {
                    (!i7 || i7.getSource().maxzoom < e10.getSource().maxzoom) && (i7 = e10);
                  };
                  return o8.forEach((e10) => s5(e10)), i7 || a5.forEach((e10) => s5(e10)), i7;
                }(this.style, this.transform.zoom);
                e8 && function(e9, t5, i7) {
                  for (let r8 = 0; r8 < i7.length; r8++) go(e9, t5, i7[r8]);
                }(this, e8, e8.getVisibleCoordinates());
              }
              this.options.showPadding && function(e8) {
                const t5 = e8.transform.padding;
                po(e8, e8.transform.height - (t5.top || 0), 3, lo), po(e8, t5.bottom || 0, 3, co), mo(e8, t5.left || 0, 3, ho), mo(e8, e8.transform.width - (t5.right || 0), 3, uo);
                const i7 = e8.transform.centerPoint;
                !function(e9, t6, i8, r8) {
                  fo(e9, t6 - 1, i8 - 10, 2, 20, r8), fo(e9, t6 - 10, i8 - 1, 20, 2, r8);
                }(e8, i7.x, e8.transform.height - i7.y, _o);
              }(this), this.context.setDefault();
            }
            maybeDrawDepthAndCoords(e7) {
              if (!this.style || !this.style.map || !this.style.map.terrain) return;
              const i6 = this.terrainFacilitator.matrix, r7 = this.transform.modelViewProjectionMatrix;
              let o7 = this.terrainFacilitator.dirty;
              o7 || (o7 = e7 ? !t4.bY(i6, r7) : !t4.bZ(i6, r7)), o7 || (o7 = this.style.map.terrain.sourceCache.anyTilesAfterTime(this.terrainFacilitator.renderTime)), o7 && (t4.b_(i6, r7), this.terrainFacilitator.renderTime = Date.now(), this.terrainFacilitator.dirty = false, function(e8, i7) {
                const r8 = e8.context, o8 = r8.gl, a4 = e8.transform, s5 = Ft.unblended, n6 = new jt(o8.LEQUAL, jt.ReadWrite, [0, 1]), l5 = i7.sourceCache.getRenderableTiles(), c5 = e8.useProgram("terrainDepth");
                r8.bindFramebuffer.set(i7.getFramebuffer("depth").framebuffer), r8.viewport.set([0, 0, e8.width / devicePixelRatio, e8.height / devicePixelRatio]), r8.clear({ color: t4.b7.transparent, depth: 1 });
                for (const e9 of l5) {
                  const t5 = i7.getTerrainMesh(e9.tileID), l6 = i7.getTerrainData(e9.tileID), h4 = a4.getProjectionData({ overscaledTileID: e9.tileID, applyTerrainMatrix: false, applyGlobeMatrix: true }), u4 = { u_ele_delta: i7.getMeshFrameDelta(a4.zoom) };
                  c5.draw(r8, o8.TRIANGLES, n6, Nt.disabled, s5, Ot.backCCW, u4, l6, h4, "terrain", t5.vertexBuffer, t5.indexBuffer, t5.segments);
                }
                r8.bindFramebuffer.set(null), r8.viewport.set([0, 0, e8.width, e8.height]);
              }(this, this.style.map.terrain), function(e8, i7) {
                const r8 = e8.context, o8 = r8.gl, a4 = e8.transform, s5 = Ft.unblended, n6 = new jt(o8.LEQUAL, jt.ReadWrite, [0, 1]), l5 = i7.getCoordsTexture(), c5 = i7.sourceCache.getRenderableTiles(), h4 = e8.useProgram("terrainCoords");
                r8.bindFramebuffer.set(i7.getFramebuffer("coords").framebuffer), r8.viewport.set([0, 0, e8.width / devicePixelRatio, e8.height / devicePixelRatio]), r8.clear({ color: t4.b7.transparent, depth: 1 }), i7.coordsIndex = [];
                for (const e9 of c5) {
                  const t5 = i7.getTerrainMesh(e9.tileID), c6 = i7.getTerrainData(e9.tileID);
                  r8.activeTexture.set(o8.TEXTURE0), o8.bindTexture(o8.TEXTURE_2D, l5.texture);
                  const u4 = { u_terrain_coords_id: (255 - i7.coordsIndex.length) / 255, u_texture: 0, u_ele_delta: i7.getMeshFrameDelta(a4.zoom) }, d4 = a4.getProjectionData({ overscaledTileID: e9.tileID, applyTerrainMatrix: false, applyGlobeMatrix: true });
                  h4.draw(r8, o8.TRIANGLES, n6, Nt.disabled, s5, Ot.backCCW, u4, c6, d4, "terrain", t5.vertexBuffer, t5.indexBuffer, t5.segments), i7.coordsIndex.push(e9.tileID.key);
                }
                r8.bindFramebuffer.set(null), r8.viewport.set([0, 0, e8.width, e8.height]);
              }(this, this.style.map.terrain));
            }
            renderLayer(e7, i6, r7, o7, a4) {
              r7.isHidden(this.transform.zoom) || ("background" === r7.type || "custom" === r7.type || (o7 || []).length) && (this.id = r7.id, t4.b$(r7) ? function(e8, i7, r8, o8, a5, s5) {
                if ("translucent" !== e8.renderPass) return;
                const { isRenderingToTexture: n6 } = s5, l5 = Nt.disabled, c5 = e8.colorModeForRenderPass();
                (r8._unevaluatedLayout.hasValue("text-variable-anchor") || r8._unevaluatedLayout.hasValue("text-variable-anchor-offset")) && function(e9, i8, r9, o9, a6, s6, n7, l6, c6) {
                  const h4 = i8.transform, u4 = i8.style.map.terrain, d4 = "map" === a6, _4 = "map" === s6;
                  for (const a7 of e9) {
                    const e10 = o9.getTile(a7), s7 = e10.getBucket(r9);
                    if (!s7 || !s7.text || !s7.text.segments.get().length) continue;
                    const p4 = t4.ag(s7.textSizeData, h4.zoom), m4 = t4.aw(e10, 1, i8.transform.zoom), f4 = ve(d4, i8.transform, m4), g4 = "none" !== r9.layout.get("icon-text-fit") && s7.hasIconData();
                    if (p4) {
                      const i9 = Math.pow(2, h4.zoom - e10.tileID.overscaledZ), r10 = u4 ? (e11, t5) => u4.getElevation(a7, e11, t5) : null;
                      $r(s7, d4, _4, c6, h4, f4, i9, p4, g4, t4.ax(h4, e10, n7, l6), a7.toUnwrapped(), r10);
                    }
                  }
                }(o8, e8, r8, i7, r8.layout.get("text-rotation-alignment"), r8.layout.get("text-pitch-alignment"), r8.paint.get("text-translate"), r8.paint.get("text-translate-anchor"), a5), 0 !== r8.paint.get("icon-opacity").constantOr(1) && Kr(e8, i7, r8, o8, false, r8.paint.get("icon-translate"), r8.paint.get("icon-translate-anchor"), r8.layout.get("icon-rotation-alignment"), r8.layout.get("icon-pitch-alignment"), r8.layout.get("icon-keep-upright"), l5, c5, n6), 0 !== r8.paint.get("text-opacity").constantOr(1) && Kr(e8, i7, r8, o8, true, r8.paint.get("text-translate"), r8.paint.get("text-translate-anchor"), r8.layout.get("text-rotation-alignment"), r8.layout.get("text-pitch-alignment"), r8.layout.get("text-keep-upright"), l5, c5, n6), i7.map.showCollisionBoxes && (Ur(e8, i7, r8, o8, true), Ur(e8, i7, r8, o8, false));
              }(e7, i6, r7, o7, this.style.placement.variableOffsets, a4) : t4.c0(r7) ? function(e8, i7, r8, o8, a5) {
                if ("translucent" !== e8.renderPass) return;
                const { isRenderingToTexture: s5 } = a5, n6 = r8.paint.get("circle-opacity"), l5 = r8.paint.get("circle-stroke-width"), c5 = r8.paint.get("circle-stroke-opacity"), h4 = !r8.layout.get("circle-sort-key").isConstant();
                if (0 === n6.constantOr(1) && (0 === l5.constantOr(1) || 0 === c5.constantOr(1))) return;
                const u4 = e8.context, d4 = u4.gl, _4 = e8.transform, p4 = e8.getDepthModeForSublayer(0, jt.ReadOnly), m4 = Nt.disabled, f4 = e8.colorModeForRenderPass(), g4 = [], v4 = _4.getCircleRadiusCorrection();
                for (let a6 = 0; a6 < o8.length; a6++) {
                  const n7 = o8[a6], l6 = i7.getTile(n7), c6 = l6.getBucket(r8);
                  if (!c6) continue;
                  const u5 = r8.paint.get("circle-translate"), d5 = r8.paint.get("circle-translate-anchor"), p5 = t4.ax(_4, l6, u5, d5), m5 = c6.programConfigurations.get(r8.id), f5 = e8.useProgram("circle", m5), x4 = c6.layoutVertexBuffer, b5 = c6.indexBuffer, y4 = e8.style.map.terrain && e8.style.map.terrain.getTerrainData(n7), w4 = { programConfiguration: m5, program: f5, layoutVertexBuffer: x4, indexBuffer: b5, uniformValues: Ri(e8, l6, r8, p5, v4), terrainData: y4, projectionData: _4.getProjectionData({ overscaledTileID: n7, applyGlobeMatrix: !s5, applyTerrainMatrix: true }) };
                  if (h4) {
                    const e9 = c6.segments.get();
                    for (const i8 of e9) g4.push({ segments: new t4.aG([i8]), sortKey: i8.sortKey, state: w4 });
                  } else g4.push({ segments: c6.segments, sortKey: 0, state: w4 });
                }
                h4 && g4.sort((e9, t5) => e9.sortKey - t5.sortKey);
                for (const t5 of g4) {
                  const { programConfiguration: i8, program: o9, layoutVertexBuffer: a6, indexBuffer: s6, uniformValues: n7, terrainData: l6, projectionData: c6 } = t5.state;
                  o9.draw(u4, d4.TRIANGLES, p4, m4, f4, Ot.backCCW, n7, l6, c6, r8.id, a6, s6, t5.segments, r8.paint, e8.transform.zoom, i8);
                }
              }(e7, i6, r7, o7, a4) : t4.c1(r7) ? function(e8, i7, r8, o8, a5) {
                if (0 === r8.paint.get("heatmap-opacity")) return;
                const s5 = e8.context, { isRenderingToTexture: n6, isRenderingGlobe: l5 } = a5;
                if (e8.style.map.terrain) {
                  for (const t5 of o8) {
                    const o9 = i7.getTile(t5);
                    i7.hasRenderableParent(t5) || ("offscreen" === e8.renderPass ? Qr(e8, o9, r8, t5, l5) : "translucent" === e8.renderPass && Yr(e8, r8, t5, n6, l5));
                  }
                  s5.viewport.set([0, 0, e8.width, e8.height]);
                } else "offscreen" === e8.renderPass ? function(e9, i8, r9, o9) {
                  const a6 = e9.context, s6 = a6.gl, n7 = e9.transform, l6 = Nt.disabled, c5 = new Ft([s6.ONE, s6.ONE], t4.b7.transparent, [true, true, true, true]);
                  (function(e10, i9, r10) {
                    const o10 = e10.gl;
                    e10.activeTexture.set(o10.TEXTURE1), e10.viewport.set([0, 0, i9.width / 4, i9.height / 4]);
                    let a7 = r10.heatmapFbos.get(t4.bS);
                    a7 ? (o10.bindTexture(o10.TEXTURE_2D, a7.colorAttachment.get()), e10.bindFramebuffer.set(a7.framebuffer)) : (a7 = Jr(e10, i9.width / 4, i9.height / 4), r10.heatmapFbos.set(t4.bS, a7));
                  })(a6, e9, r9), a6.clear({ color: t4.b7.transparent });
                  for (let t5 = 0; t5 < o9.length; t5++) {
                    const h4 = o9[t5];
                    if (i8.hasRenderableParent(h4)) continue;
                    const u4 = i8.getTile(h4), d4 = u4.getBucket(r9);
                    if (!d4) continue;
                    const _4 = d4.programConfigurations.get(r9.id), p4 = e9.useProgram("heatmap", _4), m4 = n7.getProjectionData({ overscaledTileID: h4, applyGlobeMatrix: true, applyTerrainMatrix: false }), f4 = n7.getCircleRadiusCorrection();
                    p4.draw(a6, s6.TRIANGLES, jt.disabled, l6, c5, Ot.backCCW, Li(u4, n7.zoom, r9.paint.get("heatmap-intensity"), f4), null, m4, r9.id, d4.layoutVertexBuffer, d4.indexBuffer, d4.segments, r9.paint, n7.zoom, _4);
                  }
                  a6.viewport.set([0, 0, e9.width, e9.height]);
                }(e8, i7, r8, o8) : "translucent" === e8.renderPass && function(e9, i8) {
                  const r9 = e9.context, o9 = r9.gl;
                  r9.setColorMode(e9.colorModeForRenderPass());
                  const a6 = i8.heatmapFbos.get(t4.bS);
                  a6 && (r9.activeTexture.set(o9.TEXTURE0), o9.bindTexture(o9.TEXTURE_2D, a6.colorAttachment.get()), r9.activeTexture.set(o9.TEXTURE1), eo(r9, i8).bind(o9.LINEAR, o9.CLAMP_TO_EDGE), e9.useProgram("heatmapTexture").draw(r9, o9.TRIANGLES, jt.disabled, Nt.disabled, e9.colorModeForRenderPass(), Ot.disabled, ki(e9, i8, 0, 1), null, null, i8.id, e9.viewportBuffer, e9.quadTriangleIndexBuffer, e9.viewportSegments, i8.paint, e9.transform.zoom));
                }(e8, r8);
              }(e7, i6, r7, o7, a4) : t4.c2(r7) ? function(e8, i7, r8, o8, a5) {
                if ("translucent" !== e8.renderPass) return;
                const { isRenderingToTexture: s5 } = a5, n6 = r8.paint.get("line-opacity"), l5 = r8.paint.get("line-width");
                if (0 === n6.constantOr(1) || 0 === l5.constantOr(1)) return;
                const c5 = e8.getDepthModeForSublayer(0, jt.ReadOnly), h4 = e8.colorModeForRenderPass(), u4 = r8.paint.get("line-dasharray"), d4 = r8.paint.get("line-pattern"), _4 = d4.constantOr(1), p4 = r8.paint.get("line-gradient"), m4 = r8.getCrossfadeParameters(), f4 = _4 ? "linePattern" : u4 ? "lineSDF" : p4 ? "lineGradient" : "line", g4 = e8.context, x4 = g4.gl, b5 = e8.transform;
                let y4 = true;
                for (const a6 of o8) {
                  const n7 = i7.getTile(a6);
                  if (_4 && !n7.patternsLoaded()) continue;
                  const l6 = n7.getBucket(r8);
                  if (!l6) continue;
                  const w4 = l6.programConfigurations.get(r8.id), T5 = e8.context.program.get(), P4 = e8.useProgram(f4, w4), C4 = y4 || P4.program !== T5, I4 = e8.style.map.terrain && e8.style.map.terrain.getTerrainData(a6), M5 = d4.constantOr(null);
                  if (M5 && n7.imageAtlas) {
                    const e9 = n7.imageAtlas, t5 = e9.patternPositions[M5.to.toString()], i8 = e9.patternPositions[M5.from.toString()];
                    t5 && i8 && w4.setConstantPatternPositions(t5, i8);
                  }
                  const E4 = b5.getProjectionData({ overscaledTileID: a6, applyGlobeMatrix: !s5, applyTerrainMatrix: true }), S5 = b5.getPixelScale(), R5 = _4 ? Ni(e8, n7, r8, S5, m4) : u4 ? Gi(e8, n7, r8, S5, u4, m4) : p4 ? Zi(e8, n7, r8, S5, l6.lineClipsArray.length) : ji(e8, n7, r8, S5);
                  if (_4) g4.activeTexture.set(x4.TEXTURE0), n7.imageAtlasTexture.bind(x4.LINEAR, x4.CLAMP_TO_EDGE), w4.updatePaintBuffers(m4);
                  else if (u4 && (C4 || e8.lineAtlas.dirty)) g4.activeTexture.set(x4.TEXTURE0), e8.lineAtlas.bind(g4);
                  else if (p4) {
                    const o9 = l6.gradients[r8.id];
                    let s6 = o9.texture;
                    if (r8.gradientVersion !== o9.version) {
                      let n8 = 256;
                      if (r8.stepInterpolant) {
                        const r9 = i7.getSource().maxzoom, o10 = a6.canonical.z === r9 ? Math.ceil(1 << e8.transform.maxZoom - a6.canonical.z) : 1;
                        n8 = t4.ae(t4.bT(l6.maxLineLength / t4.Z * 1024 * o10), 256, g4.maxTextureSize);
                      }
                      o9.gradient = t4.bU({ expression: r8.gradientExpression(), evaluationKey: "lineProgress", resolution: n8, image: o9.gradient || void 0, clips: l6.lineClipsArray }), o9.texture ? o9.texture.update(o9.gradient) : o9.texture = new v3(g4, o9.gradient, x4.RGBA), o9.version = r8.gradientVersion, s6 = o9.texture;
                    }
                    g4.activeTexture.set(x4.TEXTURE0), s6.bind(r8.stepInterpolant ? x4.NEAREST : x4.LINEAR, x4.CLAMP_TO_EDGE);
                  }
                  let D3;
                  if (s5) {
                    const [t5] = e8.getStencilConfigForOverlapAndUpdateStencilID(o8);
                    D3 = t5[a6.overscaledZ];
                  } else D3 = e8.stencilModeForClipping(a6);
                  P4.draw(g4, x4.TRIANGLES, c5, D3, h4, Ot.disabled, R5, I4, E4, r8.id, l6.layoutVertexBuffer, l6.indexBuffer, l6.segments, r8.paint, e8.transform.zoom, w4, l6.layoutVertexBuffer2), y4 = false;
                }
              }(e7, i6, r7, o7, a4) : t4.c3(r7) ? function(e8, i7, r8, o8, a5) {
                const s5 = r8.paint.get("fill-color"), n6 = r8.paint.get("fill-opacity");
                if (0 === n6.constantOr(1)) return;
                const { isRenderingToTexture: l5 } = a5, c5 = e8.colorModeForRenderPass(), h4 = r8.paint.get("fill-pattern"), u4 = e8.opaquePassEnabledForLayer() && !h4.constantOr(1) && 1 === s5.constantOr(t4.b7.transparent).a && 1 === n6.constantOr(0) ? "opaque" : "translucent";
                if (e8.renderPass === u4) {
                  const t5 = e8.getDepthModeForSublayer(1, "opaque" === e8.renderPass ? jt.ReadWrite : jt.ReadOnly);
                  io(e8, i7, r8, o8, t5, c5, false, l5);
                }
                if ("translucent" === e8.renderPass && r8.paint.get("fill-antialias")) {
                  const t5 = e8.getDepthModeForSublayer(r8.getPaintProperty("fill-outline-color") ? 2 : 0, jt.ReadOnly);
                  io(e8, i7, r8, o8, t5, c5, true, l5);
                }
              }(e7, i6, r7, o7, a4) : t4.c4(r7) ? function(e8, t5, i7, r8, o8) {
                const a5 = i7.paint.get("fill-extrusion-opacity");
                if (0 === a5) return;
                const { isRenderingToTexture: s5 } = o8;
                if ("translucent" === e8.renderPass) {
                  const o9 = new jt(e8.context.gl.LEQUAL, jt.ReadWrite, e8.depthRangeFor3D);
                  if (1 !== a5 || i7.paint.get("fill-extrusion-pattern").constantOr(1)) ro(e8, t5, i7, r8, o9, Nt.disabled, Ft.disabled, s5), ro(e8, t5, i7, r8, o9, e8.stencilModeFor3D(), e8.colorModeForRenderPass(), s5);
                  else {
                    const a6 = e8.colorModeForRenderPass();
                    ro(e8, t5, i7, r8, o9, Nt.disabled, a6, s5);
                  }
                }
              }(e7, i6, r7, o7, a4) : t4.c5(r7) ? function(e8, t5, i7, r8, o8) {
                if ("offscreen" !== e8.renderPass && "translucent" !== e8.renderPass) return;
                const { isRenderingToTexture: a5 } = o8, s5 = e8.context, n6 = e8.style.projection.useSubdivision, l5 = e8.getDepthModeForSublayer(0, jt.ReadOnly), c5 = e8.colorModeForRenderPass();
                if ("offscreen" === e8.renderPass) !function(e9, t6, i8, r9, o9, a6, s6) {
                  const n7 = e9.context, l6 = n7.gl;
                  for (const c6 of i8) {
                    const i9 = t6.getTile(c6), h4 = i9.dem;
                    if (!h4 || !h4.data) continue;
                    if (!i9.needsHillshadePrepare) continue;
                    const u4 = h4.dim, d4 = h4.stride, _4 = h4.getPixels();
                    if (n7.activeTexture.set(l6.TEXTURE1), n7.pixelStoreUnpackPremultiplyAlpha.set(false), i9.demTexture = i9.demTexture || e9.getTileTexture(d4), i9.demTexture) {
                      const e10 = i9.demTexture;
                      e10.update(_4, { premultiply: false }), e10.bind(l6.NEAREST, l6.CLAMP_TO_EDGE);
                    } else i9.demTexture = new v3(n7, _4, l6.RGBA, { premultiply: false }), i9.demTexture.bind(l6.NEAREST, l6.CLAMP_TO_EDGE);
                    n7.activeTexture.set(l6.TEXTURE0);
                    let p4 = i9.fbo;
                    if (!p4) {
                      const e10 = new v3(n7, { width: u4, height: u4, data: null }, l6.RGBA);
                      e10.bind(l6.LINEAR, l6.CLAMP_TO_EDGE), p4 = i9.fbo = n7.createFramebuffer(u4, u4, true, false), p4.colorAttachment.set(e10.texture);
                    }
                    n7.bindFramebuffer.set(p4.framebuffer), n7.viewport.set([0, 0, u4, u4]), e9.useProgram("hillshadePrepare").draw(n7, l6.TRIANGLES, o9, a6, s6, Ot.disabled, Bi(i9.tileID, h4), null, null, r9.id, e9.rasterBoundsBuffer, e9.quadTriangleIndexBuffer, e9.rasterBoundsSegments), i9.needsHillshadePrepare = false;
                  }
                }(e8, t5, r8, i7, l5, Nt.disabled, c5), s5.viewport.set([0, 0, e8.width, e8.height]);
                else if ("translucent" === e8.renderPass) if (n6) {
                  const [o9, s6, n7] = e8.stencilConfigForOverlapTwoPass(r8);
                  oo(e8, t5, i7, n7, o9, l5, c5, false, a5), oo(e8, t5, i7, n7, s6, l5, c5, true, a5);
                } else {
                  const [o9, s6] = e8.getStencilConfigForOverlapAndUpdateStencilID(r8);
                  oo(e8, t5, i7, s6, o9, l5, c5, false, a5);
                }
              }(e7, i6, r7, o7, a4) : t4.c6(r7) ? function(e8, t5, i7, r8, o8) {
                if ("translucent" !== e8.renderPass) return;
                if (0 === i7.paint.get("raster-opacity")) return;
                if (!r8.length) return;
                const { isRenderingToTexture: a5 } = o8, s5 = t5.getSource(), n6 = e8.style.projection.useSubdivision;
                if (s5 instanceof X2) so(e8, t5, i7, r8, null, false, false, s5.tileCoords, s5.flippedWindingOrder, a5);
                else if (n6) {
                  const [o9, s6, n7] = e8.stencilConfigForOverlapTwoPass(r8);
                  so(e8, t5, i7, n7, o9, false, true, ao, false, a5), so(e8, t5, i7, n7, s6, true, true, ao, false, a5);
                } else {
                  const [o9, s6] = e8.getStencilConfigForOverlapAndUpdateStencilID(r8);
                  so(e8, t5, i7, s6, o9, false, true, ao, false, a5);
                }
              }(e7, i6, r7, o7, a4) : t4.c7(r7) ? function(e8, t5, i7, r8, o8) {
                const a5 = i7.paint.get("background-color"), s5 = i7.paint.get("background-opacity");
                if (0 === s5) return;
                const { isRenderingToTexture: n6 } = o8, l5 = e8.context, c5 = l5.gl, h4 = e8.style.projection, u4 = e8.transform, d4 = u4.tileSize, _4 = i7.paint.get("background-pattern");
                if (e8.isPatternMissing(_4)) return;
                const p4 = !_4 && 1 === a5.a && 1 === s5 && e8.opaquePassEnabledForLayer() ? "opaque" : "translucent";
                if (e8.renderPass !== p4) return;
                const m4 = Nt.disabled, f4 = e8.getDepthModeForSublayer(0, "opaque" === p4 ? jt.ReadWrite : jt.ReadOnly), g4 = e8.colorModeForRenderPass(), v4 = e8.useProgram(_4 ? "backgroundPattern" : "background"), x4 = r8 || ue(u4, { tileSize: d4, terrain: e8.style.map.terrain });
                _4 && (l5.activeTexture.set(c5.TEXTURE0), e8.imageManager.bind(e8.context));
                const b5 = i7.getCrossfadeParameters();
                for (const t6 of x4) {
                  const r9 = u4.getProjectionData({ overscaledTileID: t6, applyGlobeMatrix: !n6, applyTerrainMatrix: true }), o9 = _4 ? Qi(s5, e8, _4, { tileID: t6, tileSize: d4 }, b5) : Xi(s5, a5), p5 = e8.style.map.terrain && e8.style.map.terrain.getTerrainData(t6), x5 = h4.getMeshFromTileID(l5, t6.canonical, false, true, "raster");
                  v4.draw(l5, c5.TRIANGLES, f4, m4, g4, Ot.backCCW, o9, p5, r9, i7.id, x5.vertexBuffer, x5.indexBuffer, x5.segments);
                }
              }(e7, 0, r7, o7, a4) : t4.c8(r7) && function(e8, t5, i7, r8) {
                const { isRenderingGlobe: o8 } = r8, a5 = e8.context, s5 = i7.implementation, n6 = e8.style.projection, l5 = e8.transform, c5 = l5.getProjectionDataForCustomLayer(o8), h4 = { farZ: l5.farZ, nearZ: l5.nearZ, fov: l5.fov * Math.PI / 180, modelViewProjectionMatrix: l5.modelViewProjectionMatrix, projectionMatrix: l5.projectionMatrix, shaderData: { variantName: n6.shaderVariantName, vertexShaderPrelude: `const float PI = 3.141592653589793;
uniform mat4 u_projection_matrix;
${n6.shaderPreludeCode.vertexSource}`, define: n6.shaderDefine }, defaultProjectionData: c5 }, u4 = s5.renderingMode ? s5.renderingMode : "2d";
                if ("offscreen" === e8.renderPass) {
                  const t6 = s5.prerender;
                  t6 && (e8.setCustomLayerDefaults(), a5.setColorMode(e8.colorModeForRenderPass()), t6.call(s5, a5.gl, h4), a5.setDirty(), e8.setBaseState());
                } else if ("translucent" === e8.renderPass) {
                  e8.setCustomLayerDefaults(), a5.setColorMode(e8.colorModeForRenderPass()), a5.setStencilMode(Nt.disabled);
                  const t6 = "3d" === u4 ? e8.getDepthModeFor3D() : e8.getDepthModeForSublayer(0, jt.ReadOnly);
                  a5.setDepthMode(t6), s5.render(a5.gl, h4), a5.setDirty(), e8.setBaseState(), a5.bindFramebuffer.set(null);
                }
              }(e7, 0, r7, a4));
            }
            saveTileTexture(e7) {
              const t5 = this._tileTextures[e7.size[0]];
              t5 ? t5.push(e7) : this._tileTextures[e7.size[0]] = [e7];
            }
            getTileTexture(e7) {
              const t5 = this._tileTextures[e7];
              return t5 && t5.length > 0 ? t5.pop() : null;
            }
            isPatternMissing(e7) {
              if (!e7) return false;
              if (!e7.from || !e7.to) return true;
              const t5 = this.imageManager.getPattern(e7.from.toString()), i6 = this.imageManager.getPattern(e7.to.toString());
              return !t5 || !i6;
            }
            useProgram(e7, t5, i6 = false) {
              this.cache = this.cache || {};
              const r7 = !!this.style.map.terrain, o7 = this.style.projection, a4 = e7 + (t5 ? t5.cacheKey : "") + `/${i6 ? gt : o7.shaderVariantName}` + (this._showOverdrawInspector ? "/overdraw" : "") + (r7 ? "/terrain" : "");
              return this.cache[a4] || (this.cache[a4] = new Ti(this.context, dt[e7], t5, Ji[e7], this._showOverdrawInspector, r7, i6 ? dt.projectionMercator : o7.shaderPreludeCode, i6 ? ft : o7.shaderDefine)), this.cache[a4];
            }
            setCustomLayerDefaults() {
              this.context.unbindVAO(), this.context.cullFace.setDefault(), this.context.activeTexture.setDefault(), this.context.pixelStoreUnpack.setDefault(), this.context.pixelStoreUnpackPremultiplyAlpha.setDefault(), this.context.pixelStoreUnpackFlipY.setDefault();
            }
            setBaseState() {
              const e7 = this.context.gl;
              this.context.cullFace.set(false), this.context.viewport.set([0, 0, this.width, this.height]), this.context.blendEquation.set(e7.FUNC_ADD);
            }
            initDebugOverlayCanvas() {
              null == this.debugOverlayCanvas && (this.debugOverlayCanvas = document.createElement("canvas"), this.debugOverlayCanvas.width = 512, this.debugOverlayCanvas.height = 512, this.debugOverlayTexture = new v3(this.context, this.debugOverlayCanvas, this.context.gl.RGBA));
            }
            destroy() {
              this.debugOverlayTexture && this.debugOverlayTexture.destroy();
            }
            overLimit() {
              const { drawingBufferWidth: e7, drawingBufferHeight: t5 } = this.context.gl;
              return this.width !== e7 || this.height !== t5;
            }
          }
          function yo(e7, t5) {
            let i6, r7 = false, o7 = null, a4 = null;
            const s5 = () => {
              o7 = null, r7 && (e7.apply(a4, i6), o7 = setTimeout(s5, t5), r7 = false);
            };
            return (...e8) => (r7 = true, a4 = this, i6 = e8, o7 || s5(), o7);
          }
          class wo {
            constructor(e7) {
              this._getCurrentHash = () => {
                const e8 = window.location.hash.replace("#", "");
                if (this._hashName) {
                  let t5;
                  return e8.split("&").map((e9) => e9.split("=")).forEach((e9) => {
                    e9[0] === this._hashName && (t5 = e9);
                  }), (t5 && t5[1] || "").split("/");
                }
                return e8.split("/");
              }, this._onHashChange = () => {
                const e8 = this._getCurrentHash();
                if (!this._isValidHash(e8)) return false;
                const t5 = this._map.dragRotate.isEnabled() && this._map.touchZoomRotate.isEnabled() ? +(e8[3] || 0) : this._map.getBearing();
                return this._map.jumpTo({ center: [+e8[2], +e8[1]], zoom: +e8[0], bearing: t5, pitch: +(e8[4] || 0) }), true;
              }, this._updateHashUnthrottled = () => {
                const e8 = window.location.href.replace(/(#.*)?$/, this.getHashString());
                window.history.replaceState(window.history.state, null, e8);
              }, this._removeHash = () => {
                const e8 = this._getCurrentHash();
                if (0 === e8.length) return;
                const t5 = e8.join("/");
                let i6 = t5;
                i6.split("&").length > 0 && (i6 = i6.split("&")[0]), this._hashName && (i6 = `${this._hashName}=${t5}`);
                let r7 = window.location.hash.replace(i6, "");
                r7.startsWith("#&") ? r7 = r7.slice(0, 1) + r7.slice(2) : "#" === r7 && (r7 = "");
                let o7 = window.location.href.replace(/(#.+)?$/, r7);
                o7 = o7.replace("&&", "&"), window.history.replaceState(window.history.state, null, o7);
              }, this._updateHash = yo(this._updateHashUnthrottled, 300), this._hashName = e7 && encodeURIComponent(e7);
            }
            addTo(e7) {
              return this._map = e7, addEventListener("hashchange", this._onHashChange, false), this._map.on("moveend", this._updateHash), this;
            }
            remove() {
              return removeEventListener("hashchange", this._onHashChange, false), this._map.off("moveend", this._updateHash), clearTimeout(this._updateHash()), this._removeHash(), delete this._map, this;
            }
            getHashString(e7) {
              const t5 = this._map.getCenter(), i6 = Math.round(100 * this._map.getZoom()) / 100, r7 = Math.ceil((i6 * Math.LN2 + Math.log(512 / 360 / 0.5)) / Math.LN10), o7 = Math.pow(10, r7), a4 = Math.round(t5.lng * o7) / o7, s5 = Math.round(t5.lat * o7) / o7, n6 = this._map.getBearing(), l5 = this._map.getPitch();
              let c5 = "";
              if (c5 += e7 ? `/${a4}/${s5}/${i6}` : `${i6}/${s5}/${a4}`, (n6 || l5) && (c5 += "/" + Math.round(10 * n6) / 10), l5 && (c5 += `/${Math.round(l5)}`), this._hashName) {
                const e8 = this._hashName;
                let t6 = false;
                const i7 = window.location.hash.slice(1).split("&").map((i8) => {
                  const r8 = i8.split("=")[0];
                  return r8 === e8 ? (t6 = true, `${r8}=${c5}`) : i8;
                }).filter((e9) => e9);
                return t6 || i7.push(`${e8}=${c5}`), `#${i7.join("&")}`;
              }
              return `#${c5}`;
            }
            _isValidHash(e7) {
              if (e7.length < 3 || e7.some(isNaN)) return false;
              try {
                new t4.Q(+e7[2], +e7[1]);
              } catch (e8) {
                return false;
              }
              const i6 = +e7[0], r7 = +(e7[3] || 0), o7 = +(e7[4] || 0);
              return i6 >= this._map.getMinZoom() && i6 <= this._map.getMaxZoom() && r7 >= -180 && r7 <= 180 && o7 >= this._map.getMinPitch() && o7 <= this._map.getMaxPitch();
            }
          }
          const To = { linearity: 0.3, easing: t4.c9(0, 0, 0.3, 1) }, Po = t4.e({ deceleration: 2500, maxSpeed: 1400 }, To), Co = t4.e({ deceleration: 20, maxSpeed: 1400 }, To), Io = t4.e({ deceleration: 1e3, maxSpeed: 360 }, To), Mo = t4.e({ deceleration: 1e3, maxSpeed: 90 }, To), Eo = t4.e({ deceleration: 1e3, maxSpeed: 360 }, To);
          class So {
            constructor(e7) {
              this._map = e7, this.clear();
            }
            clear() {
              this._inertiaBuffer = [];
            }
            record(e7) {
              this._drainInertiaBuffer(), this._inertiaBuffer.push({ time: s4.now(), settings: e7 });
            }
            _drainInertiaBuffer() {
              const e7 = this._inertiaBuffer, t5 = s4.now();
              for (; e7.length > 0 && t5 - e7[0].time > 160; ) e7.shift();
            }
            _onMoveEnd(e7) {
              if (this._drainInertiaBuffer(), this._inertiaBuffer.length < 2) return;
              const i6 = { zoom: 0, bearing: 0, pitch: 0, roll: 0, pan: new t4.P(0, 0), pinchAround: void 0, around: void 0 };
              for (const { settings: e8 } of this._inertiaBuffer) i6.zoom += e8.zoomDelta || 0, i6.bearing += e8.bearingDelta || 0, i6.pitch += e8.pitchDelta || 0, i6.roll += e8.rollDelta || 0, e8.panDelta && i6.pan._add(e8.panDelta), e8.around && (i6.around = e8.around), e8.pinchAround && (i6.pinchAround = e8.pinchAround);
              const r7 = this._inertiaBuffer[this._inertiaBuffer.length - 1].time - this._inertiaBuffer[0].time, o7 = {};
              if (i6.pan.mag()) {
                const a4 = Do(i6.pan.mag(), r7, t4.e({}, Po, e7 || {})), s5 = i6.pan.mult(a4.amount / i6.pan.mag()), n6 = this._map.cameraHelper.handlePanInertia(s5, this._map.transform);
                o7.center = n6.easingCenter, o7.offset = n6.easingOffset, Ro(o7, a4);
              }
              if (i6.zoom) {
                const e8 = Do(i6.zoom, r7, Co);
                o7.zoom = this._map.transform.zoom + e8.amount, Ro(o7, e8);
              }
              if (i6.bearing) {
                const e8 = Do(i6.bearing, r7, Io);
                o7.bearing = this._map.transform.bearing + t4.ae(e8.amount, -179, 179), Ro(o7, e8);
              }
              if (i6.pitch) {
                const e8 = Do(i6.pitch, r7, Mo);
                o7.pitch = this._map.transform.pitch + e8.amount, Ro(o7, e8);
              }
              if (i6.roll) {
                const e8 = Do(i6.roll, r7, Eo);
                o7.roll = this._map.transform.roll + t4.ae(e8.amount, -179, 179), Ro(o7, e8);
              }
              if (o7.zoom || o7.bearing) {
                const e8 = void 0 === i6.pinchAround ? i6.around : i6.pinchAround;
                o7.around = e8 ? this._map.unproject(e8) : this._map.getCenter();
              }
              return this.clear(), t4.e(o7, { noMoveStart: true });
            }
          }
          function Ro(e7, t5) {
            (!e7.duration || e7.duration < t5.duration) && (e7.duration = t5.duration, e7.easing = t5.easing);
          }
          function Do(e7, i6, r7) {
            const { maxSpeed: o7, linearity: a4, deceleration: s5 } = r7, n6 = t4.ae(e7 * a4 / (i6 / 1e3), -o7, o7), l5 = Math.abs(n6) / (s5 * a4);
            return { easing: r7.easing, duration: 1e3 * l5, amount: n6 * (l5 / 2) };
          }
          class zo extends t4.l {
            preventDefault() {
              this._defaultPrevented = true;
            }
            get defaultPrevented() {
              return this._defaultPrevented;
            }
            constructor(e7, i6, r7, o7 = {}) {
              r7 = r7 instanceof MouseEvent ? r7 : new MouseEvent(e7, r7);
              const a4 = n5.mousePos(i6.getCanvas(), r7), s5 = i6.unproject(a4);
              super(e7, t4.e({ point: a4, lngLat: s5, originalEvent: r7 }, o7)), this._defaultPrevented = false, this.target = i6;
            }
          }
          class Ao extends t4.l {
            preventDefault() {
              this._defaultPrevented = true;
            }
            get defaultPrevented() {
              return this._defaultPrevented;
            }
            constructor(e7, i6, r7) {
              const o7 = "touchend" === e7 ? r7.changedTouches : r7.touches, a4 = n5.touchPos(i6.getCanvasContainer(), o7), s5 = a4.map((e8) => i6.unproject(e8)), l5 = a4.reduce((e8, t5, i7, r8) => e8.add(t5.div(r8.length)), new t4.P(0, 0));
              super(e7, { points: a4, point: l5, lngLats: s5, lngLat: i6.unproject(l5), originalEvent: r7 }), this._defaultPrevented = false;
            }
          }
          class Lo extends t4.l {
            preventDefault() {
              this._defaultPrevented = true;
            }
            get defaultPrevented() {
              return this._defaultPrevented;
            }
            constructor(e7, t5, i6) {
              super(e7, { originalEvent: i6 }), this._defaultPrevented = false;
            }
          }
          class ko {
            constructor(e7, t5) {
              this._map = e7, this._clickTolerance = t5.clickTolerance;
            }
            reset() {
              delete this._mousedownPos;
            }
            wheel(e7) {
              return this._firePreventable(new Lo(e7.type, this._map, e7));
            }
            mousedown(e7, t5) {
              return this._mousedownPos = t5, this._firePreventable(new zo(e7.type, this._map, e7));
            }
            mouseup(e7) {
              this._map.fire(new zo(e7.type, this._map, e7));
            }
            click(e7, t5) {
              this._mousedownPos && this._mousedownPos.dist(t5) >= this._clickTolerance || this._map.fire(new zo(e7.type, this._map, e7));
            }
            dblclick(e7) {
              return this._firePreventable(new zo(e7.type, this._map, e7));
            }
            mouseover(e7) {
              this._map.fire(new zo(e7.type, this._map, e7));
            }
            mouseout(e7) {
              this._map.fire(new zo(e7.type, this._map, e7));
            }
            touchstart(e7) {
              return this._firePreventable(new Ao(e7.type, this._map, e7));
            }
            touchmove(e7) {
              this._map.fire(new Ao(e7.type, this._map, e7));
            }
            touchend(e7) {
              this._map.fire(new Ao(e7.type, this._map, e7));
            }
            touchcancel(e7) {
              this._map.fire(new Ao(e7.type, this._map, e7));
            }
            _firePreventable(e7) {
              if (this._map.fire(e7), e7.defaultPrevented) return {};
            }
            isEnabled() {
              return true;
            }
            isActive() {
              return false;
            }
            enable() {
            }
            disable() {
            }
          }
          class Fo {
            constructor(e7) {
              this._map = e7;
            }
            reset() {
              this._delayContextMenu = false, this._ignoreContextMenu = true, delete this._contextMenuEvent;
            }
            mousemove(e7) {
              this._map.fire(new zo(e7.type, this._map, e7));
            }
            mousedown() {
              this._delayContextMenu = true, this._ignoreContextMenu = false;
            }
            mouseup() {
              this._delayContextMenu = false, this._contextMenuEvent && (this._map.fire(new zo("contextmenu", this._map, this._contextMenuEvent)), delete this._contextMenuEvent);
            }
            contextmenu(e7) {
              this._delayContextMenu ? this._contextMenuEvent = e7 : this._ignoreContextMenu || this._map.fire(new zo(e7.type, this._map, e7)), this._map.listens("contextmenu") && e7.preventDefault();
            }
            isEnabled() {
              return true;
            }
            isActive() {
              return false;
            }
            enable() {
            }
            disable() {
            }
          }
          class Bo {
            constructor(e7) {
              this._map = e7;
            }
            get transform() {
              return this._map._requestedCameraState || this._map.transform;
            }
            get center() {
              return { lng: this.transform.center.lng, lat: this.transform.center.lat };
            }
            get zoom() {
              return this.transform.zoom;
            }
            get pitch() {
              return this.transform.pitch;
            }
            get bearing() {
              return this.transform.bearing;
            }
            unproject(e7) {
              return this.transform.screenPointToLocation(t4.P.convert(e7), this._map.terrain);
            }
          }
          class Oo {
            constructor(e7, t5) {
              this._map = e7, this._tr = new Bo(e7), this._el = e7.getCanvasContainer(), this._container = e7.getContainer(), this._clickTolerance = t5.clickTolerance || 1;
            }
            isEnabled() {
              return !!this._enabled;
            }
            isActive() {
              return !!this._active;
            }
            enable() {
              this.isEnabled() || (this._enabled = true);
            }
            disable() {
              this.isEnabled() && (this._enabled = false);
            }
            mousedown(e7, t5) {
              this.isEnabled() && e7.shiftKey && 0 === e7.button && (n5.disableDrag(), this._startPos = this._lastPos = t5, this._active = true);
            }
            mousemoveWindow(e7, t5) {
              if (!this._active) return;
              const i6 = t5;
              if (this._lastPos.equals(i6) || !this._box && i6.dist(this._startPos) < this._clickTolerance) return;
              const r7 = this._startPos;
              this._lastPos = i6, this._box || (this._box = n5.create("div", "maplibregl-boxzoom", this._container), this._container.classList.add("maplibregl-crosshair"), this._fireEvent("boxzoomstart", e7));
              const o7 = Math.min(r7.x, i6.x), a4 = Math.max(r7.x, i6.x), s5 = Math.min(r7.y, i6.y), l5 = Math.max(r7.y, i6.y);
              n5.setTransform(this._box, `translate(${o7}px,${s5}px)`), this._box.style.width = a4 - o7 + "px", this._box.style.height = l5 - s5 + "px";
            }
            mouseupWindow(e7, i6) {
              if (!this._active) return;
              if (0 !== e7.button) return;
              const r7 = this._startPos, o7 = i6;
              if (this.reset(), n5.suppressClick(), r7.x !== o7.x || r7.y !== o7.y) return this._map.fire(new t4.l("boxzoomend", { originalEvent: e7 })), { cameraAnimation: (e8) => e8.fitScreenCoordinates(r7, o7, this._tr.bearing, { linear: true }) };
              this._fireEvent("boxzoomcancel", e7);
            }
            keydown(e7) {
              this._active && 27 === e7.keyCode && (this.reset(), this._fireEvent("boxzoomcancel", e7));
            }
            reset() {
              this._active = false, this._container.classList.remove("maplibregl-crosshair"), this._box && (n5.remove(this._box), this._box = null), n5.enableDrag(), delete this._startPos, delete this._lastPos;
            }
            _fireEvent(e7, i6) {
              return this._map.fire(new t4.l(e7, { originalEvent: i6 }));
            }
          }
          function jo(e7, t5) {
            if (e7.length !== t5.length) throw new Error(`The number of touches and points are not equal - touches ${e7.length}, points ${t5.length}`);
            const i6 = {};
            for (let r7 = 0; r7 < e7.length; r7++) i6[e7[r7].identifier] = t5[r7];
            return i6;
          }
          class Zo {
            constructor(e7) {
              this.reset(), this.numTouches = e7.numTouches;
            }
            reset() {
              delete this.centroid, delete this.startTime, delete this.touches, this.aborted = false;
            }
            touchstart(e7, i6, r7) {
              (this.centroid || r7.length > this.numTouches) && (this.aborted = true), this.aborted || (void 0 === this.startTime && (this.startTime = e7.timeStamp), r7.length === this.numTouches && (this.centroid = function(e8) {
                const i7 = new t4.P(0, 0);
                for (const t5 of e8) i7._add(t5);
                return i7.div(e8.length);
              }(i6), this.touches = jo(r7, i6)));
            }
            touchmove(e7, t5, i6) {
              if (this.aborted || !this.centroid) return;
              const r7 = jo(i6, t5);
              for (const e8 in this.touches) {
                const t6 = r7[e8];
                (!t6 || t6.dist(this.touches[e8]) > 30) && (this.aborted = true);
              }
            }
            touchend(e7, t5, i6) {
              if ((!this.centroid || e7.timeStamp - this.startTime > 500) && (this.aborted = true), 0 === i6.length) {
                const e8 = !this.aborted && this.centroid;
                if (this.reset(), e8) return e8;
              }
            }
          }
          class No {
            constructor(e7) {
              this.singleTap = new Zo(e7), this.numTaps = e7.numTaps, this.reset();
            }
            reset() {
              this.lastTime = 1 / 0, delete this.lastTap, this.count = 0, this.singleTap.reset();
            }
            touchstart(e7, t5, i6) {
              this.singleTap.touchstart(e7, t5, i6);
            }
            touchmove(e7, t5, i6) {
              this.singleTap.touchmove(e7, t5, i6);
            }
            touchend(e7, t5, i6) {
              const r7 = this.singleTap.touchend(e7, t5, i6);
              if (r7) {
                const t6 = e7.timeStamp - this.lastTime < 500, i7 = !this.lastTap || this.lastTap.dist(r7) < 30;
                if (t6 && i7 || this.reset(), this.count++, this.lastTime = e7.timeStamp, this.lastTap = r7, this.count === this.numTaps) return this.reset(), r7;
              }
            }
          }
          class Go {
            constructor(e7) {
              this._tr = new Bo(e7), this._zoomIn = new No({ numTouches: 1, numTaps: 2 }), this._zoomOut = new No({ numTouches: 2, numTaps: 1 }), this.reset();
            }
            reset() {
              this._active = false, this._zoomIn.reset(), this._zoomOut.reset();
            }
            touchstart(e7, t5, i6) {
              this._zoomIn.touchstart(e7, t5, i6), this._zoomOut.touchstart(e7, t5, i6);
            }
            touchmove(e7, t5, i6) {
              this._zoomIn.touchmove(e7, t5, i6), this._zoomOut.touchmove(e7, t5, i6);
            }
            touchend(e7, t5, i6) {
              const r7 = this._zoomIn.touchend(e7, t5, i6), o7 = this._zoomOut.touchend(e7, t5, i6), a4 = this._tr;
              return r7 ? (this._active = true, e7.preventDefault(), setTimeout(() => this.reset(), 0), { cameraAnimation: (t6) => t6.easeTo({ duration: 300, zoom: a4.zoom + 1, around: a4.unproject(r7) }, { originalEvent: e7 }) }) : o7 ? (this._active = true, e7.preventDefault(), setTimeout(() => this.reset(), 0), { cameraAnimation: (t6) => t6.easeTo({ duration: 300, zoom: a4.zoom - 1, around: a4.unproject(o7) }, { originalEvent: e7 }) }) : void 0;
            }
            touchcancel() {
              this.reset();
            }
            enable() {
              this._enabled = true;
            }
            disable() {
              this._enabled = false, this.reset();
            }
            isEnabled() {
              return this._enabled;
            }
            isActive() {
              return this._active;
            }
          }
          class Uo {
            constructor(e7) {
              this._enabled = !!e7.enable, this._moveStateManager = e7.moveStateManager, this._clickTolerance = e7.clickTolerance || 1, this._moveFunction = e7.move, this._activateOnStart = !!e7.activateOnStart, e7.assignEvents(this), this.reset();
            }
            reset(e7) {
              this._active = false, this._moved = false, delete this._lastPoint, this._moveStateManager.endMove(e7);
            }
            _move(...e7) {
              const t5 = this._moveFunction(...e7);
              if (t5.bearingDelta || t5.pitchDelta || t5.rollDelta || t5.around || t5.panDelta) return this._active = true, t5;
            }
            dragStart(e7, t5) {
              this.isEnabled() && !this._lastPoint && this._moveStateManager.isValidStartEvent(e7) && (this._moveStateManager.startMove(e7), this._lastPoint = Array.isArray(t5) ? t5[0] : t5, this._activateOnStart && this._lastPoint && (this._active = true));
            }
            dragMove(e7, t5) {
              if (!this.isEnabled()) return;
              const i6 = this._lastPoint;
              if (!i6) return;
              if (e7.preventDefault(), !this._moveStateManager.isValidMoveEvent(e7)) return void this.reset(e7);
              const r7 = Array.isArray(t5) ? t5[0] : t5;
              return !this._moved && r7.dist(i6) < this._clickTolerance ? void 0 : (this._moved = true, this._lastPoint = r7, this._move(i6, r7));
            }
            dragEnd(e7) {
              this.isEnabled() && this._lastPoint && this._moveStateManager.isValidEndEvent(e7) && (this._moved && n5.suppressClick(), this.reset(e7));
            }
            enable() {
              this._enabled = true;
            }
            disable() {
              this._enabled = false, this.reset();
            }
            isEnabled() {
              return this._enabled;
            }
            isActive() {
              return this._active;
            }
            getClickTolerance() {
              return this._clickTolerance;
            }
          }
          const Vo = { 0: 1, 2: 2 };
          class qo {
            constructor(e7) {
              this._correctEvent = e7.checkCorrectEvent;
            }
            startMove(e7) {
              const t5 = n5.mouseButton(e7);
              this._eventButton = t5;
            }
            endMove(e7) {
              delete this._eventButton;
            }
            isValidStartEvent(e7) {
              return this._correctEvent(e7);
            }
            isValidMoveEvent(e7) {
              return !function(e8, t5) {
                const i6 = Vo[t5];
                return void 0 === e8.buttons || (e8.buttons & i6) !== i6;
              }(e7, this._eventButton);
            }
            isValidEndEvent(e7) {
              return n5.mouseButton(e7) === this._eventButton;
            }
          }
          class Wo {
            constructor() {
              this._firstTouch = void 0;
            }
            _isOneFingerTouch(e7) {
              return 1 === e7.targetTouches.length;
            }
            _isSameTouchEvent(e7) {
              return e7.targetTouches[0].identifier === this._firstTouch;
            }
            startMove(e7) {
              this._firstTouch = e7.targetTouches[0].identifier;
            }
            endMove(e7) {
              delete this._firstTouch;
            }
            isValidStartEvent(e7) {
              return this._isOneFingerTouch(e7);
            }
            isValidMoveEvent(e7) {
              return this._isOneFingerTouch(e7) && this._isSameTouchEvent(e7);
            }
            isValidEndEvent(e7) {
              return this._isOneFingerTouch(e7) && this._isSameTouchEvent(e7);
            }
          }
          class $o {
            constructor(e7 = new qo({ checkCorrectEvent: () => true }), t5 = new Wo()) {
              this.mouseMoveStateManager = e7, this.oneFingerTouchMoveStateManager = t5;
            }
            _executeRelevantHandler(e7, t5, i6) {
              return e7 instanceof MouseEvent ? t5(e7) : "undefined" != typeof TouchEvent && e7 instanceof TouchEvent ? i6(e7) : void 0;
            }
            startMove(e7) {
              this._executeRelevantHandler(e7, (e8) => this.mouseMoveStateManager.startMove(e8), (e8) => this.oneFingerTouchMoveStateManager.startMove(e8));
            }
            endMove(e7) {
              this._executeRelevantHandler(e7, (e8) => this.mouseMoveStateManager.endMove(e8), (e8) => this.oneFingerTouchMoveStateManager.endMove(e8));
            }
            isValidStartEvent(e7) {
              return this._executeRelevantHandler(e7, (e8) => this.mouseMoveStateManager.isValidStartEvent(e8), (e8) => this.oneFingerTouchMoveStateManager.isValidStartEvent(e8));
            }
            isValidMoveEvent(e7) {
              return this._executeRelevantHandler(e7, (e8) => this.mouseMoveStateManager.isValidMoveEvent(e8), (e8) => this.oneFingerTouchMoveStateManager.isValidMoveEvent(e8));
            }
            isValidEndEvent(e7) {
              return this._executeRelevantHandler(e7, (e8) => this.mouseMoveStateManager.isValidEndEvent(e8), (e8) => this.oneFingerTouchMoveStateManager.isValidEndEvent(e8));
            }
          }
          const Ho = (e7) => {
            e7.mousedown = e7.dragStart, e7.mousemoveWindow = e7.dragMove, e7.mouseup = e7.dragEnd, e7.contextmenu = (e8) => {
              e8.preventDefault();
            };
          };
          class Ko {
            constructor(e7, t5) {
              this._clickTolerance = e7.clickTolerance || 1, this._map = t5, this.reset();
            }
            reset() {
              this._active = false, this._touches = {}, this._sum = new t4.P(0, 0);
            }
            _shouldBePrevented(e7) {
              return e7 < (this._map.cooperativeGestures.isEnabled() ? 2 : 1);
            }
            touchstart(e7, t5, i6) {
              return this._calculateTransform(e7, t5, i6);
            }
            touchmove(e7, t5, i6) {
              if (this._active) {
                if (!this._shouldBePrevented(i6.length)) return e7.preventDefault(), this._calculateTransform(e7, t5, i6);
                this._map.cooperativeGestures.notifyGestureBlocked("touch_pan", e7);
              }
            }
            touchend(e7, t5, i6) {
              this._calculateTransform(e7, t5, i6), this._active && this._shouldBePrevented(i6.length) && this.reset();
            }
            touchcancel() {
              this.reset();
            }
            _calculateTransform(e7, i6, r7) {
              r7.length > 0 && (this._active = true);
              const o7 = jo(r7, i6), a4 = new t4.P(0, 0), s5 = new t4.P(0, 0);
              let n6 = 0;
              for (const e8 in o7) {
                const t5 = o7[e8], i7 = this._touches[e8];
                i7 && (a4._add(t5), s5._add(t5.sub(i7)), n6++, o7[e8] = t5);
              }
              if (this._touches = o7, this._shouldBePrevented(n6) || !s5.mag()) return;
              const l5 = s5.div(n6);
              return this._sum._add(l5), this._sum.mag() < this._clickTolerance ? void 0 : { around: a4.div(n6), panDelta: l5 };
            }
            enable() {
              this._enabled = true;
            }
            disable() {
              this._enabled = false, this.reset();
            }
            isEnabled() {
              return this._enabled;
            }
            isActive() {
              return this._active;
            }
          }
          class Xo {
            constructor() {
              this.reset();
            }
            reset() {
              this._active = false, delete this._firstTwoTouches;
            }
            touchstart(e7, t5, i6) {
              this._firstTwoTouches || i6.length < 2 || (this._firstTwoTouches = [i6[0].identifier, i6[1].identifier], this._start([t5[0], t5[1]]));
            }
            touchmove(e7, t5, i6) {
              if (!this._firstTwoTouches) return;
              e7.preventDefault();
              const [r7, o7] = this._firstTwoTouches, a4 = Qo(i6, t5, r7), s5 = Qo(i6, t5, o7);
              if (!a4 || !s5) return;
              const n6 = this._aroundCenter ? null : a4.add(s5).div(2);
              return this._move([a4, s5], n6, e7);
            }
            touchend(e7, t5, i6) {
              if (!this._firstTwoTouches) return;
              const [r7, o7] = this._firstTwoTouches, a4 = Qo(i6, t5, r7), s5 = Qo(i6, t5, o7);
              a4 && s5 || (this._active && n5.suppressClick(), this.reset());
            }
            touchcancel() {
              this.reset();
            }
            enable(e7) {
              this._enabled = true, this._aroundCenter = !!e7 && "center" === e7.around;
            }
            disable() {
              this._enabled = false, this.reset();
            }
            isEnabled() {
              return !!this._enabled;
            }
            isActive() {
              return !!this._active;
            }
          }
          function Qo(e7, t5, i6) {
            for (let r7 = 0; r7 < e7.length; r7++) if (e7[r7].identifier === i6) return t5[r7];
          }
          function Yo(e7, t5) {
            return Math.log(e7 / t5) / Math.LN2;
          }
          class Jo extends Xo {
            reset() {
              super.reset(), delete this._distance, delete this._startDistance;
            }
            _start(e7) {
              this._startDistance = this._distance = e7[0].dist(e7[1]);
            }
            _move(e7, t5) {
              const i6 = this._distance;
              if (this._distance = e7[0].dist(e7[1]), this._active || !(Math.abs(Yo(this._distance, this._startDistance)) < 0.1)) return this._active = true, { zoomDelta: Yo(this._distance, i6), pinchAround: t5 };
            }
          }
          function ea(e7, t5) {
            return 180 * e7.angleWith(t5) / Math.PI;
          }
          class ta extends Xo {
            reset() {
              super.reset(), delete this._minDiameter, delete this._startVector, delete this._vector;
            }
            _start(e7) {
              this._startVector = this._vector = e7[0].sub(e7[1]), this._minDiameter = e7[0].dist(e7[1]);
            }
            _move(e7, t5, i6) {
              const r7 = this._vector;
              if (this._vector = e7[0].sub(e7[1]), this._active || !this._isBelowThreshold(this._vector)) return this._active = true, { bearingDelta: ea(this._vector, r7), pinchAround: t5 };
            }
            _isBelowThreshold(e7) {
              this._minDiameter = Math.min(this._minDiameter, e7.mag());
              const t5 = 25 / (Math.PI * this._minDiameter) * 360, i6 = ea(e7, this._startVector);
              return Math.abs(i6) < t5;
            }
          }
          function ia(e7) {
            return Math.abs(e7.y) > Math.abs(e7.x);
          }
          class ra extends Xo {
            constructor(e7) {
              super(), this._currentTouchCount = 0, this._map = e7;
            }
            reset() {
              super.reset(), this._valid = void 0, delete this._firstMove, delete this._lastPoints;
            }
            touchstart(e7, t5, i6) {
              super.touchstart(e7, t5, i6), this._currentTouchCount = i6.length;
            }
            _start(e7) {
              this._lastPoints = e7, ia(e7[0].sub(e7[1])) && (this._valid = false);
            }
            _move(e7, t5, i6) {
              if (this._map.cooperativeGestures.isEnabled() && this._currentTouchCount < 3) return;
              const r7 = e7[0].sub(this._lastPoints[0]), o7 = e7[1].sub(this._lastPoints[1]);
              return this._valid = this.gestureBeginsVertically(r7, o7, i6.timeStamp), this._valid ? (this._lastPoints = e7, this._active = true, { pitchDelta: (r7.y + o7.y) / 2 * -0.5 }) : void 0;
            }
            gestureBeginsVertically(e7, t5, i6) {
              if (void 0 !== this._valid) return this._valid;
              const r7 = e7.mag() >= 2, o7 = t5.mag() >= 2;
              if (!r7 && !o7) return;
              if (!r7 || !o7) return void 0 === this._firstMove && (this._firstMove = i6), i6 - this._firstMove < 100 && void 0;
              const a4 = e7.y > 0 == t5.y > 0;
              return ia(e7) && ia(t5) && a4;
            }
          }
          const oa = { panStep: 100, bearingStep: 15, pitchStep: 10 };
          class aa {
            constructor(e7) {
              this._tr = new Bo(e7);
              const t5 = oa;
              this._panStep = t5.panStep, this._bearingStep = t5.bearingStep, this._pitchStep = t5.pitchStep, this._rotationDisabled = false;
            }
            reset() {
              this._active = false;
            }
            keydown(e7) {
              if (e7.altKey || e7.ctrlKey || e7.metaKey) return;
              let t5 = 0, i6 = 0, r7 = 0, o7 = 0, a4 = 0;
              switch (e7.keyCode) {
                case 61:
                case 107:
                case 171:
                case 187:
                  t5 = 1;
                  break;
                case 189:
                case 109:
                case 173:
                  t5 = -1;
                  break;
                case 37:
                  e7.shiftKey ? i6 = -1 : (e7.preventDefault(), o7 = -1);
                  break;
                case 39:
                  e7.shiftKey ? i6 = 1 : (e7.preventDefault(), o7 = 1);
                  break;
                case 38:
                  e7.shiftKey ? r7 = 1 : (e7.preventDefault(), a4 = -1);
                  break;
                case 40:
                  e7.shiftKey ? r7 = -1 : (e7.preventDefault(), a4 = 1);
                  break;
                default:
                  return;
              }
              return this._rotationDisabled && (i6 = 0, r7 = 0), { cameraAnimation: (s5) => {
                const n6 = this._tr;
                s5.easeTo({ duration: 300, easeId: "keyboardHandler", easing: sa, zoom: t5 ? Math.round(n6.zoom) + t5 * (e7.shiftKey ? 2 : 1) : n6.zoom, bearing: n6.bearing + i6 * this._bearingStep, pitch: n6.pitch + r7 * this._pitchStep, offset: [-o7 * this._panStep, -a4 * this._panStep], center: n6.center }, { originalEvent: e7 });
              } };
            }
            enable() {
              this._enabled = true;
            }
            disable() {
              this._enabled = false, this.reset();
            }
            isEnabled() {
              return this._enabled;
            }
            isActive() {
              return this._active;
            }
            disableRotation() {
              this._rotationDisabled = true;
            }
            enableRotation() {
              this._rotationDisabled = false;
            }
          }
          function sa(e7) {
            return e7 * (2 - e7);
          }
          const na = 4.000244140625;
          class la {
            constructor(e7, t5) {
              this._onTimeout = (e8) => {
                this._type = "wheel", this._delta -= this._lastValue, this._active || this._start(e8);
              }, this._map = e7, this._tr = new Bo(e7), this._triggerRenderFrame = t5, this._delta = 0, this._defaultZoomRate = 0.01, this._wheelZoomRate = 0.0022222222222222222;
            }
            setZoomRate(e7) {
              this._defaultZoomRate = e7;
            }
            setWheelZoomRate(e7) {
              this._wheelZoomRate = e7;
            }
            isEnabled() {
              return !!this._enabled;
            }
            isActive() {
              return !!this._active || void 0 !== this._finishTimeout;
            }
            isZooming() {
              return !!this._zooming;
            }
            enable(e7) {
              this.isEnabled() || (this._enabled = true, this._aroundCenter = !!e7 && "center" === e7.around);
            }
            disable() {
              this.isEnabled() && (this._enabled = false);
            }
            _shouldBePrevented(e7) {
              return !!this._map.cooperativeGestures.isEnabled() && !(e7.ctrlKey || this._map.cooperativeGestures.isBypassed(e7));
            }
            wheel(e7) {
              if (!this.isEnabled()) return;
              if (this._shouldBePrevented(e7)) return void this._map.cooperativeGestures.notifyGestureBlocked("wheel_zoom", e7);
              let t5 = e7.deltaMode === WheelEvent.DOM_DELTA_LINE ? 40 * e7.deltaY : e7.deltaY;
              const i6 = s4.now(), r7 = i6 - (this._lastWheelEventTime || 0);
              this._lastWheelEventTime = i6, 0 !== t5 && t5 % na == 0 ? this._type = "wheel" : 0 !== t5 && Math.abs(t5) < 4 ? this._type = "trackpad" : r7 > 400 ? (this._type = null, this._lastValue = t5, this._timeout = setTimeout(this._onTimeout, 40, e7)) : this._type || (this._type = Math.abs(r7 * t5) < 200 ? "trackpad" : "wheel", this._timeout && (clearTimeout(this._timeout), this._timeout = null, t5 += this._lastValue)), e7.shiftKey && t5 && (t5 /= 4), this._type && (this._lastWheelEvent = e7, this._delta -= t5, this._active || this._start(e7)), e7.preventDefault();
            }
            _start(e7) {
              if (!this._delta) return;
              this._frameId && (this._frameId = null), this._active = true, this.isZooming() || (this._zooming = true), this._finishTimeout && (clearTimeout(this._finishTimeout), delete this._finishTimeout);
              const i6 = n5.mousePos(this._map.getCanvas(), e7), r7 = this._tr;
              this._aroundPoint = this._aroundCenter ? r7.transform.locationToScreenPoint(t4.Q.convert(r7.center)) : i6, this._frameId || (this._frameId = true, this._triggerRenderFrame());
            }
            renderFrame() {
              if (!this._frameId) return;
              if (this._frameId = null, !this.isActive()) return;
              const e7 = this._tr.transform;
              if ("number" == typeof this._lastExpectedZoom) {
                const t5 = e7.zoom - this._lastExpectedZoom;
                "number" == typeof this._startZoom && (this._startZoom += t5), "number" == typeof this._targetZoom && (this._targetZoom += t5);
              }
              if (0 !== this._delta) {
                const i7 = "wheel" === this._type && Math.abs(this._delta) > na ? this._wheelZoomRate : this._defaultZoomRate;
                let r8 = 2 / (1 + Math.exp(-Math.abs(this._delta * i7)));
                this._delta < 0 && 0 !== r8 && (r8 = 1 / r8);
                const o8 = "number" != typeof this._targetZoom ? e7.scale : t4.aI(this._targetZoom);
                this._targetZoom = Math.min(e7.maxZoom, Math.max(e7.minZoom, t4.ab(o8 * r8))), "wheel" === this._type && (this._startZoom = e7.zoom, this._easing = this._smoothOutEasing(200)), this._delta = 0;
              }
              const i6 = "number" != typeof this._targetZoom ? e7.zoom : this._targetZoom, r7 = this._startZoom, o7 = this._easing;
              let a4, n6 = false;
              if ("wheel" === this._type && r7 && o7) {
                const e8 = s4.now() - this._lastWheelEventTime, l5 = Math.min((e8 + 5) / 200, 1), c5 = o7(l5);
                a4 = t4.B.number(r7, i6, c5), l5 < 1 ? this._frameId || (this._frameId = true) : n6 = true;
              } else a4 = i6, n6 = true;
              return this._active = true, n6 && (this._active = false, this._finishTimeout = setTimeout(() => {
                this._zooming = false, this._triggerRenderFrame(), delete this._targetZoom, delete this._lastExpectedZoom, delete this._finishTimeout;
              }, 200)), this._lastExpectedZoom = a4, { noInertia: true, needsRenderFrame: !n6, zoomDelta: a4 - e7.zoom, around: this._aroundPoint, originalEvent: this._lastWheelEvent };
            }
            _smoothOutEasing(e7) {
              let i6 = t4.cb;
              if (this._prevEase) {
                const e8 = this._prevEase, r7 = (s4.now() - e8.start) / e8.duration, o7 = e8.easing(r7 + 0.01) - e8.easing(r7), a4 = 0.27 / Math.sqrt(o7 * o7 + 1e-4) * 0.01, n6 = Math.sqrt(0.0729 - a4 * a4);
                i6 = t4.c9(a4, n6, 0.25, 1);
              }
              return this._prevEase = { start: s4.now(), duration: e7, easing: i6 }, i6;
            }
            reset() {
              this._active = false, this._zooming = false, delete this._targetZoom, delete this._lastExpectedZoom, this._finishTimeout && (clearTimeout(this._finishTimeout), delete this._finishTimeout);
            }
          }
          class ca {
            constructor(e7, t5) {
              this._clickZoom = e7, this._tapZoom = t5;
            }
            enable() {
              this._clickZoom.enable(), this._tapZoom.enable();
            }
            disable() {
              this._clickZoom.disable(), this._tapZoom.disable();
            }
            isEnabled() {
              return this._clickZoom.isEnabled() && this._tapZoom.isEnabled();
            }
            isActive() {
              return this._clickZoom.isActive() || this._tapZoom.isActive();
            }
          }
          class ha {
            constructor(e7) {
              this._tr = new Bo(e7), this.reset();
            }
            reset() {
              this._active = false;
            }
            dblclick(e7, t5) {
              return e7.preventDefault(), { cameraAnimation: (i6) => {
                i6.easeTo({ duration: 300, zoom: this._tr.zoom + (e7.shiftKey ? -1 : 1), around: this._tr.unproject(t5) }, { originalEvent: e7 });
              } };
            }
            enable() {
              this._enabled = true;
            }
            disable() {
              this._enabled = false, this.reset();
            }
            isEnabled() {
              return this._enabled;
            }
            isActive() {
              return this._active;
            }
          }
          class ua {
            constructor() {
              this._tap = new No({ numTouches: 1, numTaps: 1 }), this.reset();
            }
            reset() {
              this._active = false, delete this._swipePoint, delete this._swipeTouch, delete this._tapTime, delete this._tapPoint, this._tap.reset();
            }
            touchstart(e7, t5, i6) {
              if (!this._swipePoint) if (this._tapTime) {
                const r7 = t5[0], o7 = e7.timeStamp - this._tapTime < 500, a4 = this._tapPoint.dist(r7) < 30;
                o7 && a4 ? i6.length > 0 && (this._swipePoint = r7, this._swipeTouch = i6[0].identifier) : this.reset();
              } else this._tap.touchstart(e7, t5, i6);
            }
            touchmove(e7, t5, i6) {
              if (this._tapTime) {
                if (this._swipePoint) {
                  if (i6[0].identifier !== this._swipeTouch) return;
                  const r7 = t5[0], o7 = r7.y - this._swipePoint.y;
                  return this._swipePoint = r7, e7.preventDefault(), this._active = true, { zoomDelta: o7 / 128 };
                }
              } else this._tap.touchmove(e7, t5, i6);
            }
            touchend(e7, t5, i6) {
              if (this._tapTime) this._swipePoint && 0 === i6.length && this.reset();
              else {
                const r7 = this._tap.touchend(e7, t5, i6);
                r7 && (this._tapTime = e7.timeStamp, this._tapPoint = r7);
              }
            }
            touchcancel() {
              this.reset();
            }
            enable() {
              this._enabled = true;
            }
            disable() {
              this._enabled = false, this.reset();
            }
            isEnabled() {
              return this._enabled;
            }
            isActive() {
              return this._active;
            }
          }
          class da {
            constructor(e7, t5, i6) {
              this._el = e7, this._mousePan = t5, this._touchPan = i6;
            }
            enable(e7) {
              this._inertiaOptions = e7 || {}, this._mousePan.enable(), this._touchPan.enable(), this._el.classList.add("maplibregl-touch-drag-pan");
            }
            disable() {
              this._mousePan.disable(), this._touchPan.disable(), this._el.classList.remove("maplibregl-touch-drag-pan");
            }
            isEnabled() {
              return this._mousePan.isEnabled() && this._touchPan.isEnabled();
            }
            isActive() {
              return this._mousePan.isActive() || this._touchPan.isActive();
            }
          }
          class _a2 {
            constructor(e7, t5, i6, r7) {
              this._pitchWithRotate = e7.pitchWithRotate, this._rollEnabled = e7.rollEnabled, this._mouseRotate = t5, this._mousePitch = i6, this._mouseRoll = r7;
            }
            enable() {
              this._mouseRotate.enable(), this._pitchWithRotate && this._mousePitch.enable(), this._rollEnabled && this._mouseRoll.enable();
            }
            disable() {
              this._mouseRotate.disable(), this._mousePitch.disable(), this._mouseRoll.disable();
            }
            isEnabled() {
              return this._mouseRotate.isEnabled() && (!this._pitchWithRotate || this._mousePitch.isEnabled()) && (!this._rollEnabled || this._mouseRoll.isEnabled());
            }
            isActive() {
              return this._mouseRotate.isActive() || this._mousePitch.isActive() || this._mouseRoll.isActive();
            }
          }
          class pa {
            constructor(e7, t5, i6, r7) {
              this._el = e7, this._touchZoom = t5, this._touchRotate = i6, this._tapDragZoom = r7, this._rotationDisabled = false, this._enabled = true;
            }
            enable(e7) {
              this._touchZoom.enable(e7), this._rotationDisabled || this._touchRotate.enable(e7), this._tapDragZoom.enable(), this._el.classList.add("maplibregl-touch-zoom-rotate");
            }
            disable() {
              this._touchZoom.disable(), this._touchRotate.disable(), this._tapDragZoom.disable(), this._el.classList.remove("maplibregl-touch-zoom-rotate");
            }
            isEnabled() {
              return this._touchZoom.isEnabled() && (this._rotationDisabled || this._touchRotate.isEnabled()) && this._tapDragZoom.isEnabled();
            }
            isActive() {
              return this._touchZoom.isActive() || this._touchRotate.isActive() || this._tapDragZoom.isActive();
            }
            disableRotation() {
              this._rotationDisabled = true, this._touchRotate.disable();
            }
            enableRotation() {
              this._rotationDisabled = false, this._touchZoom.isEnabled() && this._touchRotate.enable();
            }
          }
          class ma {
            constructor(e7, t5) {
              this._bypassKey = -1 !== navigator.userAgent.indexOf("Mac") ? "metaKey" : "ctrlKey", this._map = e7, this._options = t5, this._enabled = false;
            }
            isActive() {
              return false;
            }
            reset() {
            }
            _setupUI() {
              if (this._container) return;
              const e7 = this._map.getCanvasContainer();
              e7.classList.add("maplibregl-cooperative-gestures"), this._container = n5.create("div", "maplibregl-cooperative-gesture-screen", e7);
              let t5 = this._map._getUIString("CooperativeGesturesHandler.WindowsHelpText");
              "metaKey" === this._bypassKey && (t5 = this._map._getUIString("CooperativeGesturesHandler.MacHelpText"));
              const i6 = this._map._getUIString("CooperativeGesturesHandler.MobileHelpText"), r7 = document.createElement("div");
              r7.className = "maplibregl-desktop-message", r7.textContent = t5, this._container.appendChild(r7);
              const o7 = document.createElement("div");
              o7.className = "maplibregl-mobile-message", o7.textContent = i6, this._container.appendChild(o7), this._container.setAttribute("aria-hidden", "true");
            }
            _destroyUI() {
              this._container && (n5.remove(this._container), this._map.getCanvasContainer().classList.remove("maplibregl-cooperative-gestures")), delete this._container;
            }
            enable() {
              this._setupUI(), this._enabled = true;
            }
            disable() {
              this._enabled = false, this._destroyUI();
            }
            isEnabled() {
              return this._enabled;
            }
            isBypassed(e7) {
              return e7[this._bypassKey];
            }
            notifyGestureBlocked(e7, i6) {
              this._enabled && (this._map.fire(new t4.l("cooperativegestureprevented", { gestureType: e7, originalEvent: i6 })), this._container.classList.add("maplibregl-show"), setTimeout(() => {
                this._container.classList.remove("maplibregl-show");
              }, 100));
            }
          }
          const fa = (e7) => e7.zoom || e7.drag || e7.roll || e7.pitch || e7.rotate;
          class ga extends t4.l {
          }
          function va(e7) {
            return e7.panDelta && e7.panDelta.mag() || e7.zoomDelta || e7.bearingDelta || e7.pitchDelta || e7.rollDelta;
          }
          class xa {
            constructor(e7, i6) {
              this.handleWindowEvent = (e8) => {
                this.handleEvent(e8, `${e8.type}Window`);
              }, this.handleEvent = (e8, i7) => {
                if ("blur" === e8.type) return void this.stop(true);
                this._updatingCamera = true;
                const r8 = "renderFrame" === e8.type ? void 0 : e8, o7 = { needsRenderFrame: false }, a4 = {}, s5 = {};
                for (const { handlerName: l6, handler: c6, allowed: h4 } of this._handlers) {
                  if (!c6.isEnabled()) continue;
                  let u4;
                  if (this._blockedByActive(s5, h4, l6)) c6.reset();
                  else if (c6[i7 || e8.type]) {
                    if (t4.cc(e8, i7 || e8.type)) {
                      const t5 = n5.mousePos(this._map.getCanvas(), e8);
                      u4 = c6[i7 || e8.type](e8, t5);
                    } else if (t4.cd(e8, i7 || e8.type)) {
                      const t5 = this._getMapTouches(e8.touches), r9 = n5.touchPos(this._map.getCanvas(), t5);
                      u4 = c6[i7 || e8.type](e8, r9, t5);
                    } else t4.ce(i7 || e8.type) || (u4 = c6[i7 || e8.type](e8));
                    this.mergeHandlerResult(o7, a4, u4, l6, r8), u4 && u4.needsRenderFrame && this._triggerRenderFrame();
                  }
                  (u4 || c6.isActive()) && (s5[l6] = c6);
                }
                const l5 = {};
                for (const e9 in this._previousActiveHandlers) s5[e9] || (l5[e9] = r8);
                this._previousActiveHandlers = s5, (Object.keys(l5).length || va(o7)) && (this._changes.push([o7, a4, l5]), this._triggerRenderFrame()), (Object.keys(s5).length || va(o7)) && this._map._stop(true), this._updatingCamera = false;
                const { cameraAnimation: c5 } = o7;
                c5 && (this._inertia.clear(), this._fireEvents({}, {}, true), this._changes = [], c5(this._map));
              }, this._map = e7, this._el = this._map.getCanvasContainer(), this._handlers = [], this._handlersById = {}, this._changes = [], this._inertia = new So(e7), this._bearingSnap = i6.bearingSnap, this._previousActiveHandlers = {}, this._eventsInProgress = {}, this._addDefaultHandlers(i6);
              const r7 = this._el;
              this._listeners = [[r7, "touchstart", { passive: true }], [r7, "touchmove", { passive: false }], [r7, "touchend", void 0], [r7, "touchcancel", void 0], [r7, "mousedown", void 0], [r7, "mousemove", void 0], [r7, "mouseup", void 0], [document, "mousemove", { capture: true }], [document, "mouseup", void 0], [r7, "mouseover", void 0], [r7, "mouseout", void 0], [r7, "dblclick", void 0], [r7, "click", void 0], [r7, "keydown", { capture: false }], [r7, "keyup", void 0], [r7, "wheel", { passive: false }], [r7, "contextmenu", void 0], [window, "blur", void 0]];
              for (const [e8, t5, i7] of this._listeners) n5.addEventListener(e8, t5, e8 === document ? this.handleWindowEvent : this.handleEvent, i7);
            }
            destroy() {
              for (const [e7, t5, i6] of this._listeners) n5.removeEventListener(e7, t5, e7 === document ? this.handleWindowEvent : this.handleEvent, i6);
            }
            _addDefaultHandlers(e7) {
              const i6 = this._map, r7 = i6.getCanvasContainer();
              this._add("mapEvent", new ko(i6, e7));
              const o7 = i6.boxZoom = new Oo(i6, e7);
              this._add("boxZoom", o7), e7.interactive && e7.boxZoom && o7.enable();
              const a4 = i6.cooperativeGestures = new ma(i6, e7.cooperativeGestures);
              this._add("cooperativeGestures", a4), e7.cooperativeGestures && a4.enable();
              const s5 = new Go(i6), l5 = new ha(i6);
              i6.doubleClickZoom = new ca(l5, s5), this._add("tapZoom", s5), this._add("clickZoom", l5), e7.interactive && e7.doubleClickZoom && i6.doubleClickZoom.enable();
              const c5 = new ua();
              this._add("tapDragZoom", c5);
              const h4 = i6.touchPitch = new ra(i6);
              this._add("touchPitch", h4), e7.interactive && e7.touchPitch && i6.touchPitch.enable(e7.touchPitch);
              const u4 = () => i6.project(i6.getCenter()), d4 = function({ enable: e8, clickTolerance: i7, aroundCenter: r8 = true, minPixelCenterThreshold: o8 = 100, rotateDegreesPerPixelMoved: a5 = 0.8 }, s6) {
                const l6 = new qo({ checkCorrectEvent: (e9) => 0 === n5.mouseButton(e9) && e9.ctrlKey || 2 === n5.mouseButton(e9) && !e9.ctrlKey });
                return new Uo({ clickTolerance: i7, move: (e9, i8) => {
                  const n6 = s6();
                  if (r8 && Math.abs(n6.y - e9.y) > o8) return { bearingDelta: t4.ca(new t4.P(e9.x, i8.y), i8, n6) };
                  let l7 = (i8.x - e9.x) * a5;
                  return r8 && i8.y < n6.y && (l7 = -l7), { bearingDelta: l7 };
                }, moveStateManager: l6, enable: e8, assignEvents: Ho });
              }(e7, u4), _4 = function({ enable: e8, clickTolerance: t5, pitchDegreesPerPixelMoved: i7 = -0.5 }) {
                const r8 = new qo({ checkCorrectEvent: (e9) => 0 === n5.mouseButton(e9) && e9.ctrlKey || 2 === n5.mouseButton(e9) });
                return new Uo({ clickTolerance: t5, move: (e9, t6) => ({ pitchDelta: (t6.y - e9.y) * i7 }), moveStateManager: r8, enable: e8, assignEvents: Ho });
              }(e7), p4 = function({ enable: e8, clickTolerance: t5, rollDegreesPerPixelMoved: i7 = 0.3 }, r8) {
                const o8 = new qo({ checkCorrectEvent: (e9) => 2 === n5.mouseButton(e9) && e9.ctrlKey });
                return new Uo({ clickTolerance: t5, move: (e9, t6) => {
                  const o9 = r8();
                  let a5 = (t6.x - e9.x) * i7;
                  return t6.y < o9.y && (a5 = -a5), { rollDelta: a5 };
                }, moveStateManager: o8, enable: e8, assignEvents: Ho });
              }(e7, u4);
              i6.dragRotate = new _a2(e7, d4, _4, p4), this._add("mouseRotate", d4, ["mousePitch"]), this._add("mousePitch", _4, ["mouseRotate", "mouseRoll"]), this._add("mouseRoll", p4, ["mousePitch"]), e7.interactive && e7.dragRotate && i6.dragRotate.enable();
              const m4 = function({ enable: e8, clickTolerance: t5 }) {
                const i7 = new qo({ checkCorrectEvent: (e9) => 0 === n5.mouseButton(e9) && !e9.ctrlKey });
                return new Uo({ clickTolerance: t5, move: (e9, t6) => ({ around: t6, panDelta: t6.sub(e9) }), activateOnStart: true, moveStateManager: i7, enable: e8, assignEvents: Ho });
              }(e7), f4 = new Ko(e7, i6);
              i6.dragPan = new da(r7, m4, f4), this._add("mousePan", m4), this._add("touchPan", f4, ["touchZoom", "touchRotate"]), e7.interactive && e7.dragPan && i6.dragPan.enable(e7.dragPan);
              const g4 = new ta(), v4 = new Jo();
              i6.touchZoomRotate = new pa(r7, v4, g4, c5), this._add("touchRotate", g4, ["touchPan", "touchZoom"]), this._add("touchZoom", v4, ["touchPan", "touchRotate"]), e7.interactive && e7.touchZoomRotate && i6.touchZoomRotate.enable(e7.touchZoomRotate);
              const x4 = i6.scrollZoom = new la(i6, () => this._triggerRenderFrame());
              this._add("scrollZoom", x4, ["mousePan"]), e7.interactive && e7.scrollZoom && i6.scrollZoom.enable(e7.scrollZoom);
              const b5 = i6.keyboard = new aa(i6);
              this._add("keyboard", b5), e7.interactive && e7.keyboard && i6.keyboard.enable(), this._add("blockableMapEvent", new Fo(i6));
            }
            _add(e7, t5, i6) {
              this._handlers.push({ handlerName: e7, handler: t5, allowed: i6 }), this._handlersById[e7] = t5;
            }
            stop(e7) {
              if (!this._updatingCamera) {
                for (const { handler: e8 } of this._handlers) e8.reset();
                this._inertia.clear(), this._fireEvents({}, {}, e7), this._changes = [];
              }
            }
            isActive() {
              for (const { handler: e7 } of this._handlers) if (e7.isActive()) return true;
              return false;
            }
            isZooming() {
              return !!this._eventsInProgress.zoom || this._map.scrollZoom.isZooming();
            }
            isRotating() {
              return !!this._eventsInProgress.rotate;
            }
            isMoving() {
              return Boolean(fa(this._eventsInProgress)) || this.isZooming();
            }
            _blockedByActive(e7, t5, i6) {
              for (const r7 in e7) if (r7 !== i6 && (!t5 || t5.indexOf(r7) < 0)) return true;
              return false;
            }
            _getMapTouches(e7) {
              const t5 = [];
              for (const i6 of e7) this._el.contains(i6.target) && t5.push(i6);
              return t5;
            }
            mergeHandlerResult(e7, i6, r7, o7, a4) {
              if (!r7) return;
              t4.e(e7, r7);
              const s5 = { handlerName: o7, originalEvent: r7.originalEvent || a4 };
              void 0 !== r7.zoomDelta && (i6.zoom = s5), void 0 !== r7.panDelta && (i6.drag = s5), void 0 !== r7.rollDelta && (i6.roll = s5), void 0 !== r7.pitchDelta && (i6.pitch = s5), void 0 !== r7.bearingDelta && (i6.rotate = s5);
            }
            _applyChanges() {
              const e7 = {}, i6 = {}, r7 = {};
              for (const [o7, a4, s5] of this._changes) o7.panDelta && (e7.panDelta = (e7.panDelta || new t4.P(0, 0))._add(o7.panDelta)), o7.zoomDelta && (e7.zoomDelta = (e7.zoomDelta || 0) + o7.zoomDelta), o7.bearingDelta && (e7.bearingDelta = (e7.bearingDelta || 0) + o7.bearingDelta), o7.pitchDelta && (e7.pitchDelta = (e7.pitchDelta || 0) + o7.pitchDelta), o7.rollDelta && (e7.rollDelta = (e7.rollDelta || 0) + o7.rollDelta), void 0 !== o7.around && (e7.around = o7.around), void 0 !== o7.pinchAround && (e7.pinchAround = o7.pinchAround), o7.noInertia && (e7.noInertia = o7.noInertia), t4.e(i6, a4), t4.e(r7, s5);
              this._updateMapTransform(e7, i6, r7), this._changes = [];
            }
            _updateMapTransform(e7, t5, i6) {
              const r7 = this._map, o7 = r7._getTransformForUpdate(), a4 = r7.terrain;
              if (!(va(e7) || a4 && this._terrainMovement)) return this._fireEvents(t5, i6, true);
              r7._stop(true);
              let { panDelta: s5, zoomDelta: n6, bearingDelta: l5, pitchDelta: c5, rollDelta: h4, around: u4, pinchAround: d4 } = e7;
              void 0 !== d4 && (u4 = d4), u4 = u4 || r7.transform.centerPoint, a4 && !o7.isPointOnMapSurface(u4) && (u4 = o7.centerPoint);
              const _4 = { panDelta: s5, zoomDelta: n6, rollDelta: h4, pitchDelta: c5, bearingDelta: l5, around: u4 };
              this._map.cameraHelper.useGlobeControls && !o7.isPointOnMapSurface(u4) && (u4 = o7.centerPoint);
              const p4 = u4.distSqr(o7.centerPoint) < 0.01 ? o7.center : o7.screenPointToLocation(s5 ? u4.sub(s5) : u4);
              a4 ? (this._map.cameraHelper.handleMapControlsRollPitchBearingZoom(_4, o7), this._terrainMovement || !t5.drag && !t5.zoom ? t5.drag && this._terrainMovement ? o7.setCenter(o7.screenPointToLocation(o7.centerPoint.sub(s5))) : this._map.cameraHelper.handleMapControlsPan(_4, o7, p4) : (this._terrainMovement = true, this._map._elevationFreeze = true, this._map.cameraHelper.handleMapControlsPan(_4, o7, p4))) : (this._map.cameraHelper.handleMapControlsRollPitchBearingZoom(_4, o7), this._map.cameraHelper.handleMapControlsPan(_4, o7, p4)), r7._applyUpdatedTransform(o7), this._map._update(), e7.noInertia || this._inertia.record(e7), this._fireEvents(t5, i6, true);
            }
            _fireEvents(e7, i6, r7) {
              const o7 = fa(this._eventsInProgress), a4 = fa(e7), n6 = {};
              for (const t5 in e7) {
                const { originalEvent: i7 } = e7[t5];
                this._eventsInProgress[t5] || (n6[`${t5}start`] = i7), this._eventsInProgress[t5] = e7[t5];
              }
              !o7 && a4 && this._fireEvent("movestart", a4.originalEvent);
              for (const e8 in n6) this._fireEvent(e8, n6[e8]);
              a4 && this._fireEvent("move", a4.originalEvent);
              for (const t5 in e7) {
                const { originalEvent: i7 } = e7[t5];
                this._fireEvent(t5, i7);
              }
              const l5 = {};
              let c5;
              for (const e8 in this._eventsInProgress) {
                const { handlerName: t5, originalEvent: r8 } = this._eventsInProgress[e8];
                this._handlersById[t5].isActive() || (delete this._eventsInProgress[e8], c5 = i6[t5] || r8, l5[`${e8}end`] = c5);
              }
              for (const e8 in l5) this._fireEvent(e8, l5[e8]);
              const h4 = fa(this._eventsInProgress), u4 = (o7 || a4) && !h4;
              if (u4 && this._terrainMovement) {
                this._map._elevationFreeze = false, this._terrainMovement = false;
                const e8 = this._map._getTransformForUpdate();
                this._map.getCenterClampedToGround() && e8.recalculateZoomAndCenter(this._map.terrain), this._map._applyUpdatedTransform(e8);
              }
              if (r7 && u4) {
                this._updatingCamera = true;
                const e8 = this._inertia._onMoveEnd(this._map.dragPan._inertiaOptions), i7 = (e9) => 0 !== e9 && -this._bearingSnap < e9 && e9 < this._bearingSnap;
                !e8 || !e8.essential && s4.prefersReducedMotion ? (this._map.fire(new t4.l("moveend", { originalEvent: c5 })), i7(this._map.getBearing()) && this._map.resetNorth()) : (i7(e8.bearing || this._map.getBearing()) && (e8.bearing = 0), e8.freezeElevation = true, this._map.easeTo(e8, { originalEvent: c5 })), this._updatingCamera = false;
              }
            }
            _fireEvent(e7, i6) {
              this._map.fire(new t4.l(e7, i6 ? { originalEvent: i6 } : {}));
            }
            _requestFrame() {
              return this._map.triggerRepaint(), this._map._renderTaskQueue.add((e7) => {
                delete this._frameId, this.handleEvent(new ga("renderFrame", { timeStamp: e7 })), this._applyChanges();
              });
            }
            _triggerRenderFrame() {
              void 0 === this._frameId && (this._frameId = this._requestFrame());
            }
          }
          class ba extends t4.E {
            constructor(e7, t5, i6) {
              super(), this._renderFrameCallback = () => {
                const e8 = Math.min((s4.now() - this._easeStart) / this._easeOptions.duration, 1);
                this._onEaseFrame(this._easeOptions.easing(e8)), e8 < 1 && this._easeFrameId ? this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback) : this.stop();
              }, this._moving = false, this._zooming = false, this.transform = e7, this._bearingSnap = i6.bearingSnap, this.cameraHelper = t5, this.on("moveend", () => {
                delete this._requestedCameraState;
              });
            }
            migrateProjection(e7, t5) {
              e7.apply(this.transform), this.transform = e7, this.cameraHelper = t5;
            }
            getCenter() {
              return new t4.Q(this.transform.center.lng, this.transform.center.lat);
            }
            setCenter(e7, t5) {
              return this.jumpTo({ center: e7 }, t5);
            }
            getCenterElevation() {
              return this.transform.elevation;
            }
            setCenterElevation(e7, t5) {
              return this.jumpTo({ elevation: e7 }, t5), this;
            }
            getCenterClampedToGround() {
              return this._centerClampedToGround;
            }
            setCenterClampedToGround(e7) {
              this._centerClampedToGround = e7;
            }
            panBy(e7, i6, r7) {
              return e7 = t4.P.convert(e7).mult(-1), this.panTo(this.transform.center, t4.e({ offset: e7 }, i6), r7);
            }
            panTo(e7, i6, r7) {
              return this.easeTo(t4.e({ center: e7 }, i6), r7);
            }
            getZoom() {
              return this.transform.zoom;
            }
            setZoom(e7, t5) {
              return this.jumpTo({ zoom: e7 }, t5), this;
            }
            zoomTo(e7, i6, r7) {
              return this.easeTo(t4.e({ zoom: e7 }, i6), r7);
            }
            zoomIn(e7, t5) {
              return this.zoomTo(this.getZoom() + 1, e7, t5), this;
            }
            zoomOut(e7, t5) {
              return this.zoomTo(this.getZoom() - 1, e7, t5), this;
            }
            getVerticalFieldOfView() {
              return this.transform.fov;
            }
            setVerticalFieldOfView(e7, i6) {
              return e7 != this.transform.fov && (this.transform.setFov(e7), this.fire(new t4.l("movestart", i6)).fire(new t4.l("move", i6)).fire(new t4.l("moveend", i6))), this;
            }
            getBearing() {
              return this.transform.bearing;
            }
            setBearing(e7, t5) {
              return this.jumpTo({ bearing: e7 }, t5), this;
            }
            getPadding() {
              return this.transform.padding;
            }
            setPadding(e7, t5) {
              return this.jumpTo({ padding: e7 }, t5), this;
            }
            rotateTo(e7, i6, r7) {
              return this.easeTo(t4.e({ bearing: e7 }, i6), r7);
            }
            resetNorth(e7, i6) {
              return this.rotateTo(0, t4.e({ duration: 1e3 }, e7), i6), this;
            }
            resetNorthPitch(e7, i6) {
              return this.easeTo(t4.e({ bearing: 0, pitch: 0, roll: 0, duration: 1e3 }, e7), i6), this;
            }
            snapToNorth(e7, t5) {
              return Math.abs(this.getBearing()) < this._bearingSnap ? this.resetNorth(e7, t5) : this;
            }
            getPitch() {
              return this.transform.pitch;
            }
            setPitch(e7, t5) {
              return this.jumpTo({ pitch: e7 }, t5), this;
            }
            getRoll() {
              return this.transform.roll;
            }
            setRoll(e7, t5) {
              return this.jumpTo({ roll: e7 }, t5), this;
            }
            cameraForBounds(e7, t5) {
              e7 = V2.convert(e7).adjustAntiMeridian();
              const i6 = t5 && t5.bearing || 0;
              return this._cameraForBoxAndBearing(e7.getNorthWest(), e7.getSouthEast(), i6, t5);
            }
            _cameraForBoxAndBearing(e7, i6, r7, o7) {
              const a4 = { top: 0, bottom: 0, right: 0, left: 0 };
              if ("number" == typeof (o7 = t4.e({ padding: a4, offset: [0, 0], maxZoom: this.transform.maxZoom }, o7)).padding) {
                const e8 = o7.padding;
                o7.padding = { top: e8, bottom: e8, right: e8, left: e8 };
              }
              const s5 = t4.e(a4, o7.padding);
              o7.padding = s5;
              const n6 = this.transform, l5 = new V2(e7, i6);
              return this.cameraHelper.cameraForBoxAndBearing(o7, s5, l5, r7, n6);
            }
            fitBounds(e7, t5, i6) {
              return this._fitInternal(this.cameraForBounds(e7, t5), t5, i6);
            }
            fitScreenCoordinates(e7, i6, r7, o7, a4) {
              return this._fitInternal(this._cameraForBoxAndBearing(this.transform.screenPointToLocation(t4.P.convert(e7)), this.transform.screenPointToLocation(t4.P.convert(i6)), r7, o7), o7, a4);
            }
            _fitInternal(e7, i6, r7) {
              return e7 ? (delete (i6 = t4.e(e7, i6)).padding, i6.linear ? this.easeTo(i6, r7) : this.flyTo(i6, r7)) : this;
            }
            jumpTo(e7, i6) {
              this.stop();
              const r7 = this._getTransformForUpdate();
              let o7 = false, a4 = false, s5 = false;
              const n6 = r7.zoom;
              this.cameraHelper.handleJumpToCenterZoom(r7, e7);
              const l5 = r7.zoom !== n6;
              return "elevation" in e7 && r7.elevation !== +e7.elevation && r7.setElevation(+e7.elevation), "bearing" in e7 && r7.bearing !== +e7.bearing && (o7 = true, r7.setBearing(+e7.bearing)), "pitch" in e7 && r7.pitch !== +e7.pitch && (a4 = true, r7.setPitch(+e7.pitch)), "roll" in e7 && r7.roll !== +e7.roll && (s5 = true, r7.setRoll(+e7.roll)), null == e7.padding || r7.isPaddingEqual(e7.padding) || r7.setPadding(e7.padding), this._applyUpdatedTransform(r7), this.fire(new t4.l("movestart", i6)).fire(new t4.l("move", i6)), l5 && this.fire(new t4.l("zoomstart", i6)).fire(new t4.l("zoom", i6)).fire(new t4.l("zoomend", i6)), o7 && this.fire(new t4.l("rotatestart", i6)).fire(new t4.l("rotate", i6)).fire(new t4.l("rotateend", i6)), a4 && this.fire(new t4.l("pitchstart", i6)).fire(new t4.l("pitch", i6)).fire(new t4.l("pitchend", i6)), s5 && this.fire(new t4.l("rollstart", i6)).fire(new t4.l("roll", i6)).fire(new t4.l("rollend", i6)), this.fire(new t4.l("moveend", i6));
            }
            calculateCameraOptionsFromTo(e7, i6, r7, o7 = 0) {
              const a4 = t4.$.fromLngLat(e7, i6), s5 = t4.$.fromLngLat(r7, o7), n6 = s5.x - a4.x, l5 = s5.y - a4.y, c5 = s5.z - a4.z, h4 = Math.hypot(n6, l5, c5);
              if (0 === h4) throw new Error("Can't calculate camera options with same From and To");
              const u4 = Math.hypot(n6, l5), d4 = t4.ab(this.transform.cameraToCenterDistance / h4 / this.transform.tileSize), _4 = 180 * Math.atan2(n6, -l5) / Math.PI;
              let p4 = 180 * Math.acos(u4 / h4) / Math.PI;
              return p4 = c5 < 0 ? 90 - p4 : 90 + p4, { center: s5.toLngLat(), elevation: o7, zoom: d4, pitch: p4, bearing: _4 };
            }
            calculateCameraOptionsFromCameraLngLatAltRotation(e7, t5, i6, r7, o7) {
              const a4 = this.transform.calculateCenterFromCameraLngLatAlt(e7, t5, i6, r7);
              return { center: a4.center, elevation: a4.elevation, zoom: a4.zoom, bearing: i6, pitch: r7, roll: o7 };
            }
            easeTo(e7, i6) {
              this._stop(false, e7.easeId), (false === (e7 = t4.e({ offset: [0, 0], duration: 500, easing: t4.cb }, e7)).animate || !e7.essential && s4.prefersReducedMotion) && (e7.duration = 0);
              const r7 = this._getTransformForUpdate(), o7 = this.getBearing(), a4 = r7.pitch, n6 = r7.roll, l5 = "bearing" in e7 ? this._normalizeBearing(e7.bearing, o7) : o7, c5 = "pitch" in e7 ? +e7.pitch : a4, h4 = "roll" in e7 ? this._normalizeBearing(e7.roll, n6) : n6, u4 = "padding" in e7 ? e7.padding : r7.padding, d4 = t4.P.convert(e7.offset);
              let _4, p4;
              e7.around && (_4 = t4.Q.convert(e7.around), p4 = r7.locationToScreenPoint(_4));
              const m4 = { moving: this._moving, zooming: this._zooming, rotating: this._rotating, pitching: this._pitching, rolling: this._rolling }, f4 = this.cameraHelper.handleEaseTo(r7, { bearing: l5, pitch: c5, roll: h4, padding: u4, around: _4, aroundPoint: p4, offsetAsPoint: d4, offset: e7.offset, zoom: e7.zoom, center: e7.center });
              return this._rotating = this._rotating || o7 !== l5, this._pitching = this._pitching || c5 !== a4, this._rolling = this._rolling || h4 !== n6, this._padding = !r7.isPaddingEqual(u4), this._zooming = this._zooming || f4.isZooming, this._easeId = e7.easeId, this._prepareEase(i6, e7.noMoveStart, m4), this.terrain && this._prepareElevation(f4.elevationCenter), this._ease((t5) => {
                f4.easeFunc(t5), this.terrain && !e7.freezeElevation && this._updateElevation(t5), this._applyUpdatedTransform(r7), this._fireMoveEvents(i6);
              }, (t5) => {
                this.terrain && e7.freezeElevation && this._finalizeElevation(), this._afterEase(i6, t5);
              }, e7), this;
            }
            _prepareEase(e7, i6, r7 = {}) {
              this._moving = true, i6 || r7.moving || this.fire(new t4.l("movestart", e7)), this._zooming && !r7.zooming && this.fire(new t4.l("zoomstart", e7)), this._rotating && !r7.rotating && this.fire(new t4.l("rotatestart", e7)), this._pitching && !r7.pitching && this.fire(new t4.l("pitchstart", e7)), this._rolling && !r7.rolling && this.fire(new t4.l("rollstart", e7));
            }
            _prepareElevation(e7) {
              this._elevationCenter = e7, this._elevationStart = this.transform.elevation, this._elevationTarget = this.terrain.getElevationForLngLatZoom(e7, this.transform.tileZoom), this._elevationFreeze = true;
            }
            _updateElevation(e7) {
              this.transform.setMinElevationForCurrentTile(this.terrain.getMinTileElevationForLngLatZoom(this._elevationCenter, this.transform.tileZoom));
              const i6 = this.terrain.getElevationForLngLatZoom(this._elevationCenter, this.transform.tileZoom);
              if (e7 < 1 && i6 !== this._elevationTarget) {
                const t5 = this._elevationTarget - this._elevationStart;
                this._elevationStart += e7 * (t5 - (i6 - (t5 * e7 + this._elevationStart)) / (1 - e7)), this._elevationTarget = i6;
              }
              this.transform.setElevation(t4.B.number(this._elevationStart, this._elevationTarget, e7));
            }
            _finalizeElevation() {
              this._elevationFreeze = false, this.getCenterClampedToGround() && this.transform.recalculateZoomAndCenter(this.terrain);
            }
            _getTransformForUpdate() {
              return this.transformCameraUpdate || this.terrain ? (this._requestedCameraState || (this._requestedCameraState = this.transform.clone()), this._requestedCameraState) : this.transform;
            }
            _elevateCameraIfInsideTerrain(e7) {
              if (!this.terrain && e7.elevation >= 0 && e7.pitch <= 90) return {};
              const t5 = e7.getCameraLngLat(), i6 = e7.getCameraAltitude(), r7 = this.terrain ? this.terrain.getElevationForLngLatZoom(t5, e7.zoom) : 0;
              if (i6 < r7) {
                const i7 = this.calculateCameraOptionsFromTo(t5, r7, e7.center, e7.elevation);
                return { pitch: i7.pitch, zoom: i7.zoom };
              }
              return {};
            }
            _applyUpdatedTransform(e7) {
              const t5 = [];
              if (t5.push((e8) => this._elevateCameraIfInsideTerrain(e8)), this.transformCameraUpdate && t5.push((e8) => this.transformCameraUpdate(e8)), !t5.length) return;
              const i6 = e7.clone();
              for (const e8 of t5) {
                const t6 = i6.clone(), { center: r7, zoom: o7, roll: a4, pitch: s5, bearing: n6, elevation: l5 } = e8(t6);
                r7 && t6.setCenter(r7), void 0 !== l5 && t6.setElevation(l5), void 0 !== o7 && t6.setZoom(o7), void 0 !== a4 && t6.setRoll(a4), void 0 !== s5 && t6.setPitch(s5), void 0 !== n6 && t6.setBearing(n6), i6.apply(t6);
              }
              this.transform.apply(i6);
            }
            _fireMoveEvents(e7) {
              this.fire(new t4.l("move", e7)), this._zooming && this.fire(new t4.l("zoom", e7)), this._rotating && this.fire(new t4.l("rotate", e7)), this._pitching && this.fire(new t4.l("pitch", e7)), this._rolling && this.fire(new t4.l("roll", e7));
            }
            _afterEase(e7, i6) {
              if (this._easeId && i6 && this._easeId === i6) return;
              delete this._easeId;
              const r7 = this._zooming, o7 = this._rotating, a4 = this._pitching, s5 = this._rolling;
              this._moving = false, this._zooming = false, this._rotating = false, this._pitching = false, this._rolling = false, this._padding = false, r7 && this.fire(new t4.l("zoomend", e7)), o7 && this.fire(new t4.l("rotateend", e7)), a4 && this.fire(new t4.l("pitchend", e7)), s5 && this.fire(new t4.l("rollend", e7)), this.fire(new t4.l("moveend", e7));
            }
            flyTo(e7, i6) {
              if (!e7.essential && s4.prefersReducedMotion) {
                const r8 = t4.O(e7, ["center", "zoom", "bearing", "pitch", "roll", "elevation"]);
                return this.jumpTo(r8, i6);
              }
              this.stop(), e7 = t4.e({ offset: [0, 0], speed: 1.2, curve: 1.42, easing: t4.cb }, e7);
              const r7 = this._getTransformForUpdate(), o7 = r7.bearing, a4 = r7.pitch, n6 = r7.roll, l5 = r7.padding, c5 = "bearing" in e7 ? this._normalizeBearing(e7.bearing, o7) : o7, h4 = "pitch" in e7 ? +e7.pitch : a4, u4 = "roll" in e7 ? this._normalizeBearing(e7.roll, n6) : n6, d4 = "padding" in e7 ? e7.padding : r7.padding, _4 = t4.P.convert(e7.offset);
              let p4 = r7.centerPoint.add(_4);
              const m4 = r7.screenPointToLocation(p4), f4 = this.cameraHelper.handleFlyTo(r7, { bearing: c5, pitch: h4, roll: u4, padding: d4, locationAtOffset: m4, offsetAsPoint: _4, center: e7.center, minZoom: e7.minZoom, zoom: e7.zoom });
              let g4 = e7.curve;
              const v4 = Math.max(r7.width, r7.height), x4 = v4 / f4.scaleOfZoom, b5 = f4.pixelPathLength;
              "number" == typeof f4.scaleOfMinZoom && (g4 = Math.sqrt(v4 / f4.scaleOfMinZoom / b5 * 2));
              const y4 = g4 * g4;
              function w4(e8) {
                const t5 = (x4 * x4 - v4 * v4 + (e8 ? -1 : 1) * y4 * y4 * b5 * b5) / (2 * (e8 ? x4 : v4) * y4 * b5);
                return Math.log(Math.sqrt(t5 * t5 + 1) - t5);
              }
              function T5(e8) {
                return (Math.exp(e8) - Math.exp(-e8)) / 2;
              }
              function P4(e8) {
                return (Math.exp(e8) + Math.exp(-e8)) / 2;
              }
              const C4 = w4(false);
              let I4 = function(e8) {
                return P4(C4) / P4(C4 + g4 * e8);
              }, M5 = function(e8) {
                return v4 * ((P4(C4) * (T5(t5 = C4 + g4 * e8) / P4(t5)) - T5(C4)) / y4) / b5;
                var t5;
              }, E4 = (w4(true) - C4) / g4;
              if (Math.abs(b5) < 2e-6 || !isFinite(E4)) {
                if (Math.abs(v4 - x4) < 1e-6) return this.easeTo(e7, i6);
                const t5 = x4 < v4 ? -1 : 1;
                E4 = Math.abs(Math.log(x4 / v4)) / g4, M5 = () => 0, I4 = (e8) => Math.exp(t5 * g4 * e8);
              }
              return e7.duration = "duration" in e7 ? +e7.duration : 1e3 * E4 / ("screenSpeed" in e7 ? +e7.screenSpeed / g4 : +e7.speed), e7.maxDuration && e7.duration > e7.maxDuration && (e7.duration = 0), this._zooming = true, this._rotating = o7 !== c5, this._pitching = h4 !== a4, this._rolling = u4 !== n6, this._padding = !r7.isPaddingEqual(d4), this._prepareEase(i6, false), this.terrain && this._prepareElevation(f4.targetCenter), this._ease((s5) => {
                const m5 = s5 * E4, g5 = 1 / I4(m5), v5 = M5(m5);
                this._rotating && r7.setBearing(t4.B.number(o7, c5, s5)), this._pitching && r7.setPitch(t4.B.number(a4, h4, s5)), this._rolling && r7.setRoll(t4.B.number(n6, u4, s5)), this._padding && (r7.interpolatePadding(l5, d4, s5), p4 = r7.centerPoint.add(_4)), f4.easeFunc(s5, g5, v5, p4), this.terrain && !e7.freezeElevation && this._updateElevation(s5), this._applyUpdatedTransform(r7), this._fireMoveEvents(i6);
              }, () => {
                this.terrain && e7.freezeElevation && this._finalizeElevation(), this._afterEase(i6);
              }, e7), this;
            }
            isEasing() {
              return !!this._easeFrameId;
            }
            stop() {
              return this._stop();
            }
            _stop(e7, t5) {
              var i6;
              if (this._easeFrameId && (this._cancelRenderFrame(this._easeFrameId), delete this._easeFrameId, delete this._onEaseFrame), this._onEaseEnd) {
                const e8 = this._onEaseEnd;
                delete this._onEaseEnd, e8.call(this, t5);
              }
              return e7 || null === (i6 = this.handlers) || void 0 === i6 || i6.stop(false), this;
            }
            _ease(e7, t5, i6) {
              false === i6.animate || 0 === i6.duration ? (e7(1), t5()) : (this._easeStart = s4.now(), this._easeOptions = i6, this._onEaseFrame = e7, this._onEaseEnd = t5, this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback));
            }
            _normalizeBearing(e7, i6) {
              e7 = t4.aL(e7, -180, 180);
              const r7 = Math.abs(e7 - i6);
              return Math.abs(e7 - 360 - i6) < r7 && (e7 -= 360), Math.abs(e7 + 360 - i6) < r7 && (e7 += 360), e7;
            }
            queryTerrainElevation(e7) {
              return this.terrain ? this.terrain.getElevationForLngLatZoom(t4.Q.convert(e7), this.transform.tileZoom) : null;
            }
          }
          const ya = { compact: true, customAttribution: '<a href="https://maplibre.org/" target="_blank">MapLibre</a>' };
          class wa {
            constructor(e7 = ya) {
              this._toggleAttribution = () => {
                this._container.classList.contains("maplibregl-compact") && (this._container.classList.contains("maplibregl-compact-show") ? (this._container.setAttribute("open", ""), this._container.classList.remove("maplibregl-compact-show")) : (this._container.classList.add("maplibregl-compact-show"), this._container.removeAttribute("open")));
              }, this._updateData = (e8) => {
                !e8 || "metadata" !== e8.sourceDataType && "visibility" !== e8.sourceDataType && "style" !== e8.dataType && "terrain" !== e8.type || this._updateAttributions();
              }, this._updateCompact = () => {
                this._map.getCanvasContainer().offsetWidth <= 640 || this._compact ? false === this._compact ? this._container.setAttribute("open", "") : this._container.classList.contains("maplibregl-compact") || this._container.classList.contains("maplibregl-attrib-empty") || (this._container.setAttribute("open", ""), this._container.classList.add("maplibregl-compact", "maplibregl-compact-show")) : (this._container.setAttribute("open", ""), this._container.classList.contains("maplibregl-compact") && this._container.classList.remove("maplibregl-compact", "maplibregl-compact-show"));
              }, this._updateCompactMinimize = () => {
                this._container.classList.contains("maplibregl-compact") && this._container.classList.contains("maplibregl-compact-show") && this._container.classList.remove("maplibregl-compact-show");
              }, this.options = e7;
            }
            getDefaultPosition() {
              return "bottom-right";
            }
            onAdd(e7) {
              return this._map = e7, this._compact = this.options.compact, this._container = n5.create("details", "maplibregl-ctrl maplibregl-ctrl-attrib"), this._compactButton = n5.create("summary", "maplibregl-ctrl-attrib-button", this._container), this._compactButton.addEventListener("click", this._toggleAttribution), this._setElementTitle(this._compactButton, "ToggleAttribution"), this._innerContainer = n5.create("div", "maplibregl-ctrl-attrib-inner", this._container), this._updateAttributions(), this._updateCompact(), this._map.on("styledata", this._updateData), this._map.on("sourcedata", this._updateData), this._map.on("terrain", this._updateData), this._map.on("resize", this._updateCompact), this._map.on("drag", this._updateCompactMinimize), this._container;
            }
            onRemove() {
              n5.remove(this._container), this._map.off("styledata", this._updateData), this._map.off("sourcedata", this._updateData), this._map.off("terrain", this._updateData), this._map.off("resize", this._updateCompact), this._map.off("drag", this._updateCompactMinimize), this._map = void 0, this._compact = void 0, this._attribHTML = void 0;
            }
            _setElementTitle(e7, t5) {
              const i6 = this._map._getUIString(`AttributionControl.${t5}`);
              e7.title = i6, e7.setAttribute("aria-label", i6);
            }
            _updateAttributions() {
              if (!this._map.style) return;
              let e7 = [];
              if (this.options.customAttribution && (Array.isArray(this.options.customAttribution) ? e7 = e7.concat(this.options.customAttribution.map((e8) => "string" != typeof e8 ? "" : e8)) : "string" == typeof this.options.customAttribution && e7.push(this.options.customAttribution)), this._map.style.stylesheet) {
                const e8 = this._map.style.stylesheet;
                this.styleOwner = e8.owner, this.styleId = e8.id;
              }
              const t5 = this._map.style.sourceCaches;
              for (const i7 in t5) {
                const r7 = t5[i7];
                if (r7.used || r7.usedForTerrain) {
                  const t6 = r7.getSource();
                  t6.attribution && e7.indexOf(t6.attribution) < 0 && e7.push(t6.attribution);
                }
              }
              e7 = e7.filter((e8) => String(e8).trim()), e7.sort((e8, t6) => e8.length - t6.length), e7 = e7.filter((t6, i7) => {
                for (let r7 = i7 + 1; r7 < e7.length; r7++) if (e7[r7].indexOf(t6) >= 0) return false;
                return true;
              });
              const i6 = e7.join(" | ");
              i6 !== this._attribHTML && (this._attribHTML = i6, e7.length ? (this._innerContainer.innerHTML = n5.sanitize(i6), this._container.classList.remove("maplibregl-attrib-empty")) : this._container.classList.add("maplibregl-attrib-empty"), this._updateCompact(), this._editLink = null);
            }
          }
          class Ta {
            constructor(e7 = {}) {
              this._updateCompact = () => {
                const e8 = this._container.children;
                if (e8.length) {
                  const t5 = e8[0];
                  this._map.getCanvasContainer().offsetWidth <= 640 || this._compact ? false !== this._compact && t5.classList.add("maplibregl-compact") : t5.classList.remove("maplibregl-compact");
                }
              }, this.options = e7;
            }
            getDefaultPosition() {
              return "bottom-left";
            }
            onAdd(e7) {
              this._map = e7, this._compact = this.options && this.options.compact, this._container = n5.create("div", "maplibregl-ctrl");
              const t5 = n5.create("a", "maplibregl-ctrl-logo");
              return t5.target = "_blank", t5.rel = "noopener nofollow", t5.href = "https://maplibre.org/", t5.setAttribute("aria-label", this._map._getUIString("LogoControl.Title")), t5.setAttribute("rel", "noopener nofollow"), this._container.appendChild(t5), this._container.style.display = "block", this._map.on("resize", this._updateCompact), this._updateCompact(), this._container;
            }
            onRemove() {
              n5.remove(this._container), this._map.off("resize", this._updateCompact), this._map = void 0, this._compact = void 0;
            }
          }
          class Pa {
            constructor() {
              this._queue = [], this._id = 0, this._cleared = false, this._currentlyRunning = false;
            }
            add(e7) {
              const t5 = ++this._id;
              return this._queue.push({ callback: e7, id: t5, cancelled: false }), t5;
            }
            remove(e7) {
              const t5 = this._currentlyRunning, i6 = t5 ? this._queue.concat(t5) : this._queue;
              for (const t6 of i6) if (t6.id === e7) return void (t6.cancelled = true);
            }
            run(e7 = 0) {
              if (this._currentlyRunning) throw new Error("Attempting to run(), but is already running.");
              const t5 = this._currentlyRunning = this._queue;
              this._queue = [];
              for (const i6 of t5) if (!i6.cancelled && (i6.callback(e7), this._cleared)) break;
              this._cleared = false, this._currentlyRunning = false;
            }
            clear() {
              this._currentlyRunning && (this._cleared = true), this._queue = [];
            }
          }
          var Ca = t4.aD([{ name: "a_pos3d", type: "Int16", components: 3 }]);
          class Ia extends t4.E {
            constructor(e7) {
              super(), this._lastTilesetChange = s4.now(), this.sourceCache = e7, this._tiles = {}, this._renderableTilesKeys = [], this._sourceTileCache = {}, this.minzoom = 0, this.maxzoom = 22, this.deltaZoom = 1, this.tileSize = e7._source.tileSize * 2 ** this.deltaZoom, e7.usedForTerrain = true, e7.tileSize = this.tileSize;
            }
            destruct() {
              this.sourceCache.usedForTerrain = false, this.sourceCache.tileSize = null;
            }
            update(e7, i6) {
              this.sourceCache.update(e7, i6), this._renderableTilesKeys = [];
              const r7 = {};
              for (const o7 of ue(e7, { tileSize: this.tileSize, minzoom: this.minzoom, maxzoom: this.maxzoom, reparseOverscaled: false, terrain: i6, calculateTileZoom: this.sourceCache._source.calculateTileZoom })) r7[o7.key] = true, this._renderableTilesKeys.push(o7.key), this._tiles[o7.key] || (o7.terrainRttPosMatrix32f = new Float64Array(16), t4.bO(o7.terrainRttPosMatrix32f, 0, t4.Z, t4.Z, 0, 0, 1), this._tiles[o7.key] = new ae(o7, this.tileSize), this._lastTilesetChange = s4.now());
              for (const e8 in this._tiles) r7[e8] || delete this._tiles[e8];
            }
            freeRtt(e7) {
              for (const t5 in this._tiles) {
                const i6 = this._tiles[t5];
                (!e7 || i6.tileID.equals(e7) || i6.tileID.isChildOf(e7) || e7.isChildOf(i6.tileID)) && (i6.rtt = []);
              }
            }
            getRenderableTiles() {
              return this._renderableTilesKeys.map((e7) => this.getTileByID(e7));
            }
            getTileByID(e7) {
              return this._tiles[e7];
            }
            getTerrainCoords(e7, t5) {
              return t5 ? this._getTerrainCoordsForTileRanges(e7, t5) : this._getTerrainCoordsForRegularTile(e7);
            }
            _getTerrainCoordsForRegularTile(e7) {
              const i6 = {};
              for (const r7 of this._renderableTilesKeys) {
                const o7 = this._tiles[r7].tileID, a4 = e7.clone(), s5 = t4.b2();
                if (o7.canonical.equals(e7.canonical)) t4.bO(s5, 0, t4.Z, t4.Z, 0, 0, 1);
                else if (o7.canonical.isChildOf(e7.canonical)) {
                  const i7 = o7.canonical.z - e7.canonical.z, r8 = o7.canonical.x - (o7.canonical.x >> i7 << i7), a5 = o7.canonical.y - (o7.canonical.y >> i7 << i7), n6 = t4.Z >> i7;
                  t4.bO(s5, 0, n6, n6, 0, 0, 1), t4.L(s5, s5, [-r8 * n6, -a5 * n6, 0]);
                } else {
                  if (!e7.canonical.isChildOf(o7.canonical)) continue;
                  {
                    const i7 = e7.canonical.z - o7.canonical.z, r8 = e7.canonical.x - (e7.canonical.x >> i7 << i7), a5 = e7.canonical.y - (e7.canonical.y >> i7 << i7), n6 = t4.Z >> i7;
                    t4.bO(s5, 0, t4.Z, t4.Z, 0, 0, 1), t4.L(s5, s5, [r8 * n6, a5 * n6, 0]), t4.M(s5, s5, [1 / 2 ** i7, 1 / 2 ** i7, 0]);
                  }
                }
                a4.terrainRttPosMatrix32f = new Float32Array(s5), i6[r7] = a4;
              }
              return i6;
            }
            _getTerrainCoordsForTileRanges(e7, i6) {
              const r7 = {};
              for (const o7 of this._renderableTilesKeys) {
                const a4 = this._tiles[o7].tileID;
                if (!this._isWithinTileRanges(a4, i6)) continue;
                const s5 = e7.clone(), n6 = t4.b2();
                if (a4.canonical.z === e7.canonical.z) {
                  const i7 = e7.canonical.x - a4.canonical.x, r8 = e7.canonical.y - a4.canonical.y;
                  t4.bO(n6, 0, t4.Z, t4.Z, 0, 0, 1), t4.L(n6, n6, [i7 * t4.Z, r8 * t4.Z, 0]);
                } else if (a4.canonical.z > e7.canonical.z) {
                  const i7 = a4.canonical.z - e7.canonical.z, r8 = a4.canonical.x - (a4.canonical.x >> i7 << i7), o8 = a4.canonical.y - (a4.canonical.y >> i7 << i7), s6 = e7.canonical.x - (a4.canonical.x >> i7), l5 = e7.canonical.y - (a4.canonical.y >> i7), c5 = t4.Z >> i7;
                  t4.bO(n6, 0, c5, c5, 0, 0, 1), t4.L(n6, n6, [-r8 * c5 + s6 * t4.Z, -o8 * c5 + l5 * t4.Z, 0]);
                } else {
                  const i7 = e7.canonical.z - a4.canonical.z, r8 = e7.canonical.x - (e7.canonical.x >> i7 << i7), o8 = e7.canonical.y - (e7.canonical.y >> i7 << i7), s6 = (e7.canonical.x >> i7) - a4.canonical.x, l5 = (e7.canonical.y >> i7) - a4.canonical.y, c5 = t4.Z << i7;
                  t4.bO(n6, 0, c5, c5, 0, 0, 1), t4.L(n6, n6, [r8 * t4.Z + s6 * c5, o8 * t4.Z + l5 * c5, 0]);
                }
                s5.terrainRttPosMatrix32f = new Float32Array(n6), r7[o7] = s5;
              }
              return r7;
            }
            getSourceTile(e7, t5) {
              const i6 = this.sourceCache._source;
              let r7 = e7.overscaledZ - this.deltaZoom;
              if (r7 > i6.maxzoom && (r7 = i6.maxzoom), r7 < i6.minzoom) return null;
              this._sourceTileCache[e7.key] || (this._sourceTileCache[e7.key] = e7.scaledTo(r7).key);
              let o7 = this.sourceCache.getTileByID(this._sourceTileCache[e7.key]);
              if ((!o7 || !o7.dem) && t5) for (; r7 >= i6.minzoom && (!o7 || !o7.dem); ) o7 = this.sourceCache.getTileByID(e7.scaledTo(r7--).key);
              return o7;
            }
            anyTilesAfterTime(e7 = Date.now()) {
              return this._lastTilesetChange >= e7;
            }
            _isWithinTileRanges(e7, t5) {
              return t5[e7.canonical.z] && e7.canonical.x >= t5[e7.canonical.z].minTileX && e7.canonical.x <= t5[e7.canonical.z].maxTileX && e7.canonical.y >= t5[e7.canonical.z].minTileY && e7.canonical.y <= t5[e7.canonical.z].maxTileY;
            }
          }
          class Ma {
            constructor(e7, t5, i6) {
              this._meshCache = {}, this.painter = e7, this.sourceCache = new Ia(t5), this.options = i6, this.exaggeration = "number" == typeof i6.exaggeration ? i6.exaggeration : 1, this.qualityFactor = 2, this.meshSize = 128, this._demMatrixCache = {}, this.coordsIndex = [], this._coordsTextureSize = 1024;
            }
            getDEMElevation(e7, i6, r7, o7 = t4.Z) {
              var a4;
              if (!(i6 >= 0 && i6 < o7 && r7 >= 0 && r7 < o7)) return 0;
              const s5 = this.getTerrainData(e7), n6 = null === (a4 = s5.tile) || void 0 === a4 ? void 0 : a4.dem;
              if (!n6) return 0;
              const l5 = t4.cf([], [i6 / o7 * t4.Z, r7 / o7 * t4.Z], s5.u_terrain_matrix), c5 = [l5[0] * n6.dim, l5[1] * n6.dim], h4 = Math.floor(c5[0]), u4 = Math.floor(c5[1]), d4 = c5[0] - h4, _4 = c5[1] - u4;
              return n6.get(h4, u4) * (1 - d4) * (1 - _4) + n6.get(h4 + 1, u4) * d4 * (1 - _4) + n6.get(h4, u4 + 1) * (1 - d4) * _4 + n6.get(h4 + 1, u4 + 1) * d4 * _4;
            }
            getElevationForLngLatZoom(e7, i6) {
              if (!t4.cg(i6, e7.wrap())) return 0;
              const { tileID: r7, mercatorX: o7, mercatorY: a4 } = this._getOverscaledTileIDFromLngLatZoom(e7, i6);
              return this.getElevation(r7, o7 % t4.Z, a4 % t4.Z, t4.Z);
            }
            getElevation(e7, i6, r7, o7 = t4.Z) {
              return this.getDEMElevation(e7, i6, r7, o7) * this.exaggeration;
            }
            getTerrainData(e7) {
              if (!this._emptyDemTexture) {
                const e8 = this.painter.context, i7 = new t4.R({ width: 1, height: 1 }, new Uint8Array(4));
                this._emptyDepthTexture = new v3(e8, i7, e8.gl.RGBA, { premultiply: false }), this._emptyDemUnpack = [0, 0, 0, 0], this._emptyDemTexture = new v3(e8, new t4.R({ width: 1, height: 1 }), e8.gl.RGBA, { premultiply: false }), this._emptyDemTexture.bind(e8.gl.NEAREST, e8.gl.CLAMP_TO_EDGE), this._emptyDemMatrix = t4.at([]);
              }
              const i6 = this.sourceCache.getSourceTile(e7, true);
              if (i6 && i6.dem && (!i6.demTexture || i6.needsTerrainPrepare)) {
                const e8 = this.painter.context;
                i6.demTexture = this.painter.getTileTexture(i6.dem.stride), i6.demTexture ? i6.demTexture.update(i6.dem.getPixels(), { premultiply: false }) : i6.demTexture = new v3(e8, i6.dem.getPixels(), e8.gl.RGBA, { premultiply: false }), i6.demTexture.bind(e8.gl.NEAREST, e8.gl.CLAMP_TO_EDGE), i6.needsTerrainPrepare = false;
              }
              const r7 = i6 && i6 + i6.tileID.key + e7.key;
              if (r7 && !this._demMatrixCache[r7]) {
                const r8 = this.sourceCache.sourceCache._source.maxzoom;
                let o7 = e7.canonical.z - i6.tileID.canonical.z;
                e7.overscaledZ > e7.canonical.z && (e7.canonical.z >= r8 ? o7 = e7.canonical.z - r8 : t4.w("cannot calculate elevation if elevation maxzoom > source.maxzoom"));
                const a4 = e7.canonical.x - (e7.canonical.x >> o7 << o7), s5 = e7.canonical.y - (e7.canonical.y >> o7 << o7), n6 = t4.ch(new Float64Array(16), [1 / (t4.Z << o7), 1 / (t4.Z << o7), 0]);
                t4.L(n6, n6, [a4 * t4.Z, s5 * t4.Z, 0]), this._demMatrixCache[e7.key] = { matrix: n6, coord: e7 };
              }
              return { u_depth: 2, u_terrain: 3, u_terrain_dim: i6 && i6.dem && i6.dem.dim || 1, u_terrain_matrix: r7 ? this._demMatrixCache[e7.key].matrix : this._emptyDemMatrix, u_terrain_unpack: i6 && i6.dem && i6.dem.getUnpackVector() || this._emptyDemUnpack, u_terrain_exaggeration: this.exaggeration, texture: (i6 && i6.demTexture || this._emptyDemTexture).texture, depthTexture: (this._fboDepthTexture || this._emptyDepthTexture).texture, tile: i6 };
            }
            getFramebuffer(e7) {
              const t5 = this.painter, i6 = t5.width / devicePixelRatio, r7 = t5.height / devicePixelRatio;
              return !this._fbo || this._fbo.width === i6 && this._fbo.height === r7 || (this._fbo.destroy(), this._fboCoordsTexture.destroy(), this._fboDepthTexture.destroy(), delete this._fbo, delete this._fboDepthTexture, delete this._fboCoordsTexture), this._fboCoordsTexture || (this._fboCoordsTexture = new v3(t5.context, { width: i6, height: r7, data: null }, t5.context.gl.RGBA, { premultiply: false }), this._fboCoordsTexture.bind(t5.context.gl.NEAREST, t5.context.gl.CLAMP_TO_EDGE)), this._fboDepthTexture || (this._fboDepthTexture = new v3(t5.context, { width: i6, height: r7, data: null }, t5.context.gl.RGBA, { premultiply: false }), this._fboDepthTexture.bind(t5.context.gl.NEAREST, t5.context.gl.CLAMP_TO_EDGE)), this._fbo || (this._fbo = t5.context.createFramebuffer(i6, r7, true, false), this._fbo.depthAttachment.set(t5.context.createRenderbuffer(t5.context.gl.DEPTH_COMPONENT16, i6, r7))), this._fbo.colorAttachment.set("coords" === e7 ? this._fboCoordsTexture.texture : this._fboDepthTexture.texture), this._fbo;
            }
            getCoordsTexture() {
              const e7 = this.painter.context;
              if (this._coordsTexture) return this._coordsTexture;
              const i6 = new Uint8Array(this._coordsTextureSize * this._coordsTextureSize * 4);
              for (let e8 = 0, t5 = 0; e8 < this._coordsTextureSize; e8++) for (let r8 = 0; r8 < this._coordsTextureSize; r8++, t5 += 4) i6[t5 + 0] = 255 & r8, i6[t5 + 1] = 255 & e8, i6[t5 + 2] = r8 >> 8 << 4 | e8 >> 8, i6[t5 + 3] = 0;
              const r7 = new t4.R({ width: this._coordsTextureSize, height: this._coordsTextureSize }, new Uint8Array(i6.buffer)), o7 = new v3(e7, r7, e7.gl.RGBA, { premultiply: false });
              return o7.bind(e7.gl.NEAREST, e7.gl.CLAMP_TO_EDGE), this._coordsTexture = o7, o7;
            }
            pointCoordinate(e7) {
              this.painter.maybeDrawDepthAndCoords(true);
              const i6 = new Uint8Array(4), r7 = this.painter.context, o7 = r7.gl, a4 = Math.round(e7.x * this.painter.pixelRatio / devicePixelRatio), s5 = Math.round(e7.y * this.painter.pixelRatio / devicePixelRatio), n6 = Math.round(this.painter.height / devicePixelRatio);
              r7.bindFramebuffer.set(this.getFramebuffer("coords").framebuffer), o7.readPixels(a4, n6 - s5 - 1, 1, 1, o7.RGBA, o7.UNSIGNED_BYTE, i6), r7.bindFramebuffer.set(null);
              const l5 = i6[0] + (i6[2] >> 4 << 8), c5 = i6[1] + ((15 & i6[2]) << 8), h4 = this.coordsIndex[255 - i6[3]], u4 = h4 && this.sourceCache.getTileByID(h4);
              if (!u4) return null;
              const d4 = this._coordsTextureSize, _4 = (1 << u4.tileID.canonical.z) * d4;
              return new t4.$((u4.tileID.canonical.x * d4 + l5) / _4 + u4.tileID.wrap, (u4.tileID.canonical.y * d4 + c5) / _4, this.getElevation(u4.tileID, l5, c5, d4));
            }
            depthAtPoint(e7) {
              const t5 = new Uint8Array(4), i6 = this.painter.context, r7 = i6.gl;
              return i6.bindFramebuffer.set(this.getFramebuffer("depth").framebuffer), r7.readPixels(e7.x, this.painter.height / devicePixelRatio - e7.y - 1, 1, 1, r7.RGBA, r7.UNSIGNED_BYTE, t5), i6.bindFramebuffer.set(null), (t5[0] / 16777216 + t5[1] / 65536 + t5[2] / 256 + t5[3]) / 256;
            }
            getTerrainMesh(e7) {
              var i6;
              const r7 = (null === (i6 = this.painter.style.projection) || void 0 === i6 ? void 0 : i6.transitionState) > 0, o7 = r7 && 0 === e7.canonical.y, a4 = r7 && e7.canonical.y === (1 << e7.canonical.z) - 1, s5 = `m_${o7 ? "n" : ""}_${a4 ? "s" : ""}`;
              if (this._meshCache[s5]) return this._meshCache[s5];
              const n6 = this.painter.context, l5 = new t4.ci(), c5 = new t4.aH(), h4 = this.meshSize, u4 = t4.Z / h4, d4 = h4 * h4;
              for (let e8 = 0; e8 <= h4; e8++) for (let t5 = 0; t5 <= h4; t5++) l5.emplaceBack(t5 * u4, e8 * u4, 0);
              for (let e8 = 0; e8 < d4; e8 += h4 + 1) for (let t5 = 0; t5 < h4; t5++) c5.emplaceBack(t5 + e8, h4 + t5 + e8 + 1, h4 + t5 + e8 + 2), c5.emplaceBack(t5 + e8, h4 + t5 + e8 + 2, t5 + e8 + 1);
              const _4 = l5.length, p4 = _4 + (h4 + 1), m4 = (h4 + 1) * h4, f4 = o7 ? t4.b9 : 0, g4 = o7 ? 0 : 1, v4 = a4 ? t4.ba : t4.Z, x4 = a4 ? 0 : 1;
              for (let e8 = 0; e8 <= h4; e8++) l5.emplaceBack(e8 * u4, f4, g4);
              for (let e8 = 0; e8 <= h4; e8++) l5.emplaceBack(e8 * u4, v4, x4);
              for (let e8 = 0; e8 < h4; e8++) c5.emplaceBack(m4 + e8, p4 + e8, p4 + e8 + 1), c5.emplaceBack(m4 + e8, p4 + e8 + 1, m4 + e8 + 1), c5.emplaceBack(0 + e8, _4 + e8 + 1, _4 + e8), c5.emplaceBack(0 + e8, 0 + e8 + 1, _4 + e8 + 1);
              const b5 = l5.length, y4 = b5 + 2 * (h4 + 1);
              for (const e8 of [0, 1]) for (let i7 = 0; i7 <= h4; i7++) for (const r8 of [0, 1]) l5.emplaceBack(e8 * t4.Z, i7 * u4, r8);
              for (let e8 = 0; e8 < 2 * h4; e8 += 2) c5.emplaceBack(b5 + e8, b5 + e8 + 1, b5 + e8 + 3), c5.emplaceBack(b5 + e8, b5 + e8 + 3, b5 + e8 + 2), c5.emplaceBack(y4 + e8, y4 + e8 + 3, y4 + e8 + 1), c5.emplaceBack(y4 + e8, y4 + e8 + 2, y4 + e8 + 3);
              const w4 = new pt(n6.createVertexBuffer(l5, Ca.members), n6.createIndexBuffer(c5), t4.aG.simpleSegment(0, 0, l5.length, c5.length));
              return this._meshCache[s5] = w4, w4;
            }
            getMeshFrameDelta(e7) {
              return 2 * Math.PI * t4.br / Math.pow(2, Math.max(e7, 0)) / 5;
            }
            getMinTileElevationForLngLatZoom(e7, t5) {
              var i6;
              const { tileID: r7 } = this._getOverscaledTileIDFromLngLatZoom(e7, t5);
              return null !== (i6 = this.getMinMaxElevation(r7).minElevation) && void 0 !== i6 ? i6 : 0;
            }
            getMinMaxElevation(e7) {
              const t5 = this.getTerrainData(e7).tile, i6 = { minElevation: null, maxElevation: null };
              return t5 && t5.dem && (i6.minElevation = t5.dem.min * this.exaggeration, i6.maxElevation = t5.dem.max * this.exaggeration), i6;
            }
            _getOverscaledTileIDFromLngLatZoom(e7, i6) {
              const r7 = t4.$.fromLngLat(e7.wrap()), o7 = (1 << i6) * t4.Z, a4 = r7.x * o7, s5 = r7.y * o7, n6 = Math.floor(a4 / t4.Z), l5 = Math.floor(s5 / t4.Z);
              return { tileID: new t4.Y(i6, 0, i6, n6, l5), mercatorX: a4, mercatorY: s5 };
            }
          }
          class Ea {
            constructor(e7, t5, i6) {
              this._context = e7, this._size = t5, this._tileSize = i6, this._objects = [], this._recentlyUsed = [], this._stamp = 0;
            }
            destruct() {
              for (const e7 of this._objects) e7.texture.destroy(), e7.fbo.destroy();
            }
            _createObject(e7) {
              const t5 = this._context.createFramebuffer(this._tileSize, this._tileSize, true, true), i6 = new v3(this._context, { width: this._tileSize, height: this._tileSize, data: null }, this._context.gl.RGBA);
              return i6.bind(this._context.gl.LINEAR, this._context.gl.CLAMP_TO_EDGE), this._context.extTextureFilterAnisotropic && this._context.gl.texParameterf(this._context.gl.TEXTURE_2D, this._context.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, this._context.extTextureFilterAnisotropicMax), t5.depthAttachment.set(this._context.createRenderbuffer(this._context.gl.DEPTH_STENCIL, this._tileSize, this._tileSize)), t5.colorAttachment.set(i6.texture), { id: e7, fbo: t5, texture: i6, stamp: -1, inUse: false };
            }
            getObjectForId(e7) {
              return this._objects[e7];
            }
            useObject(e7) {
              e7.inUse = true, this._recentlyUsed = this._recentlyUsed.filter((t5) => e7.id !== t5), this._recentlyUsed.push(e7.id);
            }
            stampObject(e7) {
              e7.stamp = ++this._stamp;
            }
            getOrCreateFreeObject() {
              for (const e8 of this._recentlyUsed) if (!this._objects[e8].inUse) return this._objects[e8];
              if (this._objects.length >= this._size) throw new Error("No free RenderPool available, call freeAllObjects() required!");
              const e7 = this._createObject(this._objects.length);
              return this._objects.push(e7), e7;
            }
            freeObject(e7) {
              e7.inUse = false;
            }
            freeAllObjects() {
              for (const e7 of this._objects) this.freeObject(e7);
            }
            isFull() {
              return !(this._objects.length < this._size) && false === this._objects.some((e7) => !e7.inUse);
            }
          }
          const Sa = { background: true, fill: true, line: true, raster: true, hillshade: true };
          class Ra {
            constructor(e7, t5) {
              this.painter = e7, this.terrain = t5, this.pool = new Ea(e7.context, 30, t5.sourceCache.tileSize * t5.qualityFactor);
            }
            destruct() {
              this.pool.destruct();
            }
            getTexture(e7) {
              return this.pool.getObjectForId(e7.rtt[this._stacks.length - 1].id).texture;
            }
            prepareForRender(e7, t5) {
              this._stacks = [], this._prevType = null, this._rttTiles = [], this._renderableTiles = this.terrain.sourceCache.getRenderableTiles(), this._renderableLayerIds = e7._order.filter((i6) => !e7._layers[i6].isHidden(t5)), this._coordsAscending = {};
              for (const t6 in e7.sourceCaches) {
                this._coordsAscending[t6] = {};
                const i6 = e7.sourceCaches[t6].getVisibleCoordinates(), r7 = e7.sourceCaches[t6].getSource(), o7 = r7 instanceof X2 ? r7.terrainTileRanges : null;
                for (const e8 of i6) {
                  const i7 = this.terrain.sourceCache.getTerrainCoords(e8, o7);
                  for (const e9 in i7) this._coordsAscending[t6][e9] || (this._coordsAscending[t6][e9] = []), this._coordsAscending[t6][e9].push(i7[e9]);
                }
              }
              this._coordsAscendingStr = {};
              for (const t6 of e7._order) {
                const i6 = e7._layers[t6], r7 = i6.source;
                if (Sa[i6.type] && !this._coordsAscendingStr[r7]) {
                  this._coordsAscendingStr[r7] = {};
                  for (const e8 in this._coordsAscending[r7]) this._coordsAscendingStr[r7][e8] = this._coordsAscending[r7][e8].map((e9) => e9.key).sort().join();
                }
              }
              for (const e8 of this._renderableTiles) for (const t6 in this._coordsAscendingStr) {
                const i6 = this._coordsAscendingStr[t6][e8.tileID.key];
                i6 && i6 !== e8.rttCoords[t6] && (e8.rtt = []);
              }
            }
            renderLayer(e7, i6) {
              if (e7.isHidden(this.painter.transform.zoom)) return false;
              const r7 = Object.assign(Object.assign({}, i6), { isRenderingToTexture: true }), o7 = e7.type, a4 = this.painter, s5 = this._renderableLayerIds[this._renderableLayerIds.length - 1] === e7.id;
              if (Sa[o7] && (this._prevType && Sa[this._prevType] || this._stacks.push([]), this._prevType = o7, this._stacks[this._stacks.length - 1].push(e7.id), !s5)) return true;
              if (Sa[this._prevType] || Sa[o7] && s5) {
                this._prevType = o7;
                const e8 = this._stacks.length - 1, i7 = this._stacks[e8] || [];
                for (const o8 of this._renderableTiles) {
                  if (this.pool.isFull() && (vo(this.painter, this.terrain, this._rttTiles, r7), this._rttTiles = [], this.pool.freeAllObjects()), this._rttTiles.push(o8), o8.rtt[e8]) {
                    const t5 = this.pool.getObjectForId(o8.rtt[e8].id);
                    if (t5.stamp === o8.rtt[e8].stamp) {
                      this.pool.useObject(t5);
                      continue;
                    }
                  }
                  const s6 = this.pool.getOrCreateFreeObject();
                  this.pool.useObject(s6), this.pool.stampObject(s6), o8.rtt[e8] = { id: s6.id, stamp: s6.stamp }, a4.context.bindFramebuffer.set(s6.fbo.framebuffer), a4.context.clear({ color: t4.b7.transparent, stencil: 0 }), a4.currentStencilSource = void 0;
                  for (let e9 = 0; e9 < i7.length; e9++) {
                    const t5 = a4.style._layers[i7[e9]], n6 = t5.source ? this._coordsAscending[t5.source][o8.tileID.key] : [o8.tileID];
                    a4.context.viewport.set([0, 0, s6.fbo.width, s6.fbo.height]), a4._renderTileClippingMasks(t5, n6, true), a4.renderLayer(a4, a4.style.sourceCaches[t5.source], t5, n6, r7), t5.source && (o8.rttCoords[t5.source] = this._coordsAscendingStr[t5.source][o8.tileID.key]);
                  }
                }
                return vo(this.painter, this.terrain, this._rttTiles, r7), this._rttTiles = [], this.pool.freeAllObjects(), Sa[o7];
              }
              return false;
            }
          }
          const Da = { "AttributionControl.ToggleAttribution": "Toggle attribution", "AttributionControl.MapFeedback": "Map feedback", "FullscreenControl.Enter": "Enter fullscreen", "FullscreenControl.Exit": "Exit fullscreen", "GeolocateControl.FindMyLocation": "Find my location", "GeolocateControl.LocationNotAvailable": "Location not available", "LogoControl.Title": "MapLibre logo", "Map.Title": "Map", "Marker.Title": "Map marker", "NavigationControl.ResetBearing": "Reset bearing to north", "NavigationControl.ZoomIn": "Zoom in", "NavigationControl.ZoomOut": "Zoom out", "Popup.Close": "Close popup", "ScaleControl.Feet": "ft", "ScaleControl.Meters": "m", "ScaleControl.Kilometers": "km", "ScaleControl.Miles": "mi", "ScaleControl.NauticalMiles": "nm", "GlobeControl.Enable": "Enable globe", "GlobeControl.Disable": "Disable globe", "TerrainControl.Enable": "Enable terrain", "TerrainControl.Disable": "Disable terrain", "CooperativeGesturesHandler.WindowsHelpText": "Use Ctrl + scroll to zoom the map", "CooperativeGesturesHandler.MacHelpText": "Use \u2318 + scroll to zoom the map", "CooperativeGesturesHandler.MobileHelpText": "Use two fingers to move the map" }, za = i5, Aa = { hash: false, interactive: true, bearingSnap: 7, attributionControl: ya, maplibreLogo: false, refreshExpiredTiles: true, canvasContextAttributes: { antialias: false, preserveDrawingBuffer: false, powerPreference: "high-performance", failIfMajorPerformanceCaveat: false, desynchronized: false, contextType: void 0 }, scrollZoom: true, minZoom: -2, maxZoom: 22, minPitch: 0, maxPitch: 60, boxZoom: true, dragRotate: true, dragPan: true, keyboard: true, doubleClickZoom: true, touchZoomRotate: true, touchPitch: true, cooperativeGestures: false, trackResize: true, center: [0, 0], elevation: 0, zoom: 0, bearing: 0, pitch: 0, roll: 0, renderWorldCopies: true, maxTileCacheSize: null, maxTileCacheZoomLevels: t4.a.MAX_TILE_CACHE_ZOOM_LEVELS, transformRequest: null, transformCameraUpdate: null, fadeDuration: 300, crossSourceCollisions: true, clickTolerance: 3, localIdeographFontFamily: "sans-serif", pitchWithRotate: true, rollEnabled: false, validateStyle: true, maxCanvasSize: [4096, 4096], cancelPendingTileRequestsWhileZooming: true, centerClampedToGround: true }, La = { showCompass: true, showZoom: true, visualizePitch: false, visualizeRoll: true };
          class ka {
            constructor(e7, i6, r7 = false) {
              this.mousedown = (e8) => {
                this.startMove(e8, n5.mousePos(this.element, e8)), n5.addEventListener(window, "mousemove", this.mousemove), n5.addEventListener(window, "mouseup", this.mouseup);
              }, this.mousemove = (e8) => {
                this.move(e8, n5.mousePos(this.element, e8));
              }, this.mouseup = (e8) => {
                this._rotatePitchHanlder.dragEnd(e8), this.offTemp();
              }, this.touchstart = (e8) => {
                1 !== e8.targetTouches.length ? this.reset() : (this._startPos = this._lastPos = n5.touchPos(this.element, e8.targetTouches)[0], this.startMove(e8, this._startPos), n5.addEventListener(window, "touchmove", this.touchmove, { passive: false }), n5.addEventListener(window, "touchend", this.touchend));
              }, this.touchmove = (e8) => {
                1 !== e8.targetTouches.length ? this.reset() : (this._lastPos = n5.touchPos(this.element, e8.targetTouches)[0], this.move(e8, this._lastPos));
              }, this.touchend = (e8) => {
                0 === e8.targetTouches.length && this._startPos && this._lastPos && this._startPos.dist(this._lastPos) < this._clickTolerance && this.element.click(), delete this._startPos, delete this._lastPos, this.offTemp();
              }, this.reset = () => {
                this._rotatePitchHanlder.reset(), delete this._startPos, delete this._lastPos, this.offTemp();
              }, this._clickTolerance = 10, this.element = i6;
              const o7 = new $o();
              this._rotatePitchHanlder = new Uo({ clickTolerance: 3, move: (e8, o8) => {
                const a4 = i6.getBoundingClientRect(), s5 = new t4.P((a4.bottom - a4.top) / 2, (a4.right - a4.left) / 2);
                return { bearingDelta: t4.ca(new t4.P(e8.x, o8.y), o8, s5), pitchDelta: r7 ? -0.5 * (o8.y - e8.y) : void 0 };
              }, moveStateManager: o7, enable: true, assignEvents: () => {
              } }), this.map = e7, n5.addEventListener(i6, "mousedown", this.mousedown), n5.addEventListener(i6, "touchstart", this.touchstart, { passive: false }), n5.addEventListener(i6, "touchcancel", this.reset);
            }
            startMove(e7, t5) {
              this._rotatePitchHanlder.dragStart(e7, t5), n5.disableDrag();
            }
            move(e7, t5) {
              const i6 = this.map, { bearingDelta: r7, pitchDelta: o7 } = this._rotatePitchHanlder.dragMove(e7, t5) || {};
              r7 && i6.setBearing(i6.getBearing() + r7), o7 && i6.setPitch(i6.getPitch() + o7);
            }
            off() {
              const e7 = this.element;
              n5.removeEventListener(e7, "mousedown", this.mousedown), n5.removeEventListener(e7, "touchstart", this.touchstart, { passive: false }), n5.removeEventListener(window, "touchmove", this.touchmove, { passive: false }), n5.removeEventListener(window, "touchend", this.touchend), n5.removeEventListener(e7, "touchcancel", this.reset), this.offTemp();
            }
            offTemp() {
              n5.enableDrag(), n5.removeEventListener(window, "mousemove", this.mousemove), n5.removeEventListener(window, "mouseup", this.mouseup), n5.removeEventListener(window, "touchmove", this.touchmove, { passive: false }), n5.removeEventListener(window, "touchend", this.touchend);
            }
          }
          let Fa;
          function Ba(e7, i6, r7) {
            const o7 = new t4.Q(e7.lng, e7.lat);
            if (e7 = new t4.Q(e7.lng, e7.lat), i6) {
              const o8 = new t4.Q(e7.lng - 360, e7.lat), a4 = new t4.Q(e7.lng + 360, e7.lat), s5 = r7.locationToScreenPoint(e7).distSqr(i6);
              r7.locationToScreenPoint(o8).distSqr(i6) < s5 ? e7 = o8 : r7.locationToScreenPoint(a4).distSqr(i6) < s5 && (e7 = a4);
            }
            for (; Math.abs(e7.lng - r7.center.lng) > 180; ) {
              const t5 = r7.locationToScreenPoint(e7);
              if (t5.x >= 0 && t5.y >= 0 && t5.x <= r7.width && t5.y <= r7.height) break;
              e7.lng > r7.center.lng ? e7.lng -= 360 : e7.lng += 360;
            }
            return e7.lng !== o7.lng && r7.isPointOnMapSurface(r7.locationToScreenPoint(e7)) ? e7 : o7;
          }
          const Oa = { center: "translate(-50%,-50%)", top: "translate(-50%,0)", "top-left": "translate(0,0)", "top-right": "translate(-100%,0)", bottom: "translate(-50%,-100%)", "bottom-left": "translate(0,-100%)", "bottom-right": "translate(-100%,-100%)", left: "translate(0,-50%)", right: "translate(-100%,-50%)" };
          function ja(e7, t5, i6) {
            const r7 = e7.classList;
            for (const e8 in Oa) r7.remove(`maplibregl-${i6}-anchor-${e8}`);
            r7.add(`maplibregl-${i6}-anchor-${t5}`);
          }
          class Za extends t4.E {
            constructor(e7) {
              if (super(), this._onKeyPress = (e8) => {
                const t5 = e8.code, i6 = e8.charCode || e8.keyCode;
                "Space" !== t5 && "Enter" !== t5 && 32 !== i6 && 13 !== i6 || this.togglePopup();
              }, this._onMapClick = (e8) => {
                const t5 = e8.originalEvent.target, i6 = this._element;
                this._popup && (t5 === i6 || i6.contains(t5)) && this.togglePopup();
              }, this._update = (e8) => {
                var t5;
                if (!this._map) return;
                const i6 = this._map.loaded() && !this._map.isMoving();
                ("terrain" === (null == e8 ? void 0 : e8.type) || "render" === (null == e8 ? void 0 : e8.type) && !i6) && this._map.once("render", this._update), this._lngLat = this._map.transform.renderWorldCopies ? Ba(this._lngLat, this._flatPos, this._map.transform) : null === (t5 = this._lngLat) || void 0 === t5 ? void 0 : t5.wrap(), this._flatPos = this._pos = this._map.project(this._lngLat)._add(this._offset), this._map.terrain && (this._flatPos = this._map.transform.locationToScreenPoint(this._lngLat)._add(this._offset));
                let r7 = "";
                "viewport" === this._rotationAlignment || "auto" === this._rotationAlignment ? r7 = `rotateZ(${this._rotation}deg)` : "map" === this._rotationAlignment && (r7 = `rotateZ(${this._rotation - this._map.getBearing()}deg)`);
                let o7 = "";
                "viewport" === this._pitchAlignment || "auto" === this._pitchAlignment ? o7 = "rotateX(0deg)" : "map" === this._pitchAlignment && (o7 = `rotateX(${this._map.getPitch()}deg)`), this._subpixelPositioning || e8 && "moveend" !== e8.type || (this._pos = this._pos.round()), n5.setTransform(this._element, `${Oa[this._anchor]} translate(${this._pos.x}px, ${this._pos.y}px) ${o7} ${r7}`), s4.frameAsync(new AbortController()).then(() => {
                  this._updateOpacity(e8 && "moveend" === e8.type);
                }).catch(() => {
                });
              }, this._onMove = (e8) => {
                if (!this._isDragging) {
                  const t5 = this._clickTolerance || this._map._clickTolerance;
                  this._isDragging = e8.point.dist(this._pointerdownPos) >= t5;
                }
                this._isDragging && (this._pos = e8.point.sub(this._positionDelta), this._lngLat = this._map.unproject(this._pos), this.setLngLat(this._lngLat), this._element.style.pointerEvents = "none", "pending" === this._state && (this._state = "active", this.fire(new t4.l("dragstart"))), this.fire(new t4.l("drag")));
              }, this._onUp = () => {
                this._element.style.pointerEvents = "auto", this._positionDelta = null, this._pointerdownPos = null, this._isDragging = false, this._map.off("mousemove", this._onMove), this._map.off("touchmove", this._onMove), "active" === this._state && this.fire(new t4.l("dragend")), this._state = "inactive";
              }, this._addDragHandler = (e8) => {
                this._element.contains(e8.originalEvent.target) && (e8.preventDefault(), this._positionDelta = e8.point.sub(this._pos).add(this._offset), this._pointerdownPos = e8.point, this._state = "pending", this._map.on("mousemove", this._onMove), this._map.on("touchmove", this._onMove), this._map.once("mouseup", this._onUp), this._map.once("touchend", this._onUp));
              }, this._anchor = e7 && e7.anchor || "center", this._color = e7 && e7.color || "#3FB1CE", this._scale = e7 && e7.scale || 1, this._draggable = e7 && e7.draggable || false, this._clickTolerance = e7 && e7.clickTolerance || 0, this._subpixelPositioning = e7 && e7.subpixelPositioning || false, this._isDragging = false, this._state = "inactive", this._rotation = e7 && e7.rotation || 0, this._rotationAlignment = e7 && e7.rotationAlignment || "auto", this._pitchAlignment = e7 && e7.pitchAlignment && "auto" !== e7.pitchAlignment ? e7.pitchAlignment : this._rotationAlignment, this.setOpacity(null == e7 ? void 0 : e7.opacity, null == e7 ? void 0 : e7.opacityWhenCovered), e7 && e7.element) this._element = e7.element, this._offset = t4.P.convert(e7 && e7.offset || [0, 0]);
              else {
                this._defaultMarker = true, this._element = n5.create("div");
                const i6 = n5.createNS("http://www.w3.org/2000/svg", "svg"), r7 = 41, o7 = 27;
                i6.setAttributeNS(null, "display", "block"), i6.setAttributeNS(null, "height", `${r7}px`), i6.setAttributeNS(null, "width", `${o7}px`), i6.setAttributeNS(null, "viewBox", `0 0 ${o7} ${r7}`);
                const a4 = n5.createNS("http://www.w3.org/2000/svg", "g");
                a4.setAttributeNS(null, "stroke", "none"), a4.setAttributeNS(null, "stroke-width", "1"), a4.setAttributeNS(null, "fill", "none"), a4.setAttributeNS(null, "fill-rule", "evenodd");
                const s5 = n5.createNS("http://www.w3.org/2000/svg", "g");
                s5.setAttributeNS(null, "fill-rule", "nonzero");
                const l5 = n5.createNS("http://www.w3.org/2000/svg", "g");
                l5.setAttributeNS(null, "transform", "translate(3.0, 29.0)"), l5.setAttributeNS(null, "fill", "#000000");
                const c5 = [{ rx: "10.5", ry: "5.25002273" }, { rx: "10.5", ry: "5.25002273" }, { rx: "9.5", ry: "4.77275007" }, { rx: "8.5", ry: "4.29549936" }, { rx: "7.5", ry: "3.81822308" }, { rx: "6.5", ry: "3.34094679" }, { rx: "5.5", ry: "2.86367051" }, { rx: "4.5", ry: "2.38636864" }];
                for (const e8 of c5) {
                  const t5 = n5.createNS("http://www.w3.org/2000/svg", "ellipse");
                  t5.setAttributeNS(null, "opacity", "0.04"), t5.setAttributeNS(null, "cx", "10.5"), t5.setAttributeNS(null, "cy", "5.80029008"), t5.setAttributeNS(null, "rx", e8.rx), t5.setAttributeNS(null, "ry", e8.ry), l5.appendChild(t5);
                }
                const h4 = n5.createNS("http://www.w3.org/2000/svg", "g");
                h4.setAttributeNS(null, "fill", this._color);
                const u4 = n5.createNS("http://www.w3.org/2000/svg", "path");
                u4.setAttributeNS(null, "d", "M27,13.5 C27,19.074644 20.250001,27.000002 14.75,34.500002 C14.016665,35.500004 12.983335,35.500004 12.25,34.500002 C6.7499993,27.000002 0,19.222562 0,13.5 C0,6.0441559 6.0441559,0 13.5,0 C20.955844,0 27,6.0441559 27,13.5 Z"), h4.appendChild(u4);
                const d4 = n5.createNS("http://www.w3.org/2000/svg", "g");
                d4.setAttributeNS(null, "opacity", "0.25"), d4.setAttributeNS(null, "fill", "#000000");
                const _4 = n5.createNS("http://www.w3.org/2000/svg", "path");
                _4.setAttributeNS(null, "d", "M13.5,0 C6.0441559,0 0,6.0441559 0,13.5 C0,19.222562 6.7499993,27 12.25,34.5 C13,35.522727 14.016664,35.500004 14.75,34.5 C20.250001,27 27,19.074644 27,13.5 C27,6.0441559 20.955844,0 13.5,0 Z M13.5,1 C20.415404,1 26,6.584596 26,13.5 C26,15.898657 24.495584,19.181431 22.220703,22.738281 C19.945823,26.295132 16.705119,30.142167 13.943359,33.908203 C13.743445,34.180814 13.612715,34.322738 13.5,34.441406 C13.387285,34.322738 13.256555,34.180814 13.056641,33.908203 C10.284481,30.127985 7.4148684,26.314159 5.015625,22.773438 C2.6163816,19.232715 1,15.953538 1,13.5 C1,6.584596 6.584596,1 13.5,1 Z"), d4.appendChild(_4);
                const p4 = n5.createNS("http://www.w3.org/2000/svg", "g");
                p4.setAttributeNS(null, "transform", "translate(6.0, 7.0)"), p4.setAttributeNS(null, "fill", "#FFFFFF");
                const m4 = n5.createNS("http://www.w3.org/2000/svg", "g");
                m4.setAttributeNS(null, "transform", "translate(8.0, 8.0)");
                const f4 = n5.createNS("http://www.w3.org/2000/svg", "circle");
                f4.setAttributeNS(null, "fill", "#000000"), f4.setAttributeNS(null, "opacity", "0.25"), f4.setAttributeNS(null, "cx", "5.5"), f4.setAttributeNS(null, "cy", "5.5"), f4.setAttributeNS(null, "r", "5.4999962");
                const g4 = n5.createNS("http://www.w3.org/2000/svg", "circle");
                g4.setAttributeNS(null, "fill", "#FFFFFF"), g4.setAttributeNS(null, "cx", "5.5"), g4.setAttributeNS(null, "cy", "5.5"), g4.setAttributeNS(null, "r", "5.4999962"), m4.appendChild(f4), m4.appendChild(g4), s5.appendChild(l5), s5.appendChild(h4), s5.appendChild(d4), s5.appendChild(p4), s5.appendChild(m4), i6.appendChild(s5), i6.setAttributeNS(null, "height", r7 * this._scale + "px"), i6.setAttributeNS(null, "width", o7 * this._scale + "px"), this._element.appendChild(i6), this._offset = t4.P.convert(e7 && e7.offset || [0, -14]);
              }
              if (this._element.classList.add("maplibregl-marker"), this._element.addEventListener("dragstart", (e8) => {
                e8.preventDefault();
              }), this._element.addEventListener("mousedown", (e8) => {
                e8.preventDefault();
              }), ja(this._element, this._anchor, "marker"), e7 && e7.className) for (const t5 of e7.className.split(" ")) this._element.classList.add(t5);
              this._popup = null;
            }
            addTo(e7) {
              return this.remove(), this._map = e7, this._element.hasAttribute("aria-label") || this._element.setAttribute("aria-label", e7._getUIString("Marker.Title")), e7.getCanvasContainer().appendChild(this._element), e7.on("move", this._update), e7.on("moveend", this._update), e7.on("terrain", this._update), e7.on("projectiontransition", this._update), this.setDraggable(this._draggable), this._update(), this._map.on("click", this._onMapClick), this;
            }
            remove() {
              return this._opacityTimeout && (clearTimeout(this._opacityTimeout), delete this._opacityTimeout), this._map && (this._map.off("click", this._onMapClick), this._map.off("move", this._update), this._map.off("moveend", this._update), this._map.off("terrain", this._update), this._map.off("projectiontransition", this._update), this._map.off("mousedown", this._addDragHandler), this._map.off("touchstart", this._addDragHandler), this._map.off("mouseup", this._onUp), this._map.off("touchend", this._onUp), this._map.off("mousemove", this._onMove), this._map.off("touchmove", this._onMove), delete this._map), n5.remove(this._element), this._popup && this._popup.remove(), this;
            }
            getLngLat() {
              return this._lngLat;
            }
            setLngLat(e7) {
              return this._lngLat = t4.Q.convert(e7), this._pos = null, this._popup && this._popup.setLngLat(this._lngLat), this._update(), this;
            }
            getElement() {
              return this._element;
            }
            setPopup(e7) {
              if (this._popup && (this._popup.remove(), this._popup = null, this._element.removeEventListener("keypress", this._onKeyPress), this._originalTabIndex || this._element.removeAttribute("tabindex")), e7) {
                if (!("offset" in e7.options)) {
                  const t5 = 38.1, i6 = 13.5, r7 = Math.abs(i6) / Math.SQRT2;
                  e7.options.offset = this._defaultMarker ? { top: [0, 0], "top-left": [0, 0], "top-right": [0, 0], bottom: [0, -38.1], "bottom-left": [r7, -1 * (t5 - i6 + r7)], "bottom-right": [-r7, -1 * (t5 - i6 + r7)], left: [i6, -1 * (t5 - i6)], right: [-13.5, -1 * (t5 - i6)] } : this._offset;
                }
                this._popup = e7, this._originalTabIndex = this._element.getAttribute("tabindex"), this._originalTabIndex || this._element.setAttribute("tabindex", "0"), this._element.addEventListener("keypress", this._onKeyPress);
              }
              return this;
            }
            setSubpixelPositioning(e7) {
              return this._subpixelPositioning = e7, this;
            }
            getPopup() {
              return this._popup;
            }
            togglePopup() {
              const e7 = this._popup;
              return this._element.style.opacity === this._opacityWhenCovered ? this : e7 ? (e7.isOpen() ? e7.remove() : (e7.setLngLat(this._lngLat), e7.addTo(this._map)), this) : this;
            }
            _updateOpacity(e7 = false) {
              var i6, r7;
              if (!(null === (i6 = this._map) || void 0 === i6 ? void 0 : i6.terrain)) {
                const e8 = this._map.transform.isLocationOccluded(this._lngLat) ? this._opacityWhenCovered : this._opacity;
                return void (this._element.style.opacity !== e8 && (this._element.style.opacity = e8));
              }
              if (e7) this._opacityTimeout = null;
              else {
                if (this._opacityTimeout) return;
                this._opacityTimeout = setTimeout(() => {
                  this._opacityTimeout = null;
                }, 100);
              }
              const o7 = this._map, a4 = o7.terrain.depthAtPoint(this._pos), s5 = o7.terrain.getElevationForLngLatZoom(this._lngLat, o7.transform.tileZoom);
              if (o7.transform.lngLatToCameraDepth(this._lngLat, s5) - a4 < 6e-3) return void (this._element.style.opacity = this._opacity);
              const n6 = -this._offset.y / o7.transform.pixelsPerMeter, l5 = Math.sin(o7.getPitch() * Math.PI / 180) * n6, c5 = o7.terrain.depthAtPoint(new t4.P(this._pos.x, this._pos.y - this._offset.y)), h4 = o7.transform.lngLatToCameraDepth(this._lngLat, s5 + l5) - c5 > 6e-3;
              (null === (r7 = this._popup) || void 0 === r7 ? void 0 : r7.isOpen()) && h4 && this._popup.remove(), this._element.style.opacity = h4 ? this._opacityWhenCovered : this._opacity;
            }
            getOffset() {
              return this._offset;
            }
            setOffset(e7) {
              return this._offset = t4.P.convert(e7), this._update(), this;
            }
            addClassName(e7) {
              this._element.classList.add(e7);
            }
            removeClassName(e7) {
              this._element.classList.remove(e7);
            }
            toggleClassName(e7) {
              return this._element.classList.toggle(e7);
            }
            setDraggable(e7) {
              return this._draggable = !!e7, this._map && (e7 ? (this._map.on("mousedown", this._addDragHandler), this._map.on("touchstart", this._addDragHandler)) : (this._map.off("mousedown", this._addDragHandler), this._map.off("touchstart", this._addDragHandler))), this;
            }
            isDraggable() {
              return this._draggable;
            }
            setRotation(e7) {
              return this._rotation = e7 || 0, this._update(), this;
            }
            getRotation() {
              return this._rotation;
            }
            setRotationAlignment(e7) {
              return this._rotationAlignment = e7 || "auto", this._update(), this;
            }
            getRotationAlignment() {
              return this._rotationAlignment;
            }
            setPitchAlignment(e7) {
              return this._pitchAlignment = e7 && "auto" !== e7 ? e7 : this._rotationAlignment, this._update(), this;
            }
            getPitchAlignment() {
              return this._pitchAlignment;
            }
            setOpacity(e7, t5) {
              return (void 0 === this._opacity || void 0 === e7 && void 0 === t5) && (this._opacity = "1", this._opacityWhenCovered = "0.2"), void 0 !== e7 && (this._opacity = e7), void 0 !== t5 && (this._opacityWhenCovered = t5), this._map && this._updateOpacity(true), this;
            }
          }
          const Na = { positionOptions: { enableHighAccuracy: false, maximumAge: 0, timeout: 6e3 }, fitBoundsOptions: { maxZoom: 15 }, trackUserLocation: false, showAccuracyCircle: true, showUserLocation: true };
          let Ga = 0, Ua = false;
          const Va = { maxWidth: 100, unit: "metric" };
          function qa(e7, t5, i6) {
            const r7 = i6 && i6.maxWidth || 100, o7 = e7._container.clientHeight / 2, a4 = e7._container.clientWidth / 2, s5 = e7.unproject([a4 - r7 / 2, o7]), n6 = e7.unproject([a4 + r7 / 2, o7]), l5 = Math.round(e7.project(n6).x - e7.project(s5).x), c5 = Math.min(r7, l5, e7._container.clientWidth), h4 = s5.distanceTo(n6);
            if (i6 && "imperial" === i6.unit) {
              const i7 = 3.2808 * h4;
              i7 > 5280 ? Wa(t5, c5, i7 / 5280, e7._getUIString("ScaleControl.Miles")) : Wa(t5, c5, i7, e7._getUIString("ScaleControl.Feet"));
            } else i6 && "nautical" === i6.unit ? Wa(t5, c5, h4 / 1852, e7._getUIString("ScaleControl.NauticalMiles")) : h4 >= 1e3 ? Wa(t5, c5, h4 / 1e3, e7._getUIString("ScaleControl.Kilometers")) : Wa(t5, c5, h4, e7._getUIString("ScaleControl.Meters"));
          }
          function Wa(e7, t5, i6, r7) {
            const o7 = function(e8) {
              const t6 = Math.pow(10, `${Math.floor(e8)}`.length - 1);
              let i7 = e8 / t6;
              return i7 = i7 >= 10 ? 10 : i7 >= 5 ? 5 : i7 >= 3 ? 3 : i7 >= 2 ? 2 : i7 >= 1 ? 1 : function(e9) {
                const t7 = Math.pow(10, Math.ceil(-Math.log(e9) / Math.LN10));
                return Math.round(e9 * t7) / t7;
              }(i7), t6 * i7;
            }(i6);
            e7.style.width = t5 * (o7 / i6) + "px", e7.innerHTML = `${o7}&nbsp;${r7}`;
          }
          const $a = { closeButton: true, closeOnClick: true, focusAfterOpen: true, className: "", maxWidth: "240px", subpixelPositioning: false, locationOccludedOpacity: void 0 }, Ha = ["a[href]", "[tabindex]:not([tabindex='-1'])", "[contenteditable]:not([contenteditable='false'])", "button:not([disabled])", "input:not([disabled])", "select:not([disabled])", "textarea:not([disabled])"].join(", ");
          function Ka(e7) {
            if (e7) {
              if ("number" == typeof e7) {
                const i6 = Math.round(Math.abs(e7) / Math.SQRT2);
                return { center: new t4.P(0, 0), top: new t4.P(0, e7), "top-left": new t4.P(i6, i6), "top-right": new t4.P(-i6, i6), bottom: new t4.P(0, -e7), "bottom-left": new t4.P(i6, -i6), "bottom-right": new t4.P(-i6, -i6), left: new t4.P(e7, 0), right: new t4.P(-e7, 0) };
              }
              if (e7 instanceof t4.P || Array.isArray(e7)) {
                const i6 = t4.P.convert(e7);
                return { center: i6, top: i6, "top-left": i6, "top-right": i6, bottom: i6, "bottom-left": i6, "bottom-right": i6, left: i6, right: i6 };
              }
              return { center: t4.P.convert(e7.center || [0, 0]), top: t4.P.convert(e7.top || [0, 0]), "top-left": t4.P.convert(e7["top-left"] || [0, 0]), "top-right": t4.P.convert(e7["top-right"] || [0, 0]), bottom: t4.P.convert(e7.bottom || [0, 0]), "bottom-left": t4.P.convert(e7["bottom-left"] || [0, 0]), "bottom-right": t4.P.convert(e7["bottom-right"] || [0, 0]), left: t4.P.convert(e7.left || [0, 0]), right: t4.P.convert(e7.right || [0, 0]) };
            }
            return Ka(new t4.P(0, 0));
          }
          const Xa = i5;
          e6.AJAXError = t4.cm, e6.Event = t4.l, e6.Evented = t4.E, e6.LngLat = t4.Q, e6.MercatorCoordinate = t4.$, e6.Point = t4.P, e6.addProtocol = t4.cn, e6.config = t4.a, e6.removeProtocol = t4.co, e6.AttributionControl = wa, e6.BoxZoomHandler = Oo, e6.CanvasSource = Y2, e6.CooperativeGesturesHandler = ma, e6.DoubleClickZoomHandler = ca, e6.DragPanHandler = da, e6.DragRotateHandler = _a2, e6.EdgeInsets = Pt, e6.FullscreenControl = class extends t4.E {
            constructor(e7 = {}) {
              super(), this._onFullscreenChange = () => {
                var e8;
                let t5 = window.document.fullscreenElement || window.document.mozFullScreenElement || window.document.webkitFullscreenElement || window.document.msFullscreenElement;
                for (; null === (e8 = null == t5 ? void 0 : t5.shadowRoot) || void 0 === e8 ? void 0 : e8.fullscreenElement; ) t5 = t5.shadowRoot.fullscreenElement;
                t5 === this._container !== this._fullscreen && this._handleFullscreenChange();
              }, this._onClickFullscreen = () => {
                this._isFullscreen() ? this._exitFullscreen() : this._requestFullscreen();
              }, this._fullscreen = false, e7 && e7.container && (e7.container instanceof HTMLElement ? this._container = e7.container : t4.w("Full screen control 'container' must be a DOM element.")), "onfullscreenchange" in document ? this._fullscreenchange = "fullscreenchange" : "onmozfullscreenchange" in document ? this._fullscreenchange = "mozfullscreenchange" : "onwebkitfullscreenchange" in document ? this._fullscreenchange = "webkitfullscreenchange" : "onmsfullscreenchange" in document && (this._fullscreenchange = "MSFullscreenChange");
            }
            onAdd(e7) {
              return this._map = e7, this._container || (this._container = this._map.getContainer()), this._controlContainer = n5.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._setupUI(), this._controlContainer;
            }
            onRemove() {
              n5.remove(this._controlContainer), this._map = null, window.document.removeEventListener(this._fullscreenchange, this._onFullscreenChange);
            }
            _setupUI() {
              const e7 = this._fullscreenButton = n5.create("button", "maplibregl-ctrl-fullscreen", this._controlContainer);
              n5.create("span", "maplibregl-ctrl-icon", e7).setAttribute("aria-hidden", "true"), e7.type = "button", this._updateTitle(), this._fullscreenButton.addEventListener("click", this._onClickFullscreen), window.document.addEventListener(this._fullscreenchange, this._onFullscreenChange);
            }
            _updateTitle() {
              const e7 = this._getTitle();
              this._fullscreenButton.setAttribute("aria-label", e7), this._fullscreenButton.title = e7;
            }
            _getTitle() {
              return this._map._getUIString(this._isFullscreen() ? "FullscreenControl.Exit" : "FullscreenControl.Enter");
            }
            _isFullscreen() {
              return this._fullscreen;
            }
            _handleFullscreenChange() {
              this._fullscreen = !this._fullscreen, this._fullscreenButton.classList.toggle("maplibregl-ctrl-shrink"), this._fullscreenButton.classList.toggle("maplibregl-ctrl-fullscreen"), this._updateTitle(), this._fullscreen ? (this.fire(new t4.l("fullscreenstart")), this._prevCooperativeGesturesEnabled = this._map.cooperativeGestures.isEnabled(), this._map.cooperativeGestures.disable()) : (this.fire(new t4.l("fullscreenend")), this._prevCooperativeGesturesEnabled && this._map.cooperativeGestures.enable());
            }
            _exitFullscreen() {
              window.document.exitFullscreen ? window.document.exitFullscreen() : window.document.mozCancelFullScreen ? window.document.mozCancelFullScreen() : window.document.msExitFullscreen ? window.document.msExitFullscreen() : window.document.webkitCancelFullScreen ? window.document.webkitCancelFullScreen() : this._togglePseudoFullScreen();
            }
            _requestFullscreen() {
              this._container.requestFullscreen ? this._container.requestFullscreen() : this._container.mozRequestFullScreen ? this._container.mozRequestFullScreen() : this._container.msRequestFullscreen ? this._container.msRequestFullscreen() : this._container.webkitRequestFullscreen ? this._container.webkitRequestFullscreen() : this._togglePseudoFullScreen();
            }
            _togglePseudoFullScreen() {
              this._container.classList.toggle("maplibregl-pseudo-fullscreen"), this._handleFullscreenChange(), this._map.resize();
            }
          }, e6.GeoJSONSource = K2, e6.GeolocateControl = class extends t4.E {
            constructor(e7) {
              super(), this._onSuccess = (e8) => {
                if (this._map) {
                  if (this._isOutOfMapMaxBounds(e8)) return this._setErrorState(), this.fire(new t4.l("outofmaxbounds", e8)), this._updateMarker(), void this._finish();
                  if (this.options.trackUserLocation) switch (this._lastKnownPosition = e8, this._watchState) {
                    case "WAITING_ACTIVE":
                    case "ACTIVE_LOCK":
                    case "ACTIVE_ERROR":
                      this._watchState = "ACTIVE_LOCK", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active");
                      break;
                    case "BACKGROUND":
                    case "BACKGROUND_ERROR":
                      this._watchState = "BACKGROUND", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-background");
                      break;
                    default:
                      throw new Error(`Unexpected watchState ${this._watchState}`);
                  }
                  this.options.showUserLocation && "OFF" !== this._watchState && this._updateMarker(e8), this.options.trackUserLocation && "ACTIVE_LOCK" !== this._watchState || this._updateCamera(e8), this.options.showUserLocation && this._dotElement.classList.remove("maplibregl-user-location-dot-stale"), this.fire(new t4.l("geolocate", e8)), this._finish();
                }
              }, this._updateCamera = (e8) => {
                const i6 = new t4.Q(e8.coords.longitude, e8.coords.latitude), r7 = e8.coords.accuracy, o7 = this._map.getBearing(), a4 = t4.e({ bearing: o7 }, this.options.fitBoundsOptions), s5 = V2.fromLngLat(i6, r7);
                this._map.fitBounds(s5, a4, { geolocateSource: true });
              }, this._updateMarker = (e8) => {
                if (e8) {
                  const i6 = new t4.Q(e8.coords.longitude, e8.coords.latitude);
                  this._accuracyCircleMarker.setLngLat(i6).addTo(this._map), this._userLocationDotMarker.setLngLat(i6).addTo(this._map), this._accuracy = e8.coords.accuracy, this.options.showUserLocation && this.options.showAccuracyCircle && this._updateCircleRadius();
                } else this._userLocationDotMarker.remove(), this._accuracyCircleMarker.remove();
              }, this._onZoom = () => {
                this.options.showUserLocation && this.options.showAccuracyCircle && this._updateCircleRadius();
              }, this._onError = (e8) => {
                if (this._map) {
                  if (this.options.trackUserLocation) if (1 === e8.code) {
                    this._watchState = "OFF", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active-error"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background-error"), this._geolocateButton.disabled = true;
                    const e9 = this._map._getUIString("GeolocateControl.LocationNotAvailable");
                    this._geolocateButton.title = e9, this._geolocateButton.setAttribute("aria-label", e9), void 0 !== this._geolocationWatchID && this._clearWatch();
                  } else {
                    if (3 === e8.code && Ua) return;
                    this._setErrorState();
                  }
                  "OFF" !== this._watchState && this.options.showUserLocation && this._dotElement.classList.add("maplibregl-user-location-dot-stale"), this.fire(new t4.l("error", e8)), this._finish();
                }
              }, this._finish = () => {
                this._timeoutId && clearTimeout(this._timeoutId), this._timeoutId = void 0;
              }, this._setupUI = () => {
                this._map && (this._container.addEventListener("contextmenu", (e8) => e8.preventDefault()), this._geolocateButton = n5.create("button", "maplibregl-ctrl-geolocate", this._container), n5.create("span", "maplibregl-ctrl-icon", this._geolocateButton).setAttribute("aria-hidden", "true"), this._geolocateButton.type = "button", this._geolocateButton.disabled = true);
              }, this._finishSetupUI = (e8) => {
                if (this._map) {
                  if (false === e8) {
                    t4.w("Geolocation support is not available so the GeolocateControl will be disabled.");
                    const e9 = this._map._getUIString("GeolocateControl.LocationNotAvailable");
                    this._geolocateButton.disabled = true, this._geolocateButton.title = e9, this._geolocateButton.setAttribute("aria-label", e9);
                  } else {
                    const e9 = this._map._getUIString("GeolocateControl.FindMyLocation");
                    this._geolocateButton.disabled = false, this._geolocateButton.title = e9, this._geolocateButton.setAttribute("aria-label", e9);
                  }
                  this.options.trackUserLocation && (this._geolocateButton.setAttribute("aria-pressed", "false"), this._watchState = "OFF"), this.options.showUserLocation && (this._dotElement = n5.create("div", "maplibregl-user-location-dot"), this._userLocationDotMarker = new Za({ element: this._dotElement }), this._circleElement = n5.create("div", "maplibregl-user-location-accuracy-circle"), this._accuracyCircleMarker = new Za({ element: this._circleElement, pitchAlignment: "map" }), this.options.trackUserLocation && (this._watchState = "OFF"), this._map.on("zoom", this._onZoom)), this._geolocateButton.addEventListener("click", () => this.trigger()), this._setup = true, this.options.trackUserLocation && this._map.on("movestart", (e9) => {
                    e9.geolocateSource || "ACTIVE_LOCK" !== this._watchState || e9.originalEvent && "resize" === e9.originalEvent.type || (this._watchState = "BACKGROUND", this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this.fire(new t4.l("trackuserlocationend")), this.fire(new t4.l("userlocationlostfocus")));
                  });
                }
              }, this.options = t4.e({}, Na, e7);
            }
            onAdd(e7) {
              return this._map = e7, this._container = n5.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._setupUI(), function() {
                return t4._(this, arguments, void 0, function* (e8 = false) {
                  if (void 0 !== Fa && !e8) return Fa;
                  if (void 0 === window.navigator.permissions) return Fa = !!window.navigator.geolocation, Fa;
                  try {
                    const e9 = yield window.navigator.permissions.query({ name: "geolocation" });
                    Fa = "denied" !== e9.state;
                  } catch (e9) {
                    Fa = !!window.navigator.geolocation;
                  }
                  return Fa;
                });
              }().then((e8) => this._finishSetupUI(e8)), this._container;
            }
            onRemove() {
              void 0 !== this._geolocationWatchID && (window.navigator.geolocation.clearWatch(this._geolocationWatchID), this._geolocationWatchID = void 0), this.options.showUserLocation && this._userLocationDotMarker && this._userLocationDotMarker.remove(), this.options.showAccuracyCircle && this._accuracyCircleMarker && this._accuracyCircleMarker.remove(), n5.remove(this._container), this._map.off("zoom", this._onZoom), this._map = void 0, Ga = 0, Ua = false;
            }
            _isOutOfMapMaxBounds(e7) {
              const t5 = this._map.getMaxBounds(), i6 = e7.coords;
              return t5 && (i6.longitude < t5.getWest() || i6.longitude > t5.getEast() || i6.latitude < t5.getSouth() || i6.latitude > t5.getNorth());
            }
            _setErrorState() {
              switch (this._watchState) {
                case "WAITING_ACTIVE":
                  this._watchState = "ACTIVE_ERROR", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active-error");
                  break;
                case "ACTIVE_LOCK":
                  this._watchState = "ACTIVE_ERROR", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting");
                  break;
                case "BACKGROUND":
                  this._watchState = "BACKGROUND_ERROR", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-background-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting");
                  break;
                case "ACTIVE_ERROR":
                  break;
                default:
                  throw new Error(`Unexpected watchState ${this._watchState}`);
              }
            }
            _updateCircleRadius() {
              const e7 = this._map.getBounds(), t5 = e7.getSouthEast(), i6 = e7.getNorthEast(), r7 = t5.distanceTo(i6), o7 = Math.ceil(this._accuracy / (r7 / this._map._container.clientHeight) * 2);
              this._circleElement.style.width = `${o7}px`, this._circleElement.style.height = `${o7}px`;
            }
            trigger() {
              if (!this._setup) return t4.w("Geolocate control triggered before added to a map"), false;
              if (this.options.trackUserLocation) {
                switch (this._watchState) {
                  case "OFF":
                    this._watchState = "WAITING_ACTIVE", this.fire(new t4.l("trackuserlocationstart"));
                    break;
                  case "WAITING_ACTIVE":
                  case "ACTIVE_LOCK":
                  case "ACTIVE_ERROR":
                  case "BACKGROUND_ERROR":
                    Ga--, Ua = false, this._watchState = "OFF", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active-error"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background-error"), this.fire(new t4.l("trackuserlocationend"));
                    break;
                  case "BACKGROUND":
                    this._watchState = "ACTIVE_LOCK", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"), this._lastKnownPosition && this._updateCamera(this._lastKnownPosition), this.fire(new t4.l("trackuserlocationstart")), this.fire(new t4.l("userlocationfocus"));
                    break;
                  default:
                    throw new Error(`Unexpected watchState ${this._watchState}`);
                }
                switch (this._watchState) {
                  case "WAITING_ACTIVE":
                    this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active");
                    break;
                  case "ACTIVE_LOCK":
                    this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active");
                    break;
                  case "OFF":
                    break;
                  default:
                    throw new Error(`Unexpected watchState ${this._watchState}`);
                }
                if ("OFF" === this._watchState && void 0 !== this._geolocationWatchID) this._clearWatch();
                else if (void 0 === this._geolocationWatchID) {
                  let e7;
                  this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.setAttribute("aria-pressed", "true"), Ga++, Ga > 1 ? (e7 = { maximumAge: 6e5, timeout: 0 }, Ua = true) : (e7 = this.options.positionOptions, Ua = false), this._geolocationWatchID = window.navigator.geolocation.watchPosition(this._onSuccess, this._onError, e7);
                }
              } else window.navigator.geolocation.getCurrentPosition(this._onSuccess, this._onError, this.options.positionOptions), this._timeoutId = setTimeout(this._finish, 1e4);
              return true;
            }
            _clearWatch() {
              window.navigator.geolocation.clearWatch(this._geolocationWatchID), this._geolocationWatchID = void 0, this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.setAttribute("aria-pressed", "false"), this.options.showUserLocation && this._updateMarker(null);
            }
          }, e6.GlobeControl = class {
            constructor() {
              this._toggleProjection = () => {
                var e7;
                const t5 = null === (e7 = this._map.getProjection()) || void 0 === e7 ? void 0 : e7.type;
                this._map.setProjection("mercator" !== t5 && t5 ? { type: "mercator" } : { type: "globe" }), this._updateGlobeIcon();
              }, this._updateGlobeIcon = () => {
                var e7;
                this._globeButton.classList.remove("maplibregl-ctrl-globe"), this._globeButton.classList.remove("maplibregl-ctrl-globe-enabled"), "globe" === (null === (e7 = this._map.getProjection()) || void 0 === e7 ? void 0 : e7.type) ? (this._globeButton.classList.add("maplibregl-ctrl-globe-enabled"), this._globeButton.title = this._map._getUIString("GlobeControl.Disable")) : (this._globeButton.classList.add("maplibregl-ctrl-globe"), this._globeButton.title = this._map._getUIString("GlobeControl.Enable"));
              };
            }
            onAdd(e7) {
              return this._map = e7, this._container = n5.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._globeButton = n5.create("button", "maplibregl-ctrl-globe", this._container), n5.create("span", "maplibregl-ctrl-icon", this._globeButton).setAttribute("aria-hidden", "true"), this._globeButton.type = "button", this._globeButton.addEventListener("click", this._toggleProjection), this._updateGlobeIcon(), this._map.on("styledata", this._updateGlobeIcon), this._container;
            }
            onRemove() {
              n5.remove(this._container), this._map.off("styledata", this._updateGlobeIcon), this._globeButton.removeEventListener("click", this._toggleProjection), this._map = void 0;
            }
          }, e6.Hash = wo, e6.ImageSource = X2, e6.KeyboardHandler = aa, e6.LngLatBounds = V2, e6.LogoControl = Ta, e6.Map = class extends ba {
            constructor(e7) {
              var i6, r7;
              t4.cj.mark(t4.ck.create);
              const o7 = Object.assign(Object.assign(Object.assign({}, Aa), e7), { canvasContextAttributes: Object.assign(Object.assign({}, Aa.canvasContextAttributes), e7.canvasContextAttributes) });
              if (null != o7.minZoom && null != o7.maxZoom && o7.minZoom > o7.maxZoom) throw new Error("maxZoom must be greater than or equal to minZoom");
              if (null != o7.minPitch && null != o7.maxPitch && o7.minPitch > o7.maxPitch) throw new Error("maxPitch must be greater than or equal to minPitch");
              if (null != o7.minPitch && o7.minPitch < 0) throw new Error("minPitch must be greater than or equal to 0");
              if (null != o7.maxPitch && o7.maxPitch > 180) throw new Error("maxPitch must be less than or equal to 180");
              const a4 = new Dt(), s5 = new kt();
              if (void 0 !== o7.minZoom && a4.setMinZoom(o7.minZoom), void 0 !== o7.maxZoom && a4.setMaxZoom(o7.maxZoom), void 0 !== o7.minPitch && a4.setMinPitch(o7.minPitch), void 0 !== o7.maxPitch && a4.setMaxPitch(o7.maxPitch), void 0 !== o7.renderWorldCopies && a4.setRenderWorldCopies(o7.renderWorldCopies), super(a4, s5, { bearingSnap: o7.bearingSnap }), this._idleTriggered = false, this._crossFadingFactor = 1, this._renderTaskQueue = new Pa(), this._controls = [], this._mapId = t4.a4(), this._contextLost = (e8) => {
                e8.preventDefault(), this._frameRequest && (this._frameRequest.abort(), this._frameRequest = null), this.fire(new t4.l("webglcontextlost", { originalEvent: e8 }));
              }, this._contextRestored = (e8) => {
                this._setupPainter(), this.resize(), this._update(), this.fire(new t4.l("webglcontextrestored", { originalEvent: e8 }));
              }, this._onMapScroll = (e8) => {
                if (e8.target === this._container) return this._container.scrollTop = 0, this._container.scrollLeft = 0, false;
              }, this._onWindowOnline = () => {
                this._update();
              }, this._interactive = o7.interactive, this._maxTileCacheSize = o7.maxTileCacheSize, this._maxTileCacheZoomLevels = o7.maxTileCacheZoomLevels, this._canvasContextAttributes = Object.assign({}, o7.canvasContextAttributes), this._trackResize = true === o7.trackResize, this._bearingSnap = o7.bearingSnap, this._centerClampedToGround = o7.centerClampedToGround, this._refreshExpiredTiles = true === o7.refreshExpiredTiles, this._fadeDuration = o7.fadeDuration, this._crossSourceCollisions = true === o7.crossSourceCollisions, this._collectResourceTiming = true === o7.collectResourceTiming, this._locale = Object.assign(Object.assign({}, Da), o7.locale), this._clickTolerance = o7.clickTolerance, this._overridePixelRatio = o7.pixelRatio, this._maxCanvasSize = o7.maxCanvasSize, this.transformCameraUpdate = o7.transformCameraUpdate, this.cancelPendingTileRequestsWhileZooming = true === o7.cancelPendingTileRequestsWhileZooming, this._imageQueueHandle = p3.addThrottleControl(() => this.isMoving()), this._requestManager = new m3(o7.transformRequest), "string" == typeof o7.container) {
                if (this._container = document.getElementById(o7.container), !this._container) throw new Error(`Container '${o7.container}' not found.`);
              } else {
                if (!(o7.container instanceof HTMLElement)) throw new Error("Invalid type: 'container' must be a String or HTMLElement.");
                this._container = o7.container;
              }
              if (o7.maxBounds && this.setMaxBounds(o7.maxBounds), this._setupContainer(), this._setupPainter(), this.on("move", () => this._update(false)), this.on("moveend", () => this._update(false)), this.on("zoom", () => this._update(true)), this.on("terrain", () => {
                this.painter.terrainFacilitator.dirty = true, this._update(true);
              }), this.once("idle", () => {
                this._idleTriggered = true;
              }), "undefined" != typeof window) {
                addEventListener("online", this._onWindowOnline, false);
                let e8 = false;
                const t5 = yo((e9) => {
                  this._trackResize && !this._removed && (this.resize(e9), this.redraw());
                }, 50);
                this._resizeObserver = new ResizeObserver((i7) => {
                  e8 ? t5(i7) : e8 = true;
                }), this._resizeObserver.observe(this._container);
              }
              this.handlers = new xa(this, o7), this._hash = o7.hash && new wo("string" == typeof o7.hash && o7.hash || void 0).addTo(this), this._hash && this._hash._onHashChange() || (this.jumpTo({ center: o7.center, elevation: o7.elevation, zoom: o7.zoom, bearing: o7.bearing, pitch: o7.pitch, roll: o7.roll }), o7.bounds && (this.resize(), this.fitBounds(o7.bounds, t4.e({}, o7.fitBoundsOptions, { duration: 0 }))));
              const n6 = "string" == typeof o7.style || !("globe" === (null === (r7 = null === (i6 = o7.style) || void 0 === i6 ? void 0 : i6.projection) || void 0 === r7 ? void 0 : r7.type));
              this.resize(null, n6), this._localIdeographFontFamily = o7.localIdeographFontFamily, this._validateStyle = o7.validateStyle, o7.style && this.setStyle(o7.style, { localIdeographFontFamily: o7.localIdeographFontFamily }), o7.attributionControl && this.addControl(new wa("boolean" == typeof o7.attributionControl ? void 0 : o7.attributionControl)), o7.maplibreLogo && this.addControl(new Ta(), o7.logoPosition), this.on("style.load", () => {
                if (n6 || this._resizeTransform(), this.transform.unmodified) {
                  const e8 = t4.O(this.style.stylesheet, ["center", "zoom", "bearing", "pitch", "roll"]);
                  this.jumpTo(e8);
                }
              }), this.on("data", (e8) => {
                this._update("style" === e8.dataType), this.fire(new t4.l(`${e8.dataType}data`, e8));
              }), this.on("dataloading", (e8) => {
                this.fire(new t4.l(`${e8.dataType}dataloading`, e8));
              }), this.on("dataabort", (e8) => {
                this.fire(new t4.l("sourcedataabort", e8));
              });
            }
            _getMapId() {
              return this._mapId;
            }
            addControl(e7, i6) {
              if (void 0 === i6 && (i6 = e7.getDefaultPosition ? e7.getDefaultPosition() : "top-right"), !e7 || !e7.onAdd) return this.fire(new t4.k(new Error("Invalid argument to map.addControl(). Argument must be a control with onAdd and onRemove methods.")));
              const r7 = e7.onAdd(this);
              this._controls.push(e7);
              const o7 = this._controlPositions[i6];
              return -1 !== i6.indexOf("bottom") ? o7.insertBefore(r7, o7.firstChild) : o7.appendChild(r7), this;
            }
            removeControl(e7) {
              if (!e7 || !e7.onRemove) return this.fire(new t4.k(new Error("Invalid argument to map.removeControl(). Argument must be a control with onAdd and onRemove methods.")));
              const i6 = this._controls.indexOf(e7);
              return i6 > -1 && this._controls.splice(i6, 1), e7.onRemove(this), this;
            }
            hasControl(e7) {
              return this._controls.indexOf(e7) > -1;
            }
            calculateCameraOptionsFromTo(e7, t5, i6, r7) {
              return null == r7 && this.terrain && (r7 = this.terrain.getElevationForLngLatZoom(i6, this.transform.tileZoom)), super.calculateCameraOptionsFromTo(e7, t5, i6, r7);
            }
            resize(e7, i6 = true) {
              const [r7, o7] = this._containerDimensions(), a4 = this._getClampedPixelRatio(r7, o7);
              if (this._resizeCanvas(r7, o7, a4), this.painter.resize(r7, o7, a4), this.painter.overLimit()) {
                const e8 = this.painter.context.gl;
                this._maxCanvasSize = [e8.drawingBufferWidth, e8.drawingBufferHeight];
                const t5 = this._getClampedPixelRatio(r7, o7);
                this._resizeCanvas(r7, o7, t5), this.painter.resize(r7, o7, t5);
              }
              this._resizeTransform(i6);
              const s5 = !this._moving;
              return s5 && (this.stop(), this.fire(new t4.l("movestart", e7)).fire(new t4.l("move", e7))), this.fire(new t4.l("resize", e7)), s5 && this.fire(new t4.l("moveend", e7)), this;
            }
            _resizeTransform(e7 = true) {
              var t5;
              const [i6, r7] = this._containerDimensions();
              this.transform.resize(i6, r7, e7), null === (t5 = this._requestedCameraState) || void 0 === t5 || t5.resize(i6, r7, e7);
            }
            _getClampedPixelRatio(e7, t5) {
              const { 0: i6, 1: r7 } = this._maxCanvasSize, o7 = this.getPixelRatio(), a4 = e7 * o7, s5 = t5 * o7;
              return Math.min(a4 > i6 ? i6 / a4 : 1, s5 > r7 ? r7 / s5 : 1) * o7;
            }
            getPixelRatio() {
              var e7;
              return null !== (e7 = this._overridePixelRatio) && void 0 !== e7 ? e7 : devicePixelRatio;
            }
            setPixelRatio(e7) {
              this._overridePixelRatio = e7, this.resize();
            }
            getBounds() {
              return this.transform.getBounds();
            }
            getMaxBounds() {
              return this.transform.getMaxBounds();
            }
            setMaxBounds(e7) {
              return this.transform.setMaxBounds(V2.convert(e7)), this._update();
            }
            setMinZoom(e7) {
              if ((e7 = null == e7 ? -2 : e7) >= -2 && e7 <= this.transform.maxZoom) return this.transform.setMinZoom(e7), this._update(), this.getZoom() < e7 && this.setZoom(e7), this;
              throw new Error("minZoom must be between -2 and the current maxZoom, inclusive");
            }
            getMinZoom() {
              return this.transform.minZoom;
            }
            setMaxZoom(e7) {
              if ((e7 = null == e7 ? 22 : e7) >= this.transform.minZoom) return this.transform.setMaxZoom(e7), this._update(), this.getZoom() > e7 && this.setZoom(e7), this;
              throw new Error("maxZoom must be greater than the current minZoom");
            }
            getMaxZoom() {
              return this.transform.maxZoom;
            }
            setMinPitch(e7) {
              if ((e7 = null == e7 ? 0 : e7) < 0) throw new Error("minPitch must be greater than or equal to 0");
              if (e7 >= 0 && e7 <= this.transform.maxPitch) return this.transform.setMinPitch(e7), this._update(), this.getPitch() < e7 && this.setPitch(e7), this;
              throw new Error("minPitch must be between 0 and the current maxPitch, inclusive");
            }
            getMinPitch() {
              return this.transform.minPitch;
            }
            setMaxPitch(e7) {
              if ((e7 = null == e7 ? 60 : e7) > 180) throw new Error("maxPitch must be less than or equal to 180");
              if (e7 >= this.transform.minPitch) return this.transform.setMaxPitch(e7), this._update(), this.getPitch() > e7 && this.setPitch(e7), this;
              throw new Error("maxPitch must be greater than the current minPitch");
            }
            getMaxPitch() {
              return this.transform.maxPitch;
            }
            getRenderWorldCopies() {
              return this.transform.renderWorldCopies;
            }
            setRenderWorldCopies(e7) {
              return this.transform.setRenderWorldCopies(e7), this._update();
            }
            project(e7) {
              return this.transform.locationToScreenPoint(t4.Q.convert(e7), this.style && this.terrain);
            }
            unproject(e7) {
              return this.transform.screenPointToLocation(t4.P.convert(e7), this.terrain);
            }
            isMoving() {
              var e7;
              return this._moving || (null === (e7 = this.handlers) || void 0 === e7 ? void 0 : e7.isMoving());
            }
            isZooming() {
              var e7;
              return this._zooming || (null === (e7 = this.handlers) || void 0 === e7 ? void 0 : e7.isZooming());
            }
            isRotating() {
              var e7;
              return this._rotating || (null === (e7 = this.handlers) || void 0 === e7 ? void 0 : e7.isRotating());
            }
            _createDelegatedListener(e7, t5, i6) {
              if ("mouseenter" === e7 || "mouseover" === e7) {
                let r7 = false;
                const o7 = (o8) => {
                  const a4 = t5.filter((e8) => this.getLayer(e8)), s5 = 0 !== a4.length ? this.queryRenderedFeatures(o8.point, { layers: a4 }) : [];
                  s5.length ? r7 || (r7 = true, i6.call(this, new zo(e7, this, o8.originalEvent, { features: s5 }))) : r7 = false;
                };
                return { layers: t5, listener: i6, delegates: { mousemove: o7, mouseout: () => {
                  r7 = false;
                } } };
              }
              if ("mouseleave" === e7 || "mouseout" === e7) {
                let r7 = false;
                const o7 = (o8) => {
                  const a5 = t5.filter((e8) => this.getLayer(e8));
                  (0 !== a5.length ? this.queryRenderedFeatures(o8.point, { layers: a5 }) : []).length ? r7 = true : r7 && (r7 = false, i6.call(this, new zo(e7, this, o8.originalEvent)));
                }, a4 = (t6) => {
                  r7 && (r7 = false, i6.call(this, new zo(e7, this, t6.originalEvent)));
                };
                return { layers: t5, listener: i6, delegates: { mousemove: o7, mouseout: a4 } };
              }
              {
                const r7 = (e8) => {
                  const r8 = t5.filter((e9) => this.getLayer(e9)), o7 = 0 !== r8.length ? this.queryRenderedFeatures(e8.point, { layers: r8 }) : [];
                  o7.length && (e8.features = o7, i6.call(this, e8), delete e8.features);
                };
                return { layers: t5, listener: i6, delegates: { [e7]: r7 } };
              }
            }
            _saveDelegatedListener(e7, t5) {
              this._delegatedListeners = this._delegatedListeners || {}, this._delegatedListeners[e7] = this._delegatedListeners[e7] || [], this._delegatedListeners[e7].push(t5);
            }
            _removeDelegatedListener(e7, t5, i6) {
              if (!this._delegatedListeners || !this._delegatedListeners[e7]) return;
              const r7 = this._delegatedListeners[e7];
              for (let e8 = 0; e8 < r7.length; e8++) {
                const o7 = r7[e8];
                if (o7.listener === i6 && o7.layers.length === t5.length && o7.layers.every((e9) => t5.includes(e9))) {
                  for (const e9 in o7.delegates) this.off(e9, o7.delegates[e9]);
                  return void r7.splice(e8, 1);
                }
              }
            }
            on(e7, t5, i6) {
              if (void 0 === i6) return super.on(e7, t5);
              const r7 = "string" == typeof t5 ? [t5] : t5, o7 = this._createDelegatedListener(e7, r7, i6);
              this._saveDelegatedListener(e7, o7);
              for (const e8 in o7.delegates) this.on(e8, o7.delegates[e8]);
              return { unsubscribe: () => {
                this._removeDelegatedListener(e7, r7, i6);
              } };
            }
            once(e7, t5, i6) {
              if (void 0 === i6) return super.once(e7, t5);
              const r7 = "string" == typeof t5 ? [t5] : t5, o7 = this._createDelegatedListener(e7, r7, i6);
              for (const t6 in o7.delegates) {
                const a4 = o7.delegates[t6];
                o7.delegates[t6] = (...t7) => {
                  this._removeDelegatedListener(e7, r7, i6), a4(...t7);
                };
              }
              this._saveDelegatedListener(e7, o7);
              for (const e8 in o7.delegates) this.once(e8, o7.delegates[e8]);
              return this;
            }
            off(e7, t5, i6) {
              return void 0 === i6 ? super.off(e7, t5) : (this._removeDelegatedListener(e7, "string" == typeof t5 ? [t5] : t5, i6), this);
            }
            queryRenderedFeatures(e7, i6) {
              if (!this.style) return [];
              let r7;
              const o7 = e7 instanceof t4.P || Array.isArray(e7), a4 = o7 ? e7 : [[0, 0], [this.transform.width, this.transform.height]];
              if (i6 = i6 || (o7 ? {} : e7) || {}, a4 instanceof t4.P || "number" == typeof a4[0]) r7 = [t4.P.convert(a4)];
              else {
                const e8 = t4.P.convert(a4[0]), i7 = t4.P.convert(a4[1]);
                r7 = [e8, new t4.P(i7.x, e8.y), i7, new t4.P(e8.x, i7.y), e8];
              }
              return this.style.queryRenderedFeatures(r7, i6, this.transform);
            }
            querySourceFeatures(e7, t5) {
              return this.style.querySourceFeatures(e7, t5);
            }
            setStyle(e7, i6) {
              return false !== (i6 = t4.e({}, { localIdeographFontFamily: this._localIdeographFontFamily, validate: this._validateStyle }, i6)).diff && i6.localIdeographFontFamily === this._localIdeographFontFamily && this.style && e7 ? (this._diffStyle(e7, i6), this) : (this._localIdeographFontFamily = i6.localIdeographFontFamily, this._updateStyle(e7, i6));
            }
            setTransformRequest(e7) {
              return this._requestManager.setTransformRequest(e7), this;
            }
            _getUIString(e7) {
              const t5 = this._locale[e7];
              if (null == t5) throw new Error(`Missing UI string '${e7}'`);
              return t5;
            }
            _updateStyle(e7, t5) {
              var i6, r7;
              if (t5.transformStyle && this.style && !this.style._loaded) return void this.style.once("style.load", () => this._updateStyle(e7, t5));
              const o7 = this.style && t5.transformStyle ? this.style.serialize() : void 0;
              return this.style && (this.style.setEventedParent(null), this.style._remove(!e7)), e7 ? (this.style = new gi(this, t5 || {}), this.style.setEventedParent(this, { style: this.style }), "string" == typeof e7 ? this.style.loadURL(e7, t5, o7) : this.style.loadJSON(e7, t5, o7), this) : (null === (r7 = null === (i6 = this.style) || void 0 === i6 ? void 0 : i6.projection) || void 0 === r7 || r7.destroy(), delete this.style, this);
            }
            _lazyInitEmptyStyle() {
              this.style || (this.style = new gi(this, {}), this.style.setEventedParent(this, { style: this.style }), this.style.loadEmpty());
            }
            _diffStyle(e7, i6) {
              if ("string" == typeof e7) {
                const r7 = this._requestManager.transformRequest(e7, "Style");
                t4.j(r7, new AbortController()).then((e8) => {
                  this._updateDiff(e8.data, i6);
                }).catch((e8) => {
                  e8 && this.fire(new t4.k(e8));
                });
              } else "object" == typeof e7 && this._updateDiff(e7, i6);
            }
            _updateDiff(e7, i6) {
              try {
                this.style.setState(e7, i6) && this._update(true);
              } catch (r7) {
                t4.w(`Unable to perform style diff: ${r7.message || r7.error || r7}.  Rebuilding the style from scratch.`), this._updateStyle(e7, i6);
              }
            }
            getStyle() {
              if (this.style) return this.style.serialize();
            }
            isStyleLoaded() {
              return this.style ? this.style.loaded() : t4.w("There is no style added to the map.");
            }
            addSource(e7, t5) {
              return this._lazyInitEmptyStyle(), this.style.addSource(e7, t5), this._update(true);
            }
            isSourceLoaded(e7) {
              const i6 = this.style && this.style.sourceCaches[e7];
              if (void 0 !== i6) return i6.loaded();
              this.fire(new t4.k(new Error(`There is no source with ID '${e7}'`)));
            }
            setTerrain(e7) {
              if (this.style._checkLoaded(), this._terrainDataCallback && this.style.off("data", this._terrainDataCallback), e7) {
                const i6 = this.style.sourceCaches[e7.source];
                if (!i6) throw new Error(`cannot load terrain, because there exists no source with ID: ${e7.source}`);
                null === this.terrain && i6.reload();
                for (const i7 in this.style._layers) {
                  const r7 = this.style._layers[i7];
                  "hillshade" === r7.type && r7.source === e7.source && t4.w("You are using the same source for a hillshade layer and for 3D terrain. Please consider using two separate sources to improve rendering quality.");
                }
                this.terrain = new Ma(this.painter, i6, e7), this.painter.renderToTexture = new Ra(this.painter, this.terrain), this.transform.setMinElevationForCurrentTile(this.terrain.getMinTileElevationForLngLatZoom(this.transform.center, this.transform.tileZoom)), this.transform.setElevation(this.terrain.getElevationForLngLatZoom(this.transform.center, this.transform.tileZoom)), this._terrainDataCallback = (t5) => {
                  var i7;
                  "style" === t5.dataType ? this.terrain.sourceCache.freeRtt() : "source" === t5.dataType && t5.tile && (t5.sourceId !== e7.source || this._elevationFreeze || (this.transform.setMinElevationForCurrentTile(this.terrain.getMinTileElevationForLngLatZoom(this.transform.center, this.transform.tileZoom)), this._centerClampedToGround && this.transform.setElevation(this.terrain.getElevationForLngLatZoom(this.transform.center, this.transform.tileZoom))), "image" === (null === (i7 = t5.source) || void 0 === i7 ? void 0 : i7.type) ? this.terrain.sourceCache.freeRtt() : this.terrain.sourceCache.freeRtt(t5.tile.tileID));
                }, this.style.on("data", this._terrainDataCallback);
              } else this.terrain && this.terrain.sourceCache.destruct(), this.terrain = null, this.painter.renderToTexture && this.painter.renderToTexture.destruct(), this.painter.renderToTexture = null, this.transform.setMinElevationForCurrentTile(0), this._centerClampedToGround && this.transform.setElevation(0);
              return this.fire(new t4.l("terrain", { terrain: e7 })), this;
            }
            getTerrain() {
              var e7, t5;
              return null !== (t5 = null === (e7 = this.terrain) || void 0 === e7 ? void 0 : e7.options) && void 0 !== t5 ? t5 : null;
            }
            areTilesLoaded() {
              const e7 = this.style && this.style.sourceCaches;
              for (const t5 in e7) {
                const i6 = e7[t5]._tiles;
                for (const e8 in i6) {
                  const t6 = i6[e8];
                  if ("loaded" !== t6.state && "errored" !== t6.state) return false;
                }
              }
              return true;
            }
            removeSource(e7) {
              return this.style.removeSource(e7), this._update(true);
            }
            getSource(e7) {
              return this.style.getSource(e7);
            }
            addImage(e7, i6, r7 = {}) {
              const { pixelRatio: o7 = 1, sdf: a4 = false, stretchX: n6, stretchY: l5, content: c5, textFitWidth: h4, textFitHeight: u4 } = r7;
              if (this._lazyInitEmptyStyle(), !(i6 instanceof HTMLImageElement || t4.b(i6))) {
                if (void 0 === i6.width || void 0 === i6.height) return this.fire(new t4.k(new Error("Invalid arguments to map.addImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`")));
                {
                  const { width: r8, height: s5, data: d4 } = i6, _4 = i6;
                  return this.style.addImage(e7, { data: new t4.R({ width: r8, height: s5 }, new Uint8Array(d4)), pixelRatio: o7, stretchX: n6, stretchY: l5, content: c5, textFitWidth: h4, textFitHeight: u4, sdf: a4, version: 0, userImage: _4 }), _4.onAdd && _4.onAdd(this, e7), this;
                }
              }
              {
                const { width: r8, height: d4, data: _4 } = s4.getImageData(i6);
                this.style.addImage(e7, { data: new t4.R({ width: r8, height: d4 }, _4), pixelRatio: o7, stretchX: n6, stretchY: l5, content: c5, textFitWidth: h4, textFitHeight: u4, sdf: a4, version: 0 });
              }
            }
            updateImage(e7, i6) {
              const r7 = this.style.getImage(e7);
              if (!r7) return this.fire(new t4.k(new Error("The map has no image with that id. If you are adding a new image use `map.addImage(...)` instead.")));
              const o7 = i6 instanceof HTMLImageElement || t4.b(i6) ? s4.getImageData(i6) : i6, { width: a4, height: n6, data: l5 } = o7;
              if (void 0 === a4 || void 0 === n6) return this.fire(new t4.k(new Error("Invalid arguments to map.updateImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`")));
              if (a4 !== r7.data.width || n6 !== r7.data.height) return this.fire(new t4.k(new Error("The width and height of the updated image must be that same as the previous version of the image")));
              const c5 = !(i6 instanceof HTMLImageElement || t4.b(i6));
              return r7.data.replace(l5, c5), this.style.updateImage(e7, r7), this;
            }
            getImage(e7) {
              return this.style.getImage(e7);
            }
            hasImage(e7) {
              return e7 ? !!this.style.getImage(e7) : (this.fire(new t4.k(new Error("Missing required image id"))), false);
            }
            removeImage(e7) {
              this.style.removeImage(e7);
            }
            loadImage(e7) {
              return p3.getImage(this._requestManager.transformRequest(e7, "Image"), new AbortController());
            }
            listImages() {
              return this.style.listImages();
            }
            addLayer(e7, t5) {
              return this._lazyInitEmptyStyle(), this.style.addLayer(e7, t5), this._update(true);
            }
            moveLayer(e7, t5) {
              return this.style.moveLayer(e7, t5), this._update(true);
            }
            removeLayer(e7) {
              return this.style.removeLayer(e7), this._update(true);
            }
            getLayer(e7) {
              return this.style.getLayer(e7);
            }
            getLayersOrder() {
              return this.style.getLayersOrder();
            }
            setLayerZoomRange(e7, t5, i6) {
              return this.style.setLayerZoomRange(e7, t5, i6), this._update(true);
            }
            setFilter(e7, t5, i6 = {}) {
              return this.style.setFilter(e7, t5, i6), this._update(true);
            }
            getFilter(e7) {
              return this.style.getFilter(e7);
            }
            setPaintProperty(e7, t5, i6, r7 = {}) {
              return this.style.setPaintProperty(e7, t5, i6, r7), this._update(true);
            }
            getPaintProperty(e7, t5) {
              return this.style.getPaintProperty(e7, t5);
            }
            setLayoutProperty(e7, t5, i6, r7 = {}) {
              return this.style.setLayoutProperty(e7, t5, i6, r7), this._update(true);
            }
            getLayoutProperty(e7, t5) {
              return this.style.getLayoutProperty(e7, t5);
            }
            setGlyphs(e7, t5 = {}) {
              return this._lazyInitEmptyStyle(), this.style.setGlyphs(e7, t5), this._update(true);
            }
            getGlyphs() {
              return this.style.getGlyphsUrl();
            }
            addSprite(e7, t5, i6 = {}) {
              return this._lazyInitEmptyStyle(), this.style.addSprite(e7, t5, i6, (e8) => {
                e8 || this._update(true);
              }), this;
            }
            removeSprite(e7) {
              return this._lazyInitEmptyStyle(), this.style.removeSprite(e7), this._update(true);
            }
            getSprite() {
              return this.style.getSprite();
            }
            setSprite(e7, t5 = {}) {
              return this._lazyInitEmptyStyle(), this.style.setSprite(e7, t5, (e8) => {
                e8 || this._update(true);
              }), this;
            }
            setLight(e7, t5 = {}) {
              return this._lazyInitEmptyStyle(), this.style.setLight(e7, t5), this._update(true);
            }
            getLight() {
              return this.style.getLight();
            }
            setSky(e7, t5 = {}) {
              return this._lazyInitEmptyStyle(), this.style.setSky(e7, t5), this._update(true);
            }
            getSky() {
              return this.style.getSky();
            }
            setFeatureState(e7, t5) {
              return this.style.setFeatureState(e7, t5), this._update();
            }
            removeFeatureState(e7, t5) {
              return this.style.removeFeatureState(e7, t5), this._update();
            }
            getFeatureState(e7) {
              return this.style.getFeatureState(e7);
            }
            getContainer() {
              return this._container;
            }
            getCanvasContainer() {
              return this._canvasContainer;
            }
            getCanvas() {
              return this._canvas;
            }
            _containerDimensions() {
              let e7 = 0, t5 = 0;
              return this._container && (e7 = this._container.clientWidth || 400, t5 = this._container.clientHeight || 300), [e7, t5];
            }
            _setupContainer() {
              const e7 = this._container;
              e7.classList.add("maplibregl-map");
              const t5 = this._canvasContainer = n5.create("div", "maplibregl-canvas-container", e7);
              this._interactive && t5.classList.add("maplibregl-interactive"), this._canvas = n5.create("canvas", "maplibregl-canvas", t5), this._canvas.addEventListener("webglcontextlost", this._contextLost, false), this._canvas.addEventListener("webglcontextrestored", this._contextRestored, false), this._canvas.setAttribute("tabindex", this._interactive ? "0" : "-1"), this._canvas.setAttribute("aria-label", this._getUIString("Map.Title")), this._canvas.setAttribute("role", "region");
              const i6 = this._containerDimensions(), r7 = this._getClampedPixelRatio(i6[0], i6[1]);
              this._resizeCanvas(i6[0], i6[1], r7);
              const o7 = this._controlContainer = n5.create("div", "maplibregl-control-container", e7), a4 = this._controlPositions = {};
              ["top-left", "top-right", "bottom-left", "bottom-right"].forEach((e8) => {
                a4[e8] = n5.create("div", `maplibregl-ctrl-${e8} `, o7);
              }), this._container.addEventListener("scroll", this._onMapScroll, false);
            }
            _resizeCanvas(e7, t5, i6) {
              this._canvas.width = Math.floor(i6 * e7), this._canvas.height = Math.floor(i6 * t5), this._canvas.style.width = `${e7}px`, this._canvas.style.height = `${t5}px`;
            }
            _setupPainter() {
              const e7 = Object.assign(Object.assign({}, this._canvasContextAttributes), { alpha: true, depth: true, stencil: true, premultipliedAlpha: true });
              let t5 = null;
              this._canvas.addEventListener("webglcontextcreationerror", (i7) => {
                t5 = { requestedAttributes: e7 }, i7 && (t5.statusMessage = i7.statusMessage, t5.type = i7.type);
              }, { once: true });
              let i6 = null;
              if (i6 = this._canvasContextAttributes.contextType ? this._canvas.getContext(this._canvasContextAttributes.contextType, e7) : this._canvas.getContext("webgl2", e7) || this._canvas.getContext("webgl", e7), !i6) {
                const e8 = "Failed to initialize WebGL";
                throw t5 ? (t5.message = e8, new Error(JSON.stringify(t5))) : new Error(e8);
              }
              this.painter = new bo(i6, this.transform), l4.testSupport(i6);
            }
            migrateProjection(e7, i6) {
              super.migrateProjection(e7, i6), this.painter.transform = e7, this.fire(new t4.l("projectiontransition", { newProjection: this.style.projection.name }));
            }
            loaded() {
              return !this._styleDirty && !this._sourcesDirty && !!this.style && this.style.loaded();
            }
            _update(e7) {
              return this.style && this.style._loaded ? (this._styleDirty = this._styleDirty || e7, this._sourcesDirty = true, this.triggerRepaint(), this) : this;
            }
            _requestRenderFrame(e7) {
              return this._update(), this._renderTaskQueue.add(e7);
            }
            _cancelRenderFrame(e7) {
              this._renderTaskQueue.remove(e7);
            }
            _render(e7) {
              var i6, r7, o7, a4, n6;
              const l5 = this._idleTriggered ? this._fadeDuration : 0, c5 = (null === (i6 = this.style.projection) || void 0 === i6 ? void 0 : i6.transitionState) > 0;
              if (this.painter.context.setDirty(), this.painter.setBaseState(), this._renderTaskQueue.run(e7), this._removed) return;
              let h4 = false;
              if (this.style && this._styleDirty) {
                this._styleDirty = false;
                const e8 = this.transform.zoom, i7 = s4.now();
                this.style.zoomHistory.update(e8, i7);
                const r8 = new t4.C(e8, { now: i7, fadeDuration: l5, zoomHistory: this.style.zoomHistory, transition: this.style.getTransition() }), o8 = r8.crossFadingFactor();
                1 === o8 && o8 === this._crossFadingFactor || (h4 = true, this._crossFadingFactor = o8), this.style.update(r8);
              }
              const u4 = (null === (r7 = this.style.projection) || void 0 === r7 ? void 0 : r7.transitionState) > 0 !== c5;
              null === (o7 = this.style.projection) || void 0 === o7 || o7.setErrorQueryLatitudeDegrees(this.transform.center.lat), this.transform.setTransitionState(null === (a4 = this.style.projection) || void 0 === a4 ? void 0 : a4.transitionState, null === (n6 = this.style.projection) || void 0 === n6 ? void 0 : n6.latitudeErrorCorrectionRadians), this.style && (this._sourcesDirty || u4) && (this._sourcesDirty = false, this.style._updateSources(this.transform)), this.terrain ? (this.terrain.sourceCache.update(this.transform, this.terrain), this.transform.setMinElevationForCurrentTile(this.terrain.getMinTileElevationForLngLatZoom(this.transform.center, this.transform.tileZoom)), !this._elevationFreeze && this._centerClampedToGround && this.transform.setElevation(this.terrain.getElevationForLngLatZoom(this.transform.center, this.transform.tileZoom))) : (this.transform.setMinElevationForCurrentTile(0), this._centerClampedToGround && this.transform.setElevation(0)), this._placementDirty = this.style && this.style._updatePlacement(this.transform, this.showCollisionBoxes, l5, this._crossSourceCollisions, u4), this.painter.render(this.style, { showTileBoundaries: this.showTileBoundaries, showOverdrawInspector: this._showOverdrawInspector, rotating: this.isRotating(), zooming: this.isZooming(), moving: this.isMoving(), fadeDuration: l5, showPadding: this.showPadding }), this.fire(new t4.l("render")), this.loaded() && !this._loaded && (this._loaded = true, t4.cj.mark(t4.ck.load), this.fire(new t4.l("load"))), this.style && (this.style.hasTransitions() || h4) && (this._styleDirty = true), this.style && !this._placementDirty && this.style._releaseSymbolFadeTiles();
              const d4 = this._sourcesDirty || this._styleDirty || this._placementDirty;
              return d4 || this._repaint ? this.triggerRepaint() : !this.isMoving() && this.loaded() && this.fire(new t4.l("idle")), !this._loaded || this._fullyLoaded || d4 || (this._fullyLoaded = true, t4.cj.mark(t4.ck.fullLoad)), this;
            }
            redraw() {
              return this.style && (this._frameRequest && (this._frameRequest.abort(), this._frameRequest = null), this._render(0)), this;
            }
            remove() {
              var e7;
              this._hash && this._hash.remove();
              for (const e8 of this._controls) e8.onRemove(this);
              this._controls = [], this._frameRequest && (this._frameRequest.abort(), this._frameRequest = null), this._renderTaskQueue.clear(), this.painter.destroy(), this.handlers.destroy(), delete this.handlers, this.setStyle(null), "undefined" != typeof window && removeEventListener("online", this._onWindowOnline, false), p3.removeThrottleControl(this._imageQueueHandle), null === (e7 = this._resizeObserver) || void 0 === e7 || e7.disconnect();
              const i6 = this.painter.context.gl.getExtension("WEBGL_lose_context");
              (null == i6 ? void 0 : i6.loseContext) && i6.loseContext(), this._canvas.removeEventListener("webglcontextrestored", this._contextRestored, false), this._canvas.removeEventListener("webglcontextlost", this._contextLost, false), n5.remove(this._canvasContainer), n5.remove(this._controlContainer), this._container.removeEventListener("scroll", this._onMapScroll, false), this._container.classList.remove("maplibregl-map"), t4.cj.clearMetrics(), this._removed = true, this.fire(new t4.l("remove"));
            }
            triggerRepaint() {
              this.style && !this._frameRequest && (this._frameRequest = new AbortController(), s4.frame(this._frameRequest, (e7) => {
                t4.cj.frame(e7), this._frameRequest = null;
                try {
                  this._render(e7);
                } catch (e8) {
                  if (!t4.cl(e8) && !function(e9) {
                    return e9.message === jr;
                  }(e8)) throw e8;
                }
              }, () => {
              }));
            }
            get showTileBoundaries() {
              return !!this._showTileBoundaries;
            }
            set showTileBoundaries(e7) {
              this._showTileBoundaries !== e7 && (this._showTileBoundaries = e7, this._update());
            }
            get showPadding() {
              return !!this._showPadding;
            }
            set showPadding(e7) {
              this._showPadding !== e7 && (this._showPadding = e7, this._update());
            }
            get showCollisionBoxes() {
              return !!this._showCollisionBoxes;
            }
            set showCollisionBoxes(e7) {
              this._showCollisionBoxes !== e7 && (this._showCollisionBoxes = e7, e7 ? this.style._generateCollisionBoxes() : this._update());
            }
            get showOverdrawInspector() {
              return !!this._showOverdrawInspector;
            }
            set showOverdrawInspector(e7) {
              this._showOverdrawInspector !== e7 && (this._showOverdrawInspector = e7, this._update());
            }
            get repaint() {
              return !!this._repaint;
            }
            set repaint(e7) {
              this._repaint !== e7 && (this._repaint = e7, this.triggerRepaint());
            }
            get vertices() {
              return !!this._vertices;
            }
            set vertices(e7) {
              this._vertices = e7, this._update();
            }
            get version() {
              return za;
            }
            getCameraTargetElevation() {
              return this.transform.elevation;
            }
            getProjection() {
              return this.style.getProjection();
            }
            setProjection(e7) {
              return this._lazyInitEmptyStyle(), this.style.setProjection(e7), this._update(true);
            }
          }, e6.MapMouseEvent = zo, e6.MapTouchEvent = Ao, e6.MapWheelEvent = Lo, e6.Marker = Za, e6.NavigationControl = class {
            constructor(e7) {
              this._updateZoomButtons = () => {
                const e8 = this._map.getZoom(), t5 = e8 === this._map.getMaxZoom(), i6 = e8 === this._map.getMinZoom();
                this._zoomInButton.disabled = t5, this._zoomOutButton.disabled = i6, this._zoomInButton.setAttribute("aria-disabled", t5.toString()), this._zoomOutButton.setAttribute("aria-disabled", i6.toString());
              }, this._rotateCompassArrow = () => {
                this._compassIcon.style.transform = this.options.visualizePitch && this.options.visualizeRoll ? `scale(${1 / Math.pow(Math.cos(this._map.transform.pitchInRadians), 0.5)}) rotateZ(${-this._map.transform.roll}deg) rotateX(${this._map.transform.pitch}deg) rotateZ(${-this._map.transform.bearing}deg)` : this.options.visualizePitch ? `scale(${1 / Math.pow(Math.cos(this._map.transform.pitchInRadians), 0.5)}) rotateX(${this._map.transform.pitch}deg) rotateZ(${-this._map.transform.bearing}deg)` : this.options.visualizeRoll ? `rotate(${-this._map.transform.bearing - this._map.transform.roll}deg)` : `rotate(${-this._map.transform.bearing}deg)`;
              }, this._setButtonTitle = (e8, t5) => {
                const i6 = this._map._getUIString(`NavigationControl.${t5}`);
                e8.title = i6, e8.setAttribute("aria-label", i6);
              }, this.options = t4.e({}, La, e7), this._container = n5.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._container.addEventListener("contextmenu", (e8) => e8.preventDefault()), this.options.showZoom && (this._zoomInButton = this._createButton("maplibregl-ctrl-zoom-in", (e8) => this._map.zoomIn({}, { originalEvent: e8 })), n5.create("span", "maplibregl-ctrl-icon", this._zoomInButton).setAttribute("aria-hidden", "true"), this._zoomOutButton = this._createButton("maplibregl-ctrl-zoom-out", (e8) => this._map.zoomOut({}, { originalEvent: e8 })), n5.create("span", "maplibregl-ctrl-icon", this._zoomOutButton).setAttribute("aria-hidden", "true")), this.options.showCompass && (this._compass = this._createButton("maplibregl-ctrl-compass", (e8) => {
                this.options.visualizePitch ? this._map.resetNorthPitch({}, { originalEvent: e8 }) : this._map.resetNorth({}, { originalEvent: e8 });
              }), this._compassIcon = n5.create("span", "maplibregl-ctrl-icon", this._compass), this._compassIcon.setAttribute("aria-hidden", "true"));
            }
            onAdd(e7) {
              return this._map = e7, this.options.showZoom && (this._setButtonTitle(this._zoomInButton, "ZoomIn"), this._setButtonTitle(this._zoomOutButton, "ZoomOut"), this._map.on("zoom", this._updateZoomButtons), this._updateZoomButtons()), this.options.showCompass && (this._setButtonTitle(this._compass, "ResetBearing"), this.options.visualizePitch && this._map.on("pitch", this._rotateCompassArrow), this.options.visualizeRoll && this._map.on("roll", this._rotateCompassArrow), this._map.on("rotate", this._rotateCompassArrow), this._rotateCompassArrow(), this._handler = new ka(this._map, this._compass, this.options.visualizePitch)), this._container;
            }
            onRemove() {
              n5.remove(this._container), this.options.showZoom && this._map.off("zoom", this._updateZoomButtons), this.options.showCompass && (this.options.visualizePitch && this._map.off("pitch", this._rotateCompassArrow), this.options.visualizeRoll && this._map.off("roll", this._rotateCompassArrow), this._map.off("rotate", this._rotateCompassArrow), this._handler.off(), delete this._handler), delete this._map;
            }
            _createButton(e7, t5) {
              const i6 = n5.create("button", e7, this._container);
              return i6.type = "button", i6.addEventListener("click", t5), i6;
            }
          }, e6.Popup = class extends t4.E {
            constructor(e7) {
              super(), this._updateOpacity = () => {
                void 0 !== this.options.locationOccludedOpacity && (this._container.style.opacity = this._map.transform.isLocationOccluded(this.getLngLat()) ? `${this.options.locationOccludedOpacity}` : void 0);
              }, this.remove = () => (this._content && n5.remove(this._content), this._container && (n5.remove(this._container), delete this._container), this._map && (this._map.off("move", this._update), this._map.off("move", this._onClose), this._map.off("click", this._onClose), this._map.off("remove", this.remove), this._map.off("mousemove", this._onMouseMove), this._map.off("mouseup", this._onMouseUp), this._map.off("drag", this._onDrag), this._map._canvasContainer.classList.remove("maplibregl-track-pointer"), delete this._map, this.fire(new t4.l("close"))), this), this._onMouseUp = (e8) => {
                this._update(e8.point);
              }, this._onMouseMove = (e8) => {
                this._update(e8.point);
              }, this._onDrag = (e8) => {
                this._update(e8.point);
              }, this._update = (e8) => {
                var t5;
                if (!this._map || !this._lngLat && !this._trackPointer || !this._content) return;
                if (!this._container) {
                  if (this._container = n5.create("div", "maplibregl-popup", this._map.getContainer()), this._tip = n5.create("div", "maplibregl-popup-tip", this._container), this._container.appendChild(this._content), this.options.className) for (const e9 of this.options.className.split(" ")) this._container.classList.add(e9);
                  this._closeButton && this._closeButton.setAttribute("aria-label", this._map._getUIString("Popup.Close")), this._trackPointer && this._container.classList.add("maplibregl-popup-track-pointer");
                }
                if (this.options.maxWidth && this._container.style.maxWidth !== this.options.maxWidth && (this._container.style.maxWidth = this.options.maxWidth), this._lngLat = this._map.transform.renderWorldCopies && !this._trackPointer ? Ba(this._lngLat, this._flatPos, this._map.transform) : null === (t5 = this._lngLat) || void 0 === t5 ? void 0 : t5.wrap(), this._trackPointer && !e8) return;
                const i6 = this._flatPos = this._pos = this._trackPointer && e8 ? e8 : this._map.project(this._lngLat);
                this._map.terrain && (this._flatPos = this._trackPointer && e8 ? e8 : this._map.transform.locationToScreenPoint(this._lngLat));
                let r7 = this.options.anchor;
                const o7 = Ka(this.options.offset);
                if (!r7) {
                  const e9 = this._container.offsetWidth, t6 = this._container.offsetHeight;
                  let a5;
                  a5 = i6.y + o7.bottom.y < t6 ? ["top"] : i6.y > this._map.transform.height - t6 ? ["bottom"] : [], i6.x < e9 / 2 ? a5.push("left") : i6.x > this._map.transform.width - e9 / 2 && a5.push("right"), r7 = 0 === a5.length ? "bottom" : a5.join("-");
                }
                let a4 = i6.add(o7[r7]);
                this.options.subpixelPositioning || (a4 = a4.round()), n5.setTransform(this._container, `${Oa[r7]} translate(${a4.x}px,${a4.y}px)`), ja(this._container, r7, "popup"), this._updateOpacity();
              }, this._onClose = () => {
                this.remove();
              }, this.options = t4.e(Object.create($a), e7);
            }
            addTo(e7) {
              return this._map && this.remove(), this._map = e7, this.options.closeOnClick && this._map.on("click", this._onClose), this.options.closeOnMove && this._map.on("move", this._onClose), this._map.on("remove", this.remove), this._update(), this._focusFirstElement(), this._trackPointer ? (this._map.on("mousemove", this._onMouseMove), this._map.on("mouseup", this._onMouseUp), this._container && this._container.classList.add("maplibregl-popup-track-pointer"), this._map._canvasContainer.classList.add("maplibregl-track-pointer")) : this._map.on("move", this._update), this.fire(new t4.l("open")), this;
            }
            isOpen() {
              return !!this._map;
            }
            getLngLat() {
              return this._lngLat;
            }
            setLngLat(e7) {
              return this._lngLat = t4.Q.convert(e7), this._pos = null, this._flatPos = null, this._trackPointer = false, this._update(), this._map && (this._map.on("move", this._update), this._map.off("mousemove", this._onMouseMove), this._container && this._container.classList.remove("maplibregl-popup-track-pointer"), this._map._canvasContainer.classList.remove("maplibregl-track-pointer")), this;
            }
            trackPointer() {
              return this._trackPointer = true, this._pos = null, this._flatPos = null, this._update(), this._map && (this._map.off("move", this._update), this._map.on("mousemove", this._onMouseMove), this._map.on("drag", this._onDrag), this._container && this._container.classList.add("maplibregl-popup-track-pointer"), this._map._canvasContainer.classList.add("maplibregl-track-pointer")), this;
            }
            getElement() {
              return this._container;
            }
            setText(e7) {
              return this.setDOMContent(document.createTextNode(e7));
            }
            setHTML(e7) {
              const t5 = document.createDocumentFragment(), i6 = document.createElement("body");
              let r7;
              for (i6.innerHTML = e7; r7 = i6.firstChild, r7; ) t5.appendChild(r7);
              return this.setDOMContent(t5);
            }
            getMaxWidth() {
              var e7;
              return null === (e7 = this._container) || void 0 === e7 ? void 0 : e7.style.maxWidth;
            }
            setMaxWidth(e7) {
              return this.options.maxWidth = e7, this._update(), this;
            }
            setDOMContent(e7) {
              if (this._content) for (; this._content.hasChildNodes(); ) this._content.firstChild && this._content.removeChild(this._content.firstChild);
              else this._content = n5.create("div", "maplibregl-popup-content", this._container);
              return this._content.appendChild(e7), this._createCloseButton(), this._update(), this._focusFirstElement(), this;
            }
            addClassName(e7) {
              return this._container && this._container.classList.add(e7), this;
            }
            removeClassName(e7) {
              return this._container && this._container.classList.remove(e7), this;
            }
            setOffset(e7) {
              return this.options.offset = e7, this._update(), this;
            }
            toggleClassName(e7) {
              if (this._container) return this._container.classList.toggle(e7);
            }
            setSubpixelPositioning(e7) {
              this.options.subpixelPositioning = e7;
            }
            _createCloseButton() {
              this.options.closeButton && (this._closeButton = n5.create("button", "maplibregl-popup-close-button", this._content), this._closeButton.type = "button", this._closeButton.innerHTML = "&#215;", this._closeButton.addEventListener("click", this._onClose));
            }
            _focusFirstElement() {
              if (!this.options.focusAfterOpen || !this._container) return;
              const e7 = this._container.querySelector(Ha);
              e7 && e7.focus();
            }
          }, e6.RasterDEMTileSource = H4, e6.RasterTileSource = $2, e6.ScaleControl = class {
            constructor(e7) {
              this._onMove = () => {
                qa(this._map, this._container, this.options);
              }, this.setUnit = (e8) => {
                this.options.unit = e8, qa(this._map, this._container, this.options);
              }, this.options = Object.assign(Object.assign({}, Va), e7);
            }
            getDefaultPosition() {
              return "bottom-left";
            }
            onAdd(e7) {
              return this._map = e7, this._container = n5.create("div", "maplibregl-ctrl maplibregl-ctrl-scale", e7.getContainer()), this._map.on("move", this._onMove), this._onMove(), this._container;
            }
            onRemove() {
              n5.remove(this._container), this._map.off("move", this._onMove), this._map = void 0;
            }
          }, e6.ScrollZoomHandler = la, e6.Style = gi, e6.TerrainControl = class {
            constructor(e7) {
              this._toggleTerrain = () => {
                this._map.getTerrain() ? this._map.setTerrain(null) : this._map.setTerrain(this.options), this._updateTerrainIcon();
              }, this._updateTerrainIcon = () => {
                this._terrainButton.classList.remove("maplibregl-ctrl-terrain"), this._terrainButton.classList.remove("maplibregl-ctrl-terrain-enabled"), this._map.terrain ? (this._terrainButton.classList.add("maplibregl-ctrl-terrain-enabled"), this._terrainButton.title = this._map._getUIString("TerrainControl.Disable")) : (this._terrainButton.classList.add("maplibregl-ctrl-terrain"), this._terrainButton.title = this._map._getUIString("TerrainControl.Enable"));
              }, this.options = e7;
            }
            onAdd(e7) {
              return this._map = e7, this._container = n5.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._terrainButton = n5.create("button", "maplibregl-ctrl-terrain", this._container), n5.create("span", "maplibregl-ctrl-icon", this._terrainButton).setAttribute("aria-hidden", "true"), this._terrainButton.type = "button", this._terrainButton.addEventListener("click", this._toggleTerrain), this._updateTerrainIcon(), this._map.on("terrain", this._updateTerrainIcon), this._container;
            }
            onRemove() {
              n5.remove(this._container), this._map.off("terrain", this._updateTerrainIcon), this._map = void 0;
            }
          }, e6.TwoFingersTouchPitchHandler = ra, e6.TwoFingersTouchRotateHandler = ta, e6.TwoFingersTouchZoomHandler = Jo, e6.TwoFingersTouchZoomRotateHandler = pa, e6.VectorTileSource = W, e6.VideoSource = Q2, e6.addSourceType = (e7, i6) => t4._(void 0, void 0, void 0, function* () {
            if (ee(e7)) throw new Error(`A source type called "${e7}" already exists.`);
            ((e8, t5) => {
              J2[e8] = t5;
            })(e7, i6);
          }), e6.clearPrewarmedResources = function() {
            const e7 = L3;
            e7 && (e7.isPreloaded() && 1 === e7.numActive() ? (e7.release(D2), L3 = null) : console.warn("Could not clear WebWorkers since there are active Map instances that still reference it. The pre-warmed WebWorker pool can only be cleared when all map instances have been removed with map.remove()"));
          }, e6.createTileMesh = Wt, e6.getMaxParallelImageRequests = function() {
            return t4.a.MAX_PARALLEL_IMAGE_REQUESTS;
          }, e6.getRTLTextPluginStatus = function() {
            return oe().getRTLTextPluginStatus();
          }, e6.getVersion = function() {
            return Xa;
          }, e6.getWorkerCount = function() {
            return z3.workerCount;
          }, e6.getWorkerUrl = function() {
            return t4.a.WORKER_URL;
          }, e6.importScriptInWorkers = function(e7) {
            return O2().broadcast("IS", e7);
          }, e6.prewarm = function() {
            F2().acquire(D2);
          }, e6.setMaxParallelImageRequests = function(e7) {
            t4.a.MAX_PARALLEL_IMAGE_REQUESTS = e7;
          }, e6.setRTLTextPlugin = function(e7, t5) {
            return oe().setRTLTextPlugin(e7, t5);
          }, e6.setWorkerCount = function(e7) {
            z3.workerCount = e7;
          }, e6.setWorkerUrl = function(e7) {
            t4.a.WORKER_URL = e7;
          };
        });
        var maplibregl$1 = maplibregl2;
        return maplibregl$1;
      });
    }
  });

  // ../node_modules/@lit/reactive-element/css-tag.js
  var t = globalThis;
  var e = t.ShadowRoot && (void 0 === t.ShadyCSS || t.ShadyCSS.nativeShadow) && "adoptedStyleSheets" in Document.prototype && "replace" in CSSStyleSheet.prototype;
  var s = Symbol();
  var o = /* @__PURE__ */ new WeakMap();
  var n = class {
    constructor(t4, e6, o6) {
      if (this._$cssResult$ = true, o6 !== s) throw Error("CSSResult is not constructable. Use `unsafeCSS` or `css` instead.");
      this.cssText = t4, this.t = e6;
    }
    get styleSheet() {
      let t4 = this.o;
      const s4 = this.t;
      if (e && void 0 === t4) {
        const e6 = void 0 !== s4 && 1 === s4.length;
        e6 && (t4 = o.get(s4)), void 0 === t4 && ((this.o = t4 = new CSSStyleSheet()).replaceSync(this.cssText), e6 && o.set(s4, t4));
      }
      return t4;
    }
    toString() {
      return this.cssText;
    }
  };
  var r = (t4) => new n("string" == typeof t4 ? t4 : t4 + "", void 0, s);
  var i = (t4, ...e6) => {
    const o6 = 1 === t4.length ? t4[0] : e6.reduce((e7, s4, o7) => e7 + ((t5) => {
      if (true === t5._$cssResult$) return t5.cssText;
      if ("number" == typeof t5) return t5;
      throw Error("Value passed to 'css' function must be a 'css' function result: " + t5 + ". Use 'unsafeCSS' to pass non-literal values, but take care to ensure page security.");
    })(s4) + t4[o7 + 1], t4[0]);
    return new n(o6, t4, s);
  };
  var S = (s4, o6) => {
    if (e) s4.adoptedStyleSheets = o6.map((t4) => t4 instanceof CSSStyleSheet ? t4 : t4.styleSheet);
    else for (const e6 of o6) {
      const o7 = document.createElement("style"), n5 = t.litNonce;
      void 0 !== n5 && o7.setAttribute("nonce", n5), o7.textContent = e6.cssText, s4.appendChild(o7);
    }
  };
  var c = e ? (t4) => t4 : (t4) => t4 instanceof CSSStyleSheet ? ((t5) => {
    let e6 = "";
    for (const s4 of t5.cssRules) e6 += s4.cssText;
    return r(e6);
  })(t4) : t4;

  // ../node_modules/@lit/reactive-element/reactive-element.js
  var { is: i2, defineProperty: e2, getOwnPropertyDescriptor: h, getOwnPropertyNames: r2, getOwnPropertySymbols: o2, getPrototypeOf: n2 } = Object;
  var a = globalThis;
  var c2 = a.trustedTypes;
  var l = c2 ? c2.emptyScript : "";
  var p = a.reactiveElementPolyfillSupport;
  var d = (t4, s4) => t4;
  var u = { toAttribute(t4, s4) {
    switch (s4) {
      case Boolean:
        t4 = t4 ? l : null;
        break;
      case Object:
      case Array:
        t4 = null == t4 ? t4 : JSON.stringify(t4);
    }
    return t4;
  }, fromAttribute(t4, s4) {
    let i5 = t4;
    switch (s4) {
      case Boolean:
        i5 = null !== t4;
        break;
      case Number:
        i5 = null === t4 ? null : Number(t4);
        break;
      case Object:
      case Array:
        try {
          i5 = JSON.parse(t4);
        } catch (t5) {
          i5 = null;
        }
    }
    return i5;
  } };
  var f = (t4, s4) => !i2(t4, s4);
  var b = { attribute: true, type: String, converter: u, reflect: false, useDefault: false, hasChanged: f };
  Symbol.metadata ??= Symbol("metadata"), a.litPropertyMetadata ??= /* @__PURE__ */ new WeakMap();
  var y = class extends HTMLElement {
    static addInitializer(t4) {
      this._$Ei(), (this.l ??= []).push(t4);
    }
    static get observedAttributes() {
      return this.finalize(), this._$Eh && [...this._$Eh.keys()];
    }
    static createProperty(t4, s4 = b) {
      if (s4.state && (s4.attribute = false), this._$Ei(), this.prototype.hasOwnProperty(t4) && ((s4 = Object.create(s4)).wrapped = true), this.elementProperties.set(t4, s4), !s4.noAccessor) {
        const i5 = Symbol(), h3 = this.getPropertyDescriptor(t4, i5, s4);
        void 0 !== h3 && e2(this.prototype, t4, h3);
      }
    }
    static getPropertyDescriptor(t4, s4, i5) {
      const { get: e6, set: r6 } = h(this.prototype, t4) ?? { get() {
        return this[s4];
      }, set(t5) {
        this[s4] = t5;
      } };
      return { get: e6, set(s5) {
        const h3 = e6?.call(this);
        r6?.call(this, s5), this.requestUpdate(t4, h3, i5);
      }, configurable: true, enumerable: true };
    }
    static getPropertyOptions(t4) {
      return this.elementProperties.get(t4) ?? b;
    }
    static _$Ei() {
      if (this.hasOwnProperty(d("elementProperties"))) return;
      const t4 = n2(this);
      t4.finalize(), void 0 !== t4.l && (this.l = [...t4.l]), this.elementProperties = new Map(t4.elementProperties);
    }
    static finalize() {
      if (this.hasOwnProperty(d("finalized"))) return;
      if (this.finalized = true, this._$Ei(), this.hasOwnProperty(d("properties"))) {
        const t5 = this.properties, s4 = [...r2(t5), ...o2(t5)];
        for (const i5 of s4) this.createProperty(i5, t5[i5]);
      }
      const t4 = this[Symbol.metadata];
      if (null !== t4) {
        const s4 = litPropertyMetadata.get(t4);
        if (void 0 !== s4) for (const [t5, i5] of s4) this.elementProperties.set(t5, i5);
      }
      this._$Eh = /* @__PURE__ */ new Map();
      for (const [t5, s4] of this.elementProperties) {
        const i5 = this._$Eu(t5, s4);
        void 0 !== i5 && this._$Eh.set(i5, t5);
      }
      this.elementStyles = this.finalizeStyles(this.styles);
    }
    static finalizeStyles(s4) {
      const i5 = [];
      if (Array.isArray(s4)) {
        const e6 = new Set(s4.flat(1 / 0).reverse());
        for (const s5 of e6) i5.unshift(c(s5));
      } else void 0 !== s4 && i5.push(c(s4));
      return i5;
    }
    static _$Eu(t4, s4) {
      const i5 = s4.attribute;
      return false === i5 ? void 0 : "string" == typeof i5 ? i5 : "string" == typeof t4 ? t4.toLowerCase() : void 0;
    }
    constructor() {
      super(), this._$Ep = void 0, this.isUpdatePending = false, this.hasUpdated = false, this._$Em = null, this._$Ev();
    }
    _$Ev() {
      this._$ES = new Promise((t4) => this.enableUpdating = t4), this._$AL = /* @__PURE__ */ new Map(), this._$E_(), this.requestUpdate(), this.constructor.l?.forEach((t4) => t4(this));
    }
    addController(t4) {
      (this._$EO ??= /* @__PURE__ */ new Set()).add(t4), void 0 !== this.renderRoot && this.isConnected && t4.hostConnected?.();
    }
    removeController(t4) {
      this._$EO?.delete(t4);
    }
    _$E_() {
      const t4 = /* @__PURE__ */ new Map(), s4 = this.constructor.elementProperties;
      for (const i5 of s4.keys()) this.hasOwnProperty(i5) && (t4.set(i5, this[i5]), delete this[i5]);
      t4.size > 0 && (this._$Ep = t4);
    }
    createRenderRoot() {
      const t4 = this.shadowRoot ?? this.attachShadow(this.constructor.shadowRootOptions);
      return S(t4, this.constructor.elementStyles), t4;
    }
    connectedCallback() {
      this.renderRoot ??= this.createRenderRoot(), this.enableUpdating(true), this._$EO?.forEach((t4) => t4.hostConnected?.());
    }
    enableUpdating(t4) {
    }
    disconnectedCallback() {
      this._$EO?.forEach((t4) => t4.hostDisconnected?.());
    }
    attributeChangedCallback(t4, s4, i5) {
      this._$AK(t4, i5);
    }
    _$ET(t4, s4) {
      const i5 = this.constructor.elementProperties.get(t4), e6 = this.constructor._$Eu(t4, i5);
      if (void 0 !== e6 && true === i5.reflect) {
        const h3 = (void 0 !== i5.converter?.toAttribute ? i5.converter : u).toAttribute(s4, i5.type);
        this._$Em = t4, null == h3 ? this.removeAttribute(e6) : this.setAttribute(e6, h3), this._$Em = null;
      }
    }
    _$AK(t4, s4) {
      const i5 = this.constructor, e6 = i5._$Eh.get(t4);
      if (void 0 !== e6 && this._$Em !== e6) {
        const t5 = i5.getPropertyOptions(e6), h3 = "function" == typeof t5.converter ? { fromAttribute: t5.converter } : void 0 !== t5.converter?.fromAttribute ? t5.converter : u;
        this._$Em = e6, this[e6] = h3.fromAttribute(s4, t5.type) ?? this._$Ej?.get(e6) ?? null, this._$Em = null;
      }
    }
    requestUpdate(t4, s4, i5) {
      if (void 0 !== t4) {
        const e6 = this.constructor, h3 = this[t4];
        if (i5 ??= e6.getPropertyOptions(t4), !((i5.hasChanged ?? f)(h3, s4) || i5.useDefault && i5.reflect && h3 === this._$Ej?.get(t4) && !this.hasAttribute(e6._$Eu(t4, i5)))) return;
        this.C(t4, s4, i5);
      }
      false === this.isUpdatePending && (this._$ES = this._$EP());
    }
    C(t4, s4, { useDefault: i5, reflect: e6, wrapped: h3 }, r6) {
      i5 && !(this._$Ej ??= /* @__PURE__ */ new Map()).has(t4) && (this._$Ej.set(t4, r6 ?? s4 ?? this[t4]), true !== h3 || void 0 !== r6) || (this._$AL.has(t4) || (this.hasUpdated || i5 || (s4 = void 0), this._$AL.set(t4, s4)), true === e6 && this._$Em !== t4 && (this._$Eq ??= /* @__PURE__ */ new Set()).add(t4));
    }
    async _$EP() {
      this.isUpdatePending = true;
      try {
        await this._$ES;
      } catch (t5) {
        Promise.reject(t5);
      }
      const t4 = this.scheduleUpdate();
      return null != t4 && await t4, !this.isUpdatePending;
    }
    scheduleUpdate() {
      return this.performUpdate();
    }
    performUpdate() {
      if (!this.isUpdatePending) return;
      if (!this.hasUpdated) {
        if (this.renderRoot ??= this.createRenderRoot(), this._$Ep) {
          for (const [t6, s5] of this._$Ep) this[t6] = s5;
          this._$Ep = void 0;
        }
        const t5 = this.constructor.elementProperties;
        if (t5.size > 0) for (const [s5, i5] of t5) {
          const { wrapped: t6 } = i5, e6 = this[s5];
          true !== t6 || this._$AL.has(s5) || void 0 === e6 || this.C(s5, void 0, i5, e6);
        }
      }
      let t4 = false;
      const s4 = this._$AL;
      try {
        t4 = this.shouldUpdate(s4), t4 ? (this.willUpdate(s4), this._$EO?.forEach((t5) => t5.hostUpdate?.()), this.update(s4)) : this._$EM();
      } catch (s5) {
        throw t4 = false, this._$EM(), s5;
      }
      t4 && this._$AE(s4);
    }
    willUpdate(t4) {
    }
    _$AE(t4) {
      this._$EO?.forEach((t5) => t5.hostUpdated?.()), this.hasUpdated || (this.hasUpdated = true, this.firstUpdated(t4)), this.updated(t4);
    }
    _$EM() {
      this._$AL = /* @__PURE__ */ new Map(), this.isUpdatePending = false;
    }
    get updateComplete() {
      return this.getUpdateComplete();
    }
    getUpdateComplete() {
      return this._$ES;
    }
    shouldUpdate(t4) {
      return true;
    }
    update(t4) {
      this._$Eq &&= this._$Eq.forEach((t5) => this._$ET(t5, this[t5])), this._$EM();
    }
    updated(t4) {
    }
    firstUpdated(t4) {
    }
  };
  y.elementStyles = [], y.shadowRootOptions = { mode: "open" }, y[d("elementProperties")] = /* @__PURE__ */ new Map(), y[d("finalized")] = /* @__PURE__ */ new Map(), p?.({ ReactiveElement: y }), (a.reactiveElementVersions ??= []).push("2.1.0");

  // ../node_modules/lit-html/lit-html.js
  var t2 = globalThis;
  var i3 = t2.trustedTypes;
  var s2 = i3 ? i3.createPolicy("lit-html", { createHTML: (t4) => t4 }) : void 0;
  var e3 = "$lit$";
  var h2 = `lit$${Math.random().toFixed(9).slice(2)}$`;
  var o3 = "?" + h2;
  var n3 = `<${o3}>`;
  var r3 = document;
  var l2 = () => r3.createComment("");
  var c3 = (t4) => null === t4 || "object" != typeof t4 && "function" != typeof t4;
  var a2 = Array.isArray;
  var u2 = (t4) => a2(t4) || "function" == typeof t4?.[Symbol.iterator];
  var d2 = "[ 	\n\f\r]";
  var f2 = /<(?:(!--|\/[^a-zA-Z])|(\/?[a-zA-Z][^>\s]*)|(\/?$))/g;
  var v = /-->/g;
  var _ = />/g;
  var m = RegExp(`>|${d2}(?:([^\\s"'>=/]+)(${d2}*=${d2}*(?:[^ 	
\f\r"'\`<>=]|("|')|))|$)`, "g");
  var p2 = /'/g;
  var g = /"/g;
  var $ = /^(?:script|style|textarea|title)$/i;
  var y2 = (t4) => (i5, ...s4) => ({ _$litType$: t4, strings: i5, values: s4 });
  var x = y2(1);
  var b2 = y2(2);
  var w = y2(3);
  var T = Symbol.for("lit-noChange");
  var E = Symbol.for("lit-nothing");
  var A = /* @__PURE__ */ new WeakMap();
  var C = r3.createTreeWalker(r3, 129);
  function P(t4, i5) {
    if (!a2(t4) || !t4.hasOwnProperty("raw")) throw Error("invalid template strings array");
    return void 0 !== s2 ? s2.createHTML(i5) : i5;
  }
  var V = (t4, i5) => {
    const s4 = t4.length - 1, o6 = [];
    let r6, l4 = 2 === i5 ? "<svg>" : 3 === i5 ? "<math>" : "", c4 = f2;
    for (let i6 = 0; i6 < s4; i6++) {
      const s5 = t4[i6];
      let a3, u3, d3 = -1, y3 = 0;
      for (; y3 < s5.length && (c4.lastIndex = y3, u3 = c4.exec(s5), null !== u3); ) y3 = c4.lastIndex, c4 === f2 ? "!--" === u3[1] ? c4 = v : void 0 !== u3[1] ? c4 = _ : void 0 !== u3[2] ? ($.test(u3[2]) && (r6 = RegExp("</" + u3[2], "g")), c4 = m) : void 0 !== u3[3] && (c4 = m) : c4 === m ? ">" === u3[0] ? (c4 = r6 ?? f2, d3 = -1) : void 0 === u3[1] ? d3 = -2 : (d3 = c4.lastIndex - u3[2].length, a3 = u3[1], c4 = void 0 === u3[3] ? m : '"' === u3[3] ? g : p2) : c4 === g || c4 === p2 ? c4 = m : c4 === v || c4 === _ ? c4 = f2 : (c4 = m, r6 = void 0);
      const x3 = c4 === m && t4[i6 + 1].startsWith("/>") ? " " : "";
      l4 += c4 === f2 ? s5 + n3 : d3 >= 0 ? (o6.push(a3), s5.slice(0, d3) + e3 + s5.slice(d3) + h2 + x3) : s5 + h2 + (-2 === d3 ? i6 : x3);
    }
    return [P(t4, l4 + (t4[s4] || "<?>") + (2 === i5 ? "</svg>" : 3 === i5 ? "</math>" : "")), o6];
  };
  var N = class _N {
    constructor({ strings: t4, _$litType$: s4 }, n5) {
      let r6;
      this.parts = [];
      let c4 = 0, a3 = 0;
      const u3 = t4.length - 1, d3 = this.parts, [f3, v3] = V(t4, s4);
      if (this.el = _N.createElement(f3, n5), C.currentNode = this.el.content, 2 === s4 || 3 === s4) {
        const t5 = this.el.content.firstChild;
        t5.replaceWith(...t5.childNodes);
      }
      for (; null !== (r6 = C.nextNode()) && d3.length < u3; ) {
        if (1 === r6.nodeType) {
          if (r6.hasAttributes()) for (const t5 of r6.getAttributeNames()) if (t5.endsWith(e3)) {
            const i5 = v3[a3++], s5 = r6.getAttribute(t5).split(h2), e6 = /([.?@])?(.*)/.exec(i5);
            d3.push({ type: 1, index: c4, name: e6[2], strings: s5, ctor: "." === e6[1] ? H : "?" === e6[1] ? I : "@" === e6[1] ? L2 : k }), r6.removeAttribute(t5);
          } else t5.startsWith(h2) && (d3.push({ type: 6, index: c4 }), r6.removeAttribute(t5));
          if ($.test(r6.tagName)) {
            const t5 = r6.textContent.split(h2), s5 = t5.length - 1;
            if (s5 > 0) {
              r6.textContent = i3 ? i3.emptyScript : "";
              for (let i5 = 0; i5 < s5; i5++) r6.append(t5[i5], l2()), C.nextNode(), d3.push({ type: 2, index: ++c4 });
              r6.append(t5[s5], l2());
            }
          }
        } else if (8 === r6.nodeType) if (r6.data === o3) d3.push({ type: 2, index: c4 });
        else {
          let t5 = -1;
          for (; -1 !== (t5 = r6.data.indexOf(h2, t5 + 1)); ) d3.push({ type: 7, index: c4 }), t5 += h2.length - 1;
        }
        c4++;
      }
    }
    static createElement(t4, i5) {
      const s4 = r3.createElement("template");
      return s4.innerHTML = t4, s4;
    }
  };
  function S2(t4, i5, s4 = t4, e6) {
    if (i5 === T) return i5;
    let h3 = void 0 !== e6 ? s4._$Co?.[e6] : s4._$Cl;
    const o6 = c3(i5) ? void 0 : i5._$litDirective$;
    return h3?.constructor !== o6 && (h3?._$AO?.(false), void 0 === o6 ? h3 = void 0 : (h3 = new o6(t4), h3._$AT(t4, s4, e6)), void 0 !== e6 ? (s4._$Co ??= [])[e6] = h3 : s4._$Cl = h3), void 0 !== h3 && (i5 = S2(t4, h3._$AS(t4, i5.values), h3, e6)), i5;
  }
  var M = class {
    constructor(t4, i5) {
      this._$AV = [], this._$AN = void 0, this._$AD = t4, this._$AM = i5;
    }
    get parentNode() {
      return this._$AM.parentNode;
    }
    get _$AU() {
      return this._$AM._$AU;
    }
    u(t4) {
      const { el: { content: i5 }, parts: s4 } = this._$AD, e6 = (t4?.creationScope ?? r3).importNode(i5, true);
      C.currentNode = e6;
      let h3 = C.nextNode(), o6 = 0, n5 = 0, l4 = s4[0];
      for (; void 0 !== l4; ) {
        if (o6 === l4.index) {
          let i6;
          2 === l4.type ? i6 = new R(h3, h3.nextSibling, this, t4) : 1 === l4.type ? i6 = new l4.ctor(h3, l4.name, l4.strings, this, t4) : 6 === l4.type && (i6 = new z(h3, this, t4)), this._$AV.push(i6), l4 = s4[++n5];
        }
        o6 !== l4?.index && (h3 = C.nextNode(), o6++);
      }
      return C.currentNode = r3, e6;
    }
    p(t4) {
      let i5 = 0;
      for (const s4 of this._$AV) void 0 !== s4 && (void 0 !== s4.strings ? (s4._$AI(t4, s4, i5), i5 += s4.strings.length - 2) : s4._$AI(t4[i5])), i5++;
    }
  };
  var R = class _R {
    get _$AU() {
      return this._$AM?._$AU ?? this._$Cv;
    }
    constructor(t4, i5, s4, e6) {
      this.type = 2, this._$AH = E, this._$AN = void 0, this._$AA = t4, this._$AB = i5, this._$AM = s4, this.options = e6, this._$Cv = e6?.isConnected ?? true;
    }
    get parentNode() {
      let t4 = this._$AA.parentNode;
      const i5 = this._$AM;
      return void 0 !== i5 && 11 === t4?.nodeType && (t4 = i5.parentNode), t4;
    }
    get startNode() {
      return this._$AA;
    }
    get endNode() {
      return this._$AB;
    }
    _$AI(t4, i5 = this) {
      t4 = S2(this, t4, i5), c3(t4) ? t4 === E || null == t4 || "" === t4 ? (this._$AH !== E && this._$AR(), this._$AH = E) : t4 !== this._$AH && t4 !== T && this._(t4) : void 0 !== t4._$litType$ ? this.$(t4) : void 0 !== t4.nodeType ? this.T(t4) : u2(t4) ? this.k(t4) : this._(t4);
    }
    O(t4) {
      return this._$AA.parentNode.insertBefore(t4, this._$AB);
    }
    T(t4) {
      this._$AH !== t4 && (this._$AR(), this._$AH = this.O(t4));
    }
    _(t4) {
      this._$AH !== E && c3(this._$AH) ? this._$AA.nextSibling.data = t4 : this.T(r3.createTextNode(t4)), this._$AH = t4;
    }
    $(t4) {
      const { values: i5, _$litType$: s4 } = t4, e6 = "number" == typeof s4 ? this._$AC(t4) : (void 0 === s4.el && (s4.el = N.createElement(P(s4.h, s4.h[0]), this.options)), s4);
      if (this._$AH?._$AD === e6) this._$AH.p(i5);
      else {
        const t5 = new M(e6, this), s5 = t5.u(this.options);
        t5.p(i5), this.T(s5), this._$AH = t5;
      }
    }
    _$AC(t4) {
      let i5 = A.get(t4.strings);
      return void 0 === i5 && A.set(t4.strings, i5 = new N(t4)), i5;
    }
    k(t4) {
      a2(this._$AH) || (this._$AH = [], this._$AR());
      const i5 = this._$AH;
      let s4, e6 = 0;
      for (const h3 of t4) e6 === i5.length ? i5.push(s4 = new _R(this.O(l2()), this.O(l2()), this, this.options)) : s4 = i5[e6], s4._$AI(h3), e6++;
      e6 < i5.length && (this._$AR(s4 && s4._$AB.nextSibling, e6), i5.length = e6);
    }
    _$AR(t4 = this._$AA.nextSibling, i5) {
      for (this._$AP?.(false, true, i5); t4 && t4 !== this._$AB; ) {
        const i6 = t4.nextSibling;
        t4.remove(), t4 = i6;
      }
    }
    setConnected(t4) {
      void 0 === this._$AM && (this._$Cv = t4, this._$AP?.(t4));
    }
  };
  var k = class {
    get tagName() {
      return this.element.tagName;
    }
    get _$AU() {
      return this._$AM._$AU;
    }
    constructor(t4, i5, s4, e6, h3) {
      this.type = 1, this._$AH = E, this._$AN = void 0, this.element = t4, this.name = i5, this._$AM = e6, this.options = h3, s4.length > 2 || "" !== s4[0] || "" !== s4[1] ? (this._$AH = Array(s4.length - 1).fill(new String()), this.strings = s4) : this._$AH = E;
    }
    _$AI(t4, i5 = this, s4, e6) {
      const h3 = this.strings;
      let o6 = false;
      if (void 0 === h3) t4 = S2(this, t4, i5, 0), o6 = !c3(t4) || t4 !== this._$AH && t4 !== T, o6 && (this._$AH = t4);
      else {
        const e7 = t4;
        let n5, r6;
        for (t4 = h3[0], n5 = 0; n5 < h3.length - 1; n5++) r6 = S2(this, e7[s4 + n5], i5, n5), r6 === T && (r6 = this._$AH[n5]), o6 ||= !c3(r6) || r6 !== this._$AH[n5], r6 === E ? t4 = E : t4 !== E && (t4 += (r6 ?? "") + h3[n5 + 1]), this._$AH[n5] = r6;
      }
      o6 && !e6 && this.j(t4);
    }
    j(t4) {
      t4 === E ? this.element.removeAttribute(this.name) : this.element.setAttribute(this.name, t4 ?? "");
    }
  };
  var H = class extends k {
    constructor() {
      super(...arguments), this.type = 3;
    }
    j(t4) {
      this.element[this.name] = t4 === E ? void 0 : t4;
    }
  };
  var I = class extends k {
    constructor() {
      super(...arguments), this.type = 4;
    }
    j(t4) {
      this.element.toggleAttribute(this.name, !!t4 && t4 !== E);
    }
  };
  var L2 = class extends k {
    constructor(t4, i5, s4, e6, h3) {
      super(t4, i5, s4, e6, h3), this.type = 5;
    }
    _$AI(t4, i5 = this) {
      if ((t4 = S2(this, t4, i5, 0) ?? E) === T) return;
      const s4 = this._$AH, e6 = t4 === E && s4 !== E || t4.capture !== s4.capture || t4.once !== s4.once || t4.passive !== s4.passive, h3 = t4 !== E && (s4 === E || e6);
      e6 && this.element.removeEventListener(this.name, this, s4), h3 && this.element.addEventListener(this.name, this, t4), this._$AH = t4;
    }
    handleEvent(t4) {
      "function" == typeof this._$AH ? this._$AH.call(this.options?.host ?? this.element, t4) : this._$AH.handleEvent(t4);
    }
  };
  var z = class {
    constructor(t4, i5, s4) {
      this.element = t4, this.type = 6, this._$AN = void 0, this._$AM = i5, this.options = s4;
    }
    get _$AU() {
      return this._$AM._$AU;
    }
    _$AI(t4) {
      S2(this, t4);
    }
  };
  var j = t2.litHtmlPolyfillSupport;
  j?.(N, R), (t2.litHtmlVersions ??= []).push("3.3.0");
  var B = (t4, i5, s4) => {
    const e6 = s4?.renderBefore ?? i5;
    let h3 = e6._$litPart$;
    if (void 0 === h3) {
      const t5 = s4?.renderBefore ?? null;
      e6._$litPart$ = h3 = new R(i5.insertBefore(l2(), t5), t5, void 0, s4 ?? {});
    }
    return h3._$AI(t4), h3;
  };

  // ../node_modules/lit-element/lit-element.js
  var s3 = globalThis;
  var i4 = class extends y {
    constructor() {
      super(...arguments), this.renderOptions = { host: this }, this._$Do = void 0;
    }
    createRenderRoot() {
      const t4 = super.createRenderRoot();
      return this.renderOptions.renderBefore ??= t4.firstChild, t4;
    }
    update(t4) {
      const r6 = this.render();
      this.hasUpdated || (this.renderOptions.isConnected = this.isConnected), super.update(t4), this._$Do = B(r6, this.renderRoot, this.renderOptions);
    }
    connectedCallback() {
      super.connectedCallback(), this._$Do?.setConnected(true);
    }
    disconnectedCallback() {
      super.disconnectedCallback(), this._$Do?.setConnected(false);
    }
    render() {
      return T;
    }
  };
  i4._$litElement$ = true, i4["finalized"] = true, s3.litElementHydrateSupport?.({ LitElement: i4 });
  var o4 = s3.litElementPolyfillSupport;
  o4?.({ LitElement: i4 });
  (s3.litElementVersions ??= []).push("4.2.0");

  // ../node_modules/@lit/reactive-element/decorators/custom-element.js
  var t3 = (t4) => (e6, o6) => {
    void 0 !== o6 ? o6.addInitializer(() => {
      customElements.define(t4, e6);
    }) : customElements.define(t4, e6);
  };

  // ../node_modules/@lit/reactive-element/decorators/property.js
  var o5 = { attribute: true, type: String, converter: u, reflect: false, hasChanged: f };
  var r4 = (t4 = o5, e6, r6) => {
    const { kind: n5, metadata: i5 } = r6;
    let s4 = globalThis.litPropertyMetadata.get(i5);
    if (void 0 === s4 && globalThis.litPropertyMetadata.set(i5, s4 = /* @__PURE__ */ new Map()), "setter" === n5 && ((t4 = Object.create(t4)).wrapped = true), s4.set(r6.name, t4), "accessor" === n5) {
      const { name: o6 } = r6;
      return { set(r7) {
        const n6 = e6.get.call(this);
        e6.set.call(this, r7), this.requestUpdate(o6, n6, t4);
      }, init(e7) {
        return void 0 !== e7 && this.C(o6, void 0, t4, e7), e7;
      } };
    }
    if ("setter" === n5) {
      const { name: o6 } = r6;
      return function(r7) {
        const n6 = this[o6];
        e6.call(this, r7), this.requestUpdate(o6, n6, t4);
      };
    }
    throw Error("Unsupported decorator location: " + n5);
  };
  function n4(t4) {
    return (e6, o6) => "object" == typeof o6 ? r4(t4, e6, o6) : ((t5, e7, o7) => {
      const r6 = e7.hasOwnProperty(o7);
      return e7.constructor.createProperty(o7, t5), r6 ? Object.getOwnPropertyDescriptor(e7, o7) : void 0;
    })(t4, e6, o6);
  }

  // ../node_modules/@lit/reactive-element/decorators/state.js
  function r5(r6) {
    return n4({ ...r6, state: true, attribute: false });
  }

  // ../node_modules/@lit/reactive-element/decorators/base.js
  var e4 = (e6, t4, c4) => (c4.configurable = true, c4.enumerable = true, Reflect.decorate && "object" != typeof t4 && Object.defineProperty(e6, t4, c4), c4);

  // ../node_modules/@lit/reactive-element/decorators/query.js
  function e5(e6, r6) {
    return (n5, s4, i5) => {
      const o6 = (t4) => t4.renderRoot?.querySelector(e6) ?? null;
      if (r6) {
        const { get: e7, set: r7 } = "object" == typeof s4 ? n5 : i5 ?? (() => {
          const t4 = Symbol();
          return { get() {
            return this[t4];
          }, set(e8) {
            this[t4] = e8;
          } };
        })();
        return e4(n5, s4, { get() {
          let t4 = e7.call(this);
          return void 0 === t4 && (t4 = o6(this), (null !== t4 || this.hasUpdated) && r7.call(this, t4)), t4;
        } });
      }
      return e4(n5, s4, { get() {
        return o6(this);
      } });
    };
  }

  // src/mock-triplestore.ts
  var oxigraph;
  try {
    Promise.resolve().then(() => (init_web(), web_exports)).then((module2) => {
      oxigraph = module2;
      console.log("Oxigraph module loaded successfully");
    }).catch((error) => {
      console.error("Failed to load oxigraph module:", error);
    });
  } catch (error) {
    console.error("Error importing oxigraph:", error);
  }
  var MockTriplestore = class {
    constructor() {
      this.store = null;
      this.initialized = false;
      this.fallbackMode = false;
      console.log("Mock triplestore created");
    }
    /**
     * Initialize the store with data from TTL file
     */
    async initialize(ttlUrl) {
      if (this.initialized) return;
      try {
        if (!oxigraph) {
          console.log("Waiting for oxigraph to load...");
          await new Promise((resolve) => {
            const checkInterval = setInterval(() => {
              if (oxigraph) {
                clearInterval(checkInterval);
                resolve();
              }
            }, 100);
            setTimeout(() => {
              clearInterval(checkInterval);
              this.fallbackMode = true;
              console.warn("Oxigraph failed to load in time, using fallback mode");
              resolve();
            }, 5e3);
          });
        }
        if (oxigraph && !this.fallbackMode) {
          try {
            console.log("Creating oxigraph store...");
            this.store = new oxigraph.Store();
            console.log("Oxigraph store created successfully");
            try {
              const response = await fetch(ttlUrl);
              if (response.ok) {
                const ttlData = await response.text();
                const loadOptions = {
                  format: "text/turtle",
                  baseIRI: "http://example.org/"
                };
                this.store.load(ttlData, loadOptions);
                console.log("Data loaded into oxigraph store");
              } else {
                console.warn(`Failed to fetch TTL data: ${response.status} ${response.statusText}`);
              }
            } catch (loadError) {
              console.error("Error loading TTL data:", loadError);
            }
          } catch (storeError) {
            console.error("Failed to create oxigraph store:", storeError);
            this.fallbackMode = true;
          }
        } else {
          this.fallbackMode = true;
        }
        this.initialized = true;
        console.log(`Mock triplestore initialized (fallback mode: ${this.fallbackMode})`);
      } catch (error) {
        console.error("Failed to initialize mock triplestore:", error);
        this.fallbackMode = true;
        this.initialized = true;
      }
    }
    /**
     * Execute a SPARQL query against the in-memory store or return mock data
     */
    executeQuery(query) {
      if (!this.initialized) {
        console.warn("Mock triplestore not initialized, using fallback data");
        return this.getFallbackResults(query);
      }
      if (this.fallbackMode || !this.store) {
        console.log("Using fallback data for query");
        return this.getFallbackResults(query);
      }
      try {
        console.log("Executing query against oxigraph store");
        const results = this.store.query(query);
        const bindings = [];
        if (typeof results === "boolean") {
          return {
            head: { vars: [] },
            boolean: results
          };
        } else if (results && typeof results[Symbol.iterator] === "function") {
          for (const binding of results) {
            const resultBinding = {};
            if (binding instanceof Map) {
              for (const [key, value] of binding) {
                resultBinding[key] = this.termToObject(value);
              }
            } else if (oxigraph && binding instanceof oxigraph.Quad) {
              resultBinding.subject = this.termToObject(binding.subject);
              resultBinding.predicate = this.termToObject(binding.predicate);
              resultBinding.object = this.termToObject(binding.object);
              resultBinding.graph = this.termToObject(binding.graph);
            }
            bindings.push(resultBinding);
          }
        }
        const vars = bindings.length > 0 ? Object.keys(bindings[0]) : [];
        return {
          head: { vars },
          results: { bindings }
        };
      } catch (error) {
        console.error("Error executing SPARQL query:", error);
        return this.getFallbackResults(query);
      }
    }
    /**
     * Generate fallback results based on the query content
     */
    getFallbackResults(query) {
      const response = {
        head: { vars: ["id", "name"] },
        results: { bindings: [] }
      };
      if (query.includes("located-sites") || query.toLowerCase().includes("site_name")) {
        this.addSiteData(response);
      } else if (query.includes("site-types")) {
        this.addSiteTypes(response);
      } else if (query.includes("roman-provinces")) {
        this.addProvinces(response);
      } else if (query.includes("municipalities")) {
        this.addMunicipalities(response);
      } else if (query.includes("ceramic-types")) {
        this.addCeramicTypes(response);
      } else if (query.includes("analytic-regions")) {
        this.addAnalyticRegions(response);
      }
      return response;
    }
    // Helper methods to add mock data to response
    addSiteData(response) {
      response.head.vars = ["id", "site_name", "latitude", "longitude", "municipality", "siteType", "analysisType", "region", "provincia", "TSH", "TSHT", "TSHTB", "TSHTM", "TSG", "DSP", "ARSA", "ARSC", "ARSD", "LRC", "LRD", "PRCW", "TS_any", "TS_early", "TS_late", "ARS_325", "ARS_400", "ARS_450", "ARS_525", "ARS_600", "Coin_pre234", "Coin_C3crisis", "Coins_tetrarchy", "Coin_C4_E", "Coin_C4_L", "Coin_C5", "Coin_Just"];
      response.results.bindings = [
        {
          id: { type: "literal", value: "site1" },
          site_name: { type: "literal", value: "Lucentum" },
          latitude: { type: "literal", value: "38.3572" },
          longitude: { type: "literal", value: "-0.4519" },
          municipality: { type: "literal", value: "Alicante" },
          siteType: { type: "literal", value: "urban" },
          analysisType: { type: "literal", value: "excavation" },
          region: { type: "literal", value: "Tarraconensis" },
          provincia: { type: "literal", value: "Hispania Citerior" },
          TSH: { type: "literal", value: "1" },
          TSHT: { type: "literal", value: "0" },
          TSHTB: { type: "literal", value: "0" },
          TSHTM: { type: "literal", value: "0" },
          TSG: { type: "literal", value: "1" },
          DSP: { type: "literal", value: "0" },
          ARSA: { type: "literal", value: "1" },
          ARSC: { type: "literal", value: "1" },
          ARSD: { type: "literal", value: "1" },
          LRC: { type: "literal", value: "0" },
          LRD: { type: "literal", value: "0" },
          PRCW: { type: "literal", value: "0" },
          TS_any: { type: "literal", value: "1" },
          TS_early: { type: "literal", value: "1" },
          TS_late: { type: "literal", value: "0" },
          ARS_325: { type: "literal", value: "1" },
          ARS_400: { type: "literal", value: "1" },
          ARS_450: { type: "literal", value: "0" },
          ARS_525: { type: "literal", value: "0" },
          ARS_600: { type: "literal", value: "0" },
          Coin_pre234: { type: "literal", value: "1" },
          Coin_C3crisis: { type: "literal", value: "1" },
          Coins_tetrarchy: { type: "literal", value: "0" },
          Coin_C4_E: { type: "literal", value: "0" },
          Coin_C4_L: { type: "literal", value: "0" },
          Coin_C5: { type: "literal", value: "0" },
          Coin_Just: { type: "literal", value: "0" }
        },
        {
          id: { type: "literal", value: "site2" },
          site_name: { type: "literal", value: "Tarraco" },
          latitude: { type: "literal", value: "41.1188" },
          longitude: { type: "literal", value: "1.2542" },
          municipality: { type: "literal", value: "Tarragona" },
          siteType: { type: "literal", value: "urban" },
          analysisType: { type: "literal", value: "excavation" },
          region: { type: "literal", value: "Tarraconensis" },
          provincia: { type: "literal", value: "Hispania Citerior" },
          TSH: { type: "literal", value: "1" },
          TSHT: { type: "literal", value: "1" },
          TSHTB: { type: "literal", value: "0" },
          TSHTM: { type: "literal", value: "0" },
          TSG: { type: "literal", value: "1" },
          DSP: { type: "literal", value: "1" },
          ARSA: { type: "literal", value: "1" },
          ARSC: { type: "literal", value: "1" },
          ARSD: { type: "literal", value: "1" },
          LRC: { type: "literal", value: "1" },
          LRD: { type: "literal", value: "0" },
          PRCW: { type: "literal", value: "0" },
          TS_any: { type: "literal", value: "1" },
          TS_early: { type: "literal", value: "1" },
          TS_late: { type: "literal", value: "1" },
          ARS_325: { type: "literal", value: "1" },
          ARS_400: { type: "literal", value: "1" },
          ARS_450: { type: "literal", value: "1" },
          ARS_525: { type: "literal", value: "1" },
          ARS_600: { type: "literal", value: "0" },
          Coin_pre234: { type: "literal", value: "1" },
          Coin_C3crisis: { type: "literal", value: "1" },
          Coins_tetrarchy: { type: "literal", value: "1" },
          Coin_C4_E: { type: "literal", value: "1" },
          Coin_C4_L: { type: "literal", value: "1" },
          Coin_C5: { type: "literal", value: "1" },
          Coin_Just: { type: "literal", value: "0" }
        }
      ];
    }
    addSiteTypes(response) {
      response.head.vars = ["id", "name", "label"];
      response.results.bindings = [
        {
          id: { type: "literal", value: "urban" },
          name: { type: "literal", value: "Urban" },
          label: { type: "literal", value: "Urban Settlement" }
        },
        {
          id: { type: "literal", value: "rural" },
          name: { type: "literal", value: "Rural" },
          label: { type: "literal", value: "Rural Settlement" }
        }
      ];
    }
    addProvinces(response) {
      response.head.vars = ["id", "name", "geojson"];
      response.results.bindings = [
        {
          id: { type: "literal", value: "province1" },
          name: { type: "literal", value: "Hispania Citerior" },
          geojson: { type: "literal", value: '{"type":"Feature","properties":{},"geometry":{"type":"Polygon","coordinates":[[[0,40],[2,40],[2,42],[0,42],[0,40]]]}}' }
        }
      ];
    }
    addMunicipalities(response) {
      response.head.vars = ["id", "name", "region"];
      response.results.bindings = [
        {
          id: { type: "literal", value: "mun1" },
          name: { type: "literal", value: "Alicante" },
          region: { type: "literal", value: "Tarraconensis" }
        },
        {
          id: { type: "literal", value: "mun2" },
          name: { type: "literal", value: "Tarragona" },
          region: { type: "literal", value: "Tarraconensis" }
        }
      ];
    }
    addCeramicTypes(response) {
      response.head.vars = ["id", "name", "description", "period"];
      response.results.bindings = [
        {
          id: { type: "literal", value: "TSH" },
          name: { type: "literal", value: "Terra Sigillata Hispanic" },
          description: { type: "literal", value: "Roman ceramic produced in Hispanic workshops" },
          period: { type: "literal", value: "early-roman" }
        },
        {
          id: { type: "literal", value: "TSHT" },
          name: { type: "literal", value: "Late Hispanic Terra Sigillata" },
          description: { type: "literal", value: "Late Roman ceramic produced in Hispanic workshops" },
          period: { type: "literal", value: "late-roman" }
        }
      ];
    }
    addAnalyticRegions(response) {
      response.head.vars = ["id", "name", "description", "geojson"];
      response.results.bindings = [
        {
          id: { type: "literal", value: "region1" },
          name: { type: "literal", value: "Tarraconensis" },
          description: { type: "literal", value: "Northern region of Roman Hispania" },
          geojson: { type: "literal", value: '{"type":"Feature","properties":{},"geometry":{"type":"Polygon","coordinates":[[[0,40],[3,40],[3,43],[0,43],[0,40]]]}}' }
        }
      ];
    }
    /**
     * Helper method to convert an Oxigraph term to a SPARQL JSON result object
     */
    termToObject(term) {
      const obj = {
        type: "literal",
        value: ""
      };
      if (!term) {
        return obj;
      }
      try {
        if (oxigraph && term instanceof oxigraph.NamedNode) {
          obj.type = "uri";
          obj.value = term.value;
        } else if (oxigraph && term instanceof oxigraph.BlankNode) {
          obj.type = "bnode";
          obj.value = term.value;
        } else if (oxigraph && term instanceof oxigraph.Literal) {
          obj.type = "literal";
          obj.value = term.value;
          if (term.datatype && typeof term.datatype === "object" && "value" in term.datatype) {
            obj.datatype = term.datatype.value;
          }
          if (term.language) {
            obj["xml:lang"] = term.language;
          }
        } else if (oxigraph && term instanceof oxigraph.DefaultGraph) {
          obj.type = "uri";
          obj.value = "default";
        } else if (typeof term === "string") {
          obj.type = "literal";
          obj.value = term;
        } else {
          obj.value = String(term);
        }
      } catch (error) {
        console.error("Error processing term:", error);
        obj.type = "literal";
        obj.value = term ? String(term) : "";
      }
      return obj;
    }
  };
  var mockTriplestore = new MockTriplestore();

  // src/graph-store.ts
  var oxigraph2;
  try {
    Promise.resolve().then(() => (init_web(), web_exports)).then((module2) => {
      oxigraph2 = module2;
      console.log("Oxigraph module loaded successfully in graph-store");
    }).catch((error) => {
      console.error("Failed to load oxigraph module in graph-store:", error);
    });
  } catch (error) {
    console.error("Error importing oxigraph in graph-store:", error);
  }
  var GraphStore = class {
    constructor(endpoint = "http://localhost:3030/sites/query", useMock = true) {
      this.store = null;
      this.endpoint = endpoint;
      this.useMock = useMock;
      setTimeout(() => {
        try {
          if (oxigraph2) {
            console.log("Creating oxigraph store in GraphStore");
            this.store = new oxigraph2.Store();
            console.log("Successfully created oxigraph store in GraphStore");
          }
        } catch (error) {
          console.error("Failed to create oxigraph store in GraphStore:", error);
        }
      }, 500);
      if (this.useMock) {
        console.log("Initializing mock triplestore in GraphStore");
        mockTriplestore.initialize("/data.ttl").catch((error) => {
          console.error("Failed to initialize mock triplestore:", error);
        });
      }
    }
    async query(sparqlQuery, params = {}) {
      try {
        let processedQuery = sparqlQuery;
        for (const [key, value] of Object.entries(params)) {
          const paramPlaceholder = `?${key}Param`;
          processedQuery = processedQuery.replace(new RegExp(paramPlaceholder, "g"), `"${value}"`);
        }
        let results;
        if (this.useMock) {
          console.log("Using mock triplestore for query");
          results = mockTriplestore.executeQuery(processedQuery);
        } else {
          try {
            console.log("Using real SPARQL endpoint");
            const response = await fetch(this.endpoint, {
              method: "POST",
              headers: {
                "Content-Type": "application/sparql-query",
                "Accept": "application/sparql-results+json"
              },
              body: processedQuery
            });
            if (!response.ok) {
              throw new Error(`SPARQL query failed: ${response.status} ${response.statusText}`);
            }
            results = await response.json();
          } catch (endpointError) {
            console.error("Error with SPARQL endpoint, falling back to mock:", endpointError);
            results = mockTriplestore.executeQuery(processedQuery);
          }
        }
        const bindings = [];
        if (results.results && results.results.bindings) {
          for (const binding of results.results.bindings) {
            const bindingMap = /* @__PURE__ */ new Map();
            for (const [key, value] of Object.entries(binding)) {
              bindingMap.set(key, value);
            }
            bindings.push(bindingMap);
          }
        }
        return bindings;
      } catch (error) {
        console.error("Error executing SPARQL query:", error);
        return [];
      }
    }
  };

  // src/data-loader.ts
  var SPARQL_ENDPOINT = "http://localhost:3030/sites/query";
  var store = new GraphStore(SPARQL_ENDPOINT, true);
  async function loadSiteData() {
    try {
      console.log("Loading site data from SPARQL endpoint...");
      const response = await fetch("/queries/select/located-sites.rq");
      if (!response.ok) {
        throw new Error(`Failed to load located-sites.rq query: ${response.status} ${response.statusText}`);
      }
      const sitesQuery = await response.text();
      console.log("Executing SPARQL query for site data...");
      const bindings = await store.query(sitesQuery);
      console.log(`Received ${bindings.length} results from SPARQL query`);
      const ceramicColumns = [
        "TSH",
        "TSHT",
        "TSHTB",
        "TSHTM",
        "TSG",
        "DSP",
        "ARSA",
        "ARSC",
        "ARSD",
        "LRC",
        "LRD",
        "PRCW",
        "TS_any",
        "TS_early",
        "TS_late",
        "ARS_325",
        "ARS_400",
        "ARS_450",
        "ARS_525",
        "ARS_600"
      ];
      const coinColumns = [
        "Coin_pre234",
        "Coin_C3crisis",
        "Coins_tetrarchy",
        "Coin_C4_E",
        "Coin_C4_L",
        "Coin_C5",
        "Coin_Just"
      ];
      const sites = bindings.map((binding) => {
        const ceramics = {};
        for (const ceramic of ceramicColumns) {
          ceramics[ceramic] = binding.get(ceramic) ? parseInt(binding.get(ceramic).value) || 0 : 0;
        }
        const coins = {};
        for (const coin of coinColumns) {
          coins[coin] = binding.get(coin) ? parseInt(binding.get(coin).value) || 0 : 0;
        }
        const periods = [];
        if (ceramics["TS_early"] === 1) periods.push("early-roman");
        if (ceramics["TS_late"] === 1) periods.push("late-roman");
        if (ceramics["ARS_450"] === 1 || ceramics["ARS_525"] === 1 || ceramics["ARS_600"] === 1)
          periods.push("post-roman");
        if (periods.length === 0 && ceramics["TS_any"] === 1) {
          periods.push("early-roman");
        }
        let region = binding.get("region") ? binding.get("region").value : "";
        let provincia = binding.get("provincia") ? binding.get("provincia").value : "";
        if (!region || region.trim() === "") {
          region = "Unknown Region";
        }
        if (!provincia || provincia.trim() === "") {
          provincia = "Unknown Province";
        }
        return {
          id: binding.get("id").value,
          name: binding.get("site_name").value,
          municipality: binding.get("municipality") ? binding.get("municipality").value : "",
          siteType: binding.get("siteType") ? binding.get("siteType").value : "",
          analysisType: binding.get("analysisType") ? binding.get("analysisType").value : "",
          provincia,
          region,
          location: [
            parseFloat(binding.get("longitude").value),
            parseFloat(binding.get("latitude").value)
          ],
          ceramics,
          coins,
          periods
        };
      });
      console.log(`Successfully loaded ${sites.length} sites from SPARQL query`);
      return sites;
    } catch (error) {
      console.error("Error loading site data from SPARQL:", error);
      return [];
    }
  }
  async function loadProvinces() {
    try {
      console.log("Loading province boundaries from SPARQL endpoint...");
      const response = await fetch("/queries/select/roman-provinces.rq");
      if (!response.ok) {
        throw new Error(`Failed to load roman-provinces.rq query: ${response.status} ${response.statusText}`);
      }
      const provincesQuery = await response.text();
      console.log("Executing SPARQL query for province boundaries...");
      const bindings = await store.query(provincesQuery);
      console.log(`Received ${bindings.length} province boundaries from SPARQL query`);
      const features = bindings.map((binding) => {
        try {
          const featureJson = JSON.parse(binding.get("geojson").value);
          featureJson.properties = featureJson.properties || {};
          featureJson.properties.id = binding.get("id").value;
          featureJson.properties.name = binding.get("name").value;
          return featureJson;
        } catch (parseError) {
          console.error("Error parsing GeoJSON for province:", parseError);
          return null;
        }
      }).filter((feature) => feature !== null);
      console.log(`Successfully processed ${features.length} province features`);
      return {
        type: "FeatureCollection",
        features
      };
    } catch (error) {
      console.error("Error loading province data from SPARQL:", error);
      return { type: "FeatureCollection", features: [] };
    }
  }
  async function loadMunicipalities() {
    try {
      console.log("Loading municipalities from SPARQL endpoint...");
      const response = await fetch("/queries/select/municipalities.rq");
      if (!response.ok) {
        throw new Error(`Failed to load municipalities.rq query: ${response.status} ${response.statusText}`);
      }
      const municipalitiesQuery = await response.text();
      console.log("Executing SPARQL query for municipalities...");
      const bindings = await store.query(municipalitiesQuery);
      console.log(`Received ${bindings.length} municipalities from SPARQL query`);
      const municipalities = /* @__PURE__ */ new Map();
      bindings.forEach((binding) => {
        const id = binding.get("id").value;
        const name = binding.get("name").value;
        const region = binding.get("region") ? binding.get("region").value : "Unknown";
        municipalities.set(name, { id, name, region });
      });
      return municipalities;
    } catch (error) {
      console.error("Error loading municipalities from SPARQL:", error);
      return /* @__PURE__ */ new Map();
    }
  }
  async function loadCeramicTypes() {
    try {
      console.log("Loading ceramic types from SPARQL endpoint...");
      const response = await fetch("/queries/select/ceramic-types.rq");
      if (!response.ok) {
        throw new Error(`Failed to load ceramic-types.rq query: ${response.status} ${response.statusText}`);
      }
      const ceramicTypesQuery = await response.text();
      console.log("Executing SPARQL query for ceramic types...");
      const bindings = await store.query(ceramicTypesQuery);
      console.log(`Received ${bindings.length} ceramic types from SPARQL query`);
      const ceramicTypes = bindings.map((binding) => {
        return {
          id: binding.get("id").value,
          name: binding.get("name").value,
          description: binding.get("description") ? binding.get("description").value : "",
          period: binding.get("period") ? binding.get("period").value : ""
        };
      });
      return ceramicTypes;
    } catch (error) {
      console.error("Error loading ceramic types from SPARQL:", error);
      return [];
    }
  }
  async function loadAnalyticRegions() {
    try {
      console.log("Loading analytic regions from SPARQL endpoint...");
      const response = await fetch("/queries/select/analytic-regions.rq");
      if (!response.ok) {
        throw new Error(`Failed to load analytic-regions.rq query: ${response.status} ${response.statusText}`);
      }
      const regionsQuery = await response.text();
      console.log("Executing SPARQL query for analytic regions...");
      const bindings = await store.query(regionsQuery);
      console.log(`Received ${bindings.length} analytic regions from SPARQL query`);
      const regions = bindings.map((binding) => {
        return {
          id: binding.get("id").value,
          name: binding.get("name").value,
          description: binding.get("description") ? binding.get("description").value : "",
          geojson: binding.get("geojson") ? JSON.parse(binding.get("geojson").value) : null
        };
      });
      return regions;
    } catch (error) {
      console.error("Error loading analytic regions from SPARQL:", error);
      return [];
    }
  }
  function sitesToGeoJSON(sites, period) {
    const features = sites.filter((site) => !period || site.periods.includes(period)).map((site) => ({
      type: "Feature",
      properties: {
        id: site.id,
        name: site.name,
        municipality: site.municipality,
        siteType: site.siteType,
        analysisType: site.analysisType,
        provincia: site.provincia,
        region: site.region,
        periods: site.periods,
        ...site.ceramics,
        ...site.coins
      },
      geometry: {
        type: "Point",
        coordinates: site.location
      }
    }));
    return {
      type: "FeatureCollection",
      features
    };
  }

  // src/time-slider.ts
  var TIME_PERIODS = [
    { id: "all", label: "All Periods", years: "1st-7th Century CE" },
    { id: "early-roman", label: "Early Roman", years: "1st-3rd Century CE" },
    { id: "late-roman", label: "Late Roman", years: "4th-5th Century CE" },
    { id: "post-roman", label: "Post-Roman", years: "5th-7th Century CE" }
  ];
  var TimeSlider = class extends i4 {
    constructor() {
      super(...arguments);
      this.selected = "all";
    }
    render() {
      return x`
      <div class="slider-container">
        <div class="slider-title">Time Filter</div>
        
        <div class="time-labels">
          ${TIME_PERIODS.map((period) => x`
            <div 
              class="time-label ${period.id === this.selected ? "selected" : ""}"
              @click=${() => this.handlePeriodClick(period.id)}
            >
              ${period.label}
              <span class="years">${period.years}</span>
            </div>
          `)}
        </div>
        
        <div class="timeline">
          <!-- Early Roman Period -->
          <div 
            class="timeline-period ${this.selected === "early-roman" || this.selected === "all" ? "selected" : ""}" 
            style="left: 10%; width: 30%"
            @click=${() => this.handlePeriodClick("early-roman")}
          ></div>
          
          <!-- Late Roman Period -->
          <div 
            class="timeline-period ${this.selected === "late-roman" || this.selected === "all" ? "selected" : ""}" 
            style="left: 40%; width: 20%"
            @click=${() => this.handlePeriodClick("late-roman")}
          ></div>
          
          <!-- Post-Roman Period -->
          <div 
            class="timeline-period ${this.selected === "post-roman" || this.selected === "all" ? "selected" : ""}" 
            style="left: 60%; width: 30%"
            @click=${() => this.handlePeriodClick("post-roman")}
          ></div>
          
          <!-- Time Markers -->
          <div class="timeline-marker" style="left: 10%">
            <div class="timeline-label">1st Century CE</div>
          </div>
          <div class="timeline-marker" style="left: 40%">
            <div class="timeline-label">4th Century CE</div>
          </div>
          <div class="timeline-marker" style="left: 60%">
            <div class="timeline-label">5th Century CE</div>
          </div>
          <div class="timeline-marker" style="left: 90%">
            <div class="timeline-label">7th Century CE</div>
          </div>
        </div>
      </div>
    `;
    }
    handlePeriodClick(periodId) {
      this.selected = periodId;
      this.dispatchEvent(new CustomEvent("period-change", {
        detail: { period: periodId },
        bubbles: true,
        composed: true
      }));
    }
  };
  TimeSlider.styles = i`
    :host {
      display: block;
      width: 100%;
      padding: 1rem;
      background: white;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
      border-radius: 4px;
    }
    
    .slider-container {
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
    }
    
    .time-labels {
      display: flex;
      justify-content: space-between;
      flex-wrap: wrap;
    }
    
    .time-label {
      flex: 1;
      min-width: 120px;
      text-align: center;
      cursor: pointer;
      padding: 0.5rem;
      border-radius: 4px;
      margin: 0.25rem;
      transition: all 0.3s ease;
      border: 2px solid transparent;
    }
    
    .time-label:hover {
      background: #e0e0e0;
    }
    
    .time-label.selected {
      background: #4b6cb7;
      color: white;
      box-shadow: 0 2px 4px rgba(0,0,0,0.2);
    }
    
    .slider-title {
      font-weight: bold;
      margin-bottom: 0.5rem;
      color: #4b6cb7;
    }
    
    .years {
      display: block;
      font-size: 0.8rem;
      margin-top: 0.2rem;
      opacity: 0.8;
    }
    
    .timeline {
      position: relative;
      height: 5px;
      background: #e0e0e0;
      margin: 1rem 0;
      border-radius: 5px;
    }
    
    .timeline-marker {
      position: absolute;
      width: 15px;
      height: 15px;
      background: #4b6cb7;
      border-radius: 50%;
      top: -5px;
      transform: translateX(-50%);
      cursor: pointer;
    }
    
    .timeline-period {
      position: absolute;
      height: 5px;
      background: #b0c4de;
      border-radius: 5px;
    }
    
    .timeline-period.selected {
      background: #4b6cb7;
    }
    
    .timeline-label {
      position: absolute;
      top: -25px;
      transform: translateX(-50%);
      font-size: 0.8rem;
      color: #666;
    }
  `;
  __decorateClass([
    n4({ type: String })
  ], TimeSlider.prototype, "selected", 2);
  TimeSlider = __decorateClass([
    t3("time-slider")
  ], TimeSlider);

  // src/ceramic-filter.ts
  var CERAMIC_TYPES = [
    { id: "all", label: "All Ceramic Types" },
    { id: "TSH", label: "Terra Sigillata Hispanic (TSH)" },
    { id: "TSHT", label: "Late Hispanic Terra Sigillata (TSHT)" },
    { id: "TSHTB", label: "Betic Late Hispanic Terra Sigillata (TSHTB)" },
    { id: "TSHTM", label: "Meseta Late Hispanic Terra Sigillata (TSHTM)" },
    { id: "TSG", label: "Gallic Terra Sigillata (TSG)" },
    { id: "DSP", label: "Paleochristian Grey Pottery (DSP)" },
    { id: "ARSA", label: "African Red Slip A (ARSA)" },
    { id: "ARSC", label: "African Red Slip C (ARSC)" },
    { id: "ARSD", label: "African Red Slip D (ARSD)" },
    { id: "LRC", label: "Late Roman C Ware (LRC)" },
    { id: "LRD", label: "Late Roman D Ware (LRD)" },
    { id: "PRCW", label: "Painted Red Coated Ware (PRCW)" }
  ];
  var CeramicFilter = class extends i4 {
    constructor() {
      super(...arguments);
      this.selected = "all";
    }
    render() {
      return x`
      <div class="filter-container">
        <div class="filter-title">Ceramic Type Filter</div>
        
        <select @change=${this.handleChange}>
          <option value="all" ?selected=${this.selected === "all"}>All Ceramic Types</option>
          
          <optgroup label="Hispanic Terra Sigillata">
            ${CERAMIC_TYPES.filter((t4) => ["TSH", "TSHT", "TSHTB", "TSHTM"].includes(t4.id)).map((type) => x`
              <option value=${type.id} ?selected=${this.selected === type.id}>${type.label}</option>
            `)}
          </optgroup>
          
          <optgroup label="Gallic Terra Sigillata">
            ${CERAMIC_TYPES.filter((t4) => ["TSG", "DSP"].includes(t4.id)).map((type) => x`
              <option value=${type.id} ?selected=${this.selected === type.id}>${type.label}</option>
            `)}
          </optgroup>
          
          <optgroup label="African Red Slip">
            ${CERAMIC_TYPES.filter((t4) => ["ARSA", "ARSC", "ARSD"].includes(t4.id)).map((type) => x`
              <option value=${type.id} ?selected=${this.selected === type.id}>${type.label}</option>
            `)}
          </optgroup>
          
          <optgroup label="Eastern Pottery">
            ${CERAMIC_TYPES.filter((t4) => ["LRC", "LRD", "PRCW"].includes(t4.id)).map((type) => x`
              <option value=${type.id} ?selected=${this.selected === type.id}>${type.label}</option>
            `)}
          </optgroup>
        </select>
      </div>
    `;
    }
    handleChange(e6) {
      const select = e6.target;
      this.selected = select.value;
      this.dispatchEvent(new CustomEvent("ceramic-filter-change", {
        detail: { type: this.selected },
        bubbles: true,
        composed: true
      }));
    }
  };
  CeramicFilter.styles = i`
    :host {
      display: block;
      padding: 1rem;
      background: white;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
      border-radius: 4px;
    }
    
    .filter-container {
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
    }
    
    .filter-title {
      font-weight: bold;
      margin-bottom: 0.5rem;
      color: #4b6cb7;
    }
    
    .ceramic-option {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      padding: 3px 0;
    }
    
    .ceramic-option:hover {
      background-color: #f5f5f5;
    }
    
    input[type="radio"] {
      cursor: pointer;
    }
    
    label {
      cursor: pointer;
      font-size: 0.9rem;
    }
    
    .group-title {
      font-weight: bold;
      margin-top: 0.5rem;
      margin-bottom: 0.2rem;
      font-size: 0.85rem;
      color: #666;
    }
    
    select {
      width: 100%;
      padding: 0.5rem;
      border-radius: 4px;
      border: 1px solid #ccc;
      background-color: white;
      font-size: 0.9rem;
    }
  `;
  __decorateClass([
    n4({ type: String })
  ], CeramicFilter.prototype, "selected", 2);
  CeramicFilter = __decorateClass([
    t3("ceramic-filter")
  ], CeramicFilter);

  // src/site-type-filter.ts
  var SITE_TYPES = [
    { id: "all", label: "All Site Types" },
    { id: "Villa", label: "Villa" },
    { id: "Urban", label: "Urban" },
    { id: "Rural", label: "Rural" },
    { id: "Settlement", label: "Settlement" },
    { id: "Necropolis", label: "Necropolis" },
    { id: "Fort", label: "Fort" },
    { id: "Hillfort", label: "Hillfort" },
    { id: "Industrial", label: "Industrial" },
    { id: "Port", label: "Port" },
    { id: "Religious", label: "Religious" }
  ];
  var SiteTypeFilter = class extends i4 {
    constructor() {
      super(...arguments);
      this.selected = "all";
    }
    render() {
      return x`
      <div class="filter-container">
        <div class="filter-title">Site Type Filter</div>
        
        <select @change=${this.handleChange}>
          ${SITE_TYPES.map((type) => x`
            <option value=${type.id} ?selected=${this.selected === type.id}>${type.label}</option>
          `)}
        </select>
      </div>
    `;
    }
    handleChange(e6) {
      const select = e6.target;
      this.selected = select.value;
      this.dispatchEvent(new CustomEvent("site-filter-change", {
        detail: { type: this.selected },
        bubbles: true,
        composed: true
      }));
    }
  };
  SiteTypeFilter.styles = i`
    :host {
      display: block;
      padding: 1rem;
      background: white;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
      border-radius: 4px;
    }
    
    .filter-container {
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
    }
    
    .filter-title {
      font-weight: bold;
      margin-bottom: 0.5rem;
      color: #4b6cb7;
    }
    
    .site-option {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      padding: 3px 0;
    }
    
    .site-option:hover {
      background-color: #f5f5f5;
    }
    
    input[type="radio"] {
      cursor: pointer;
    }
    
    label {
      cursor: pointer;
      font-size: 0.9rem;
    }
    
    select {
      width: 100%;
      padding: 0.5rem;
      border-radius: 4px;
      border: 1px solid #ccc;
      background-color: white;
      font-size: 0.9rem;
    }
  `;
  __decorateClass([
    n4({ type: String })
  ], SiteTypeFilter.prototype, "selected", 2);
  SiteTypeFilter = __decorateClass([
    t3("site-type-filter")
  ], SiteTypeFilter);

  // src/region-filter.ts
  var RegionFilter = class extends i4 {
    constructor() {
      super(...arguments);
      this.selected = "all";
      this.sites = [];
      this.dropdownVisible = false;
      this.handleClickOutside = (event) => {
        const path = event.composedPath();
        if (!path.includes(this)) {
          this.dropdownVisible = false;
        }
      };
    }
    render() {
      const regions = this.getRegions();
      console.log("Region filter regions:", regions.regions);
      console.log("Region filter provincias:", regions.provincias);
      return x`
      <div class="filter-container">
        <div class="filter-title">Region Filter</div>
        
        <button class="filter-button" @click=${this.toggleDropdown}>
          ${this.getSelectedLabel()}
          <span>${this.dropdownVisible ? "\u25B2" : "\u25BC"}</span>
        </button>
        
        <div class="dropdown ${this.dropdownVisible ? "" : "hidden"}">
          <div 
            class="option ${this.selected === "all" ? "selected" : ""}"
            @click=${() => this.selectOption("all")}
          >
            All Regions
          </div>
          
          ${regions.regions.length > 0 ? x`
            <div class="section-title">Regions</div>
            ${regions.regions.map((region) => x`
              <div 
                class="option ${this.selected === region ? "selected" : ""}"
                @click=${() => this.selectOption(region)}
              >
                ${region}
              </div>
            `)}
          ` : ""}
          
          ${regions.provincias.length > 0 ? x`
            <div class="section-title">Provinces</div>
            ${regions.provincias.map((provincia) => x`
              <div 
                class="option ${this.selected === provincia ? "selected" : ""}"
                @click=${() => this.selectOption(provincia)}
              >
                ${provincia}
              </div>
            `)}
          ` : ""}
        </div>
      </div>
    `;
    }
    getSelectedLabel() {
      if (this.selected === "all") return "All Regions";
      const regions = this.getRegions();
      if (regions.regions.includes(this.selected)) return this.selected;
      if (regions.provincias.includes(this.selected)) return this.selected;
      return "All Regions";
    }
    toggleDropdown() {
      this.dropdownVisible = !this.dropdownVisible;
    }
    selectOption(value) {
      this.selected = value;
      this.dropdownVisible = false;
      this.dispatchEvent(new CustomEvent("region-filter-change", {
        detail: { region: this.selected },
        bubbles: true,
        composed: true
      }));
      console.log(`Region filter changed to: ${this.selected}`);
    }
    getRegions() {
      const regions = /* @__PURE__ */ new Set();
      const provincias = /* @__PURE__ */ new Set();
      if (!this.sites || this.sites.length === 0) {
        console.warn("No sites data available for region filter");
        return {
          regions: ["Lusitania", "Baetica", "Tarraconensis"],
          provincias: ["Gallecia", "Carthaginensis", "Baleares"]
        };
      }
      this.sites.forEach((site) => {
        try {
          if (site.region && typeof site.region === "string" && site.region.trim() !== "") {
            regions.add(site.region);
          }
          if (site.provincia && typeof site.provincia === "string" && site.provincia.trim() !== "") {
            provincias.add(site.provincia);
          }
        } catch (error) {
          console.error("Error processing site for regions:", error, site);
        }
      });
      return {
        regions: Array.from(regions).sort(),
        provincias: Array.from(provincias).sort()
      };
    }
    // Close dropdown when clicking outside
    connectedCallback() {
      super.connectedCallback();
      console.log("Region filter connected, sites count:", this.sites?.length || 0);
      if (this.sites && this.sites.length > 0) {
        console.log("Sample sites data (first 5):");
        for (let i5 = 0; i5 < Math.min(5, this.sites.length); i5++) {
          const site = this.sites[i5];
          console.log(`Site ${i5 + 1}: id=${site.id}, region=${site.region}, provincia=${site.provincia}`);
        }
        const sitesWithRegion = this.sites.filter((site) => site.region && site.region.trim() !== "").length;
        const sitesWithProvincia = this.sites.filter((site) => site.provincia && site.provincia.trim() !== "").length;
        console.log(`Stats: ${sitesWithRegion}/${this.sites.length} sites have region, ${sitesWithProvincia}/${this.sites.length} sites have provincia`);
      } else {
        console.warn("No sites data available for region-filter");
      }
      document.addEventListener("click", this.handleClickOutside);
    }
    updated(changedProperties) {
      if (changedProperties.has("sites")) {
        console.log("Sites updated in region-filter, new count:", this.sites?.length || 0);
        const regions = this.getRegions();
        console.log("Updated regions:", regions.regions.length, "provincias:", regions.provincias.length);
      }
    }
    disconnectedCallback() {
      document.removeEventListener("click", this.handleClickOutside);
      super.disconnectedCallback();
    }
  };
  RegionFilter.styles = i`
    :host {
      display: block;
      padding: 1rem;
      background: white;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
      border-radius: 4px;
    }
    
    .filter-container {
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
    }
    
    .filter-title {
      font-weight: bold;
      margin-bottom: 0.5rem;
      color: #4b6cb7;
    }
    
    .filter-button {
      width: 100%;
      padding: 0.5rem;
      border-radius: 4px;
      border: 1px solid #ccc;
      background-color: white;
      text-align: left;
      font-size: 0.9rem;
      cursor: pointer;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    
    .dropdown {
      margin-top: 5px;
      border: 1px solid #ccc;
      border-radius: 4px;
      background-color: white;
      max-height: 300px;
      overflow-y: auto;
    }
    
    .section-title {
      padding: 0.5rem;
      font-weight: bold;
      background-color: #f0f0f0;
      border-bottom: 1px solid #ddd;
    }
    
    .option {
      padding: 0.5rem;
      cursor: pointer;
    }
    
    .option:hover {
      background-color: #f5f5f5;
    }
    
    .option.selected {
      background-color: #e0e0e0;
      font-weight: bold;
    }
    
    .hidden {
      display: none;
    }
  `;
  __decorateClass([
    n4({ type: String })
  ], RegionFilter.prototype, "selected", 2);
  __decorateClass([
    n4({ type: Array })
  ], RegionFilter.prototype, "sites", 2);
  __decorateClass([
    r5()
  ], RegionFilter.prototype, "dropdownVisible", 2);
  RegionFilter = __decorateClass([
    t3("region-filter")
  ], RegionFilter);

  // src/ceramic-chart.ts
  var CeramicChart = class extends i4 {
    constructor() {
      super(...arguments);
      this.sites = [];
      this.period = "all";
      this.ceramicType = "all";
      this.siteType = "all";
      this.region = "all";
      this.activeTab = "ceramics";
    }
    render() {
      const filteredSites = this.filterSites();
      if (filteredSites.length === 0) {
        return x`
        <div class="chart-title">Statistical Analysis</div>
        <div class="tab-container">
          <div class="tab ${this.activeTab === "ceramics" ? "active" : ""}" @click=${() => this.activeTab = "ceramics"}>Ceramic Types</div>
          <div class="tab ${this.activeTab === "regions" ? "active" : ""}" @click=${() => this.activeTab = "regions"}>Regional Distribution</div>
          <div class="tab ${this.activeTab === "periods" ? "active" : ""}" @click=${() => this.activeTab = "periods"}>Period Distribution</div>
        </div>
        <div class="no-data">No data matching the selected criteria</div>
      `;
      }
      return x`
      <div class="chart-title">Statistical Analysis</div>
      
      <div class="tab-container">
        <div class="tab ${this.activeTab === "ceramics" ? "active" : ""}" @click=${() => this.activeTab = "ceramics"}>Ceramic Types</div>
        <div class="tab ${this.activeTab === "regions" ? "active" : ""}" @click=${() => this.activeTab = "regions"}>Regional Distribution</div>
        <div class="tab ${this.activeTab === "periods" ? "active" : ""}" @click=${() => this.activeTab = "periods"}>Period Distribution</div>
      </div>
      
      <div class="chart-container">
        ${this.activeTab === "ceramics" ? this.renderCeramicChart(filteredSites) : this.activeTab === "regions" ? this.renderRegionChart(filteredSites) : this.renderPeriodChart(filteredSites)}
      </div>
    `;
    }
    renderCeramicChart(sites) {
      const ceramicStats = this.calculateCeramicStatistics(sites);
      const totalSites = sites.length;
      const sortedStats = Object.entries(ceramicStats).sort(([, countA], [, countB]) => countB - countA);
      return x`
      ${sortedStats.map(([type, count]) => {
        if (count === 0) return null;
        const typeLabel = CERAMIC_TYPES.find((t4) => t4.id === type)?.label || type;
        const percentage = count / totalSites * 100;
        return x`
          <div class="bar-container">
            <div class="bar" style="width: ${percentage}%"></div>
            <span class="bar-label">${typeLabel}</span>
            <span class="bar-value">${count} (${percentage.toFixed(1)}%)</span>
          </div>
        `;
      })}
    `;
    }
    renderRegionChart(sites) {
      const regionStats = this.calculateRegionStatistics(sites);
      const totalSites = sites.length;
      const sortedStats = Object.entries(regionStats).filter(([region]) => region !== "").sort(([, countA], [, countB]) => countB - countA);
      return x`
      ${sortedStats.map(([region, count]) => {
        if (count === 0) return null;
        const percentage = count / totalSites * 100;
        return x`
          <div class="bar-container">
            <div class="bar" style="width: ${percentage}%"></div>
            <span class="bar-label">${region}</span>
            <span class="bar-value">${count} (${percentage.toFixed(1)}%)</span>
          </div>
        `;
      })}
    `;
    }
    renderPeriodChart(sites) {
      const periodStats = this.calculatePeriodStatistics(sites);
      const totalSites = sites.length;
      const periods = [
        { id: "early-roman", label: "Early Roman (1st-3rd Century)" },
        { id: "late-roman", label: "Late Roman (4th-5th Century)" },
        { id: "post-roman", label: "Post-Roman (5th-7th Century)" }
      ];
      return x`
      ${periods.map((period) => {
        const count = periodStats[period.id] || 0;
        if (count === 0) return null;
        const percentage = count / totalSites * 100;
        return x`
          <div class="bar-container">
            <div class="bar" style="width: ${percentage}%"></div>
            <span class="bar-label">${period.label}</span>
            <span class="bar-value">${count} (${percentage.toFixed(1)}%)</span>
          </div>
        `;
      })}
    `;
    }
    filterSites() {
      let filtered = [...this.sites];
      if (this.period !== "all") {
        filtered = filtered.filter(
          (site) => site.periods.includes(this.period)
        );
      }
      if (this.ceramicType !== "all") {
        filtered = filtered.filter(
          (site) => site.ceramics[this.ceramicType] === 1
        );
      }
      if (this.siteType !== "all") {
        filtered = filtered.filter(
          (site) => site.siteType === this.siteType || site.analysisType === this.siteType
        );
      }
      if (this.region !== "all") {
        filtered = filtered.filter(
          (site) => site.region === this.region || site.provincia === this.region
        );
      }
      return filtered;
    }
    calculateCeramicStatistics(sites) {
      const ceramicTypes = [
        "TSH",
        "TSHT",
        "TSHTB",
        "TSHTM",
        "TSG",
        "DSP",
        "ARSA",
        "ARSC",
        "ARSD",
        "LRC",
        "LRD",
        "PRCW"
      ];
      const stats = {};
      ceramicTypes.forEach((type) => {
        stats[type] = sites.filter((site) => site.ceramics[type] === 1).length;
      });
      return stats;
    }
    calculateRegionStatistics(sites) {
      const stats = {};
      sites.forEach((site) => {
        const region = site.region || "Other";
        stats[region] = (stats[region] || 0) + 1;
      });
      return stats;
    }
    calculatePeriodStatistics(sites) {
      const periods = ["early-roman", "late-roman", "post-roman"];
      const stats = {};
      periods.forEach((period) => {
        stats[period] = sites.filter((site) => site.periods.includes(period)).length;
      });
      return stats;
    }
  };
  CeramicChart.styles = i`
    :host {
      display: block;
      padding: 1rem;
      background: white;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
      border-radius: 4px;
    }
    
    .chart-container {
      margin-top: 1rem;
    }
    
    .chart-title {
      font-weight: bold;
      margin-bottom: 0.5rem;
      color: #4b6cb7;
    }
    
    .bar-container {
      height: 25px;
      width: 100%;
      background-color: #f0f0f0;
      border-radius: 3px;
      margin-bottom: 8px;
      position: relative;
    }
    
    .bar {
      height: 100%;
      background-color: #4b6cb7;
      border-radius: 3px;
      transition: width 0.3s ease;
    }
    
    .bar-label {
      position: absolute;
      left: 8px;
      top: 50%;
      transform: translateY(-50%);
      color: #333;
      font-size: 0.8rem;
      z-index: 1;
    }
    
    .bar-value {
      position: absolute;
      right: 8px;
      top: 50%;
      transform: translateY(-50%);
      color: #333;
      font-size: 0.8rem;
      z-index: 1;
    }
    
    .tab-container {
      display: flex;
      margin-bottom: 1rem;
    }
    
    .tab {
      padding: 0.5rem 1rem;
      cursor: pointer;
      border-bottom: 2px solid transparent;
      transition: all 0.3s ease;
    }
    
    .tab.active {
      border-bottom: 2px solid #4b6cb7;
      color: #4b6cb7;
      font-weight: bold;
    }
    
    .no-data {
      padding: 2rem;
      text-align: center;
      color: #888;
    }
  `;
  __decorateClass([
    n4({ type: Array })
  ], CeramicChart.prototype, "sites", 2);
  __decorateClass([
    n4({ type: String })
  ], CeramicChart.prototype, "period", 2);
  __decorateClass([
    n4({ type: String })
  ], CeramicChart.prototype, "ceramicType", 2);
  __decorateClass([
    n4({ type: String })
  ], CeramicChart.prototype, "siteType", 2);
  __decorateClass([
    n4({ type: String })
  ], CeramicChart.prototype, "region", 2);
  __decorateClass([
    n4({ type: String })
  ], CeramicChart.prototype, "activeTab", 2);
  CeramicChart = __decorateClass([
    t3("ceramic-chart")
  ], CeramicChart);

  // src/tile-map.ts
  var import_maplibre_gl = __toESM(require_maplibre_gl());

  // ../node_modules/@turf/meta/dist/esm/index.js
  function coordEach(geojson, callback, excludeWrapCoord) {
    if (geojson === null) return;
    var j3, k3, l4, geometry, stopG, coords, geometryMaybeCollection, wrapShrink = 0, coordIndex = 0, isGeometryCollection, type = geojson.type, isFeatureCollection = type === "FeatureCollection", isFeature = type === "Feature", stop = isFeatureCollection ? geojson.features.length : 1;
    for (var featureIndex = 0; featureIndex < stop; featureIndex++) {
      geometryMaybeCollection = isFeatureCollection ? geojson.features[featureIndex].geometry : isFeature ? geojson.geometry : geojson;
      isGeometryCollection = geometryMaybeCollection ? geometryMaybeCollection.type === "GeometryCollection" : false;
      stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;
      for (var geomIndex = 0; geomIndex < stopG; geomIndex++) {
        var multiFeatureIndex = 0;
        var geometryIndex = 0;
        geometry = isGeometryCollection ? geometryMaybeCollection.geometries[geomIndex] : geometryMaybeCollection;
        if (geometry === null) continue;
        coords = geometry.coordinates;
        var geomType = geometry.type;
        wrapShrink = excludeWrapCoord && (geomType === "Polygon" || geomType === "MultiPolygon") ? 1 : 0;
        switch (geomType) {
          case null:
            break;
          case "Point":
            if (callback(
              coords,
              coordIndex,
              featureIndex,
              multiFeatureIndex,
              geometryIndex
            ) === false)
              return false;
            coordIndex++;
            multiFeatureIndex++;
            break;
          case "LineString":
          case "MultiPoint":
            for (j3 = 0; j3 < coords.length; j3++) {
              if (callback(
                coords[j3],
                coordIndex,
                featureIndex,
                multiFeatureIndex,
                geometryIndex
              ) === false)
                return false;
              coordIndex++;
              if (geomType === "MultiPoint") multiFeatureIndex++;
            }
            if (geomType === "LineString") multiFeatureIndex++;
            break;
          case "Polygon":
          case "MultiLineString":
            for (j3 = 0; j3 < coords.length; j3++) {
              for (k3 = 0; k3 < coords[j3].length - wrapShrink; k3++) {
                if (callback(
                  coords[j3][k3],
                  coordIndex,
                  featureIndex,
                  multiFeatureIndex,
                  geometryIndex
                ) === false)
                  return false;
                coordIndex++;
              }
              if (geomType === "MultiLineString") multiFeatureIndex++;
              if (geomType === "Polygon") geometryIndex++;
            }
            if (geomType === "Polygon") multiFeatureIndex++;
            break;
          case "MultiPolygon":
            for (j3 = 0; j3 < coords.length; j3++) {
              geometryIndex = 0;
              for (k3 = 0; k3 < coords[j3].length; k3++) {
                for (l4 = 0; l4 < coords[j3][k3].length - wrapShrink; l4++) {
                  if (callback(
                    coords[j3][k3][l4],
                    coordIndex,
                    featureIndex,
                    multiFeatureIndex,
                    geometryIndex
                  ) === false)
                    return false;
                  coordIndex++;
                }
                geometryIndex++;
              }
              multiFeatureIndex++;
            }
            break;
          case "GeometryCollection":
            for (j3 = 0; j3 < geometry.geometries.length; j3++)
              if (coordEach(geometry.geometries[j3], callback, excludeWrapCoord) === false)
                return false;
            break;
          default:
            throw new Error("Unknown Geometry Type");
        }
      }
    }
  }

  // ../node_modules/@turf/bbox/dist/esm/index.js
  function bbox(geojson, options = {}) {
    if (geojson.bbox != null && true !== options.recompute) {
      return geojson.bbox;
    }
    const result = [Infinity, Infinity, -Infinity, -Infinity];
    coordEach(geojson, (coord) => {
      if (result[0] > coord[0]) {
        result[0] = coord[0];
      }
      if (result[1] > coord[1]) {
        result[1] = coord[1];
      }
      if (result[2] < coord[0]) {
        result[2] = coord[0];
      }
      if (result[3] < coord[1]) {
        result[3] = coord[1];
      }
    });
    return result;
  }

  // ../node_modules/fflate/esm/browser.js
  var u8 = Uint8Array;
  var u16 = Uint16Array;
  var i32 = Int32Array;
  var fleb = new u8([
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    2,
    2,
    2,
    2,
    3,
    3,
    3,
    3,
    4,
    4,
    4,
    4,
    5,
    5,
    5,
    5,
    0,
    /* unused */
    0,
    0,
    /* impossible */
    0
  ]);
  var fdeb = new u8([
    0,
    0,
    0,
    0,
    1,
    1,
    2,
    2,
    3,
    3,
    4,
    4,
    5,
    5,
    6,
    6,
    7,
    7,
    8,
    8,
    9,
    9,
    10,
    10,
    11,
    11,
    12,
    12,
    13,
    13,
    /* unused */
    0,
    0
  ]);
  var clim = new u8([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
  var freb = function(eb, start) {
    var b4 = new u16(31);
    for (var i5 = 0; i5 < 31; ++i5) {
      b4[i5] = start += 1 << eb[i5 - 1];
    }
    var r6 = new i32(b4[30]);
    for (var i5 = 1; i5 < 30; ++i5) {
      for (var j3 = b4[i5]; j3 < b4[i5 + 1]; ++j3) {
        r6[j3] = j3 - b4[i5] << 5 | i5;
      }
    }
    return { b: b4, r: r6 };
  };
  var _a = freb(fleb, 2);
  var fl = _a.b;
  var revfl = _a.r;
  fl[28] = 258, revfl[258] = 28;
  var _b = freb(fdeb, 0);
  var fd = _b.b;
  var revfd = _b.r;
  var rev = new u16(32768);
  for (i5 = 0; i5 < 32768; ++i5) {
    x3 = (i5 & 43690) >> 1 | (i5 & 21845) << 1;
    x3 = (x3 & 52428) >> 2 | (x3 & 13107) << 2;
    x3 = (x3 & 61680) >> 4 | (x3 & 3855) << 4;
    rev[i5] = ((x3 & 65280) >> 8 | (x3 & 255) << 8) >> 1;
  }
  var x3;
  var i5;
  var hMap = function(cd, mb, r6) {
    var s4 = cd.length;
    var i5 = 0;
    var l4 = new u16(mb);
    for (; i5 < s4; ++i5) {
      if (cd[i5])
        ++l4[cd[i5] - 1];
    }
    var le = new u16(mb);
    for (i5 = 1; i5 < mb; ++i5) {
      le[i5] = le[i5 - 1] + l4[i5 - 1] << 1;
    }
    var co;
    if (r6) {
      co = new u16(1 << mb);
      var rvb = 15 - mb;
      for (i5 = 0; i5 < s4; ++i5) {
        if (cd[i5]) {
          var sv = i5 << 4 | cd[i5];
          var r_1 = mb - cd[i5];
          var v3 = le[cd[i5] - 1]++ << r_1;
          for (var m3 = v3 | (1 << r_1) - 1; v3 <= m3; ++v3) {
            co[rev[v3] >> rvb] = sv;
          }
        }
      }
    } else {
      co = new u16(s4);
      for (i5 = 0; i5 < s4; ++i5) {
        if (cd[i5]) {
          co[i5] = rev[le[cd[i5] - 1]++] >> 15 - cd[i5];
        }
      }
    }
    return co;
  };
  var flt = new u8(288);
  for (i5 = 0; i5 < 144; ++i5)
    flt[i5] = 8;
  var i5;
  for (i5 = 144; i5 < 256; ++i5)
    flt[i5] = 9;
  var i5;
  for (i5 = 256; i5 < 280; ++i5)
    flt[i5] = 7;
  var i5;
  for (i5 = 280; i5 < 288; ++i5)
    flt[i5] = 8;
  var i5;
  var fdt = new u8(32);
  for (i5 = 0; i5 < 32; ++i5)
    fdt[i5] = 5;
  var i5;
  var flrm = /* @__PURE__ */ hMap(flt, 9, 1);
  var fdrm = /* @__PURE__ */ hMap(fdt, 5, 1);
  var max = function(a3) {
    var m3 = a3[0];
    for (var i5 = 1; i5 < a3.length; ++i5) {
      if (a3[i5] > m3)
        m3 = a3[i5];
    }
    return m3;
  };
  var bits = function(d3, p3, m3) {
    var o6 = p3 / 8 | 0;
    return (d3[o6] | d3[o6 + 1] << 8) >> (p3 & 7) & m3;
  };
  var bits16 = function(d3, p3) {
    var o6 = p3 / 8 | 0;
    return (d3[o6] | d3[o6 + 1] << 8 | d3[o6 + 2] << 16) >> (p3 & 7);
  };
  var shft = function(p3) {
    return (p3 + 7) / 8 | 0;
  };
  var slc = function(v3, s4, e6) {
    if (s4 == null || s4 < 0)
      s4 = 0;
    if (e6 == null || e6 > v3.length)
      e6 = v3.length;
    return new u8(v3.subarray(s4, e6));
  };
  var ec = [
    "unexpected EOF",
    "invalid block type",
    "invalid length/literal",
    "invalid distance",
    "stream finished",
    "no stream handler",
    ,
    "no callback",
    "invalid UTF-8 data",
    "extra field too long",
    "date not in range 1980-2099",
    "filename too long",
    "stream finishing",
    "invalid zip data"
    // determined by unknown compression method
  ];
  var err = function(ind, msg, nt) {
    var e6 = new Error(msg || ec[ind]);
    e6.code = ind;
    if (Error.captureStackTrace)
      Error.captureStackTrace(e6, err);
    if (!nt)
      throw e6;
    return e6;
  };
  var inflt = function(dat, st, buf, dict) {
    var sl = dat.length, dl = dict ? dict.length : 0;
    if (!sl || st.f && !st.l)
      return buf || new u8(0);
    var noBuf = !buf;
    var resize = noBuf || st.i != 2;
    var noSt = st.i;
    if (noBuf)
      buf = new u8(sl * 3);
    var cbuf = function(l5) {
      var bl = buf.length;
      if (l5 > bl) {
        var nbuf = new u8(Math.max(bl * 2, l5));
        nbuf.set(buf);
        buf = nbuf;
      }
    };
    var final = st.f || 0, pos = st.p || 0, bt = st.b || 0, lm = st.l, dm = st.d, lbt = st.m, dbt = st.n;
    var tbts = sl * 8;
    do {
      if (!lm) {
        final = bits(dat, pos, 1);
        var type = bits(dat, pos + 1, 3);
        pos += 3;
        if (!type) {
          var s4 = shft(pos) + 4, l4 = dat[s4 - 4] | dat[s4 - 3] << 8, t4 = s4 + l4;
          if (t4 > sl) {
            if (noSt)
              err(0);
            break;
          }
          if (resize)
            cbuf(bt + l4);
          buf.set(dat.subarray(s4, t4), bt);
          st.b = bt += l4, st.p = pos = t4 * 8, st.f = final;
          continue;
        } else if (type == 1)
          lm = flrm, dm = fdrm, lbt = 9, dbt = 5;
        else if (type == 2) {
          var hLit = bits(dat, pos, 31) + 257, hcLen = bits(dat, pos + 10, 15) + 4;
          var tl = hLit + bits(dat, pos + 5, 31) + 1;
          pos += 14;
          var ldt = new u8(tl);
          var clt = new u8(19);
          for (var i5 = 0; i5 < hcLen; ++i5) {
            clt[clim[i5]] = bits(dat, pos + i5 * 3, 7);
          }
          pos += hcLen * 3;
          var clb = max(clt), clbmsk = (1 << clb) - 1;
          var clm = hMap(clt, clb, 1);
          for (var i5 = 0; i5 < tl; ) {
            var r6 = clm[bits(dat, pos, clbmsk)];
            pos += r6 & 15;
            var s4 = r6 >> 4;
            if (s4 < 16) {
              ldt[i5++] = s4;
            } else {
              var c4 = 0, n5 = 0;
              if (s4 == 16)
                n5 = 3 + bits(dat, pos, 3), pos += 2, c4 = ldt[i5 - 1];
              else if (s4 == 17)
                n5 = 3 + bits(dat, pos, 7), pos += 3;
              else if (s4 == 18)
                n5 = 11 + bits(dat, pos, 127), pos += 7;
              while (n5--)
                ldt[i5++] = c4;
            }
          }
          var lt = ldt.subarray(0, hLit), dt = ldt.subarray(hLit);
          lbt = max(lt);
          dbt = max(dt);
          lm = hMap(lt, lbt, 1);
          dm = hMap(dt, dbt, 1);
        } else
          err(1);
        if (pos > tbts) {
          if (noSt)
            err(0);
          break;
        }
      }
      if (resize)
        cbuf(bt + 131072);
      var lms = (1 << lbt) - 1, dms = (1 << dbt) - 1;
      var lpos = pos;
      for (; ; lpos = pos) {
        var c4 = lm[bits16(dat, pos) & lms], sym = c4 >> 4;
        pos += c4 & 15;
        if (pos > tbts) {
          if (noSt)
            err(0);
          break;
        }
        if (!c4)
          err(2);
        if (sym < 256)
          buf[bt++] = sym;
        else if (sym == 256) {
          lpos = pos, lm = null;
          break;
        } else {
          var add = sym - 254;
          if (sym > 264) {
            var i5 = sym - 257, b4 = fleb[i5];
            add = bits(dat, pos, (1 << b4) - 1) + fl[i5];
            pos += b4;
          }
          var d3 = dm[bits16(dat, pos) & dms], dsym = d3 >> 4;
          if (!d3)
            err(3);
          pos += d3 & 15;
          var dt = fd[dsym];
          if (dsym > 3) {
            var b4 = fdeb[dsym];
            dt += bits16(dat, pos) & (1 << b4) - 1, pos += b4;
          }
          if (pos > tbts) {
            if (noSt)
              err(0);
            break;
          }
          if (resize)
            cbuf(bt + 131072);
          var end = bt + add;
          if (bt < dt) {
            var shift = dl - dt, dend = Math.min(dt, end);
            if (shift + bt < 0)
              err(3);
            for (; bt < dend; ++bt)
              buf[bt] = dict[shift + bt];
          }
          for (; bt < end; ++bt)
            buf[bt] = buf[bt - dt];
        }
      }
      st.l = lm, st.p = lpos, st.b = bt, st.f = final;
      if (lm)
        final = 1, st.m = lbt, st.d = dm, st.n = dbt;
    } while (!final);
    return bt != buf.length && noBuf ? slc(buf, 0, bt) : buf.subarray(0, bt);
  };
  var et = /* @__PURE__ */ new u8(0);
  var gzs = function(d3) {
    if (d3[0] != 31 || d3[1] != 139 || d3[2] != 8)
      err(6, "invalid gzip data");
    var flg = d3[3];
    var st = 10;
    if (flg & 4)
      st += (d3[10] | d3[11] << 8) + 2;
    for (var zs = (flg >> 3 & 1) + (flg >> 4 & 1); zs > 0; zs -= !d3[st++])
      ;
    return st + (flg & 2);
  };
  var gzl = function(d3) {
    var l4 = d3.length;
    return (d3[l4 - 4] | d3[l4 - 3] << 8 | d3[l4 - 2] << 16 | d3[l4 - 1] << 24) >>> 0;
  };
  var zls = function(d3, dict) {
    if ((d3[0] & 15) != 8 || d3[0] >> 4 > 7 || (d3[0] << 8 | d3[1]) % 31)
      err(6, "invalid zlib data");
    if ((d3[1] >> 5 & 1) == +!dict)
      err(6, "invalid zlib data: " + (d3[1] & 32 ? "need" : "unexpected") + " dictionary");
    return (d3[1] >> 3 & 4) + 2;
  };
  function inflateSync(data, opts) {
    return inflt(data, { i: 2 }, opts && opts.out, opts && opts.dictionary);
  }
  function gunzipSync(data, opts) {
    var st = gzs(data);
    if (st + 8 > data.length)
      err(6, "invalid gzip data");
    return inflt(data.subarray(st, -8), { i: 2 }, opts && opts.out || new u8(gzl(data)), opts && opts.dictionary);
  }
  function unzlibSync(data, opts) {
    return inflt(data.subarray(zls(data, opts && opts.dictionary), -4), { i: 2 }, opts && opts.out, opts && opts.dictionary);
  }
  function decompressSync(data, opts) {
    return data[0] == 31 && data[1] == 139 && data[2] == 8 ? gunzipSync(data, opts) : (data[0] & 15) != 8 || data[0] >> 4 > 7 || (data[0] << 8 | data[1]) % 31 ? inflateSync(data, opts) : unzlibSync(data, opts);
  }
  var td = typeof TextDecoder != "undefined" && /* @__PURE__ */ new TextDecoder();
  var tds = 0;
  try {
    td.decode(et, { stream: true });
    tds = 1;
  } catch (e6) {
  }

  // ../node_modules/pmtiles/dist/esm/index.js
  var z2 = Object.defineProperty;
  var b3 = Math.pow;
  var l3 = (i5, e6) => z2(i5, "name", { value: e6, configurable: true });
  var m2 = (i5, e6, t4) => new Promise((r6, n5) => {
    var s4 = (u3) => {
      try {
        a3(t4.next(u3));
      } catch (c4) {
        n5(c4);
      }
    }, o6 = (u3) => {
      try {
        a3(t4.throw(u3));
      } catch (c4) {
        n5(c4);
      }
    }, a3 = (u3) => u3.done ? r6(u3.value) : Promise.resolve(u3.value).then(s4, o6);
    a3((t4 = t4.apply(i5, e6)).next());
  });
  var re = l3((i5, e6) => {
    let t4 = false, r6 = "", n5 = L.GridLayer.extend({ createTile: l3((s4, o6) => {
      let a3 = document.createElement("img"), u3 = new AbortController(), c4 = u3.signal;
      return a3.cancel = () => {
        u3.abort();
      }, t4 || (i5.getHeader().then((d3) => {
        d3.tileType === 1 ? console.error("Error: archive contains MVT vector tiles, but leafletRasterLayer is for displaying raster tiles. See https://github.com/protomaps/PMTiles/tree/main/js for details.") : d3.tileType === 2 ? r6 = "image/png" : d3.tileType === 3 ? r6 = "image/jpeg" : d3.tileType === 4 ? r6 = "image/webp" : d3.tileType === 5 && (r6 = "image/avif");
      }), t4 = true), i5.getZxy(s4.z, s4.x, s4.y, c4).then((d3) => {
        if (d3) {
          let h3 = new Blob([d3.data], { type: r6 }), p3 = window.URL.createObjectURL(h3);
          a3.src = p3, a3.cancel = void 0, o6(void 0, a3);
        }
      }).catch((d3) => {
        if (d3.name !== "AbortError") throw d3;
      }), a3;
    }, "createTile"), _removeTile: l3(function(s4) {
      let o6 = this._tiles[s4];
      o6 && (o6.el.cancel && o6.el.cancel(), o6.el.width = 0, o6.el.height = 0, o6.el.deleted = true, L.DomUtil.remove(o6.el), delete this._tiles[s4], this.fire("tileunload", { tile: o6.el, coords: this._keyToTileCoords(s4) }));
    }, "_removeTile") });
    return new n5(e6);
  }, "leafletRasterLayer");
  var j2 = l3((i5) => (e6, t4) => {
    if (t4 instanceof AbortController) return i5(e6, t4);
    let r6 = new AbortController();
    return i5(e6, r6).then((n5) => t4(void 0, n5.data, n5.cacheControl || "", n5.expires || ""), (n5) => t4(n5)).catch((n5) => t4(n5)), { cancel: l3(() => r6.abort(), "cancel") };
  }, "v3compat");
  var T2 = class T3 {
    constructor(e6) {
      this.tilev4 = l3((e7, t4) => m2(this, null, function* () {
        if (e7.type === "json") {
          let p3 = e7.url.substr(10), y3 = this.tiles.get(p3);
          if (y3 || (y3 = new x2(p3), this.tiles.set(p3, y3)), this.metadata) return { data: yield y3.getTileJson(e7.url) };
          let f3 = yield y3.getHeader();
          return (f3.minLon >= f3.maxLon || f3.minLat >= f3.maxLat) && console.error(`Bounds of PMTiles archive ${f3.minLon},${f3.minLat},${f3.maxLon},${f3.maxLat} are not valid.`), { data: { tiles: [`${e7.url}/{z}/{x}/{y}`], minzoom: f3.minZoom, maxzoom: f3.maxZoom, bounds: [f3.minLon, f3.minLat, f3.maxLon, f3.maxLat] } };
        }
        let r6 = new RegExp(/pmtiles:\/\/(.+)\/(\d+)\/(\d+)\/(\d+)/), n5 = e7.url.match(r6);
        if (!n5) throw new Error("Invalid PMTiles protocol URL");
        let s4 = n5[1], o6 = this.tiles.get(s4);
        o6 || (o6 = new x2(s4), this.tiles.set(s4, o6));
        let a3 = n5[2], u3 = n5[3], c4 = n5[4], d3 = yield o6.getHeader(), h3 = yield o6 == null ? void 0 : o6.getZxy(+a3, +u3, +c4, t4.signal);
        if (h3) return { data: new Uint8Array(h3.data), cacheControl: h3.cacheControl, expires: h3.expires };
        if (d3.tileType === 1) {
          if (this.errorOnMissingTile) throw new Error("Tile not found.");
          return { data: new Uint8Array() };
        }
        return { data: null };
      }), "tilev4");
      this.tile = j2(this.tilev4);
      this.tiles = /* @__PURE__ */ new Map(), this.metadata = (e6 == null ? void 0 : e6.metadata) || false, this.errorOnMissingTile = (e6 == null ? void 0 : e6.errorOnMissingTile) || false;
    }
    add(e6) {
      this.tiles.set(e6.source.getKey(), e6);
    }
    get(e6) {
      return this.tiles.get(e6);
    }
  };
  l3(T2, "Protocol");
  var S3 = T2;
  function w2(i5, e6) {
    return (e6 >>> 0) * 4294967296 + (i5 >>> 0);
  }
  l3(w2, "toNum");
  function F(i5, e6) {
    let t4 = e6.buf, r6 = t4[e6.pos++], n5 = (r6 & 112) >> 4;
    if (r6 < 128 || (r6 = t4[e6.pos++], n5 |= (r6 & 127) << 3, r6 < 128) || (r6 = t4[e6.pos++], n5 |= (r6 & 127) << 10, r6 < 128) || (r6 = t4[e6.pos++], n5 |= (r6 & 127) << 17, r6 < 128) || (r6 = t4[e6.pos++], n5 |= (r6 & 127) << 24, r6 < 128) || (r6 = t4[e6.pos++], n5 |= (r6 & 1) << 31, r6 < 128)) return w2(i5, n5);
    throw new Error("Expected varint not more than 10 bytes");
  }
  l3(F, "readVarintRemainder");
  function v2(i5) {
    let e6 = i5.buf, t4 = e6[i5.pos++], r6 = t4 & 127;
    return t4 < 128 || (t4 = e6[i5.pos++], r6 |= (t4 & 127) << 7, t4 < 128) || (t4 = e6[i5.pos++], r6 |= (t4 & 127) << 14, t4 < 128) || (t4 = e6[i5.pos++], r6 |= (t4 & 127) << 21, t4 < 128) ? r6 : (t4 = e6[i5.pos], r6 |= (t4 & 15) << 28, F(r6, i5));
  }
  l3(v2, "readVarint");
  function k2(i5, e6, t4, r6) {
    if (r6 === 0) {
      t4 === 1 && (e6[0] = i5 - 1 - e6[0], e6[1] = i5 - 1 - e6[1]);
      let n5 = e6[0];
      e6[0] = e6[1], e6[1] = n5;
    }
  }
  l3(k2, "rotate");
  function N2(i5, e6) {
    let t4 = b3(2, i5), r6 = e6, n5 = e6, s4 = e6, o6 = [0, 0], a3 = 1;
    for (; a3 < t4; ) r6 = 1 & s4 / 2, n5 = 1 & (s4 ^ r6), k2(a3, o6, r6, n5), o6[0] += a3 * r6, o6[1] += a3 * n5, s4 = s4 / 4, a3 *= 2;
    return [i5, o6[0], o6[1]];
  }
  l3(N2, "idOnLevel");
  var q = [0, 1, 5, 21, 85, 341, 1365, 5461, 21845, 87381, 349525, 1398101, 5592405, 22369621, 89478485, 357913941, 1431655765, 5726623061, 22906492245, 91625968981, 366503875925, 1466015503701, 5864062014805, 23456248059221, 93824992236885, 375299968947541, 1501199875790165];
  function G(i5, e6, t4) {
    if (i5 > 26) throw new Error("Tile zoom level exceeds max safe number limit (26)");
    if (e6 > b3(2, i5) - 1 || t4 > b3(2, i5) - 1) throw new Error("tile x/y outside zoom level bounds");
    let r6 = q[i5], n5 = b3(2, i5), s4 = 0, o6 = 0, a3 = 0, u3 = [e6, t4], c4 = n5 / 2;
    for (; c4 > 0; ) s4 = (u3[0] & c4) > 0 ? 1 : 0, o6 = (u3[1] & c4) > 0 ? 1 : 0, a3 += c4 * c4 * (3 * s4 ^ o6), k2(c4, u3, s4, o6), c4 = c4 / 2;
    return r6 + a3;
  }
  l3(G, "zxyToTileId");
  function ie(i5) {
    let e6 = 0, t4 = 0;
    for (let r6 = 0; r6 < 27; r6++) {
      let n5 = (1 << r6) * (1 << r6);
      if (e6 + n5 > i5) return N2(r6, i5 - e6);
      e6 += n5;
    }
    throw new Error("Tile zoom level exceeds max safe number limit (26)");
  }
  l3(ie, "tileIdToZxy");
  var J = ((s4) => (s4[s4.Unknown = 0] = "Unknown", s4[s4.None = 1] = "None", s4[s4.Gzip = 2] = "Gzip", s4[s4.Brotli = 3] = "Brotli", s4[s4.Zstd = 4] = "Zstd", s4))(J || {});
  function D(i5, e6) {
    return m2(this, null, function* () {
      if (e6 === 1 || e6 === 0) return i5;
      if (e6 === 2) {
        if (typeof globalThis.DecompressionStream == "undefined") return decompressSync(new Uint8Array(i5));
        let t4 = new Response(i5).body;
        if (!t4) throw new Error("Failed to read response stream");
        let r6 = t4.pipeThrough(new globalThis.DecompressionStream("gzip"));
        return new Response(r6).arrayBuffer();
      }
      throw new Error("Compression method not supported");
    });
  }
  l3(D, "defaultDecompress");
  var O = ((o6) => (o6[o6.Unknown = 0] = "Unknown", o6[o6.Mvt = 1] = "Mvt", o6[o6.Png = 2] = "Png", o6[o6.Jpeg = 3] = "Jpeg", o6[o6.Webp = 4] = "Webp", o6[o6.Avif = 5] = "Avif", o6))(O || {});
  function _2(i5) {
    return i5 === 1 ? ".mvt" : i5 === 2 ? ".png" : i5 === 3 ? ".jpg" : i5 === 4 ? ".webp" : i5 === 5 ? ".avif" : "";
  }
  l3(_2, "tileTypeExt");
  var Y = 127;
  function Q(i5, e6) {
    let t4 = 0, r6 = i5.length - 1;
    for (; t4 <= r6; ) {
      let n5 = r6 + t4 >> 1, s4 = e6 - i5[n5].tileId;
      if (s4 > 0) t4 = n5 + 1;
      else if (s4 < 0) r6 = n5 - 1;
      else return i5[n5];
    }
    return r6 >= 0 && (i5[r6].runLength === 0 || e6 - i5[r6].tileId < i5[r6].runLength) ? i5[r6] : null;
  }
  l3(Q, "findTile");
  var A2 = class A3 {
    constructor(e6) {
      this.file = e6;
    }
    getKey() {
      return this.file.name;
    }
    getBytes(e6, t4) {
      return m2(this, null, function* () {
        return { data: yield this.file.slice(e6, e6 + t4).arrayBuffer() };
      });
    }
  };
  l3(A2, "FileSource");
  var U = class U2 {
    constructor(e6, t4 = new Headers()) {
      this.url = e6, this.customHeaders = t4, this.mustReload = false;
      let r6 = "";
      "navigator" in globalThis && (r6 = globalThis.navigator.userAgent || "");
      let n5 = r6.indexOf("Windows") > -1, s4 = /Chrome|Chromium|Edg|OPR|Brave/.test(r6);
      this.chromeWindowsNoCache = false, n5 && s4 && (this.chromeWindowsNoCache = true);
    }
    getKey() {
      return this.url;
    }
    setHeaders(e6) {
      this.customHeaders = e6;
    }
    getBytes(e6, t4, r6, n5) {
      return m2(this, null, function* () {
        let s4, o6;
        r6 ? o6 = r6 : (s4 = new AbortController(), o6 = s4.signal);
        let a3 = new Headers(this.customHeaders);
        a3.set("range", `bytes=${e6}-${e6 + t4 - 1}`);
        let u3;
        this.mustReload ? u3 = "reload" : this.chromeWindowsNoCache && (u3 = "no-store");
        let c4 = yield fetch(this.url, { signal: o6, cache: u3, headers: a3 });
        if (e6 === 0 && c4.status === 416) {
          let y3 = c4.headers.get("Content-Range");
          if (!y3 || !y3.startsWith("bytes */")) throw new Error("Missing content-length on 416 response");
          let f3 = +y3.substr(8);
          c4 = yield fetch(this.url, { signal: o6, cache: "reload", headers: { range: `bytes=0-${f3 - 1}` } });
        }
        let d3 = c4.headers.get("Etag");
        if (d3 != null && d3.startsWith("W/") && (d3 = null), c4.status === 416 || n5 && d3 && d3 !== n5) throw this.mustReload = true, new E2(`Server returned non-matching ETag ${n5} after one retry. Check browser extensions and servers for issues that may affect correct ETag headers.`);
        if (c4.status >= 300) throw new Error(`Bad response code: ${c4.status}`);
        let h3 = c4.headers.get("Content-Length");
        if (c4.status === 200 && (!h3 || +h3 > t4)) throw s4 && s4.abort(), new Error("Server returned no content-length header or content-length exceeding request. Check that your storage backend supports HTTP Byte Serving.");
        return { data: yield c4.arrayBuffer(), etag: d3 || void 0, cacheControl: c4.headers.get("Cache-Control") || void 0, expires: c4.headers.get("Expires") || void 0 };
      });
    }
  };
  l3(U, "FetchSource");
  var C2 = U;
  function g2(i5, e6) {
    let t4 = i5.getUint32(e6 + 4, true), r6 = i5.getUint32(e6 + 0, true);
    return t4 * b3(2, 32) + r6;
  }
  l3(g2, "getUint64");
  function X(i5, e6) {
    let t4 = new DataView(i5), r6 = t4.getUint8(7);
    if (r6 > 3) throw new Error(`Archive is spec version ${r6} but this library supports up to spec version 3`);
    return { specVersion: r6, rootDirectoryOffset: g2(t4, 8), rootDirectoryLength: g2(t4, 16), jsonMetadataOffset: g2(t4, 24), jsonMetadataLength: g2(t4, 32), leafDirectoryOffset: g2(t4, 40), leafDirectoryLength: g2(t4, 48), tileDataOffset: g2(t4, 56), tileDataLength: g2(t4, 64), numAddressedTiles: g2(t4, 72), numTileEntries: g2(t4, 80), numTileContents: g2(t4, 88), clustered: t4.getUint8(96) === 1, internalCompression: t4.getUint8(97), tileCompression: t4.getUint8(98), tileType: t4.getUint8(99), minZoom: t4.getUint8(100), maxZoom: t4.getUint8(101), minLon: t4.getInt32(102, true) / 1e7, minLat: t4.getInt32(106, true) / 1e7, maxLon: t4.getInt32(110, true) / 1e7, maxLat: t4.getInt32(114, true) / 1e7, centerZoom: t4.getUint8(118), centerLon: t4.getInt32(119, true) / 1e7, centerLat: t4.getInt32(123, true) / 1e7, etag: e6 };
  }
  l3(X, "bytesToHeader");
  function Z(i5) {
    let e6 = { buf: new Uint8Array(i5), pos: 0 }, t4 = v2(e6), r6 = [], n5 = 0;
    for (let s4 = 0; s4 < t4; s4++) {
      let o6 = v2(e6);
      r6.push({ tileId: n5 + o6, offset: 0, length: 0, runLength: 1 }), n5 += o6;
    }
    for (let s4 = 0; s4 < t4; s4++) r6[s4].runLength = v2(e6);
    for (let s4 = 0; s4 < t4; s4++) r6[s4].length = v2(e6);
    for (let s4 = 0; s4 < t4; s4++) {
      let o6 = v2(e6);
      o6 === 0 && s4 > 0 ? r6[s4].offset = r6[s4 - 1].offset + r6[s4 - 1].length : r6[s4].offset = o6 - 1;
    }
    return r6;
  }
  l3(Z, "deserializeIndex");
  var R2 = class R3 extends Error {
  };
  l3(R2, "EtagMismatch");
  var E2 = R2;
  function K(i5, e6) {
    return m2(this, null, function* () {
      let t4 = yield i5.getBytes(0, 16384);
      if (new DataView(t4.data).getUint16(0, true) !== 19792) throw new Error("Wrong magic number for PMTiles archive");
      let n5 = t4.data.slice(0, Y), s4 = X(n5, t4.etag), o6 = t4.data.slice(s4.rootDirectoryOffset, s4.rootDirectoryOffset + s4.rootDirectoryLength), a3 = `${i5.getKey()}|${s4.etag || ""}|${s4.rootDirectoryOffset}|${s4.rootDirectoryLength}`, u3 = Z(yield e6(o6, s4.internalCompression));
      return [s4, [a3, u3.length, u3]];
    });
  }
  l3(K, "getHeaderAndRoot");
  function I2(i5, e6, t4, r6, n5) {
    return m2(this, null, function* () {
      let s4 = yield i5.getBytes(t4, r6, void 0, n5.etag), o6 = yield e6(s4.data, n5.internalCompression), a3 = Z(o6);
      if (a3.length === 0) throw new Error("Empty directory is invalid");
      return a3;
    });
  }
  l3(I2, "getDirectory");
  var H2 = class H3 {
    constructor(e6 = 100, t4 = true, r6 = D) {
      this.cache = /* @__PURE__ */ new Map(), this.maxCacheEntries = e6, this.counter = 1, this.decompress = r6;
    }
    getHeader(e6) {
      return m2(this, null, function* () {
        let t4 = e6.getKey(), r6 = this.cache.get(t4);
        if (r6) return r6.lastUsed = this.counter++, r6.data;
        let n5 = yield K(e6, this.decompress);
        return n5[1] && this.cache.set(n5[1][0], { lastUsed: this.counter++, data: n5[1][2] }), this.cache.set(t4, { lastUsed: this.counter++, data: n5[0] }), this.prune(), n5[0];
      });
    }
    getDirectory(e6, t4, r6, n5) {
      return m2(this, null, function* () {
        let s4 = `${e6.getKey()}|${n5.etag || ""}|${t4}|${r6}`, o6 = this.cache.get(s4);
        if (o6) return o6.lastUsed = this.counter++, o6.data;
        let a3 = yield I2(e6, this.decompress, t4, r6, n5);
        return this.cache.set(s4, { lastUsed: this.counter++, data: a3 }), this.prune(), a3;
      });
    }
    prune() {
      if (this.cache.size > this.maxCacheEntries) {
        let e6 = 1 / 0, t4;
        this.cache.forEach((r6, n5) => {
          r6.lastUsed < e6 && (e6 = r6.lastUsed, t4 = n5);
        }), t4 && this.cache.delete(t4);
      }
    }
    invalidate(e6) {
      return m2(this, null, function* () {
        this.cache.delete(e6.getKey());
      });
    }
  };
  l3(H2, "ResolvedValueCache");
  var M2 = class M3 {
    constructor(e6 = 100, t4 = true, r6 = D) {
      this.cache = /* @__PURE__ */ new Map(), this.invalidations = /* @__PURE__ */ new Map(), this.maxCacheEntries = e6, this.counter = 1, this.decompress = r6;
    }
    getHeader(e6) {
      return m2(this, null, function* () {
        let t4 = e6.getKey(), r6 = this.cache.get(t4);
        if (r6) return r6.lastUsed = this.counter++, yield r6.data;
        let n5 = new Promise((s4, o6) => {
          K(e6, this.decompress).then((a3) => {
            a3[1] && this.cache.set(a3[1][0], { lastUsed: this.counter++, data: Promise.resolve(a3[1][2]) }), s4(a3[0]), this.prune();
          }).catch((a3) => {
            o6(a3);
          });
        });
        return this.cache.set(t4, { lastUsed: this.counter++, data: n5 }), n5;
      });
    }
    getDirectory(e6, t4, r6, n5) {
      return m2(this, null, function* () {
        let s4 = `${e6.getKey()}|${n5.etag || ""}|${t4}|${r6}`, o6 = this.cache.get(s4);
        if (o6) return o6.lastUsed = this.counter++, yield o6.data;
        let a3 = new Promise((u3, c4) => {
          I2(e6, this.decompress, t4, r6, n5).then((d3) => {
            u3(d3), this.prune();
          }).catch((d3) => {
            c4(d3);
          });
        });
        return this.cache.set(s4, { lastUsed: this.counter++, data: a3 }), a3;
      });
    }
    prune() {
      if (this.cache.size >= this.maxCacheEntries) {
        let e6 = 1 / 0, t4;
        this.cache.forEach((r6, n5) => {
          r6.lastUsed < e6 && (e6 = r6.lastUsed, t4 = n5);
        }), t4 && this.cache.delete(t4);
      }
    }
    invalidate(e6) {
      return m2(this, null, function* () {
        let t4 = e6.getKey();
        if (this.invalidations.get(t4)) return yield this.invalidations.get(t4);
        this.cache.delete(e6.getKey());
        let r6 = new Promise((n5, s4) => {
          this.getHeader(e6).then((o6) => {
            n5(), this.invalidations.delete(t4);
          }).catch((o6) => {
            s4(o6);
          });
        });
        this.invalidations.set(t4, r6);
      });
    }
  };
  l3(M2, "SharedPromiseCache");
  var P2 = M2;
  var B2 = class B3 {
    constructor(e6, t4, r6) {
      typeof e6 == "string" ? this.source = new C2(e6) : this.source = e6, r6 ? this.decompress = r6 : this.decompress = D, t4 ? this.cache = t4 : this.cache = new P2();
    }
    getHeader() {
      return m2(this, null, function* () {
        return yield this.cache.getHeader(this.source);
      });
    }
    getZxyAttempt(e6, t4, r6, n5) {
      return m2(this, null, function* () {
        let s4 = G(e6, t4, r6), o6 = yield this.cache.getHeader(this.source);
        if (e6 < o6.minZoom || e6 > o6.maxZoom) return;
        let a3 = o6.rootDirectoryOffset, u3 = o6.rootDirectoryLength;
        for (let c4 = 0; c4 <= 3; c4++) {
          let d3 = yield this.cache.getDirectory(this.source, a3, u3, o6), h3 = Q(d3, s4);
          if (h3) {
            if (h3.runLength > 0) {
              let p3 = yield this.source.getBytes(o6.tileDataOffset + h3.offset, h3.length, n5, o6.etag);
              return { data: yield this.decompress(p3.data, o6.tileCompression), cacheControl: p3.cacheControl, expires: p3.expires };
            }
            a3 = o6.leafDirectoryOffset + h3.offset, u3 = h3.length;
          } else return;
        }
        throw new Error("Maximum directory depth exceeded");
      });
    }
    getZxy(e6, t4, r6, n5) {
      return m2(this, null, function* () {
        try {
          return yield this.getZxyAttempt(e6, t4, r6, n5);
        } catch (s4) {
          if (s4 instanceof E2) return this.cache.invalidate(this.source), yield this.getZxyAttempt(e6, t4, r6, n5);
          throw s4;
        }
      });
    }
    getMetadataAttempt() {
      return m2(this, null, function* () {
        let e6 = yield this.cache.getHeader(this.source), t4 = yield this.source.getBytes(e6.jsonMetadataOffset, e6.jsonMetadataLength, void 0, e6.etag), r6 = yield this.decompress(t4.data, e6.internalCompression), n5 = new TextDecoder("utf-8");
        return JSON.parse(n5.decode(r6));
      });
    }
    getMetadata() {
      return m2(this, null, function* () {
        try {
          return yield this.getMetadataAttempt();
        } catch (e6) {
          if (e6 instanceof E2) return this.cache.invalidate(this.source), yield this.getMetadataAttempt();
          throw e6;
        }
      });
    }
    getTileJson(e6) {
      return m2(this, null, function* () {
        let t4 = yield this.getHeader(), r6 = yield this.getMetadata(), n5 = _2(t4.tileType);
        return { tilejson: "3.0.0", scheme: "xyz", tiles: [`${e6}/{z}/{x}/{y}${n5}`], vector_layers: r6.vector_layers, attribution: r6.attribution, description: r6.description, name: r6.name, version: r6.version, bounds: [t4.minLon, t4.minLat, t4.maxLon, t4.maxLat], center: [t4.centerLon, t4.centerLat, t4.centerZoom], minzoom: t4.minZoom, maxzoom: t4.maxZoom };
      });
    }
  };
  l3(B2, "PMTiles");
  var x2 = B2;

  // src/tile-map.ts
  var DEFAULT_ZOOM = 5.5;
  var DEFAULT_CENTER = [-3.7, 40.4];
  var PMTILES_URL = "https://fly.storage.tigris.dev/cawm-pmtiles/cawm.pmtiles";
  var CERAMIC_COLORS = {
    "all": "#4b6cb7",
    "TSH": "#e41a1c",
    "TSHT": "#377eb8",
    "TSHTB": "#4daf4a",
    "TSHTM": "#984ea3",
    "TSG": "#ff7f00",
    "DSP": "#ffff33",
    "ARSA": "#a65628",
    "ARSC": "#f781bf",
    "ARSD": "#999999",
    "LRC": "#66c2a5",
    "LRD": "#fc8d62",
    "PRCW": "#8da0cb"
  };
  var TileMap = class extends HTMLElement {
    constructor() {
      super();
      this.placeTypeLayerNames = [];
      this.map = null;
      this.currentCeramicFilter = "all";
      this.currentPeriodFilter = "all";
      this.currentSiteTypeFilter = "all";
      this.currentRegionFilter = "all";
      this.popup = null;
      this.provincesVisible = false;
      this.attachShadow({ mode: "open" });
    }
    async connectedCallback() {
      this.render();
      const protocol = new S3();
      import_maplibre_gl.default.addProtocol("pmtiles", protocol.tile);
      const tileserver = new x2(PMTILES_URL);
      protocol.add(tileserver);
      const header = await tileserver.getHeader();
      const container = this.shadowRoot.getElementById(this.id);
      this.map = new import_maplibre_gl.default.Map({
        container,
        minZoom: header.minZoom,
        maxZoom: 10,
        zoom: DEFAULT_ZOOM,
        center: DEFAULT_CENTER,
        style: {
          version: 8,
          // Add glyphs property for text rendering
          glyphs: "https://fonts.openmaptiles.org/Open%20Sans%20Regular/{fontstack}/{range}.pbf",
          sources: {
            cawm: {
              type: "raster",
              url: `pmtiles://${PMTILES_URL}`
            },
            places: {
              type: "geojson",
              data: {
                type: "FeatureCollection",
                features: []
              }
            },
            provinces: {
              type: "geojson",
              data: {
                type: "FeatureCollection",
                features: []
              }
            }
          },
          layers: [
            {
              id: "tiles",
              type: "raster",
              source: "cawm"
            },
            {
              id: "province-boundaries",
              type: "line",
              source: "provinces",
              layout: {
                visibility: "none"
              },
              paint: {
                "line-color": "#4b6cb7",
                "line-width": 2,
                "line-opacity": 0.7
              }
            },
            {
              id: "province-fill",
              type: "fill",
              source: "provinces",
              layout: {
                visibility: "none"
              },
              paint: {
                "fill-color": "#4b6cb7",
                "fill-opacity": 0.1
              }
            },
            {
              id: "province-labels",
              type: "symbol",
              source: "provinces",
              layout: {
                visibility: "none",
                "text-field": ["get", "name"],
                "text-font": ["Open Sans Regular"],
                "text-size": 12,
                "text-allow-overlap": false
              },
              paint: {
                "text-color": "#4b6cb7",
                "text-halo-color": "rgba(255,255,255,0.8)",
                "text-halo-width": 2
              }
            },
            {
              id: "points",
              type: "circle",
              source: "places",
              filter: ["==", ["geometry-type"], "Point"],
              paint: {
                "circle-radius": [
                  "interpolate",
                  ["linear"],
                  ["zoom"],
                  4,
                  3,
                  8,
                  6,
                  12,
                  12
                ],
                "circle-color": CERAMIC_COLORS.all,
                "circle-stroke-width": 1,
                "circle-stroke-color": "#ffffff",
                "circle-opacity": 0.8
              }
            }
          ]
        }
      });
      this.map.addControl(new import_maplibre_gl.default.NavigationControl());
      this.map.addControl(new import_maplibre_gl.default.ScaleControl({
        maxWidth: 100,
        unit: "metric"
      }));
      this.map.on("click", "points", this.handleMapClick.bind(this));
      this.map.on("mouseenter", "points", () => {
        if (this.map) this.map.getCanvas().style.cursor = "pointer";
      });
      this.map.on("mouseleave", "points", () => {
        if (this.map) this.map.getCanvas().style.cursor = "";
      });
      this.addEventListener("period-change", (e6) => {
        const customEvent = e6;
        this.currentPeriodFilter = customEvent.detail.period;
        this.updateFilters();
      });
      this.addEventListener("ceramic-filter-change", (e6) => {
        const customEvent = e6;
        this.currentCeramicFilter = customEvent.detail.type;
        this.updateFilters();
        this.updatePointColors();
      });
      this.addEventListener("site-filter-change", (e6) => {
        const customEvent = e6;
        this.currentSiteTypeFilter = customEvent.detail.type;
        this.updateFilters();
      });
      this.addEventListener("region-filter-change", (e6) => {
        const customEvent = e6;
        this.currentRegionFilter = customEvent.detail.region;
        this.updateFilters();
      });
    }
    render() {
      this.shadowRoot.innerHTML = `
      <link rel="stylesheet" href="https://unpkg.com/maplibre-gl@5.2.0/dist/maplibre-gl.css">
      <style>
        #${this.id} { 
          height: 100%; 
        }
        .maplibregl-popup {
          max-width: 300px;
          font: 12px/20px 'Helvetica Neue', Arial, Helvetica, sans-serif;
        }
        .maplibregl-popup-content {
          padding: 15px;
        }
        .popup-title {
          font-weight: bold;
          margin-bottom: 8px;
          font-size: 14px;
          color: #4b6cb7;
        }
        .popup-section {
          margin-bottom: 8px;
        }
        .popup-label {
          font-weight: bold;
          color: #666;
        }
        .popup-value {
          margin-left: 5px;
        }
        .popup-ceramic {
          display: inline-block;
          margin-right: 5px;
          margin-bottom: 3px;
          padding: 2px 5px;
          border-radius: 3px;
          background: #eee;
          font-size: 11px;
        }
      </style>
      <div id="${this.id}"></div>
    `;
    }
    handleMapClick(e6) {
      if (!this.map) return;
      const features = this.map.queryRenderedFeatures(e6.point, { layers: ["points"] });
      if (!features.length) return;
      const feature = features[0];
      const props = feature.properties || {};
      const ceramicTypes = ["TSH", "TSHT", "TSHTB", "TSHTM", "TSG", "DSP", "ARSA", "ARSC", "ARSD", "LRC", "LRD", "PRCW"];
      const presentCeramics = ceramicTypes.filter((type) => props[type] === 1).map((type) => `<span class="popup-ceramic">${type}</span>`).join(" ");
      const periods = [];
      if (props.periods?.includes("early-roman")) periods.push("Early Roman (1st-3rd Century)");
      if (props.periods?.includes("late-roman")) periods.push("Late Roman (4th-5th Century)");
      if (props.periods?.includes("post-roman")) periods.push("Post-Roman (5th-7th Century)");
      let html = `
      <div class="popup-title">${props.name || "Unnamed Site"}</div>
      
      <div class="popup-section">
        <span class="popup-label">ID:</span>
        <span class="popup-value">${props.id || "No data"}</span>
      </div>
      
      <div class="popup-section">
        <span class="popup-label">Region:</span>
        <span class="popup-value">${props.region || props.provincia || "No data"}</span>
      </div>
      
      <div class="popup-section">
        <span class="popup-label">Site Type:</span>
        <span class="popup-value">${props.siteType || "No data"}</span>
      </div>
      
      <div class="popup-section">
        <span class="popup-label">Period:</span>
        <span class="popup-value">${periods.length ? periods.join(", ") : "No data"}</span>
      </div>
      
      <div class="popup-section">
        <span class="popup-label">Ceramic Types:</span><br>
        <span class="popup-value">${presentCeramics || "No data"}</span>
      </div>
    `;
      if (this.popup) this.popup.remove();
      this.popup = new import_maplibre_gl.default.Popup().setLngLat(feature.geometry.coordinates).setHTML(html).addTo(this.map);
    }
    updateFilters() {
      if (!this.map) return;
      let filters = ["all", ["==", ["geometry-type"], "Point"]];
      if (this.currentCeramicFilter !== "all") {
        filters.push(["==", ["get", this.currentCeramicFilter], 1]);
      }
      if (this.currentSiteTypeFilter !== "all") {
        filters.push([
          "any",
          ["==", ["get", "siteType"], this.currentSiteTypeFilter],
          ["==", ["get", "analysisType"], this.currentSiteTypeFilter]
        ]);
      }
      if (this.currentRegionFilter !== "all") {
        const lowerRegion = this.currentRegionFilter.toLowerCase();
        console.log(`Applying region filter: ${this.currentRegionFilter} (${lowerRegion})`);
        filters.push([
          "any",
          ["==", ["downcase", ["get", "region"]], lowerRegion],
          ["==", ["downcase", ["get", "provincia"]], lowerRegion]
        ]);
      }
      if (this.currentPeriodFilter === "early-roman") {
        filters.push([
          "any",
          ["==", ["get", "TS_early"], 1],
          ["in", "early-roman", ["get", "periods"]]
        ]);
      } else if (this.currentPeriodFilter === "late-roman") {
        filters.push([
          "any",
          ["==", ["get", "TS_late"], 1],
          ["in", "late-roman", ["get", "periods"]]
        ]);
      } else if (this.currentPeriodFilter === "post-roman") {
        filters.push([
          "any",
          ["==", ["get", "ARS_450"], 1],
          ["==", ["get", "ARS_525"], 1],
          ["==", ["get", "ARS_600"], 1],
          ["in", "post-roman", ["get", "periods"]]
        ]);
      }
      this.map.setFilter("points", filters);
      const visibleFeatures = this.map.queryRenderedFeatures({ layers: ["points"] });
      console.log(`Number of visible points after filtering: ${visibleFeatures.length}`);
    }
    updatePointColors() {
      if (!this.map) return;
      const color = CERAMIC_COLORS[this.currentCeramicFilter] || CERAMIC_COLORS.all;
      this.map.setPaintProperty("points", "circle-color", color);
    }
    async addProvinces(geojsonData) {
      if (!this.map) return;
      await new Promise((resolve) => {
        if (this.map.loaded()) {
          resolve();
        } else {
          this.map.on("load", () => resolve());
        }
      });
      const source = this.map.getSource("provinces");
      if (source) {
        source.setData(geojsonData);
      }
    }
    toggleProvinces(visible) {
      if (!this.map) return;
      this.provincesVisible = visible;
      const visibility = visible ? "visible" : "none";
      this.map.setLayoutProperty("province-boundaries", "visibility", visibility);
      this.map.setLayoutProperty("province-fill", "visibility", visibility);
      this.map.setLayoutProperty("province-labels", "visibility", visibility);
    }
    async getPlacesSource() {
      while (true) {
        if (this.map) {
          const source = this.map.getSource("places");
          if (source !== void 0) {
            return source;
          }
        }
        await new Promise((resolve) => setTimeout(resolve, 100));
      }
    }
    async showFeatures(collection) {
      try {
        console.log(`Showing ${collection.features.length} features on the map`);
        const source = await this.getPlacesSource();
        source.setData({
          type: "FeatureCollection",
          features: []
        });
        source.setData(collection);
        if (this.map && collection.features.length > 0) {
          try {
            console.log("Fitting map to feature bounds");
            const extent = bbox(collection);
            this.map.fitBounds(extent, { padding: 50, maxZoom: 8 });
          } catch (error) {
            console.error("Error fitting bounds:", error);
            this.map.flyTo({ center: DEFAULT_CENTER, zoom: DEFAULT_ZOOM });
          }
        } else if (this.map) {
          console.log("No features to show, resetting map view");
          this.map.flyTo({ center: DEFAULT_CENTER, zoom: DEFAULT_ZOOM });
        }
        this.updatePointColors();
        if (this.map) {
          const visibleFeatures = this.map.queryRenderedFeatures({ layers: ["points"] });
          console.log(`Number of visible points on the map: ${visibleFeatures.length}`);
        }
      } catch (error) {
        console.error("Error in showFeatures:", error);
      }
    }
  };
  customElements.define("tile-map", TileMap);

  // src/ceramic-explorer.ts
  var CeramicExplorer = class extends i4 {
    constructor() {
      super(...arguments);
      this.sites = [];
      this.loading = true;
      this.loadError = null;
      this.currentPeriod = "all";
      this.currentCeramicType = "all";
      this.currentSiteType = "all";
      this.currentRegion = "all";
      this.filteredSitesCount = 0;
      this.showProvinces = false;
      this.provincesData = null;
      this.municipalitiesData = null;
      this.ceramicTypesData = [];
      this.analyticRegionsData = [];
    }
    async firstUpdated() {
      try {
        console.log("Ceramic Explorer: Loading data from SPARQL endpoint...");
        this.loading = true;
        this.loadError = null;
        const [sites, provinces, municipalities, ceramicTypes, analyticRegions] = await Promise.all([
          loadSiteData(),
          loadProvinces(),
          loadMunicipalities(),
          loadCeramicTypes(),
          loadAnalyticRegions()
        ]);
        console.log("Data loaded in ceramic-explorer:");
        console.log(`Total sites: ${sites.length}`);
        console.log(`Ceramic types: ${ceramicTypes.length}`);
        this.sites = sites;
        this.sites = this.sites.map((site) => {
          if (!site.region || site.region.trim() === "") {
            site.region = "Unknown Region";
          }
          if (!site.provincia || site.provincia.trim() === "") {
            site.provincia = "Unknown Province";
          }
          return site;
        });
        const regionSet = /* @__PURE__ */ new Set();
        const provinciasSet = /* @__PURE__ */ new Set();
        this.sites.forEach((site) => {
          if (site.region && site.region.trim() !== "") {
            regionSet.add(site.region);
          }
          if (site.provincia && site.provincia.trim() !== "") {
            provinciasSet.add(site.provincia);
          }
        });
        console.log(`Found ${regionSet.size} unique regions: ${Array.from(regionSet).join(", ")}`);
        console.log(`Found ${provinciasSet.size} unique provincias: ${Array.from(provinciasSet).join(", ")}`);
        console.log(`Loaded ${this.sites.length} sites with ${this.sites.filter((s4) => s4.region && s4.region.trim() !== "").length} regions and ${this.sites.filter((s4) => s4.provincia && s4.provincia.trim() !== "").length} provincias`);
        this.provincesData = provinces;
        this.municipalitiesData = municipalities;
        this.ceramicTypesData = ceramicTypes;
        this.analyticRegionsData = analyticRegions;
        this.filteredSitesCount = sites.length;
        if (this.sites.length === 0) {
          this.loadError = "No site data was returned from the SPARQL endpoint. Please check your query and endpoint configuration.";
          this.loading = false;
          return;
        }
        const map = this.mapElement;
        if (map) {
          try {
            const geoJSON = sitesToGeoJSON(this.sites);
            await map.showFeatures(geoJSON);
            if (this.provincesData && this.provincesData.features && this.provincesData.features.length > 0) {
              await map.addProvinces(this.provincesData);
            }
          } catch (mapError) {
            console.error("Error initializing map:", mapError);
            this.loadError = "Error initializing map. Please check console for details.";
          }
        } else {
          console.error("Map element not found");
          this.loadError = "Map element not found. Please check your HTML template.";
        }
        this.loading = false;
      } catch (error) {
        console.error("Failed to load data:", error);
        this.loadError = `Failed to load data from SPARQL endpoint: ${error instanceof Error ? error.message : "Unknown error"}`;
        this.loading = false;
      }
    }
    handlePeriodChange(e6) {
      this.currentPeriod = e6.detail.period;
      this.updateMap();
    }
    handleCeramicFilterChange(e6) {
      this.currentCeramicType = e6.detail.type;
      this.updateMap();
    }
    handleSiteFilterChange(e6) {
      this.currentSiteType = e6.detail.type;
      this.updateMap();
    }
    handleRegionFilterChange(e6) {
      this.currentRegion = e6.detail.region;
      console.log(`Region filter changed to: ${this.currentRegion}`);
      this.updateMap();
    }
    toggleProvinces() {
      this.showProvinces = !this.showProvinces;
      if (this.mapElement) {
        this.mapElement.toggleProvinces(this.showProvinces);
      }
    }
    updateMap() {
      if (!this.mapElement) return;
      let filteredSites = [...this.sites];
      if (this.currentPeriod !== "all") {
        filteredSites = filteredSites.filter(
          (site) => site.periods.includes(this.currentPeriod)
        );
        console.log(`After period filter (${this.currentPeriod}): ${filteredSites.length} sites`);
      }
      if (this.currentCeramicType !== "all") {
        filteredSites = filteredSites.filter(
          (site) => site.ceramics[this.currentCeramicType] === 1
        );
        console.log(`After ceramic filter (${this.currentCeramicType}): ${filteredSites.length} sites`);
      }
      if (this.currentSiteType !== "all") {
        filteredSites = filteredSites.filter(
          (site) => site.siteType === this.currentSiteType || site.analysisType === this.currentSiteType
        );
        console.log(`After site type filter (${this.currentSiteType}): ${filteredSites.length} sites`);
      }
      if (this.currentRegion !== "all") {
        const regionValues = /* @__PURE__ */ new Set();
        const provinciaValues = /* @__PURE__ */ new Set();
        this.sites.slice(0, 20).forEach((site) => {
          if (site.region) regionValues.add(site.region);
          if (site.provincia) provinciaValues.add(site.provincia);
        });
        console.log(`Sample region values: ${Array.from(regionValues).join(", ")}`);
        console.log(`Sample provincia values: ${Array.from(provinciaValues).join(", ")}`);
        const lowerRegion = this.currentRegion.toLowerCase();
        filteredSites = filteredSites.filter(
          (site) => site.region && site.region.toLowerCase() === lowerRegion || site.provincia && site.provincia.toLowerCase() === lowerRegion
        );
        console.log(`After region filter (${this.currentRegion}): ${filteredSites.length} sites`);
        if (filteredSites.length > 0) {
          console.log("Sample filtered sites:");
          filteredSites.slice(0, 3).forEach((site) => {
            console.log(`- Site ${site.id}: region=${site.region}, provincia=${site.provincia}`);
          });
        } else {
          console.warn(`No sites match the region filter "${this.currentRegion}"`);
        }
      }
      this.filteredSitesCount = filteredSites.length;
      const geoJSON = sitesToGeoJSON(filteredSites);
      this.mapElement.showFeatures(geoJSON);
    }
    render() {
      if (this.loading) {
        return x`
        <div class="loading">
          <div class="loading-spinner"></div>
          <span>Loading data from SPARQL endpoint...</span>
        </div>
      `;
      }
      if (this.loadError) {
        return x`
        <div class="header">
          <h1>Iberian Peninsula Ceramic Distribution Time Series Visualization</h1>
        </div>
        <div class="error-message">
          <h2>Error Loading Data</h2>
          <p>${this.loadError}</p>
          <button @click=${this.retryLoading}>Retry</button>
        </div>
      `;
      }
      let filteredSites = this.sites;
      if (this.currentPeriod !== "all") {
        filteredSites = filteredSites.filter(
          (site) => site.periods.includes(this.currentPeriod)
        );
      }
      if (this.currentCeramicType !== "all") {
        filteredSites = filteredSites.filter(
          (site) => site.ceramics[this.currentCeramicType] === 1
        );
      }
      if (this.currentSiteType !== "all") {
        filteredSites = filteredSites.filter(
          (site) => site.siteType === this.currentSiteType || site.analysisType === this.currentSiteType
        );
      }
      if (this.currentRegion !== "all") {
        const lowerRegion = this.currentRegion.toLowerCase();
        filteredSites = filteredSites.filter(
          (site) => site.region && site.region.toLowerCase() === lowerRegion || site.provincia && site.provincia.toLowerCase() === lowerRegion
        );
      }
      return x`
      <div class="header">
        <h1>Iberian Peninsula Ceramic Distribution Time Series Visualization</h1>
      </div>
      
      <div class="main-content">
        <div class="sidebar">
          <div class="filter-section">
            <time-slider 
              @period-change=${this.handlePeriodChange}
              .selected=${this.currentPeriod}
            ></time-slider>
          </div>
          
          <div class="filter-section">
            <ceramic-filter
              @ceramic-filter-change=${this.handleCeramicFilterChange}
              .selected=${this.currentCeramicType}
            ></ceramic-filter>
          </div>
          
          <div class="filter-section">
            <site-type-filter
              @site-filter-change=${this.handleSiteFilterChange}
              .selected=${this.currentSiteType}
            ></site-type-filter>
          </div>
          
          <div class="filter-section">
            <region-filter
              @region-filter-change=${this.handleRegionFilterChange}
              .selected=${this.currentRegion}
              .sites=${this.sites}
            ></region-filter>
          </div>
          
          <div class="stats-card">
            <div class="stats-title">Current Filter Results</div>
            <div>Showing ${this.filteredSitesCount} sites (out of ${this.sites.length})</div>
            
            <label style="display: block; margin-top: 10px;">
              <input 
                type="checkbox" 
                ?checked=${this.showProvinces} 
                @change=${this.toggleProvinces}
              /> 
              Show Roman province boundaries
            </label>
          </div>
          
          <ceramic-chart
            .sites=${filteredSites}
            .period=${this.currentPeriod}
            .ceramicType=${this.currentCeramicType}
            .siteType=${this.currentSiteType}
            .region=${this.currentRegion}
          ></ceramic-chart>
        </div>
        
        <div class="map-container">
          <tile-map id="main-map"></tile-map>
        </div>
      </div>
    `;
    }
    retryLoading() {
      this.firstUpdated();
    }
  };
  CeramicExplorer.styles = i`
    :host {
      display: block;
      height: 100vh;
      width: 100%;
      display: flex;
      flex-direction: column;
      font-family: Arial, sans-serif;
    }
    
    .header {
      background: linear-gradient(to right, #4b6cb7, #182848);
      color: white;
      padding: 1rem;
      display: flex;
      justify-content: center;
      align-items: center;
      box-shadow: 0 2px 10px rgba(0,0,0,0.2);
    }
    
    .header h1 {
      margin: 0;
      font-size: 1.5rem;
    }
    
    .main-content {
      flex: 1;
      display: flex;
      overflow: hidden;
    }
    
    .map-container {
      flex: 1;
      height: 100%;
      position: relative;
    }
    
    .sidebar {
      width: 320px;
      background: #f5f5f5;
      overflow-y: auto;
      display: flex;
      flex-direction: column;
      gap: 1rem;
      padding: 1rem;
      box-shadow: 2px 0 5px rgba(0,0,0,0.1);
    }
    
    .loading {
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100%;
      font-size: 1.2rem;
      background: #f5f5f5;
    }
    
    .loading-spinner {
      width: 40px;
      height: 40px;
      border: 4px solid #f3f3f3;
      border-top: 4px solid #3498db;
      border-radius: 50%;
      animation: spin 1s linear infinite;
      margin-right: 10px;
    }
    
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
    
    .stats-card {
      background: white;
      padding: 1rem;
      border-radius: 4px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
      margin-top: 1rem;
    }
    
    .stats-title {
      font-weight: bold;
      margin-bottom: 0.5rem;
      color: #4b6cb7;
    }
    
    .filter-section {
      border-bottom: 1px solid #e0e0e0;
      padding-bottom: 1rem;
      margin-bottom: 1rem;
    }
    
    .filter-section:last-child {
      border-bottom: none;
    }
    
    .error-message {
      color: #e74c3c;
      padding: 1rem;
      background-color: #fadbd8;
      border-radius: 4px;
      margin: 1rem;
      text-align: center;
    }
  `;
  __decorateClass([
    r5()
  ], CeramicExplorer.prototype, "sites", 2);
  __decorateClass([
    r5()
  ], CeramicExplorer.prototype, "loading", 2);
  __decorateClass([
    r5()
  ], CeramicExplorer.prototype, "loadError", 2);
  __decorateClass([
    r5()
  ], CeramicExplorer.prototype, "currentPeriod", 2);
  __decorateClass([
    r5()
  ], CeramicExplorer.prototype, "currentCeramicType", 2);
  __decorateClass([
    r5()
  ], CeramicExplorer.prototype, "currentSiteType", 2);
  __decorateClass([
    r5()
  ], CeramicExplorer.prototype, "currentRegion", 2);
  __decorateClass([
    r5()
  ], CeramicExplorer.prototype, "filteredSitesCount", 2);
  __decorateClass([
    r5()
  ], CeramicExplorer.prototype, "showProvinces", 2);
  __decorateClass([
    r5()
  ], CeramicExplorer.prototype, "provincesData", 2);
  __decorateClass([
    r5()
  ], CeramicExplorer.prototype, "municipalitiesData", 2);
  __decorateClass([
    r5()
  ], CeramicExplorer.prototype, "ceramicTypesData", 2);
  __decorateClass([
    r5()
  ], CeramicExplorer.prototype, "analyticRegionsData", 2);
  __decorateClass([
    e5("#main-map")
  ], CeramicExplorer.prototype, "mapElement", 2);
  CeramicExplorer = __decorateClass([
    t3("ceramic-explorer")
  ], CeramicExplorer);
})();
/*! Bundled license information:

maplibre-gl/dist/maplibre-gl.js:
  (**
   * MapLibre GL JS
   * @license 3-Clause BSD. Full text of license: https://github.com/maplibre/maplibre-gl-js/blob/v5.3.1/LICENSE.txt
   *)

@lit/reactive-element/css-tag.js:
  (**
   * @license
   * Copyright 2019 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/reactive-element.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

lit-html/lit-html.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

lit-element/lit-element.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

lit-html/is-server.js:
  (**
   * @license
   * Copyright 2022 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/decorators/custom-element.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/decorators/property.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/decorators/state.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/decorators/event-options.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/decorators/base.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/decorators/query.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/decorators/query-all.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/decorators/query-async.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/decorators/query-assigned-elements.js:
  (**
   * @license
   * Copyright 2021 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/decorators/query-assigned-nodes.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)
*/
//# sourceMappingURL=ceramic-explorer.js.map
